var Yf = Object.defineProperty,
    qf = Object.defineProperties;
var $f = Object.getOwnPropertyDescriptors;
var Jp = Object.getOwnPropertySymbols;
var Kf = Object.prototype.hasOwnProperty,
    em = Object.prototype.propertyIsEnumerable;
var dp = Math.pow,
    Zp = (ue, R, y) => R in ue ? Yf(ue, R, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: y
    }) : ue[R] = y,
    Xp = (ue, R) => {
        for (var y in R || (R = {})) Kf.call(R, y) && Zp(ue, y, R[y]);
        if (Jp)
            for (var y of Jp(R)) em.call(R, y) && Zp(ue, y, R[y]);
        return ue
    },
    jp = (ue, R) => qf(ue, $f(R));
var no = (ue, R, y) => new Promise((z, V) => {
    var Y = se => {
            try {
                p(y.next(se))
            } catch (ie) {
                V(ie)
            }
        },
        C = se => {
            try {
                p(y.throw(se))
            } catch (ie) {
                V(ie)
            }
        },
        p = se => se.done ? z(se.value) : Promise.resolve(se.value).then(Y, C);
    p((y = y.apply(ue, R)).next())
});
(function() {
    const R = document.createElement("link").relList;
    if (R && R.supports && R.supports("modulepreload")) return;
    for (const V of document.querySelectorAll('link[rel="modulepreload"]')) z(V);
    new MutationObserver(V => {
        for (const Y of V)
            if (Y.type === "childList")
                for (const C of Y.addedNodes) C.tagName === "LINK" && C.rel === "modulepreload" && z(C)
    }).observe(document, {
        childList: !0,
        subtree: !0
    });

    function y(V) {
        const Y = {};
        return V.integrity && (Y.integrity = V.integrity), V.referrerPolicy && (Y.referrerPolicy = V.referrerPolicy), V.crossOrigin === "use-credentials" ? Y.credentials = "include" : V.crossOrigin === "anonymous" ? Y.credentials = "omit" : Y.credentials = "same-origin", Y
    }

    function z(V) {
        if (V.ep) return;
        V.ep = !0;
        const Y = y(V);
        fetch(V.href, Y)
    }
})();
var uf = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};

function tm(ue) {
    return ue && ue.__esModule && Object.prototype.hasOwnProperty.call(ue, "default") ? ue.default : ue
}
var df = {
    exports: {}
};
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v4.1.0/LICENSE.txt
 */
(function(ue, R) {
    (function(y, z) {
        ue.exports = z()
    })(uf, function() {
        var y = {},
            z = {};

        function V(C, p, se) {
            if (z[C] = se, C === "index") {
                var ie = "var sharedModule = {}; (" + z.shared + ")(sharedModule); (" + z.worker + ")(sharedModule);",
                    He = {};
                return z.shared(He), z.index(y, He), typeof window != "undefined" && y.setWorkerUrl(window.URL.createObjectURL(new Blob([ie], {
                    type: "text/javascript"
                }))), y
            }
        }
        V("shared", ["exports"], function(C) {
            function p(i, t, a, l) {
                return new(a || (a = Promise))(function(d, g) {
                    function x(F) {
                        try {
                            M(l.next(F))
                        } catch (D) {
                            g(D)
                        }
                    }

                    function A(F) {
                        try {
                            M(l.throw(F))
                        } catch (D) {
                            g(D)
                        }
                    }

                    function M(F) {
                        var D;
                        F.done ? d(F.value) : (D = F.value, D instanceof a ? D : new a(function(U) {
                            U(D)
                        })).then(x, A)
                    }
                    M((l = l.apply(i, t || [])).next())
                })
            }

            function se(i) {
                return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i
            }
            typeof SuppressedError == "function" && SuppressedError;
            var ie = He;

            function He(i, t) {
                this.x = i, this.y = t
            }
            He.prototype = {
                clone: function() {
                    return new He(this.x, this.y)
                },
                add: function(i) {
                    return this.clone()._add(i)
                },
                sub: function(i) {
                    return this.clone()._sub(i)
                },
                multByPoint: function(i) {
                    return this.clone()._multByPoint(i)
                },
                divByPoint: function(i) {
                    return this.clone()._divByPoint(i)
                },
                mult: function(i) {
                    return this.clone()._mult(i)
                },
                div: function(i) {
                    return this.clone()._div(i)
                },
                rotate: function(i) {
                    return this.clone()._rotate(i)
                },
                rotateAround: function(i, t) {
                    return this.clone()._rotateAround(i, t)
                },
                matMult: function(i) {
                    return this.clone()._matMult(i)
                },
                unit: function() {
                    return this.clone()._unit()
                },
                perp: function() {
                    return this.clone()._perp()
                },
                round: function() {
                    return this.clone()._round()
                },
                mag: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                },
                equals: function(i) {
                    return this.x === i.x && this.y === i.y
                },
                dist: function(i) {
                    return Math.sqrt(this.distSqr(i))
                },
                distSqr: function(i) {
                    var t = i.x - this.x,
                        a = i.y - this.y;
                    return t * t + a * a
                },
                angle: function() {
                    return Math.atan2(this.y, this.x)
                },
                angleTo: function(i) {
                    return Math.atan2(this.y - i.y, this.x - i.x)
                },
                angleWith: function(i) {
                    return this.angleWithSep(i.x, i.y)
                },
                angleWithSep: function(i, t) {
                    return Math.atan2(this.x * t - this.y * i, this.x * i + this.y * t)
                },
                _matMult: function(i) {
                    var t = i[2] * this.x + i[3] * this.y;
                    return this.x = i[0] * this.x + i[1] * this.y, this.y = t, this
                },
                _add: function(i) {
                    return this.x += i.x, this.y += i.y, this
                },
                _sub: function(i) {
                    return this.x -= i.x, this.y -= i.y, this
                },
                _mult: function(i) {
                    return this.x *= i, this.y *= i, this
                },
                _div: function(i) {
                    return this.x /= i, this.y /= i, this
                },
                _multByPoint: function(i) {
                    return this.x *= i.x, this.y *= i.y, this
                },
                _divByPoint: function(i) {
                    return this.x /= i.x, this.y /= i.y, this
                },
                _unit: function() {
                    return this._div(this.mag()), this
                },
                _perp: function() {
                    var i = this.y;
                    return this.y = this.x, this.x = -i, this
                },
                _rotate: function(i) {
                    var t = Math.cos(i),
                        a = Math.sin(i),
                        l = a * this.x + t * this.y;
                    return this.x = t * this.x - a * this.y, this.y = l, this
                },
                _rotateAround: function(i, t) {
                    var a = Math.cos(i),
                        l = Math.sin(i),
                        d = t.y + l * (this.x - t.x) + a * (this.y - t.y);
                    return this.x = t.x + a * (this.x - t.x) - l * (this.y - t.y), this.y = d, this
                },
                _round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                }
            }, He.convert = function(i) {
                return i instanceof He ? i : Array.isArray(i) ? new He(i[0], i[1]) : i
            };
            var be = se(ie),
                Ee = Lt;

            function Lt(i, t, a, l) {
                this.cx = 3 * i, this.bx = 3 * (a - i) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (l - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = i, this.p1y = t, this.p2x = a, this.p2y = l
            }
            Lt.prototype = {
                sampleCurveX: function(i) {
                    return ((this.ax * i + this.bx) * i + this.cx) * i
                },
                sampleCurveY: function(i) {
                    return ((this.ay * i + this.by) * i + this.cy) * i
                },
                sampleCurveDerivativeX: function(i) {
                    return (3 * this.ax * i + 2 * this.bx) * i + this.cx
                },
                solveCurveX: function(i, t) {
                    if (t === void 0 && (t = 1e-6), i < 0) return 0;
                    if (i > 1) return 1;
                    for (var a = i, l = 0; l < 8; l++) {
                        var d = this.sampleCurveX(a) - i;
                        if (Math.abs(d) < t) return a;
                        var g = this.sampleCurveDerivativeX(a);
                        if (Math.abs(g) < 1e-6) break;
                        a -= d / g
                    }
                    var x = 0,
                        A = 1;
                    for (a = i, l = 0; l < 20 && (d = this.sampleCurveX(a), !(Math.abs(d - i) < t)); l++) i > d ? x = a : A = a, a = .5 * (A - x) + x;
                    return a
                },
                solve: function(i, t) {
                    return this.sampleCurveY(this.solveCurveX(i, t))
                }
            };
            var Tt = se(Ee);
            let Je, wt;

            function Ke() {
                return Je == null && (Je = typeof OffscreenCanvas != "undefined" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), Je
            }

            function Ye() {
                if (wt == null && (wt = !1, Ke())) {
                    const t = new OffscreenCanvas(5, 5).getContext("2d", {
                        willReadFrequently: !0
                    });
                    if (t) {
                        for (let l = 0; l < 5 * 5; l++) {
                            const d = 4 * l;
                            t.fillStyle = `rgb(${d},${d+1},${d+2})`, t.fillRect(l % 5, Math.floor(l / 5), 1, 1)
                        }
                        const a = t.getImageData(0, 0, 5, 5).data;
                        for (let l = 0; l < 5 * 5 * 4; l++)
                            if (l % 4 != 3 && a[l] !== l) {
                                wt = !0;
                                break
                            }
                    }
                }
                return wt || !1
            }

            function jt(i, t, a, l) {
                const d = new Tt(i, t, a, l);
                return function(g) {
                    return d.solve(g)
                }
            }
            const di = jt(.25, .1, .25, 1);

            function $e(i, t, a) {
                return Math.min(a, Math.max(t, i))
            }

            function vt(i, t, a) {
                const l = a - t,
                    d = ((i - t) % l + l) % l + t;
                return d === t ? a : d
            }

            function Kt(i, ...t) {
                for (const a of t)
                    for (const l in a) i[l] = a[l];
                return i
            }
            let vi = 1;

            function Li(i, t, a) {
                const l = {};
                for (const d in i) l[d] = t.call(a || this, i[d], d, i);
                return l
            }

            function Ei(i, t, a) {
                const l = {};
                for (const d in i) t.call(a || this, i[d], d, i) && (l[d] = i[d]);
                return l
            }

            function ct(i) {
                return Array.isArray(i) ? i.map(ct) : typeof i == "object" && i ? Li(i, ct) : i
            }
            const je = {};

            function li(i) {
                je[i] || (typeof console != "undefined" && console.warn(i), je[i] = !0)
            }

            function O(i, t, a) {
                return (a.y - i.y) * (t.x - i.x) > (t.y - i.y) * (a.x - i.x)
            }

            function K(i) {
                let t = 0;
                for (let a, l, d = 0, g = i.length, x = g - 1; d < g; x = d++) a = i[d], l = i[x], t += (l.x - a.x) * (a.y + l.y);
                return t
            }

            function ae(i) {
                return typeof WorkerGlobalScope != "undefined" && i !== void 0 && i instanceof WorkerGlobalScope
            }
            let _e = null;

            function xe(i) {
                return typeof ImageBitmap != "undefined" && i instanceof ImageBitmap
            }
            const Ze = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";

            function st(i, t, a, l, d) {
                return p(this, void 0, void 0, function*() {
                    if (typeof VideoFrame == "undefined") throw new Error("VideoFrame not supported");
                    const g = new VideoFrame(i, {
                        timestamp: 0
                    });
                    try {
                        const x = g == null ? void 0 : g.format;
                        if (!x || !x.startsWith("BGR") && !x.startsWith("RGB")) throw new Error(`Unrecognized format ${x}`);
                        const A = x.startsWith("BGR"),
                            M = new Uint8ClampedArray(l * d * 4);
                        if (yield g.copyTo(M, function(F, D, U, N, H) {
                                const X = 4 * Math.max(-D, 0),
                                    ne = (Math.max(0, U) - U) * N * 4 + X,
                                    le = 4 * N,
                                    ce = Math.max(0, D),
                                    Qe = Math.max(0, U);
                                return {
                                    rect: {
                                        x: ce,
                                        y: Qe,
                                        width: Math.min(F.width, D + N) - ce,
                                        height: Math.min(F.height, U + H) - Qe
                                    },
                                    layout: [{
                                        offset: ne,
                                        stride: le
                                    }]
                                }
                            }(i, t, a, l, d)), A)
                            for (let F = 0; F < M.length; F += 4) {
                                const D = M[F];
                                M[F] = M[F + 2], M[F + 2] = D
                            }
                        return M
                    } finally {
                        g.close()
                    }
                })
            }
            let De, gt;
            const Qt = "AbortError";

            function Ve() {
                return new Error(Qt)
            }
            const Dt = {
                MAX_PARALLEL_IMAGE_REQUESTS: 16,
                MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
                MAX_TILE_CACHE_ZOOM_LEVELS: 5,
                REGISTERED_PROTOCOLS: {},
                WORKER_URL: ""
            };

            function ei(i) {
                return Dt.REGISTERED_PROTOCOLS[i.substring(0, i.indexOf("://"))]
            }
            const xi = "global-dispatcher";
            class oe extends Error {
                constructor(t, a, l, d) {
                    super(`AJAXError: ${a} (${t}): ${l}`), this.status = t, this.statusText = a, this.url = l, this.body = d
                }
            }
            const ve = () => ae(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href,
                Ne = function(i, t) {
                    if (/:\/\//.test(i.url) && !/^https?:|^file:/.test(i.url)) {
                        const l = ei(i.url);
                        if (l) return l(i, t);
                        if (ae(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
                            type: "getResource",
                            data: i,
                            targetMapId: xi
                        }, t)
                    }
                    if (!(/^file:/.test(a = i.url) || /^file:/.test(ve()) && !/^\w+:/.test(a))) {
                        if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function(l, d) {
                            return p(this, void 0, void 0, function*() {
                                const g = new Request(l.url, {
                                    method: l.method || "GET",
                                    body: l.body,
                                    credentials: l.credentials,
                                    headers: l.headers,
                                    cache: l.cache,
                                    referrer: ve(),
                                    signal: d.signal
                                });
                                l.type === "json" && g.headers.set("Accept", "application/json");
                                const x = yield fetch(g);
                                if (!x.ok) {
                                    const F = yield x.blob();
                                    throw new oe(x.status, x.statusText, l.url, F)
                                }
                                const A = l.type === "arrayBuffer" || l.type === "image" ? x.arrayBuffer() : l.type === "json" ? x.json() : x.text(),
                                    M = yield A;
                                if (d.signal.aborted) throw Ve();
                                return {
                                    data: M,
                                    cacheControl: x.headers.get("Cache-Control"),
                                    expires: x.headers.get("Expires")
                                }
                            })
                        }(i, t);
                        if (ae(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
                            type: "getResource",
                            data: i,
                            mustQueue: !0,
                            targetMapId: xi
                        }, t)
                    }
                    var a;
                    return function(l, d) {
                        return new Promise((g, x) => {
                            const A = new XMLHttpRequest;
                            A.open(l.method || "GET", l.url, !0), l.type !== "arrayBuffer" && l.type !== "image" || (A.responseType = "arraybuffer");
                            for (const M in l.headers) A.setRequestHeader(M, l.headers[M]);
                            l.type === "json" && (A.responseType = "text", A.setRequestHeader("Accept", "application/json")), A.withCredentials = l.credentials === "include", A.onerror = () => {
                                x(new Error(A.statusText))
                            }, A.onload = () => {
                                if (!d.signal.aborted)
                                    if ((A.status >= 200 && A.status < 300 || A.status === 0) && A.response !== null) {
                                        let M = A.response;
                                        if (l.type === "json") try {
                                            M = JSON.parse(A.response)
                                        } catch (F) {
                                            return void x(F)
                                        }
                                        g({
                                            data: M,
                                            cacheControl: A.getResponseHeader("Cache-Control"),
                                            expires: A.getResponseHeader("Expires")
                                        })
                                    } else {
                                        const M = new Blob([A.response], {
                                            type: A.getResponseHeader("Content-Type")
                                        });
                                        x(new oe(A.status, A.statusText, l.url, M))
                                    }
                            }, d.signal.addEventListener("abort", () => {
                                A.abort(), x(Ve())
                            }), A.send(l.body)
                        })
                    }(i, t)
                };

            function Ue(i) {
                if (!i || i.indexOf("://") <= 0 || i.indexOf("data:image/") === 0 || i.indexOf("blob:") === 0) return !0;
                const t = new URL(i),
                    a = window.location;
                return t.protocol === a.protocol && t.host === a.host
            }

            function Oe(i, t, a) {
                a[i] && a[i].indexOf(t) !== -1 || (a[i] = a[i] || [], a[i].push(t))
            }

            function at(i, t, a) {
                if (a && a[i]) {
                    const l = a[i].indexOf(t);
                    l !== -1 && a[i].splice(l, 1)
                }
            }
            class ht {
                constructor(t, a = {}) {
                    Kt(this, a), this.type = t
                }
            }
            class tt extends ht {
                constructor(t, a = {}) {
                    super("error", Kt({
                        error: t
                    }, a))
                }
            }
            class Bt {
                on(t, a) {
                    return this._listeners = this._listeners || {}, Oe(t, a, this._listeners), this
                }
                off(t, a) {
                    return at(t, a, this._listeners), at(t, a, this._oneTimeListeners), this
                }
                once(t, a) {
                    return a ? (this._oneTimeListeners = this._oneTimeListeners || {}, Oe(t, a, this._oneTimeListeners), this) : new Promise(l => this.once(t, l))
                }
                fire(t, a) {
                    typeof t == "string" && (t = new ht(t, a || {}));
                    const l = t.type;
                    if (this.listens(l)) {
                        t.target = this;
                        const d = this._listeners && this._listeners[l] ? this._listeners[l].slice() : [];
                        for (const A of d) A.call(this, t);
                        const g = this._oneTimeListeners && this._oneTimeListeners[l] ? this._oneTimeListeners[l].slice() : [];
                        for (const A of g) at(l, A, this._oneTimeListeners), A.call(this, t);
                        const x = this._eventedParent;
                        x && (Kt(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), x.fire(t))
                    } else t instanceof tt && console.error(t.error);
                    return this
                }
                listens(t) {
                    return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t)
                }
                setEventedParent(t, a) {
                    return this._eventedParent = t, this._eventedParentData = a, this
                }
            }
            var Le = {
                $version: 8,
                $root: {
                    version: {
                        required: !0,
                        type: "enum",
                        values: [8]
                    },
                    name: {
                        type: "string"
                    },
                    metadata: {
                        type: "*"
                    },
                    center: {
                        type: "array",
                        value: "number"
                    },
                    zoom: {
                        type: "number"
                    },
                    bearing: {
                        type: "number",
                        default: 0,
                        period: 360,
                        units: "degrees"
                    },
                    pitch: {
                        type: "number",
                        default: 0,
                        units: "degrees"
                    },
                    light: {
                        type: "light"
                    },
                    sky: {
                        type: "sky"
                    },
                    terrain: {
                        type: "terrain"
                    },
                    sources: {
                        required: !0,
                        type: "sources"
                    },
                    sprite: {
                        type: "sprite"
                    },
                    glyphs: {
                        type: "string"
                    },
                    transition: {
                        type: "transition"
                    },
                    layers: {
                        required: !0,
                        type: "array",
                        value: "layer"
                    }
                },
                sources: {
                    "*": {
                        type: "source"
                    }
                },
                source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"],
                source_vector: {
                    type: {
                        required: !0,
                        type: "enum",
                        values: {
                            vector: {}
                        }
                    },
                    url: {
                        type: "string"
                    },
                    tiles: {
                        type: "array",
                        value: "string"
                    },
                    bounds: {
                        type: "array",
                        value: "number",
                        length: 4,
                        default: [-180, -85.051129, 180, 85.051129]
                    },
                    scheme: {
                        type: "enum",
                        values: {
                            xyz: {},
                            tms: {}
                        },
                        default: "xyz"
                    },
                    minzoom: {
                        type: "number",
                        default: 0
                    },
                    maxzoom: {
                        type: "number",
                        default: 22
                    },
                    attribution: {
                        type: "string"
                    },
                    promoteId: {
                        type: "promoteId"
                    },
                    volatile: {
                        type: "boolean",
                        default: !1
                    },
                    "*": {
                        type: "*"
                    }
                },
                source_raster: {
                    type: {
                        required: !0,
                        type: "enum",
                        values: {
                            raster: {}
                        }
                    },
                    url: {
                        type: "string"
                    },
                    tiles: {
                        type: "array",
                        value: "string"
                    },
                    bounds: {
                        type: "array",
                        value: "number",
                        length: 4,
                        default: [-180, -85.051129, 180, 85.051129]
                    },
                    minzoom: {
                        type: "number",
                        default: 0
                    },
                    maxzoom: {
                        type: "number",
                        default: 22
                    },
                    tileSize: {
                        type: "number",
                        default: 512,
                        units: "pixels"
                    },
                    scheme: {
                        type: "enum",
                        values: {
                            xyz: {},
                            tms: {}
                        },
                        default: "xyz"
                    },
                    attribution: {
                        type: "string"
                    },
                    volatile: {
                        type: "boolean",
                        default: !1
                    },
                    "*": {
                        type: "*"
                    }
                },
                source_raster_dem: {
                    type: {
                        required: !0,
                        type: "enum",
                        values: {
                            "raster-dem": {}
                        }
                    },
                    url: {
                        type: "string"
                    },
                    tiles: {
                        type: "array",
                        value: "string"
                    },
                    bounds: {
                        type: "array",
                        value: "number",
                        length: 4,
                        default: [-180, -85.051129, 180, 85.051129]
                    },
                    minzoom: {
                        type: "number",
                        default: 0
                    },
                    maxzoom: {
                        type: "number",
                        default: 22
                    },
                    tileSize: {
                        type: "number",
                        default: 512,
                        units: "pixels"
                    },
                    attribution: {
                        type: "string"
                    },
                    encoding: {
                        type: "enum",
                        values: {
                            terrarium: {},
                            mapbox: {},
                            custom: {}
                        },
                        default: "mapbox"
                    },
                    redFactor: {
                        type: "number",
                        default: 1
                    },
                    blueFactor: {
                        type: "number",
                        default: 1
                    },
                    greenFactor: {
                        type: "number",
                        default: 1
                    },
                    baseShift: {
                        type: "number",
                        default: 0
                    },
                    volatile: {
                        type: "boolean",
                        default: !1
                    },
                    "*": {
                        type: "*"
                    }
                },
                source_geojson: {
                    type: {
                        required: !0,
                        type: "enum",
                        values: {
                            geojson: {}
                        }
                    },
                    data: {
                        required: !0,
                        type: "*"
                    },
                    maxzoom: {
                        type: "number",
                        default: 18
                    },
                    attribution: {
                        type: "string"
                    },
                    buffer: {
                        type: "number",
                        default: 128,
                        maximum: 512,
                        minimum: 0
                    },
                    filter: {
                        type: "*"
                    },
                    tolerance: {
                        type: "number",
                        default: .375
                    },
                    cluster: {
                        type: "boolean",
                        default: !1
                    },
                    clusterRadius: {
                        type: "number",
                        default: 50,
                        minimum: 0
                    },
                    clusterMaxZoom: {
                        type: "number"
                    },
                    clusterMinPoints: {
                        type: "number"
                    },
                    clusterProperties: {
                        type: "*"
                    },
                    lineMetrics: {
                        type: "boolean",
                        default: !1
                    },
                    generateId: {
                        type: "boolean",
                        default: !1
                    },
                    promoteId: {
                        type: "promoteId"
                    }
                },
                source_video: {
                    type: {
                        required: !0,
                        type: "enum",
                        values: {
                            video: {}
                        }
                    },
                    urls: {
                        required: !0,
                        type: "array",
                        value: "string"
                    },
                    coordinates: {
                        required: !0,
                        type: "array",
                        length: 4,
                        value: {
                            type: "array",
                            length: 2,
                            value: "number"
                        }
                    }
                },
                source_image: {
                    type: {
                        required: !0,
                        type: "enum",
                        values: {
                            image: {}
                        }
                    },
                    url: {
                        required: !0,
                        type: "string"
                    },
                    coordinates: {
                        required: !0,
                        type: "array",
                        length: 4,
                        value: {
                            type: "array",
                            length: 2,
                            value: "number"
                        }
                    }
                },
                layer: {
                    id: {
                        type: "string",
                        required: !0
                    },
                    type: {
                        type: "enum",
                        values: {
                            fill: {},
                            line: {},
                            symbol: {},
                            circle: {},
                            heatmap: {},
                            "fill-extrusion": {},
                            raster: {},
                            hillshade: {},
                            background: {}
                        },
                        required: !0
                    },
                    metadata: {
                        type: "*"
                    },
                    source: {
                        type: "string"
                    },
                    "source-layer": {
                        type: "string"
                    },
                    minzoom: {
                        type: "number",
                        minimum: 0,
                        maximum: 24
                    },
                    maxzoom: {
                        type: "number",
                        minimum: 0,
                        maximum: 24
                    },
                    filter: {
                        type: "filter"
                    },
                    layout: {
                        type: "layout"
                    },
                    paint: {
                        type: "paint"
                    }
                },
                layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"],
                layout_background: {
                    visibility: {
                        type: "enum",
                        values: {
                            visible: {},
                            none: {}
                        },
                        default: "visible",
                        "property-type": "constant"
                    }
                },
                layout_fill: {
                    "fill-sort-key": {
                        type: "number",
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom", "feature"]
                        },
                        "property-type": "data-driven"
                    },
                    visibility: {
                        type: "enum",
                        values: {
                            visible: {},
                            none: {}
                        },
                        default: "visible",
                        "property-type": "constant"
                    }
                },
                layout_circle: {
                    "circle-sort-key": {
                        type: "number",
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom", "feature"]
                        },
                        "property-type": "data-driven"
                    },
                    visibility: {
                        type: "enum",
                        values: {
                            visible: {},
                            none: {}
                        },
                        default: "visible",
                        "property-type": "constant"
                    }
                },
                layout_heatmap: {
                    visibility: {
                        type: "enum",
                        values: {
                            visible: {},
                            none: {}
                        },
                        default: "visible",
                        "property-type": "constant"
                    }
                },
                "layout_fill-extrusion": {
                    visibility: {
                        type: "enum",
                        values: {
                            visible: {},
                            none: {}
                        },
                        default: "visible",
                        "property-type": "constant"
                    }
                },
                layout_line: {
                    "line-cap": {
                        type: "enum",
                        values: {
                            butt: {},
                            round: {},
                            square: {}
                        },
                        default: "butt",
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "line-join": {
                        type: "enum",
                        values: {
                            bevel: {},
                            round: {},
                            miter: {}
                        },
                        default: "miter",
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom", "feature"]
                        },
                        "property-type": "data-driven"
                    },
                    "line-miter-limit": {
                        type: "number",
                        default: 2,
                        requires: [{
                            "line-join": "miter"
                        }],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "line-round-limit": {
                        type: "number",
                        default: 1.05,
                        requires: [{
                            "line-join": "round"
                        }],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "line-sort-key": {
                        type: "number",
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom", "feature"]
                        },
                        "property-type": "data-driven"
                    },
                    visibility: {
                        type: "enum",
                        values: {
                            visible: {},
                            none: {}
                        },
                        default: "visible",
                        "property-type": "constant"
                    }
                },
                layout_symbol: {
                    "symbol-placement": {
                        type: "enum",
                        values: {
                            point: {},
                            line: {},
                            "line-center": {}
                        },
                        default: "point",
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "symbol-spacing": {
                        type: "number",
                        default: 250,
                        minimum: 1,
                        units: "pixels",
                        requires: [{
                            "symbol-placement": "line"
                        }],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "symbol-avoid-edges": {
                        type: "boolean",
                        default: !1,
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "symbol-sort-key": {
                        type: "number",
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom", "feature"]
                        },
                        "property-type": "data-driven"
                    },
                    "symbol-z-order": {
                        type: "enum",
                        values: {
                            auto: {},
                            "viewport-y": {},
                            source: {}
                        },
                        default: "auto",
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "icon-allow-overlap": {
                        type: "boolean",
                        default: !1,
                        requires: ["icon-image", {
                            "!": "icon-overlap"
                        }],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "icon-overlap": {
                        type: "enum",
                        values: {
                            never: {},
                            always: {},
                            cooperative: {}
                        },
                        requires: ["icon-image"],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "icon-ignore-placement": {
                        type: "boolean",
                        default: !1,
                        requires: ["icon-image"],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "icon-optional": {
                        type: "boolean",
                        default: !1,
                        requires: ["icon-image", "text-field"],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "icon-rotation-alignment": {
                        type: "enum",
                        values: {
                            map: {},
                            viewport: {},
                            auto: {}
                        },
                        default: "auto",
                        requires: ["icon-image"],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "icon-size": {
                        type: "number",
                        default: 1,
                        minimum: 0,
                        units: "factor of the original icon size",
                        requires: ["icon-image"],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature"]
                        },
                        "property-type": "data-driven"
                    },
                    "icon-text-fit": {
                        type: "enum",
                        values: {
                            none: {},
                            width: {},
                            height: {},
                            both: {}
                        },
                        default: "none",
                        requires: ["icon-image", "text-field"],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "icon-text-fit-padding": {
                        type: "array",
                        value: "number",
                        length: 4,
                        default: [0, 0, 0, 0],
                        units: "pixels",
                        requires: ["icon-image", "text-field", {
                            "icon-text-fit": ["both", "width", "height"]
                        }],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "icon-image": {
                        type: "resolvedImage",
                        tokens: !0,
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom", "feature"]
                        },
                        "property-type": "data-driven"
                    },
                    "icon-rotate": {
                        type: "number",
                        default: 0,
                        period: 360,
                        units: "degrees",
                        requires: ["icon-image"],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature"]
                        },
                        "property-type": "data-driven"
                    },
                    "icon-padding": {
                        type: "padding",
                        default: [2],
                        units: "pixels",
                        requires: ["icon-image"],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature"]
                        },
                        "property-type": "data-driven"
                    },
                    "icon-keep-upright": {
                        type: "boolean",
                        default: !1,
                        requires: ["icon-image", {
                            "icon-rotation-alignment": "map"
                        }, {
                            "symbol-placement": ["line", "line-center"]
                        }],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "icon-offset": {
                        type: "array",
                        value: "number",
                        length: 2,
                        default: [0, 0],
                        requires: ["icon-image"],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature"]
                        },
                        "property-type": "data-driven"
                    },
                    "icon-anchor": {
                        type: "enum",
                        values: {
                            center: {},
                            left: {},
                            right: {},
                            top: {},
                            bottom: {},
                            "top-left": {},
                            "top-right": {},
                            "bottom-left": {},
                            "bottom-right": {}
                        },
                        default: "center",
                        requires: ["icon-image"],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom", "feature"]
                        },
                        "property-type": "data-driven"
                    },
                    "icon-pitch-alignment": {
                        type: "enum",
                        values: {
                            map: {},
                            viewport: {},
                            auto: {}
                        },
                        default: "auto",
                        requires: ["icon-image"],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "text-pitch-alignment": {
                        type: "enum",
                        values: {
                            map: {},
                            viewport: {},
                            auto: {}
                        },
                        default: "auto",
                        requires: ["text-field"],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "text-rotation-alignment": {
                        type: "enum",
                        values: {
                            map: {},
                            viewport: {},
                            "viewport-glyph": {},
                            auto: {}
                        },
                        default: "auto",
                        requires: ["text-field"],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "text-field": {
                        type: "formatted",
                        default: "",
                        tokens: !0,
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom", "feature"]
                        },
                        "property-type": "data-driven"
                    },
                    "text-font": {
                        type: "array",
                        value: "string",
                        default: ["Open Sans Regular", "Arial Unicode MS Regular"],
                        requires: ["text-field"],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom", "feature"]
                        },
                        "property-type": "data-driven"
                    },
                    "text-size": {
                        type: "number",
                        default: 16,
                        minimum: 0,
                        units: "pixels",
                        requires: ["text-field"],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature"]
                        },
                        "property-type": "data-driven"
                    },
                    "text-max-width": {
                        type: "number",
                        default: 10,
                        minimum: 0,
                        units: "ems",
                        requires: ["text-field"],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature"]
                        },
                        "property-type": "data-driven"
                    },
                    "text-line-height": {
                        type: "number",
                        default: 1.2,
                        units: "ems",
                        requires: ["text-field"],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "text-letter-spacing": {
                        type: "number",
                        default: 0,
                        units: "ems",
                        requires: ["text-field"],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature"]
                        },
                        "property-type": "data-driven"
                    },
                    "text-justify": {
                        type: "enum",
                        values: {
                            auto: {},
                            left: {},
                            center: {},
                            right: {}
                        },
                        default: "center",
                        requires: ["text-field"],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom", "feature"]
                        },
                        "property-type": "data-driven"
                    },
                    "text-radial-offset": {
                        type: "number",
                        units: "ems",
                        default: 0,
                        requires: ["text-field"],
                        "property-type": "data-driven",
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature"]
                        }
                    },
                    "text-variable-anchor": {
                        type: "array",
                        value: "enum",
                        values: {
                            center: {},
                            left: {},
                            right: {},
                            top: {},
                            bottom: {},
                            "top-left": {},
                            "top-right": {},
                            "bottom-left": {},
                            "bottom-right": {}
                        },
                        requires: ["text-field", {
                            "symbol-placement": ["point"]
                        }],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "text-variable-anchor-offset": {
                        type: "variableAnchorOffsetCollection",
                        requires: ["text-field", {
                            "symbol-placement": ["point"]
                        }],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature"]
                        },
                        "property-type": "data-driven"
                    },
                    "text-anchor": {
                        type: "enum",
                        values: {
                            center: {},
                            left: {},
                            right: {},
                            top: {},
                            bottom: {},
                            "top-left": {},
                            "top-right": {},
                            "bottom-left": {},
                            "bottom-right": {}
                        },
                        default: "center",
                        requires: ["text-field", {
                            "!": "text-variable-anchor"
                        }],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom", "feature"]
                        },
                        "property-type": "data-driven"
                    },
                    "text-max-angle": {
                        type: "number",
                        default: 45,
                        units: "degrees",
                        requires: ["text-field", {
                            "symbol-placement": ["line", "line-center"]
                        }],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "text-writing-mode": {
                        type: "array",
                        value: "enum",
                        values: {
                            horizontal: {},
                            vertical: {}
                        },
                        requires: ["text-field", {
                            "symbol-placement": ["point"]
                        }],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "text-rotate": {
                        type: "number",
                        default: 0,
                        period: 360,
                        units: "degrees",
                        requires: ["text-field"],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature"]
                        },
                        "property-type": "data-driven"
                    },
                    "text-padding": {
                        type: "number",
                        default: 2,
                        minimum: 0,
                        units: "pixels",
                        requires: ["text-field"],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "text-keep-upright": {
                        type: "boolean",
                        default: !0,
                        requires: ["text-field", {
                            "text-rotation-alignment": "map"
                        }, {
                            "symbol-placement": ["line", "line-center"]
                        }],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "text-transform": {
                        type: "enum",
                        values: {
                            none: {},
                            uppercase: {},
                            lowercase: {}
                        },
                        default: "none",
                        requires: ["text-field"],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom", "feature"]
                        },
                        "property-type": "data-driven"
                    },
                    "text-offset": {
                        type: "array",
                        value: "number",
                        units: "ems",
                        length: 2,
                        default: [0, 0],
                        requires: ["text-field", {
                            "!": "text-radial-offset"
                        }],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature"]
                        },
                        "property-type": "data-driven"
                    },
                    "text-allow-overlap": {
                        type: "boolean",
                        default: !1,
                        requires: ["text-field", {
                            "!": "text-overlap"
                        }],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "text-overlap": {
                        type: "enum",
                        values: {
                            never: {},
                            always: {},
                            cooperative: {}
                        },
                        requires: ["text-field"],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "text-ignore-placement": {
                        type: "boolean",
                        default: !1,
                        requires: ["text-field"],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "text-optional": {
                        type: "boolean",
                        default: !1,
                        requires: ["text-field", "icon-image"],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    visibility: {
                        type: "enum",
                        values: {
                            visible: {},
                            none: {}
                        },
                        default: "visible",
                        "property-type": "constant"
                    }
                },
                layout_raster: {
                    visibility: {
                        type: "enum",
                        values: {
                            visible: {},
                            none: {}
                        },
                        default: "visible",
                        "property-type": "constant"
                    }
                },
                layout_hillshade: {
                    visibility: {
                        type: "enum",
                        values: {
                            visible: {},
                            none: {}
                        },
                        default: "visible",
                        "property-type": "constant"
                    }
                },
                filter: {
                    type: "array",
                    value: "*"
                },
                filter_operator: {
                    type: "enum",
                    values: {
                        "==": {},
                        "!=": {},
                        ">": {},
                        ">=": {},
                        "<": {},
                        "<=": {},
                        in: {},
                        "!in": {},
                        all: {},
                        any: {},
                        none: {},
                        has: {},
                        "!has": {},
                        within: {}
                    }
                },
                geometry_type: {
                    type: "enum",
                    values: {
                        Point: {},
                        LineString: {},
                        Polygon: {}
                    }
                },
                function: {
                    expression: {
                        type: "expression"
                    },
                    stops: {
                        type: "array",
                        value: "function_stop"
                    },
                    base: {
                        type: "number",
                        default: 1,
                        minimum: 0
                    },
                    property: {
                        type: "string",
                        default: "$zoom"
                    },
                    type: {
                        type: "enum",
                        values: {
                            identity: {},
                            exponential: {},
                            interval: {},
                            categorical: {}
                        },
                        default: "exponential"
                    },
                    colorSpace: {
                        type: "enum",
                        values: {
                            rgb: {},
                            lab: {},
                            hcl: {}
                        },
                        default: "rgb"
                    },
                    default: {
                        type: "*",
                        required: !1
                    }
                },
                function_stop: {
                    type: "array",
                    minimum: 0,
                    maximum: 24,
                    value: ["number", "color"],
                    length: 2
                },
                expression: {
                    type: "array",
                    value: "*",
                    minimum: 1
                },
                light: {
                    anchor: {
                        type: "enum",
                        default: "viewport",
                        values: {
                            map: {},
                            viewport: {}
                        },
                        "property-type": "data-constant",
                        transition: !1,
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        }
                    },
                    position: {
                        type: "array",
                        default: [1.15, 210, 30],
                        length: 3,
                        value: "number",
                        "property-type": "data-constant",
                        transition: !0,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        }
                    },
                    color: {
                        type: "color",
                        "property-type": "data-constant",
                        default: "#ffffff",
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        transition: !0
                    },
                    intensity: {
                        type: "number",
                        "property-type": "data-constant",
                        default: .5,
                        minimum: 0,
                        maximum: 1,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        transition: !0
                    }
                },
                sky: {
                    "sky-color": {
                        type: "color",
                        "property-type": "data-constant",
                        default: "#88C6FC",
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        transition: !0
                    },
                    "fog-color": {
                        type: "color",
                        "property-type": "data-constant",
                        default: "#ffffff",
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        transition: !0
                    },
                    "fog-blend": {
                        type: "number",
                        "property-type": "data-constant",
                        default: .5,
                        minimum: 0,
                        maximum: 1,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        transition: !0
                    },
                    "horizon-blend": {
                        type: "number",
                        "property-type": "data-constant",
                        default: .8,
                        minimum: 0,
                        maximum: 1,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        transition: !0
                    }
                },
                terrain: {
                    source: {
                        type: "string",
                        required: !0
                    },
                    exaggeration: {
                        type: "number",
                        minimum: 0,
                        default: 1
                    }
                },
                paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"],
                paint_fill: {
                    "fill-antialias": {
                        type: "boolean",
                        default: !0,
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "fill-opacity": {
                        type: "number",
                        default: 1,
                        minimum: 0,
                        maximum: 1,
                        transition: !0,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "fill-color": {
                        type: "color",
                        default: "#000000",
                        transition: !0,
                        requires: [{
                            "!": "fill-pattern"
                        }],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "fill-outline-color": {
                        type: "color",
                        transition: !0,
                        requires: [{
                            "!": "fill-pattern"
                        }, {
                            "fill-antialias": !0
                        }],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "fill-translate": {
                        type: "array",
                        value: "number",
                        length: 2,
                        default: [0, 0],
                        transition: !0,
                        units: "pixels",
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "fill-translate-anchor": {
                        type: "enum",
                        values: {
                            map: {},
                            viewport: {}
                        },
                        default: "map",
                        requires: ["fill-translate"],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "fill-pattern": {
                        type: "resolvedImage",
                        transition: !0,
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom", "feature"]
                        },
                        "property-type": "cross-faded-data-driven"
                    }
                },
                "paint_fill-extrusion": {
                    "fill-extrusion-opacity": {
                        type: "number",
                        default: 1,
                        minimum: 0,
                        maximum: 1,
                        transition: !0,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "fill-extrusion-color": {
                        type: "color",
                        default: "#000000",
                        transition: !0,
                        requires: [{
                            "!": "fill-extrusion-pattern"
                        }],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "fill-extrusion-translate": {
                        type: "array",
                        value: "number",
                        length: 2,
                        default: [0, 0],
                        transition: !0,
                        units: "pixels",
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "fill-extrusion-translate-anchor": {
                        type: "enum",
                        values: {
                            map: {},
                            viewport: {}
                        },
                        default: "map",
                        requires: ["fill-extrusion-translate"],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "fill-extrusion-pattern": {
                        type: "resolvedImage",
                        transition: !0,
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom", "feature"]
                        },
                        "property-type": "cross-faded-data-driven"
                    },
                    "fill-extrusion-height": {
                        type: "number",
                        default: 0,
                        minimum: 0,
                        units: "meters",
                        transition: !0,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "fill-extrusion-base": {
                        type: "number",
                        default: 0,
                        minimum: 0,
                        units: "meters",
                        transition: !0,
                        requires: ["fill-extrusion-height"],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "fill-extrusion-vertical-gradient": {
                        type: "boolean",
                        default: !0,
                        transition: !1,
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    }
                },
                paint_line: {
                    "line-opacity": {
                        type: "number",
                        default: 1,
                        minimum: 0,
                        maximum: 1,
                        transition: !0,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "line-color": {
                        type: "color",
                        default: "#000000",
                        transition: !0,
                        requires: [{
                            "!": "line-pattern"
                        }],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "line-translate": {
                        type: "array",
                        value: "number",
                        length: 2,
                        default: [0, 0],
                        transition: !0,
                        units: "pixels",
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "line-translate-anchor": {
                        type: "enum",
                        values: {
                            map: {},
                            viewport: {}
                        },
                        default: "map",
                        requires: ["line-translate"],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "line-width": {
                        type: "number",
                        default: 1,
                        minimum: 0,
                        transition: !0,
                        units: "pixels",
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "line-gap-width": {
                        type: "number",
                        default: 0,
                        minimum: 0,
                        transition: !0,
                        units: "pixels",
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "line-offset": {
                        type: "number",
                        default: 0,
                        transition: !0,
                        units: "pixels",
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "line-blur": {
                        type: "number",
                        default: 0,
                        minimum: 0,
                        transition: !0,
                        units: "pixels",
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "line-dasharray": {
                        type: "array",
                        value: "number",
                        minimum: 0,
                        transition: !0,
                        units: "line widths",
                        requires: [{
                            "!": "line-pattern"
                        }],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "cross-faded"
                    },
                    "line-pattern": {
                        type: "resolvedImage",
                        transition: !0,
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom", "feature"]
                        },
                        "property-type": "cross-faded-data-driven"
                    },
                    "line-gradient": {
                        type: "color",
                        transition: !1,
                        requires: [{
                            "!": "line-dasharray"
                        }, {
                            "!": "line-pattern"
                        }, {
                            source: "geojson",
                            has: {
                                lineMetrics: !0
                            }
                        }],
                        expression: {
                            interpolated: !0,
                            parameters: ["line-progress"]
                        },
                        "property-type": "color-ramp"
                    }
                },
                paint_circle: {
                    "circle-radius": {
                        type: "number",
                        default: 5,
                        minimum: 0,
                        transition: !0,
                        units: "pixels",
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "circle-color": {
                        type: "color",
                        default: "#000000",
                        transition: !0,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "circle-blur": {
                        type: "number",
                        default: 0,
                        transition: !0,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "circle-opacity": {
                        type: "number",
                        default: 1,
                        minimum: 0,
                        maximum: 1,
                        transition: !0,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "circle-translate": {
                        type: "array",
                        value: "number",
                        length: 2,
                        default: [0, 0],
                        transition: !0,
                        units: "pixels",
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "circle-translate-anchor": {
                        type: "enum",
                        values: {
                            map: {},
                            viewport: {}
                        },
                        default: "map",
                        requires: ["circle-translate"],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "circle-pitch-scale": {
                        type: "enum",
                        values: {
                            map: {},
                            viewport: {}
                        },
                        default: "map",
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "circle-pitch-alignment": {
                        type: "enum",
                        values: {
                            map: {},
                            viewport: {}
                        },
                        default: "viewport",
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "circle-stroke-width": {
                        type: "number",
                        default: 0,
                        minimum: 0,
                        transition: !0,
                        units: "pixels",
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "circle-stroke-color": {
                        type: "color",
                        default: "#000000",
                        transition: !0,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "circle-stroke-opacity": {
                        type: "number",
                        default: 1,
                        minimum: 0,
                        maximum: 1,
                        transition: !0,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    }
                },
                paint_heatmap: {
                    "heatmap-radius": {
                        type: "number",
                        default: 30,
                        minimum: 1,
                        transition: !0,
                        units: "pixels",
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "heatmap-weight": {
                        type: "number",
                        default: 1,
                        minimum: 0,
                        transition: !1,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "heatmap-intensity": {
                        type: "number",
                        default: 1,
                        minimum: 0,
                        transition: !0,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "heatmap-color": {
                        type: "color",
                        default: ["interpolate", ["linear"],
                            ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"
                        ],
                        transition: !1,
                        expression: {
                            interpolated: !0,
                            parameters: ["heatmap-density"]
                        },
                        "property-type": "color-ramp"
                    },
                    "heatmap-opacity": {
                        type: "number",
                        default: 1,
                        minimum: 0,
                        maximum: 1,
                        transition: !0,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    }
                },
                paint_symbol: {
                    "icon-opacity": {
                        type: "number",
                        default: 1,
                        minimum: 0,
                        maximum: 1,
                        transition: !0,
                        requires: ["icon-image"],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "icon-color": {
                        type: "color",
                        default: "#000000",
                        transition: !0,
                        requires: ["icon-image"],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "icon-halo-color": {
                        type: "color",
                        default: "rgba(0, 0, 0, 0)",
                        transition: !0,
                        requires: ["icon-image"],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "icon-halo-width": {
                        type: "number",
                        default: 0,
                        minimum: 0,
                        transition: !0,
                        units: "pixels",
                        requires: ["icon-image"],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "icon-halo-blur": {
                        type: "number",
                        default: 0,
                        minimum: 0,
                        transition: !0,
                        units: "pixels",
                        requires: ["icon-image"],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "icon-translate": {
                        type: "array",
                        value: "number",
                        length: 2,
                        default: [0, 0],
                        transition: !0,
                        units: "pixels",
                        requires: ["icon-image"],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "icon-translate-anchor": {
                        type: "enum",
                        values: {
                            map: {},
                            viewport: {}
                        },
                        default: "map",
                        requires: ["icon-image", "icon-translate"],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "text-opacity": {
                        type: "number",
                        default: 1,
                        minimum: 0,
                        maximum: 1,
                        transition: !0,
                        requires: ["text-field"],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "text-color": {
                        type: "color",
                        default: "#000000",
                        transition: !0,
                        overridable: !0,
                        requires: ["text-field"],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "text-halo-color": {
                        type: "color",
                        default: "rgba(0, 0, 0, 0)",
                        transition: !0,
                        requires: ["text-field"],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "text-halo-width": {
                        type: "number",
                        default: 0,
                        minimum: 0,
                        transition: !0,
                        units: "pixels",
                        requires: ["text-field"],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "text-halo-blur": {
                        type: "number",
                        default: 0,
                        minimum: 0,
                        transition: !0,
                        units: "pixels",
                        requires: ["text-field"],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom", "feature", "feature-state"]
                        },
                        "property-type": "data-driven"
                    },
                    "text-translate": {
                        type: "array",
                        value: "number",
                        length: 2,
                        default: [0, 0],
                        transition: !0,
                        units: "pixels",
                        requires: ["text-field"],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "text-translate-anchor": {
                        type: "enum",
                        values: {
                            map: {},
                            viewport: {}
                        },
                        default: "map",
                        requires: ["text-field", "text-translate"],
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    }
                },
                paint_raster: {
                    "raster-opacity": {
                        type: "number",
                        default: 1,
                        minimum: 0,
                        maximum: 1,
                        transition: !0,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "raster-hue-rotate": {
                        type: "number",
                        default: 0,
                        period: 360,
                        transition: !0,
                        units: "degrees",
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "raster-brightness-min": {
                        type: "number",
                        default: 0,
                        minimum: 0,
                        maximum: 1,
                        transition: !0,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "raster-brightness-max": {
                        type: "number",
                        default: 1,
                        minimum: 0,
                        maximum: 1,
                        transition: !0,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "raster-saturation": {
                        type: "number",
                        default: 0,
                        minimum: -1,
                        maximum: 1,
                        transition: !0,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "raster-contrast": {
                        type: "number",
                        default: 0,
                        minimum: -1,
                        maximum: 1,
                        transition: !0,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "raster-resampling": {
                        type: "enum",
                        values: {
                            linear: {},
                            nearest: {}
                        },
                        default: "linear",
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "raster-fade-duration": {
                        type: "number",
                        default: 300,
                        minimum: 0,
                        transition: !1,
                        units: "milliseconds",
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    }
                },
                paint_hillshade: {
                    "hillshade-illumination-direction": {
                        type: "number",
                        default: 335,
                        minimum: 0,
                        maximum: 359,
                        transition: !1,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "hillshade-illumination-anchor": {
                        type: "enum",
                        values: {
                            map: {},
                            viewport: {}
                        },
                        default: "viewport",
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "hillshade-exaggeration": {
                        type: "number",
                        default: .5,
                        minimum: 0,
                        maximum: 1,
                        transition: !0,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "hillshade-shadow-color": {
                        type: "color",
                        default: "#000000",
                        transition: !0,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "hillshade-highlight-color": {
                        type: "color",
                        default: "#FFFFFF",
                        transition: !0,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "hillshade-accent-color": {
                        type: "color",
                        default: "#000000",
                        transition: !0,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    }
                },
                paint_background: {
                    "background-color": {
                        type: "color",
                        default: "#000000",
                        transition: !0,
                        requires: [{
                            "!": "background-pattern"
                        }],
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    },
                    "background-pattern": {
                        type: "resolvedImage",
                        transition: !0,
                        expression: {
                            interpolated: !1,
                            parameters: ["zoom"]
                        },
                        "property-type": "cross-faded"
                    },
                    "background-opacity": {
                        type: "number",
                        default: 1,
                        minimum: 0,
                        maximum: 1,
                        transition: !0,
                        expression: {
                            interpolated: !0,
                            parameters: ["zoom"]
                        },
                        "property-type": "data-constant"
                    }
                },
                transition: {
                    duration: {
                        type: "number",
                        default: 300,
                        minimum: 0,
                        units: "milliseconds"
                    },
                    delay: {
                        type: "number",
                        default: 0,
                        minimum: 0,
                        units: "milliseconds"
                    }
                },
                "property-type": {
                    "data-driven": {
                        type: "property-type"
                    },
                    "cross-faded": {
                        type: "property-type"
                    },
                    "cross-faded-data-driven": {
                        type: "property-type"
                    },
                    "color-ramp": {
                        type: "property-type"
                    },
                    "data-constant": {
                        type: "property-type"
                    },
                    constant: {
                        type: "property-type"
                    }
                },
                promoteId: {
                    "*": {
                        type: "string"
                    }
                }
            };
            const Ot = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];

            function ii(i, t) {
                const a = {};
                for (const l in i) l !== "ref" && (a[l] = i[l]);
                return Ot.forEach(l => {
                    l in t && (a[l] = t[l])
                }), a
            }

            function Wt(i, t) {
                if (Array.isArray(i)) {
                    if (!Array.isArray(t) || i.length !== t.length) return !1;
                    for (let a = 0; a < i.length; a++)
                        if (!Wt(i[a], t[a])) return !1;
                    return !0
                }
                if (typeof i == "object" && i !== null && t !== null) {
                    if (typeof t != "object" || Object.keys(i).length !== Object.keys(t).length) return !1;
                    for (const a in i)
                        if (!Wt(i[a], t[a])) return !1;
                    return !0
                }
                return i === t
            }

            function bi(i, t) {
                i.push(t)
            }

            function Qi(i, t, a) {
                bi(a, {
                    command: "addSource",
                    args: [i, t[i]]
                })
            }

            function sn(i, t, a) {
                bi(t, {
                    command: "removeSource",
                    args: [i]
                }), a[i] = !0
            }

            function yn(i, t, a, l) {
                sn(i, a, l), Qi(i, t, a)
            }

            function Yi(i, t, a) {
                let l;
                for (l in i[a])
                    if (Object.prototype.hasOwnProperty.call(i[a], l) && l !== "data" && !Wt(i[a][l], t[a][l])) return !1;
                for (l in t[a])
                    if (Object.prototype.hasOwnProperty.call(t[a], l) && l !== "data" && !Wt(i[a][l], t[a][l])) return !1;
                return !0
            }

            function rn(i, t, a, l, d, g) {
                i = i || {}, t = t || {};
                for (const x in i) Object.prototype.hasOwnProperty.call(i, x) && (Wt(i[x], t[x]) || a.push({
                    command: g,
                    args: [l, x, t[x], d]
                }));
                for (const x in t) Object.prototype.hasOwnProperty.call(t, x) && !Object.prototype.hasOwnProperty.call(i, x) && (Wt(i[x], t[x]) || a.push({
                    command: g,
                    args: [l, x, t[x], d]
                }))
            }

            function Mi(i) {
                return i.id
            }

            function Ht(i, t) {
                return i[t.id] = t, i
            }
            class Pt {
                constructor(t, a, l, d) {
                    this.message = (t ? `${t}: ` : "") + l, d && (this.identifier = d), a != null && a.__line__ && (this.line = a.__line__)
                }
            }

            function qn(i, ...t) {
                for (const a of t)
                    for (const l in a) i[l] = a[l];
                return i
            }
            class ji extends Error {
                constructor(t, a) {
                    super(a), this.message = a, this.key = t
                }
            }
            class na {
                constructor(t, a = []) {
                    this.parent = t, this.bindings = {};
                    for (const [l, d] of a) this.bindings[l] = d
                }
                concat(t) {
                    return new na(this, t)
                }
                get(t) {
                    if (this.bindings[t]) return this.bindings[t];
                    if (this.parent) return this.parent.get(t);
                    throw new Error(`${t} not found in scope.`)
                }
                has(t) {
                    return !!this.bindings[t] || !!this.parent && this.parent.has(t)
                }
            }
            const cn = {
                    kind: "null"
                },
                yi = {
                    kind: "number"
                },
                Si = {
                    kind: "string"
                },
                qi = {
                    kind: "boolean"
                },
                Nn = {
                    kind: "color"
                },
                Bn = {
                    kind: "object"
                },
                ge = {
                    kind: "value"
                },
                ga = {
                    kind: "collator"
                },
                On = {
                    kind: "formatted"
                },
                Te = {
                    kind: "padding"
                },
                te = {
                    kind: "resolvedImage"
                },
                he = {
                    kind: "variableAnchorOffsetCollection"
                };

            function fe(i, t) {
                return {
                    kind: "array",
                    itemType: i,
                    N: t
                }
            }

            function Ae(i) {
                if (i.kind === "array") {
                    const t = Ae(i.itemType);
                    return typeof i.N == "number" ? `array<${t}, ${i.N}>` : i.itemType.kind === "value" ? "array" : `array<${t}>`
                }
                return i.kind
            }
            const qe = [cn, yi, Si, qi, Nn, On, Bn, fe(ge), Te, te, he];

            function et(i, t) {
                if (t.kind === "error") return null;
                if (i.kind === "array") {
                    if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !et(i.itemType, t.itemType)) && (typeof i.N != "number" || i.N === t.N)) return null
                } else {
                    if (i.kind === t.kind) return null;
                    if (i.kind === "value") {
                        for (const a of qe)
                            if (!et(a, t)) return null
                    }
                }
                return `Expected ${Ae(i)} but found ${Ae(t)} instead.`
            }

            function it(i, t) {
                return t.some(a => a.kind === i.kind)
            }

            function We(i, t) {
                return t.some(a => a === "null" ? i === null : a === "array" ? Array.isArray(i) : a === "object" ? i && !Array.isArray(i) && typeof i == "object" : a === typeof i)
            }

            function ft(i, t) {
                return i.kind === "array" && t.kind === "array" ? i.itemType.kind === t.itemType.kind && typeof i.N == "number" : i.kind === t.kind
            }
            const Jt = .96422,
                zt = .82521,
                It = 4 / 29,
                zi = 6 / 29,
                Zi = 3 * zi * zi,
                dn = zi * zi * zi,
                on = Math.PI / 180,
                vn = 180 / Math.PI;

            function Pn(i) {
                return (i %= 360) < 0 && (i += 360), i
            }

            function Fn([i, t, a, l]) {
                let d, g;
                const x = hn((.2225045 * (i = kn(i)) + .7168786 * (t = kn(t)) + .0606169 * (a = kn(a))) / 1);
                i === t && t === a ? d = g = x : (d = hn((.4360747 * i + .3850649 * t + .1430804 * a) / Jt), g = hn((.0139322 * i + .0971045 * t + .7141733 * a) / zt));
                const A = 116 * x - 16;
                return [A < 0 ? 0 : A, 500 * (d - x), 200 * (x - g), l]
            }

            function kn(i) {
                return i <= .04045 ? i / 12.92 : Math.pow((i + .055) / 1.055, 2.4)
            }

            function hn(i) {
                return i > dn ? Math.pow(i, 1 / 3) : i / Zi + It
            }

            function Vn([i, t, a, l]) {
                let d = (i + 16) / 116,
                    g = isNaN(t) ? d : d + t / 500,
                    x = isNaN(a) ? d : d - a / 200;
                return d = 1 * zr(d), g = Jt * zr(g), x = zt * zr(x), [Gn(3.1338561 * g - 1.6168667 * d - .4906146 * x), Gn(-.9787684 * g + 1.9161415 * d + .033454 * x), Gn(.0719453 * g - .2289914 * d + 1.4052427 * x), l]
            }

            function Gn(i) {
                return (i = i <= .00304 ? 12.92 * i : 1.055 * Math.pow(i, 1 / 2.4) - .055) < 0 ? 0 : i > 1 ? 1 : i
            }

            function zr(i) {
                return i > zi ? i * i * i : Zi * (i - It)
            }

            function br(i) {
                return parseInt(i.padEnd(2, i), 16) / 255
            }

            function ur(i, t) {
                return wr(t ? i / 100 : i, 0, 1)
            }

            function wr(i, t, a) {
                return Math.min(Math.max(t, i), a)
            }

            function Ui(i) {
                return !i.some(Number.isNaN)
            }
            const ya = {
                aliceblue: [240, 248, 255],
                antiquewhite: [250, 235, 215],
                aqua: [0, 255, 255],
                aquamarine: [127, 255, 212],
                azure: [240, 255, 255],
                beige: [245, 245, 220],
                bisque: [255, 228, 196],
                black: [0, 0, 0],
                blanchedalmond: [255, 235, 205],
                blue: [0, 0, 255],
                blueviolet: [138, 43, 226],
                brown: [165, 42, 42],
                burlywood: [222, 184, 135],
                cadetblue: [95, 158, 160],
                chartreuse: [127, 255, 0],
                chocolate: [210, 105, 30],
                coral: [255, 127, 80],
                cornflowerblue: [100, 149, 237],
                cornsilk: [255, 248, 220],
                crimson: [220, 20, 60],
                cyan: [0, 255, 255],
                darkblue: [0, 0, 139],
                darkcyan: [0, 139, 139],
                darkgoldenrod: [184, 134, 11],
                darkgray: [169, 169, 169],
                darkgreen: [0, 100, 0],
                darkgrey: [169, 169, 169],
                darkkhaki: [189, 183, 107],
                darkmagenta: [139, 0, 139],
                darkolivegreen: [85, 107, 47],
                darkorange: [255, 140, 0],
                darkorchid: [153, 50, 204],
                darkred: [139, 0, 0],
                darksalmon: [233, 150, 122],
                darkseagreen: [143, 188, 143],
                darkslateblue: [72, 61, 139],
                darkslategray: [47, 79, 79],
                darkslategrey: [47, 79, 79],
                darkturquoise: [0, 206, 209],
                darkviolet: [148, 0, 211],
                deeppink: [255, 20, 147],
                deepskyblue: [0, 191, 255],
                dimgray: [105, 105, 105],
                dimgrey: [105, 105, 105],
                dodgerblue: [30, 144, 255],
                firebrick: [178, 34, 34],
                floralwhite: [255, 250, 240],
                forestgreen: [34, 139, 34],
                fuchsia: [255, 0, 255],
                gainsboro: [220, 220, 220],
                ghostwhite: [248, 248, 255],
                gold: [255, 215, 0],
                goldenrod: [218, 165, 32],
                gray: [128, 128, 128],
                green: [0, 128, 0],
                greenyellow: [173, 255, 47],
                grey: [128, 128, 128],
                honeydew: [240, 255, 240],
                hotpink: [255, 105, 180],
                indianred: [205, 92, 92],
                indigo: [75, 0, 130],
                ivory: [255, 255, 240],
                khaki: [240, 230, 140],
                lavender: [230, 230, 250],
                lavenderblush: [255, 240, 245],
                lawngreen: [124, 252, 0],
                lemonchiffon: [255, 250, 205],
                lightblue: [173, 216, 230],
                lightcoral: [240, 128, 128],
                lightcyan: [224, 255, 255],
                lightgoldenrodyellow: [250, 250, 210],
                lightgray: [211, 211, 211],
                lightgreen: [144, 238, 144],
                lightgrey: [211, 211, 211],
                lightpink: [255, 182, 193],
                lightsalmon: [255, 160, 122],
                lightseagreen: [32, 178, 170],
                lightskyblue: [135, 206, 250],
                lightslategray: [119, 136, 153],
                lightslategrey: [119, 136, 153],
                lightsteelblue: [176, 196, 222],
                lightyellow: [255, 255, 224],
                lime: [0, 255, 0],
                limegreen: [50, 205, 50],
                linen: [250, 240, 230],
                magenta: [255, 0, 255],
                maroon: [128, 0, 0],
                mediumaquamarine: [102, 205, 170],
                mediumblue: [0, 0, 205],
                mediumorchid: [186, 85, 211],
                mediumpurple: [147, 112, 219],
                mediumseagreen: [60, 179, 113],
                mediumslateblue: [123, 104, 238],
                mediumspringgreen: [0, 250, 154],
                mediumturquoise: [72, 209, 204],
                mediumvioletred: [199, 21, 133],
                midnightblue: [25, 25, 112],
                mintcream: [245, 255, 250],
                mistyrose: [255, 228, 225],
                moccasin: [255, 228, 181],
                navajowhite: [255, 222, 173],
                navy: [0, 0, 128],
                oldlace: [253, 245, 230],
                olive: [128, 128, 0],
                olivedrab: [107, 142, 35],
                orange: [255, 165, 0],
                orangered: [255, 69, 0],
                orchid: [218, 112, 214],
                palegoldenrod: [238, 232, 170],
                palegreen: [152, 251, 152],
                paleturquoise: [175, 238, 238],
                palevioletred: [219, 112, 147],
                papayawhip: [255, 239, 213],
                peachpuff: [255, 218, 185],
                peru: [205, 133, 63],
                pink: [255, 192, 203],
                plum: [221, 160, 221],
                powderblue: [176, 224, 230],
                purple: [128, 0, 128],
                rebeccapurple: [102, 51, 153],
                red: [255, 0, 0],
                rosybrown: [188, 143, 143],
                royalblue: [65, 105, 225],
                saddlebrown: [139, 69, 19],
                salmon: [250, 128, 114],
                sandybrown: [244, 164, 96],
                seagreen: [46, 139, 87],
                seashell: [255, 245, 238],
                sienna: [160, 82, 45],
                silver: [192, 192, 192],
                skyblue: [135, 206, 235],
                slateblue: [106, 90, 205],
                slategray: [112, 128, 144],
                slategrey: [112, 128, 144],
                snow: [255, 250, 250],
                springgreen: [0, 255, 127],
                steelblue: [70, 130, 180],
                tan: [210, 180, 140],
                teal: [0, 128, 128],
                thistle: [216, 191, 216],
                tomato: [255, 99, 71],
                turquoise: [64, 224, 208],
                violet: [238, 130, 238],
                wheat: [245, 222, 179],
                white: [255, 255, 255],
                whitesmoke: [245, 245, 245],
                yellow: [255, 255, 0],
                yellowgreen: [154, 205, 50]
            };
            class _n {
                constructor(t, a, l, d = 1, g = !0) {
                    this.r = t, this.g = a, this.b = l, this.a = d, g || (this.r *= d, this.g *= d, this.b *= d, d || this.overwriteGetter("rgb", [t, a, l, d]))
                }
                static parse(t) {
                    if (t instanceof _n) return t;
                    if (typeof t != "string") return;
                    const a = function(l) {
                        if ((l = l.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
                        const d = ya[l];
                        if (d) {
                            const [x, A, M] = d;
                            return [x / 255, A / 255, M / 255, 1]
                        }
                        if (l.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(l)) {
                            const x = l.length < 6 ? 1 : 2;
                            let A = 1;
                            return [br(l.slice(A, A += x)), br(l.slice(A, A += x)), br(l.slice(A, A += x)), br(l.slice(A, A + x) || "ff")]
                        }
                        if (l.startsWith("rgb")) {
                            const x = l.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                            if (x) {
                                const [A, M, F, D, U, N, H, X, ne, le, ce, Qe] = x, Se = [D || " ", H || " ", le].join("");
                                if (Se === "  " || Se === "  /" || Se === ",," || Se === ",,,") {
                                    const Re = [F, N, ne].join(""),
                                        ot = Re === "%%%" ? 100 : Re === "" ? 255 : 0;
                                    if (ot) {
                                        const dt = [wr(+M / ot, 0, 1), wr(+U / ot, 0, 1), wr(+X / ot, 0, 1), ce ? ur(+ce, Qe) : 1];
                                        if (Ui(dt)) return dt
                                    }
                                }
                                return
                            }
                        }
                        const g = l.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                        if (g) {
                            const [x, A, M, F, D, U, N, H, X] = g, ne = [M || " ", D || " ", N].join("");
                            if (ne === "  " || ne === "  /" || ne === ",," || ne === ",,,") {
                                const le = [+A, wr(+F, 0, 100), wr(+U, 0, 100), H ? ur(+H, X) : 1];
                                if (Ui(le)) return function([ce, Qe, Se, Re]) {
                                    function ot(dt) {
                                        const Ct = (dt + ce / 30) % 12,
                                            Nt = Qe * Math.min(Se, 1 - Se);
                                        return Se - Nt * Math.max(-1, Math.min(Ct - 3, 9 - Ct, 1))
                                    }
                                    return ce = Pn(ce), Qe /= 100, Se /= 100, [ot(0), ot(8), ot(4), Re]
                                }(le)
                            }
                        }
                    }(t);
                    return a ? new _n(...a, !1) : void 0
                }
                get rgb() {
                    const {
                        r: t,
                        g: a,
                        b: l,
                        a: d
                    } = this, g = d || 1 / 0;
                    return this.overwriteGetter("rgb", [t / g, a / g, l / g, d])
                }
                get hcl() {
                    return this.overwriteGetter("hcl", function(t) {
                        const [a, l, d, g] = Fn(t), x = Math.sqrt(l * l + d * d);
                        return [Math.round(1e4 * x) ? Pn(Math.atan2(d, l) * vn) : NaN, x, a, g]
                    }(this.rgb))
                }
                get lab() {
                    return this.overwriteGetter("lab", Fn(this.rgb))
                }
                overwriteGetter(t, a) {
                    return Object.defineProperty(this, t, {
                        value: a
                    }), a
                }
                toString() {
                    const [t, a, l, d] = this.rgb;
                    return `rgba(${[t,a,l].map(g=>Math.round(255*g)).join(",")},${d})`
                }
            }
            _n.black = new _n(0, 0, 0, 1), _n.white = new _n(1, 1, 1, 1), _n.transparent = new _n(0, 0, 0, 0), _n.red = new _n(1, 0, 0, 1);
            class Qs {
                constructor(t, a, l) {
                    this.sensitivity = t ? a ? "variant" : "case" : a ? "accent" : "base", this.locale = l, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
                        sensitivity: this.sensitivity,
                        usage: "search"
                    })
                }
                compare(t, a) {
                    return this.collator.compare(t, a)
                }
                resolvedLocale() {
                    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale
                }
            }
            class Ra {
                constructor(t, a, l, d, g) {
                    this.text = t, this.image = a, this.scale = l, this.fontStack = d, this.textColor = g
                }
            }
            class rr {
                constructor(t) {
                    this.sections = t
                }
                static fromString(t) {
                    return new rr([new Ra(t, null, null, null, null)])
                }
                isEmpty() {
                    return this.sections.length === 0 || !this.sections.some(t => t.text.length !== 0 || t.image && t.image.name.length !== 0)
                }
                static factory(t) {
                    return t instanceof rr ? t : rr.fromString(t)
                }
                toString() {
                    return this.sections.length === 0 ? "" : this.sections.map(t => t.text).join("")
                }
            }
            class Fr {
                constructor(t) {
                    this.values = t.slice()
                }
                static parse(t) {
                    if (t instanceof Fr) return t;
                    if (typeof t == "number") return new Fr([t, t, t, t]);
                    if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
                        for (const a of t)
                            if (typeof a != "number") return;
                        switch (t.length) {
                            case 1:
                                t = [t[0], t[0], t[0], t[0]];
                                break;
                            case 2:
                                t = [t[0], t[1], t[0], t[1]];
                                break;
                            case 3:
                                t = [t[0], t[1], t[2], t[1]]
                        }
                        return new Fr(t)
                    }
                }
                toString() {
                    return JSON.stringify(this.values)
                }
            }
            const Lr = new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
            class ra {
                constructor(t) {
                    this.values = t.slice()
                }
                static parse(t) {
                    if (t instanceof ra) return t;
                    if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
                        for (let a = 0; a < t.length; a += 2) {
                            const l = t[a],
                                d = t[a + 1];
                            if (typeof l != "string" || !Lr.has(l) || !Array.isArray(d) || d.length !== 2 || typeof d[0] != "number" || typeof d[1] != "number") return
                        }
                        return new ra(t)
                    }
                }
                toString() {
                    return JSON.stringify(this.values)
                }
            }
            class $r {
                constructor(t) {
                    this.name = t.name, this.available = t.available
                }
                toString() {
                    return this.name
                }
                static fromString(t) {
                    return t ? new $r({
                        name: t,
                        available: !1
                    }) : null
                }
            }

            function gr(i, t, a, l) {
                return typeof i == "number" && i >= 0 && i <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof a == "number" && a >= 0 && a <= 255 ? l === void 0 || typeof l == "number" && l >= 0 && l <= 1 ? null : `Invalid rgba value [${[i,t,a,l].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof l=="number"?[i,t,a,l]:[i,t,a]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`
            }

            function Jr(i) {
                if (i === null || typeof i == "string" || typeof i == "boolean" || typeof i == "number" || i instanceof _n || i instanceof Qs || i instanceof rr || i instanceof Fr || i instanceof ra || i instanceof $r) return !0;
                if (Array.isArray(i)) {
                    for (const t of i)
                        if (!Jr(t)) return !1;
                    return !0
                }
                if (typeof i == "object") {
                    for (const t in i)
                        if (!Jr(i[t])) return !1;
                    return !0
                }
                return !1
            }

            function or(i) {
                if (i === null) return cn;
                if (typeof i == "string") return Si;
                if (typeof i == "boolean") return qi;
                if (typeof i == "number") return yi;
                if (i instanceof _n) return Nn;
                if (i instanceof Qs) return ga;
                if (i instanceof rr) return On;
                if (i instanceof Fr) return Te;
                if (i instanceof ra) return he;
                if (i instanceof $r) return te;
                if (Array.isArray(i)) {
                    const t = i.length;
                    let a;
                    for (const l of i) {
                        const d = or(l);
                        if (a) {
                            if (a === d) continue;
                            a = ge;
                            break
                        }
                        a = d
                    }
                    return fe(a || ge, t)
                }
                return Bn
            }

            function wa(i) {
                const t = typeof i;
                return i === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(i) : i instanceof _n || i instanceof rr || i instanceof Fr || i instanceof ra || i instanceof $r ? i.toString() : JSON.stringify(i)
            }
            class la {
                constructor(t, a) {
                    this.type = t, this.value = a
                }
                static parse(t, a) {
                    if (t.length !== 2) return a.error(`'literal' expression requires exactly one argument, but found ${t.length-1} instead.`);
                    if (!Jr(t[1])) return a.error("invalid value");
                    const l = t[1];
                    let d = or(l);
                    const g = a.expectedType;
                    return d.kind !== "array" || d.N !== 0 || !g || g.kind !== "array" || typeof g.N == "number" && g.N !== 0 || (d = g), new la(d, l)
                }
                evaluate() {
                    return this.value
                }
                eachChild() {}
                outputDefined() {
                    return !0
                }
            }
            class Ln {
                constructor(t) {
                    this.name = "ExpressionEvaluationError", this.message = t
                }
                toJSON() {
                    return this.message
                }
            }
            const ja = {
                string: Si,
                number: yi,
                boolean: qi,
                object: Bn
            };
            class Nr {
                constructor(t, a) {
                    this.type = t, this.args = a
                }
                static parse(t, a) {
                    if (t.length < 2) return a.error("Expected at least one argument.");
                    let l, d = 1;
                    const g = t[0];
                    if (g === "array") {
                        let A, M;
                        if (t.length > 2) {
                            const F = t[1];
                            if (typeof F != "string" || !(F in ja) || F === "object") return a.error('The item type argument of "array" must be one of string, number, boolean', 1);
                            A = ja[F], d++
                        } else A = ge;
                        if (t.length > 3) {
                            if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return a.error('The length argument to "array" must be a positive integer literal', 2);
                            M = t[2], d++
                        }
                        l = fe(A, M)
                    } else {
                        if (!ja[g]) throw new Error(`Types doesn't contain name = ${g}`);
                        l = ja[g]
                    }
                    const x = [];
                    for (; d < t.length; d++) {
                        const A = a.parse(t[d], d, ge);
                        if (!A) return null;
                        x.push(A)
                    }
                    return new Nr(l, x)
                }
                evaluate(t) {
                    for (let a = 0; a < this.args.length; a++) {
                        const l = this.args[a].evaluate(t);
                        if (!et(this.type, or(l))) return l;
                        if (a === this.args.length - 1) throw new Ln(`Expected value to be of type ${Ae(this.type)}, but found ${Ae(or(l))} instead.`)
                    }
                    throw new Error
                }
                eachChild(t) {
                    this.args.forEach(t)
                }
                outputDefined() {
                    return this.args.every(t => t.outputDefined())
                }
            }
            const Ps = {
                "to-boolean": qi,
                "to-color": Nn,
                "to-number": yi,
                "to-string": Si
            };
            class va {
                constructor(t, a) {
                    this.type = t, this.args = a
                }
                static parse(t, a) {
                    if (t.length < 2) return a.error("Expected at least one argument.");
                    const l = t[0];
                    if (!Ps[l]) throw new Error(`Can't parse ${l} as it is not part of the known types`);
                    if ((l === "to-boolean" || l === "to-string") && t.length !== 2) return a.error("Expected one argument.");
                    const d = Ps[l],
                        g = [];
                    for (let x = 1; x < t.length; x++) {
                        const A = a.parse(t[x], x, ge);
                        if (!A) return null;
                        g.push(A)
                    }
                    return new va(d, g)
                }
                evaluate(t) {
                    switch (this.type.kind) {
                        case "boolean":
                            return !!this.args[0].evaluate(t);
                        case "color": {
                            let a, l;
                            for (const d of this.args) {
                                if (a = d.evaluate(t), l = null, a instanceof _n) return a;
                                if (typeof a == "string") {
                                    const g = t.parseColor(a);
                                    if (g) return g
                                } else if (Array.isArray(a) && (l = a.length < 3 || a.length > 4 ? `Invalid rbga value ${JSON.stringify(a)}: expected an array containing either three or four numeric values.` : gr(a[0], a[1], a[2], a[3]), !l)) return new _n(a[0] / 255, a[1] / 255, a[2] / 255, a[3])
                            }
                            throw new Ln(l || `Could not parse color from value '${typeof a=="string"?a:JSON.stringify(a)}'`)
                        }
                        case "padding": {
                            let a;
                            for (const l of this.args) {
                                a = l.evaluate(t);
                                const d = Fr.parse(a);
                                if (d) return d
                            }
                            throw new Ln(`Could not parse padding from value '${typeof a=="string"?a:JSON.stringify(a)}'`)
                        }
                        case "variableAnchorOffsetCollection": {
                            let a;
                            for (const l of this.args) {
                                a = l.evaluate(t);
                                const d = ra.parse(a);
                                if (d) return d
                            }
                            throw new Ln(`Could not parse variableAnchorOffsetCollection from value '${typeof a=="string"?a:JSON.stringify(a)}'`)
                        }
                        case "number": {
                            let a = null;
                            for (const l of this.args) {
                                if (a = l.evaluate(t), a === null) return 0;
                                const d = Number(a);
                                if (!isNaN(d)) return d
                            }
                            throw new Ln(`Could not convert ${JSON.stringify(a)} to number.`)
                        }
                        case "formatted":
                            return rr.fromString(wa(this.args[0].evaluate(t)));
                        case "resolvedImage":
                            return $r.fromString(wa(this.args[0].evaluate(t)));
                        default:
                            return wa(this.args[0].evaluate(t))
                    }
                }
                eachChild(t) {
                    this.args.forEach(t)
                }
                outputDefined() {
                    return this.args.every(t => t.outputDefined())
                }
            }
            const $n = ["Unknown", "Point", "LineString", "Polygon"];
            class Qn {
                constructor() {
                    this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null
                }
                id() {
                    return this.feature && "id" in this.feature ? this.feature.id : null
                }
                geometryType() {
                    return this.feature ? typeof this.feature.type == "number" ? $n[this.feature.type] : this.feature.type : null
                }
                geometry() {
                    return this.feature && "geometry" in this.feature ? this.feature.geometry : null
                }
                canonicalID() {
                    return this.canonical
                }
                properties() {
                    return this.feature && this.feature.properties || {}
                }
                parseColor(t) {
                    let a = this._parseColorCache[t];
                    return a || (a = this._parseColorCache[t] = _n.parse(t)), a
                }
            }
            class os {
                constructor(t, a, l = [], d, g = new na, x = []) {
                    this.registry = t, this.path = l, this.key = l.map(A => `[${A}]`).join(""), this.scope = g, this.errors = x, this.expectedType = d, this._isConstant = a
                }
                parse(t, a, l, d, g = {}) {
                    return a ? this.concat(a, l, d)._parse(t, g) : this._parse(t, g)
                }
                _parse(t, a) {
                    function l(d, g, x) {
                        return x === "assert" ? new Nr(g, [d]) : x === "coerce" ? new va(g, [d]) : d
                    }
                    if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) {
                        if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                        const d = t[0];
                        if (typeof d != "string") return this.error(`Expression name must be a string, but found ${typeof d} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
                        const g = this.registry[d];
                        if (g) {
                            let x = g.parse(t, this);
                            if (!x) return null;
                            if (this.expectedType) {
                                const A = this.expectedType,
                                    M = x.type;
                                if (A.kind !== "string" && A.kind !== "number" && A.kind !== "boolean" && A.kind !== "object" && A.kind !== "array" || M.kind !== "value")
                                    if (A.kind !== "color" && A.kind !== "formatted" && A.kind !== "resolvedImage" || M.kind !== "value" && M.kind !== "string")
                                        if (A.kind !== "padding" || M.kind !== "value" && M.kind !== "number" && M.kind !== "array")
                                            if (A.kind !== "variableAnchorOffsetCollection" || M.kind !== "value" && M.kind !== "array") {
                                                if (this.checkSubtype(A, M)) return null
                                            } else x = l(x, A, a.typeAnnotation || "coerce");
                                else x = l(x, A, a.typeAnnotation || "coerce");
                                else x = l(x, A, a.typeAnnotation || "coerce");
                                else x = l(x, A, a.typeAnnotation || "assert")
                            }
                            if (!(x instanceof la) && x.type.kind !== "resolvedImage" && this._isConstant(x)) {
                                const A = new Qn;
                                try {
                                    x = new la(x.type, x.evaluate(A))
                                } catch (M) {
                                    return this.error(M.message), null
                                }
                            }
                            return x
                        }
                        return this.error(`Unknown expression "${d}". If you wanted a literal array, use ["literal", [...]].`, 0)
                    }
                    return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`)
                }
                concat(t, a, l) {
                    const d = typeof t == "number" ? this.path.concat(t) : this.path,
                        g = l ? this.scope.concat(l) : this.scope;
                    return new os(this.registry, this._isConstant, d, a || null, g, this.errors)
                }
                error(t, ...a) {
                    const l = `${this.key}${a.map(d=>`[${d}]`).join("")}`;
                    this.errors.push(new ji(l, t))
                }
                checkSubtype(t, a) {
                    const l = et(t, a);
                    return l && this.error(l), l
                }
            }
            class Va {
                constructor(t, a, l) {
                    this.type = ga, this.locale = l, this.caseSensitive = t, this.diacriticSensitive = a
                }
                static parse(t, a) {
                    if (t.length !== 2) return a.error("Expected one argument.");
                    const l = t[1];
                    if (typeof l != "object" || Array.isArray(l)) return a.error("Collator options argument must be an object.");
                    const d = a.parse(l["case-sensitive"] !== void 0 && l["case-sensitive"], 1, qi);
                    if (!d) return null;
                    const g = a.parse(l["diacritic-sensitive"] !== void 0 && l["diacritic-sensitive"], 1, qi);
                    if (!g) return null;
                    let x = null;
                    return l.locale && (x = a.parse(l.locale, 1, Si), !x) ? null : new Va(d, g, x)
                }
                evaluate(t) {
                    return new Qs(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null)
                }
                eachChild(t) {
                    t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale)
                }
                outputDefined() {
                    return !1
                }
            }
            const Da = 8192;

            function Z(i, t) {
                i[0] = Math.min(i[0], t[0]), i[1] = Math.min(i[1], t[1]), i[2] = Math.max(i[2], t[0]), i[3] = Math.max(i[3], t[1])
            }

            function q(i, t) {
                return !(i[0] <= t[0] || i[2] >= t[2] || i[1] <= t[1] || i[3] >= t[3])
            }

            function de(i, t) {
                const a = (180 + i[0]) / 360,
                    l = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i[1] * Math.PI / 360))) / 360,
                    d = Math.pow(2, t.z);
                return [Math.round(a * d * Da), Math.round(l * d * Da)]
            }

            function Pe(i, t, a) {
                const l = i[0] - t[0],
                    d = i[1] - t[1],
                    g = i[0] - a[0],
                    x = i[1] - a[1];
                return l * x - g * d == 0 && l * g <= 0 && d * x <= 0
            }

            function Et(i, t) {
                let a = !1;
                for (let x = 0, A = t.length; x < A; x++) {
                    const M = t[x];
                    for (let F = 0, D = M.length; F < D - 1; F++) {
                        if (Pe(i, M[F], M[F + 1])) return !1;
                        (d = M[F])[1] > (l = i)[1] != (g = M[F + 1])[1] > l[1] && l[0] < (g[0] - d[0]) * (l[1] - d[1]) / (g[1] - d[1]) + d[0] && (a = !a)
                    }
                }
                var l, d, g;
                return a
            }

            function Ft(i, t) {
                for (let a = 0; a < t.length; a++)
                    if (Et(i, t[a])) return !0;
                return !1
            }

            function _t(i, t, a, l) {
                const d = l[0] - a[0],
                    g = l[1] - a[1],
                    x = (i[0] - a[0]) * g - d * (i[1] - a[1]),
                    A = (t[0] - a[0]) * g - d * (t[1] - a[1]);
                return x > 0 && A < 0 || x < 0 && A > 0
            }

            function Yt(i, t, a) {
                for (const F of a)
                    for (let D = 0; D < F.length - 1; ++D)
                        if ((A = [(x = F[D + 1])[0] - (g = F[D])[0], x[1] - g[1]])[0] * (M = [(d = t)[0] - (l = i)[0], d[1] - l[1]])[1] - A[1] * M[0] != 0 && _t(l, d, g, x) && _t(g, x, l, d)) return !0;
                var l, d, g, x, A, M;
                return !1
            }

            function J(i, t) {
                for (let a = 0; a < i.length; ++a)
                    if (!Et(i[a], t)) return !1;
                for (let a = 0; a < i.length - 1; ++a)
                    if (Yt(i[a], i[a + 1], t)) return !1;
                return !0
            }

            function W(i, t) {
                for (let a = 0; a < t.length; a++)
                    if (J(i, t[a])) return !0;
                return !1
            }

            function re(i, t, a) {
                const l = [];
                for (let d = 0; d < i.length; d++) {
                    const g = [];
                    for (let x = 0; x < i[d].length; x++) {
                        const A = de(i[d][x], a);
                        Z(t, A), g.push(A)
                    }
                    l.push(g)
                }
                return l
            }

            function ye(i, t, a) {
                const l = [];
                for (let d = 0; d < i.length; d++) {
                    const g = re(i[d], t, a);
                    l.push(g)
                }
                return l
            }

            function me(i, t, a, l) {
                if (i[0] < a[0] || i[0] > a[2]) {
                    const d = .5 * l;
                    let g = i[0] - a[0] > d ? -l : a[0] - i[0] > d ? l : 0;
                    g === 0 && (g = i[0] - a[2] > d ? -l : a[2] - i[0] > d ? l : 0), i[0] += g
                }
                Z(t, i)
            }

            function rt(i, t, a, l) {
                const d = Math.pow(2, l.z) * Da,
                    g = [l.x * Da, l.y * Da],
                    x = [];
                for (const A of i)
                    for (const M of A) {
                        const F = [M.x + g[0], M.y + g[1]];
                        me(F, t, a, d), x.push(F)
                    }
                return x
            }

            function At(i, t, a, l) {
                const d = Math.pow(2, l.z) * Da,
                    g = [l.x * Da, l.y * Da],
                    x = [];
                for (const M of i) {
                    const F = [];
                    for (const D of M) {
                        const U = [D.x + g[0], D.y + g[1]];
                        Z(t, U), F.push(U)
                    }
                    x.push(F)
                }
                if (t[2] - t[0] <= d / 2) {
                    (A = t)[0] = A[1] = 1 / 0, A[2] = A[3] = -1 / 0;
                    for (const M of x)
                        for (const F of M) me(F, t, a, d)
                }
                var A;
                return x
            }
            class Mt {
                constructor(t, a) {
                    this.type = qi, this.geojson = t, this.geometries = a
                }
                static parse(t, a) {
                    if (t.length !== 2) return a.error(`'within' expression requires exactly one argument, but found ${t.length-1} instead.`);
                    if (Jr(t[1])) {
                        const l = t[1];
                        if (l.type === "FeatureCollection") {
                            const d = [];
                            for (const g of l.features) {
                                const {
                                    type: x,
                                    coordinates: A
                                } = g.geometry;
                                x === "Polygon" && d.push(A), x === "MultiPolygon" && d.push(...A)
                            }
                            if (d.length) return new Mt(l, {
                                type: "MultiPolygon",
                                coordinates: d
                            })
                        } else if (l.type === "Feature") {
                            const d = l.geometry.type;
                            if (d === "Polygon" || d === "MultiPolygon") return new Mt(l, l.geometry)
                        } else if (l.type === "Polygon" || l.type === "MultiPolygon") return new Mt(l, l)
                    }
                    return a.error("'within' expression requires valid geojson object that contains polygon geometry type.")
                }
                evaluate(t) {
                    if (t.geometry() != null && t.canonicalID() != null) {
                        if (t.geometryType() === "Point") return function(a, l) {
                            const d = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                                g = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                                x = a.canonicalID();
                            if (l.type === "Polygon") {
                                const A = re(l.coordinates, g, x),
                                    M = rt(a.geometry(), d, g, x);
                                if (!q(d, g)) return !1;
                                for (const F of M)
                                    if (!Et(F, A)) return !1
                            }
                            if (l.type === "MultiPolygon") {
                                const A = ye(l.coordinates, g, x),
                                    M = rt(a.geometry(), d, g, x);
                                if (!q(d, g)) return !1;
                                for (const F of M)
                                    if (!Ft(F, A)) return !1
                            }
                            return !0
                        }(t, this.geometries);
                        if (t.geometryType() === "LineString") return function(a, l) {
                            const d = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                                g = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                                x = a.canonicalID();
                            if (l.type === "Polygon") {
                                const A = re(l.coordinates, g, x),
                                    M = At(a.geometry(), d, g, x);
                                if (!q(d, g)) return !1;
                                for (const F of M)
                                    if (!J(F, A)) return !1
                            }
                            if (l.type === "MultiPolygon") {
                                const A = ye(l.coordinates, g, x),
                                    M = At(a.geometry(), d, g, x);
                                if (!q(d, g)) return !1;
                                for (const F of M)
                                    if (!W(F, A)) return !1
                            }
                            return !0
                        }(t, this.geometries)
                    }
                    return !1
                }
                eachChild() {}
                outputDefined() {
                    return !0
                }
            }
            class si {
                constructor(t, a) {
                    this.type = a.type, this.name = t, this.boundExpression = a
                }
                static parse(t, a) {
                    if (t.length !== 2 || typeof t[1] != "string") return a.error("'var' expression requires exactly one string literal argument.");
                    const l = t[1];
                    return a.scope.has(l) ? new si(l, a.scope.get(l)) : a.error(`Unknown variable "${l}". Make sure "${l}" has been bound in an enclosing "let" expression before using it.`, 1)
                }
                evaluate(t) {
                    return this.boundExpression.evaluate(t)
                }
                eachChild() {}
                outputDefined() {
                    return !1
                }
            }
            class ti {
                constructor(t, a, l, d) {
                    this.name = t, this.type = a, this._evaluate = l, this.args = d
                }
                evaluate(t) {
                    return this._evaluate(t, this.args)
                }
                eachChild(t) {
                    this.args.forEach(t)
                }
                outputDefined() {
                    return !1
                }
                static parse(t, a) {
                    const l = t[0],
                        d = ti.definitions[l];
                    if (!d) return a.error(`Unknown expression "${l}". If you wanted a literal array, use ["literal", [...]].`, 0);
                    const g = Array.isArray(d) ? d[0] : d.type,
                        x = Array.isArray(d) ? [
                            [d[1], d[2]]
                        ] : d.overloads,
                        A = x.filter(([F]) => !Array.isArray(F) || F.length === t.length - 1);
                    let M = null;
                    for (const [F, D] of A) {
                        M = new os(a.registry, ni, a.path, null, a.scope);
                        const U = [];
                        let N = !1;
                        for (let H = 1; H < t.length; H++) {
                            const X = t[H],
                                ne = Array.isArray(F) ? F[H - 1] : F.type,
                                le = M.parse(X, 1 + U.length, ne);
                            if (!le) {
                                N = !0;
                                break
                            }
                            U.push(le)
                        }
                        if (!N)
                            if (Array.isArray(F) && F.length !== U.length) M.error(`Expected ${F.length} arguments, but found ${U.length} instead.`);
                            else {
                                for (let H = 0; H < U.length; H++) {
                                    const X = Array.isArray(F) ? F[H] : F.type,
                                        ne = U[H];
                                    M.concat(H + 1).checkSubtype(X, ne.type)
                                }
                                if (M.errors.length === 0) return new ti(l, g, D, U)
                            }
                    }
                    if (A.length === 1) a.errors.push(...M.errors);
                    else {
                        const F = (A.length ? A : x).map(([U]) => {
                                return N = U, Array.isArray(N) ? `(${N.map(Ae).join(", ")})` : `(${Ae(N.type)}...)`;
                                var N
                            }).join(" | "),
                            D = [];
                        for (let U = 1; U < t.length; U++) {
                            const N = a.parse(t[U], 1 + D.length);
                            if (!N) return null;
                            D.push(Ae(N.type))
                        }
                        a.error(`Expected arguments of type ${F}, but found (${D.join(", ")}) instead.`)
                    }
                    return null
                }
                static register(t, a) {
                    ti.definitions = a;
                    for (const l in a) t[l] = ti
                }
            }

            function ni(i) {
                if (i instanceof si) return ni(i.boundExpression);
                if (i instanceof ti && i.name === "error" || i instanceof Va || i instanceof Mt) return !1;
                const t = i instanceof va || i instanceof Nr;
                let a = !0;
                return i.eachChild(l => {
                    a = t ? a && ni(l) : a && l instanceof la
                }), !!a && ri(i) && Ci(i, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"])
            }

            function ri(i) {
                if (i instanceof ti && (i.name === "get" && i.args.length === 1 || i.name === "feature-state" || i.name === "has" && i.args.length === 1 || i.name === "properties" || i.name === "geometry-type" || i.name === "id" || /^filter-/.test(i.name)) || i instanceof Mt) return !1;
                let t = !0;
                return i.eachChild(a => {
                    t && !ri(a) && (t = !1)
                }), t
            }

            function Wi(i) {
                if (i instanceof ti && i.name === "feature-state") return !1;
                let t = !0;
                return i.eachChild(a => {
                    t && !Wi(a) && (t = !1)
                }), t
            }

            function Ci(i, t) {
                if (i instanceof ti && t.indexOf(i.name) >= 0) return !1;
                let a = !0;
                return i.eachChild(l => {
                    a && !Ci(l, t) && (a = !1)
                }), a
            }

            function Pi(i, t) {
                const a = i.length - 1;
                let l, d, g = 0,
                    x = a,
                    A = 0;
                for (; g <= x;)
                    if (A = Math.floor((g + x) / 2), l = i[A], d = i[A + 1], l <= t) {
                        if (A === a || t < d) return A;
                        g = A + 1
                    } else {
                        if (!(l > t)) throw new Ln("Input is not a number.");
                        x = A - 1
                    } return 0
            }
            class ai {
                constructor(t, a, l) {
                    this.type = t, this.input = a, this.labels = [], this.outputs = [];
                    for (const [d, g] of l) this.labels.push(d), this.outputs.push(g)
                }
                static parse(t, a) {
                    if (t.length - 1 < 4) return a.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
                    if ((t.length - 1) % 2 != 0) return a.error("Expected an even number of arguments.");
                    const l = a.parse(t[1], 1, yi);
                    if (!l) return null;
                    const d = [];
                    let g = null;
                    a.expectedType && a.expectedType.kind !== "value" && (g = a.expectedType);
                    for (let x = 1; x < t.length; x += 2) {
                        const A = x === 1 ? -1 / 0 : t[x],
                            M = t[x + 1],
                            F = x,
                            D = x + 1;
                        if (typeof A != "number") return a.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', F);
                        if (d.length && d[d.length - 1][0] >= A) return a.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', F);
                        const U = a.parse(M, D, g);
                        if (!U) return null;
                        g = g || U.type, d.push([A, U])
                    }
                    return new ai(g, l, d)
                }
                evaluate(t) {
                    const a = this.labels,
                        l = this.outputs;
                    if (a.length === 1) return l[0].evaluate(t);
                    const d = this.input.evaluate(t);
                    if (d <= a[0]) return l[0].evaluate(t);
                    const g = a.length;
                    return d >= a[g - 1] ? l[g - 1].evaluate(t) : l[Pi(a, d)].evaluate(t)
                }
                eachChild(t) {
                    t(this.input);
                    for (const a of this.outputs) t(a)
                }
                outputDefined() {
                    return this.outputs.every(t => t.outputDefined())
                }
            }

            function Rt(i) {
                return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i
            }
            var Gi = ki;

            function ki(i, t, a, l) {
                this.cx = 3 * i, this.bx = 3 * (a - i) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (l - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = i, this.p1y = t, this.p2x = a, this.p2y = l
            }
            ki.prototype = {
                sampleCurveX: function(i) {
                    return ((this.ax * i + this.bx) * i + this.cx) * i
                },
                sampleCurveY: function(i) {
                    return ((this.ay * i + this.by) * i + this.cy) * i
                },
                sampleCurveDerivativeX: function(i) {
                    return (3 * this.ax * i + 2 * this.bx) * i + this.cx
                },
                solveCurveX: function(i, t) {
                    if (t === void 0 && (t = 1e-6), i < 0) return 0;
                    if (i > 1) return 1;
                    for (var a = i, l = 0; l < 8; l++) {
                        var d = this.sampleCurveX(a) - i;
                        if (Math.abs(d) < t) return a;
                        var g = this.sampleCurveDerivativeX(a);
                        if (Math.abs(g) < 1e-6) break;
                        a -= d / g
                    }
                    var x = 0,
                        A = 1;
                    for (a = i, l = 0; l < 20 && (d = this.sampleCurveX(a), !(Math.abs(d - i) < t)); l++) i > d ? x = a : A = a, a = .5 * (A - x) + x;
                    return a
                },
                solve: function(i, t) {
                    return this.sampleCurveY(this.solveCurveX(i, t))
                }
            };
            var pn = Rt(Gi);

            function pi(i, t, a) {
                return i + a * (t - i)
            }

            function Hi(i, t, a) {
                return i.map((l, d) => pi(l, t[d], a))
            }
            const en = {
                number: pi,
                color: function(i, t, a, l = "rgb") {
                    switch (l) {
                        case "rgb": {
                            const [d, g, x, A] = Hi(i.rgb, t.rgb, a);
                            return new _n(d, g, x, A, !1)
                        }
                        case "hcl": {
                            const [d, g, x, A] = i.hcl, [M, F, D, U] = t.hcl;
                            let N, H;
                            if (isNaN(d) || isNaN(M)) isNaN(d) ? isNaN(M) ? N = NaN : (N = M, x !== 1 && x !== 0 || (H = F)) : (N = d, D !== 1 && D !== 0 || (H = g));
                            else {
                                let Qe = M - d;
                                M > d && Qe > 180 ? Qe -= 360 : M < d && d - M > 180 && (Qe += 360), N = d + a * Qe
                            }
                            const [X, ne, le, ce] = function([Qe, Se, Re, ot]) {
                                return Qe = isNaN(Qe) ? 0 : Qe * on, Vn([Re, Math.cos(Qe) * Se, Math.sin(Qe) * Se, ot])
                            }([N, H != null ? H : pi(g, F, a), pi(x, D, a), pi(A, U, a)]);
                            return new _n(X, ne, le, ce, !1)
                        }
                        case "lab": {
                            const [d, g, x, A] = Vn(Hi(i.lab, t.lab, a));
                            return new _n(d, g, x, A, !1)
                        }
                    }
                },
                array: Hi,
                padding: function(i, t, a) {
                    return new Fr(Hi(i.values, t.values, a))
                },
                variableAnchorOffsetCollection: function(i, t, a) {
                    const l = i.values,
                        d = t.values;
                    if (l.length !== d.length) throw new Ln(`Cannot interpolate values of different length. from: ${i.toString()}, to: ${t.toString()}`);
                    const g = [];
                    for (let x = 0; x < l.length; x += 2) {
                        if (l[x] !== d[x]) throw new Ln(`Cannot interpolate values containing mismatched anchors. from[${x}]: ${l[x]}, to[${x}]: ${d[x]}`);
                        g.push(l[x]);
                        const [A, M] = l[x + 1], [F, D] = d[x + 1];
                        g.push([pi(A, F, a), pi(M, D, a)])
                    }
                    return new ra(g)
                }
            };
            class Bi {
                constructor(t, a, l, d, g) {
                    this.type = t, this.operator = a, this.interpolation = l, this.input = d, this.labels = [], this.outputs = [];
                    for (const [x, A] of g) this.labels.push(x), this.outputs.push(A)
                }
                static interpolationFactor(t, a, l, d) {
                    let g = 0;
                    if (t.name === "exponential") g = Xi(a, t.base, l, d);
                    else if (t.name === "linear") g = Xi(a, 1, l, d);
                    else if (t.name === "cubic-bezier") {
                        const x = t.controlPoints;
                        g = new pn(x[0], x[1], x[2], x[3]).solve(Xi(a, 1, l, d))
                    }
                    return g
                }
                static parse(t, a) {
                    let [l, d, g, ...x] = t;
                    if (!Array.isArray(d) || d.length === 0) return a.error("Expected an interpolation type expression.", 1);
                    if (d[0] === "linear") d = {
                        name: "linear"
                    };
                    else if (d[0] === "exponential") {
                        const F = d[1];
                        if (typeof F != "number") return a.error("Exponential interpolation requires a numeric base.", 1, 1);
                        d = {
                            name: "exponential",
                            base: F
                        }
                    } else {
                        if (d[0] !== "cubic-bezier") return a.error(`Unknown interpolation type ${String(d[0])}`, 1, 0);
                        {
                            const F = d.slice(1);
                            if (F.length !== 4 || F.some(D => typeof D != "number" || D < 0 || D > 1)) return a.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                            d = {
                                name: "cubic-bezier",
                                controlPoints: F
                            }
                        }
                    }
                    if (t.length - 1 < 4) return a.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
                    if ((t.length - 1) % 2 != 0) return a.error("Expected an even number of arguments.");
                    if (g = a.parse(g, 2, yi), !g) return null;
                    const A = [];
                    let M = null;
                    l === "interpolate-hcl" || l === "interpolate-lab" ? M = Nn : a.expectedType && a.expectedType.kind !== "value" && (M = a.expectedType);
                    for (let F = 0; F < x.length; F += 2) {
                        const D = x[F],
                            U = x[F + 1],
                            N = F + 3,
                            H = F + 4;
                        if (typeof D != "number") return a.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', N);
                        if (A.length && A[A.length - 1][0] >= D) return a.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', N);
                        const X = a.parse(U, H, M);
                        if (!X) return null;
                        M = M || X.type, A.push([D, X])
                    }
                    return ft(M, yi) || ft(M, Nn) || ft(M, Te) || ft(M, he) || ft(M, fe(yi)) ? new Bi(M, l, d, g, A) : a.error(`Type ${Ae(M)} is not interpolatable.`)
                }
                evaluate(t) {
                    const a = this.labels,
                        l = this.outputs;
                    if (a.length === 1) return l[0].evaluate(t);
                    const d = this.input.evaluate(t);
                    if (d <= a[0]) return l[0].evaluate(t);
                    const g = a.length;
                    if (d >= a[g - 1]) return l[g - 1].evaluate(t);
                    const x = Pi(a, d),
                        A = Bi.interpolationFactor(this.interpolation, d, a[x], a[x + 1]),
                        M = l[x].evaluate(t),
                        F = l[x + 1].evaluate(t);
                    switch (this.operator) {
                        case "interpolate":
                            return en[this.type.kind](M, F, A);
                        case "interpolate-hcl":
                            return en.color(M, F, A, "hcl");
                        case "interpolate-lab":
                            return en.color(M, F, A, "lab")
                    }
                }
                eachChild(t) {
                    t(this.input);
                    for (const a of this.outputs) t(a)
                }
                outputDefined() {
                    return this.outputs.every(t => t.outputDefined())
                }
            }

            function Xi(i, t, a, l) {
                const d = l - a,
                    g = i - a;
                return d === 0 ? 0 : t === 1 ? g / d : (Math.pow(t, g) - 1) / (Math.pow(t, d) - 1)
            }
            class Un {
                constructor(t, a) {
                    this.type = t, this.args = a
                }
                static parse(t, a) {
                    if (t.length < 2) return a.error("Expectected at least one argument.");
                    let l = null;
                    const d = a.expectedType;
                    d && d.kind !== "value" && (l = d);
                    const g = [];
                    for (const A of t.slice(1)) {
                        const M = a.parse(A, 1 + g.length, l, void 0, {
                            typeAnnotation: "omit"
                        });
                        if (!M) return null;
                        l = l || M.type, g.push(M)
                    }
                    if (!l) throw new Error("No output type");
                    const x = d && g.some(A => et(d, A.type));
                    return new Un(x ? ge : l, g)
                }
                evaluate(t) {
                    let a, l = null,
                        d = 0;
                    for (const g of this.args)
                        if (d++, l = g.evaluate(t), l && l instanceof $r && !l.available && (a || (a = l.name), l = null, d === this.args.length && (l = a)), l !== null) break;
                    return l
                }
                eachChild(t) {
                    this.args.forEach(t)
                }
                outputDefined() {
                    return this.args.every(t => t.outputDefined())
                }
            }
            class lr {
                constructor(t, a) {
                    this.type = a.type, this.bindings = [].concat(t), this.result = a
                }
                evaluate(t) {
                    return this.result.evaluate(t)
                }
                eachChild(t) {
                    for (const a of this.bindings) t(a[1]);
                    t(this.result)
                }
                static parse(t, a) {
                    if (t.length < 4) return a.error(`Expected at least 3 arguments, but found ${t.length-1} instead.`);
                    const l = [];
                    for (let g = 1; g < t.length - 1; g += 2) {
                        const x = t[g];
                        if (typeof x != "string") return a.error(`Expected string, but found ${typeof x} instead.`, g);
                        if (/[^a-zA-Z0-9_]/.test(x)) return a.error("Variable names must contain only alphanumeric characters or '_'.", g);
                        const A = a.parse(t[g + 1], g + 1);
                        if (!A) return null;
                        l.push([x, A])
                    }
                    const d = a.parse(t[t.length - 1], t.length - 1, a.expectedType, l);
                    return d ? new lr(l, d) : null
                }
                outputDefined() {
                    return this.result.outputDefined()
                }
            }
            class Qr {
                constructor(t, a, l) {
                    this.type = t, this.index = a, this.input = l
                }
                static parse(t, a) {
                    if (t.length !== 3) return a.error(`Expected 2 arguments, but found ${t.length-1} instead.`);
                    const l = a.parse(t[1], 1, yi),
                        d = a.parse(t[2], 2, fe(a.expectedType || ge));
                    return l && d ? new Qr(d.type.itemType, l, d) : null
                }
                evaluate(t) {
                    const a = this.index.evaluate(t),
                        l = this.input.evaluate(t);
                    if (a < 0) throw new Ln(`Array index out of bounds: ${a} < 0.`);
                    if (a >= l.length) throw new Ln(`Array index out of bounds: ${a} > ${l.length-1}.`);
                    if (a !== Math.floor(a)) throw new Ln(`Array index must be an integer, but found ${a} instead.`);
                    return l[a]
                }
                eachChild(t) {
                    t(this.index), t(this.input)
                }
                outputDefined() {
                    return !1
                }
            }
            class aa {
                constructor(t, a) {
                    this.type = qi, this.needle = t, this.haystack = a
                }
                static parse(t, a) {
                    if (t.length !== 3) return a.error(`Expected 2 arguments, but found ${t.length-1} instead.`);
                    const l = a.parse(t[1], 1, ge),
                        d = a.parse(t[2], 2, ge);
                    return l && d ? it(l.type, [qi, Si, yi, cn, ge]) ? new aa(l, d) : a.error(`Expected first argument to be of type boolean, string, number or null, but found ${Ae(l.type)} instead`) : null
                }
                evaluate(t) {
                    const a = this.needle.evaluate(t),
                        l = this.haystack.evaluate(t);
                    if (!l) return !1;
                    if (!We(a, ["boolean", "string", "number", "null"])) throw new Ln(`Expected first argument to be of type boolean, string, number or null, but found ${Ae(or(a))} instead.`);
                    if (!We(l, ["string", "array"])) throw new Ln(`Expected second argument to be of type array or string, but found ${Ae(or(l))} instead.`);
                    return l.indexOf(a) >= 0
                }
                eachChild(t) {
                    t(this.needle), t(this.haystack)
                }
                outputDefined() {
                    return !0
                }
            }
            class Ai {
                constructor(t, a, l) {
                    this.type = yi, this.needle = t, this.haystack = a, this.fromIndex = l
                }
                static parse(t, a) {
                    if (t.length <= 2 || t.length >= 5) return a.error(`Expected 3 or 4 arguments, but found ${t.length-1} instead.`);
                    const l = a.parse(t[1], 1, ge),
                        d = a.parse(t[2], 2, ge);
                    if (!l || !d) return null;
                    if (!it(l.type, [qi, Si, yi, cn, ge])) return a.error(`Expected first argument to be of type boolean, string, number or null, but found ${Ae(l.type)} instead`);
                    if (t.length === 4) {
                        const g = a.parse(t[3], 3, yi);
                        return g ? new Ai(l, d, g) : null
                    }
                    return new Ai(l, d)
                }
                evaluate(t) {
                    const a = this.needle.evaluate(t),
                        l = this.haystack.evaluate(t);
                    if (!We(a, ["boolean", "string", "number", "null"])) throw new Ln(`Expected first argument to be of type boolean, string, number or null, but found ${Ae(or(a))} instead.`);
                    if (!We(l, ["string", "array"])) throw new Ln(`Expected second argument to be of type array or string, but found ${Ae(or(l))} instead.`);
                    if (this.fromIndex) {
                        const d = this.fromIndex.evaluate(t);
                        return l.indexOf(a, d)
                    }
                    return l.indexOf(a)
                }
                eachChild(t) {
                    t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex)
                }
                outputDefined() {
                    return !1
                }
            }
            class ca {
                constructor(t, a, l, d, g, x) {
                    this.inputType = t, this.type = a, this.input = l, this.cases = d, this.outputs = g, this.otherwise = x
                }
                static parse(t, a) {
                    if (t.length < 5) return a.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
                    if (t.length % 2 != 1) return a.error("Expected an even number of arguments.");
                    let l, d;
                    a.expectedType && a.expectedType.kind !== "value" && (d = a.expectedType);
                    const g = {},
                        x = [];
                    for (let F = 2; F < t.length - 1; F += 2) {
                        let D = t[F];
                        const U = t[F + 1];
                        Array.isArray(D) || (D = [D]);
                        const N = a.concat(F);
                        if (D.length === 0) return N.error("Expected at least one branch label.");
                        for (const X of D) {
                            if (typeof X != "number" && typeof X != "string") return N.error("Branch labels must be numbers or strings.");
                            if (typeof X == "number" && Math.abs(X) > Number.MAX_SAFE_INTEGER) return N.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                            if (typeof X == "number" && Math.floor(X) !== X) return N.error("Numeric branch labels must be integer values.");
                            if (l) {
                                if (N.checkSubtype(l, or(X))) return null
                            } else l = or(X);
                            if (g[String(X)] !== void 0) return N.error("Branch labels must be unique.");
                            g[String(X)] = x.length
                        }
                        const H = a.parse(U, F, d);
                        if (!H) return null;
                        d = d || H.type, x.push(H)
                    }
                    const A = a.parse(t[1], 1, ge);
                    if (!A) return null;
                    const M = a.parse(t[t.length - 1], t.length - 1, d);
                    return M ? A.type.kind !== "value" && a.concat(1).checkSubtype(l, A.type) ? null : new ca(l, d, A, g, x, M) : null
                }
                evaluate(t) {
                    const a = this.input.evaluate(t);
                    return (or(a) === this.inputType && this.outputs[this.cases[a]] || this.otherwise).evaluate(t)
                }
                eachChild(t) {
                    t(this.input), this.outputs.forEach(t), t(this.otherwise)
                }
                outputDefined() {
                    return this.outputs.every(t => t.outputDefined()) && this.otherwise.outputDefined()
                }
            }
            class Ea {
                constructor(t, a, l) {
                    this.type = t, this.branches = a, this.otherwise = l
                }
                static parse(t, a) {
                    if (t.length < 4) return a.error(`Expected at least 3 arguments, but found only ${t.length-1}.`);
                    if (t.length % 2 != 0) return a.error("Expected an odd number of arguments.");
                    let l;
                    a.expectedType && a.expectedType.kind !== "value" && (l = a.expectedType);
                    const d = [];
                    for (let x = 1; x < t.length - 1; x += 2) {
                        const A = a.parse(t[x], x, qi);
                        if (!A) return null;
                        const M = a.parse(t[x + 1], x + 1, l);
                        if (!M) return null;
                        d.push([A, M]), l = l || M.type
                    }
                    const g = a.parse(t[t.length - 1], t.length - 1, l);
                    if (!g) return null;
                    if (!l) throw new Error("Can't infer output type");
                    return new Ea(l, d, g)
                }
                evaluate(t) {
                    for (const [a, l] of this.branches)
                        if (a.evaluate(t)) return l.evaluate(t);
                    return this.otherwise.evaluate(t)
                }
                eachChild(t) {
                    for (const [a, l] of this.branches) t(a), t(l);
                    t(this.otherwise)
                }
                outputDefined() {
                    return this.branches.every(([t, a]) => a.outputDefined()) && this.otherwise.outputDefined()
                }
            }
            class Kr {
                constructor(t, a, l, d) {
                    this.type = t, this.input = a, this.beginIndex = l, this.endIndex = d
                }
                static parse(t, a) {
                    if (t.length <= 2 || t.length >= 5) return a.error(`Expected 3 or 4 arguments, but found ${t.length-1} instead.`);
                    const l = a.parse(t[1], 1, ge),
                        d = a.parse(t[2], 2, yi);
                    if (!l || !d) return null;
                    if (!it(l.type, [fe(ge), Si, ge])) return a.error(`Expected first argument to be of type array or string, but found ${Ae(l.type)} instead`);
                    if (t.length === 4) {
                        const g = a.parse(t[3], 3, yi);
                        return g ? new Kr(l.type, l, d, g) : null
                    }
                    return new Kr(l.type, l, d)
                }
                evaluate(t) {
                    const a = this.input.evaluate(t),
                        l = this.beginIndex.evaluate(t);
                    if (!We(a, ["string", "array"])) throw new Ln(`Expected first argument to be of type array or string, but found ${Ae(or(a))} instead.`);
                    if (this.endIndex) {
                        const d = this.endIndex.evaluate(t);
                        return a.slice(l, d)
                    }
                    return a.slice(l)
                }
                eachChild(t) {
                    t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex)
                }
                outputDefined() {
                    return !1
                }
            }

            function Er(i, t) {
                return i === "==" || i === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value"
            }

            function ro(i, t, a, l) {
                return l.compare(t, a) === 0
            }

            function Or(i, t, a) {
                const l = i !== "==" && i !== "!=";
                return class pf {
                    constructor(g, x, A) {
                        this.type = qi, this.lhs = g, this.rhs = x, this.collator = A, this.hasUntypedArgument = g.type.kind === "value" || x.type.kind === "value"
                    }
                    static parse(g, x) {
                        if (g.length !== 3 && g.length !== 4) return x.error("Expected two or three arguments.");
                        const A = g[0];
                        let M = x.parse(g[1], 1, ge);
                        if (!M) return null;
                        if (!Er(A, M.type)) return x.concat(1).error(`"${A}" comparisons are not supported for type '${Ae(M.type)}'.`);
                        let F = x.parse(g[2], 2, ge);
                        if (!F) return null;
                        if (!Er(A, F.type)) return x.concat(2).error(`"${A}" comparisons are not supported for type '${Ae(F.type)}'.`);
                        if (M.type.kind !== F.type.kind && M.type.kind !== "value" && F.type.kind !== "value") return x.error(`Cannot compare types '${Ae(M.type)}' and '${Ae(F.type)}'.`);
                        l && (M.type.kind === "value" && F.type.kind !== "value" ? M = new Nr(F.type, [M]) : M.type.kind !== "value" && F.type.kind === "value" && (F = new Nr(M.type, [F])));
                        let D = null;
                        if (g.length === 4) {
                            if (M.type.kind !== "string" && F.type.kind !== "string" && M.type.kind !== "value" && F.type.kind !== "value") return x.error("Cannot use collator to compare non-string types.");
                            if (D = x.parse(g[3], 3, ga), !D) return null
                        }
                        return new pf(M, F, D)
                    }
                    evaluate(g) {
                        const x = this.lhs.evaluate(g),
                            A = this.rhs.evaluate(g);
                        if (l && this.hasUntypedArgument) {
                            const M = or(x),
                                F = or(A);
                            if (M.kind !== F.kind || M.kind !== "string" && M.kind !== "number") throw new Ln(`Expected arguments for "${i}" to be (string, string) or (number, number), but found (${M.kind}, ${F.kind}) instead.`)
                        }
                        if (this.collator && !l && this.hasUntypedArgument) {
                            const M = or(x),
                                F = or(A);
                            if (M.kind !== "string" || F.kind !== "string") return t(g, x, A)
                        }
                        return this.collator ? a(g, x, A, this.collator.evaluate(g)) : t(g, x, A)
                    }
                    eachChild(g) {
                        g(this.lhs), g(this.rhs), this.collator && g(this.collator)
                    }
                    outputDefined() {
                        return !0
                    }
                }
            }
            const ls = Or("==", function(i, t, a) {
                    return t === a
                }, ro),
                ms = Or("!=", function(i, t, a) {
                    return t !== a
                }, function(i, t, a, l) {
                    return !ro(0, t, a, l)
                }),
                _a = Or("<", function(i, t, a) {
                    return t < a
                }, function(i, t, a, l) {
                    return l.compare(t, a) < 0
                }),
                ks = Or(">", function(i, t, a) {
                    return t > a
                }, function(i, t, a, l) {
                    return l.compare(t, a) > 0
                }),
                Pr = Or("<=", function(i, t, a) {
                    return t <= a
                }, function(i, t, a, l) {
                    return l.compare(t, a) <= 0
                }),
                an = Or(">=", function(i, t, a) {
                    return t >= a
                }, function(i, t, a, l) {
                    return l.compare(t, a) >= 0
                });
            class Nl {
                constructor(t, a, l, d, g) {
                    this.type = Si, this.number = t, this.locale = a, this.currency = l, this.minFractionDigits = d, this.maxFractionDigits = g
                }
                static parse(t, a) {
                    if (t.length !== 3) return a.error("Expected two arguments.");
                    const l = a.parse(t[1], 1, yi);
                    if (!l) return null;
                    const d = t[2];
                    if (typeof d != "object" || Array.isArray(d)) return a.error("NumberFormat options argument must be an object.");
                    let g = null;
                    if (d.locale && (g = a.parse(d.locale, 1, Si), !g)) return null;
                    let x = null;
                    if (d.currency && (x = a.parse(d.currency, 1, Si), !x)) return null;
                    let A = null;
                    if (d["min-fraction-digits"] && (A = a.parse(d["min-fraction-digits"], 1, yi), !A)) return null;
                    let M = null;
                    return d["max-fraction-digits"] && (M = a.parse(d["max-fraction-digits"], 1, yi), !M) ? null : new Nl(l, g, x, A, M)
                }
                evaluate(t) {
                    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {
                        style: this.currency ? "currency" : "decimal",
                        currency: this.currency ? this.currency.evaluate(t) : void 0,
                        minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,
                        maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0
                    }).format(this.number.evaluate(t))
                }
                eachChild(t) {
                    t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits)
                }
                outputDefined() {
                    return !1
                }
            }
            class gs {
                constructor(t) {
                    this.type = On, this.sections = t
                }
                static parse(t, a) {
                    if (t.length < 2) return a.error("Expected at least one argument.");
                    const l = t[1];
                    if (!Array.isArray(l) && typeof l == "object") return a.error("First argument must be an image or text section.");
                    const d = [];
                    let g = !1;
                    for (let x = 1; x <= t.length - 1; ++x) {
                        const A = t[x];
                        if (g && typeof A == "object" && !Array.isArray(A)) {
                            g = !1;
                            let M = null;
                            if (A["font-scale"] && (M = a.parse(A["font-scale"], 1, yi), !M)) return null;
                            let F = null;
                            if (A["text-font"] && (F = a.parse(A["text-font"], 1, fe(Si)), !F)) return null;
                            let D = null;
                            if (A["text-color"] && (D = a.parse(A["text-color"], 1, Nn), !D)) return null;
                            const U = d[d.length - 1];
                            U.scale = M, U.font = F, U.textColor = D
                        } else {
                            const M = a.parse(t[x], 1, ge);
                            if (!M) return null;
                            const F = M.type.kind;
                            if (F !== "string" && F !== "value" && F !== "null" && F !== "resolvedImage") return a.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                            g = !0, d.push({
                                content: M,
                                scale: null,
                                font: null,
                                textColor: null
                            })
                        }
                    }
                    return new gs(d)
                }
                evaluate(t) {
                    return new rr(this.sections.map(a => {
                        const l = a.content.evaluate(t);
                        return or(l) === te ? new Ra("", l, null, null, null) : new Ra(wa(l), null, a.scale ? a.scale.evaluate(t) : null, a.font ? a.font.evaluate(t).join(",") : null, a.textColor ? a.textColor.evaluate(t) : null)
                    }))
                }
                eachChild(t) {
                    for (const a of this.sections) t(a.content), a.scale && t(a.scale), a.font && t(a.font), a.textColor && t(a.textColor)
                }
                outputDefined() {
                    return !1
                }
            }
            class cl {
                constructor(t) {
                    this.type = te, this.input = t
                }
                static parse(t, a) {
                    if (t.length !== 2) return a.error("Expected two arguments.");
                    const l = a.parse(t[1], 1, Si);
                    return l ? new cl(l) : a.error("No image name provided.")
                }
                evaluate(t) {
                    const a = this.input.evaluate(t),
                        l = $r.fromString(a);
                    return l && t.availableImages && (l.available = t.availableImages.indexOf(a) > -1), l
                }
                eachChild(t) {
                    t(this.input)
                }
                outputDefined() {
                    return !1
                }
            }
            class cs {
                constructor(t) {
                    this.type = yi, this.input = t
                }
                static parse(t, a) {
                    if (t.length !== 2) return a.error(`Expected 1 argument, but found ${t.length-1} instead.`);
                    const l = a.parse(t[1], 1);
                    return l ? l.type.kind !== "array" && l.type.kind !== "string" && l.type.kind !== "value" ? a.error(`Expected argument of type string or array, but found ${Ae(l.type)} instead.`) : new cs(l) : null
                }
                evaluate(t) {
                    const a = this.input.evaluate(t);
                    if (typeof a == "string" || Array.isArray(a)) return a.length;
                    throw new Ln(`Expected value to be of type string or array, but found ${Ae(or(a))} instead.`)
                }
                eachChild(t) {
                    t(this.input)
                }
                outputDefined() {
                    return !1
                }
            }
            const Ua = {
                "==": ls,
                "!=": ms,
                ">": ks,
                "<": _a,
                ">=": an,
                "<=": Pr,
                array: Nr,
                at: Qr,
                boolean: Nr,
                case: Ea,
                coalesce: Un,
                collator: Va,
                format: gs,
                image: cl,
                in: aa,
                "index-of": Ai,
                interpolate: Bi,
                "interpolate-hcl": Bi,
                "interpolate-lab": Bi,
                length: cs,
                let: lr,
                literal: la,
                match: ca,
                number: Nr,
                "number-format": Nl,
                object: Nr,
                slice: Kr,
                step: ai,
                string: Nr,
                "to-boolean": va,
                "to-color": va,
                "to-number": va,
                "to-string": va,
                var: si,
                within: Mt
            };

            function ys(i, [t, a, l, d]) {
                t = t.evaluate(i), a = a.evaluate(i), l = l.evaluate(i);
                const g = d ? d.evaluate(i) : 1,
                    x = gr(t, a, l, g);
                if (x) throw new Ln(x);
                return new _n(t / 255, a / 255, l / 255, g, !1)
            }

            function Ol(i, t) {
                return i in t
            }

            function hl(i, t) {
                const a = t[i];
                return a === void 0 ? null : a
            }

            function vs(i) {
                return {
                    type: i
                }
            }

            function ul(i) {
                return {
                    result: "success",
                    value: i
                }
            }

            function _s(i) {
                return {
                    result: "error",
                    value: i
                }
            }

            function xs(i) {
                return i["property-type"] === "data-driven" || i["property-type"] === "cross-faded-data-driven"
            }

            function dl(i) {
                return !!i.expression && i.expression.parameters.indexOf("zoom") > -1
            }

            function Bo(i) {
                return !!i.expression && i.expression.interpolated
            }

            function Mn(i) {
                return i instanceof Number ? "number" : i instanceof String ? "string" : i instanceof Boolean ? "boolean" : Array.isArray(i) ? "array" : i === null ? "null" : typeof i
            }

            function Ro(i) {
                return typeof i == "object" && i !== null && !Array.isArray(i)
            }

            function Vl(i) {
                return i
            }

            function ar(i, t) {
                const a = t.type === "color",
                    l = i.stops && typeof i.stops[0][0] == "object",
                    d = l || !(l || i.property !== void 0),
                    g = i.type || (Bo(t) ? "exponential" : "interval");
                if (a || t.type === "padding") {
                    const D = a ? _n.parse : Fr.parse;
                    (i = qn({}, i)).stops && (i.stops = i.stops.map(U => [U[0], D(U[1])])), i.default = D(i.default ? i.default : t.default)
                }
                if (i.colorSpace && (x = i.colorSpace) !== "rgb" && x !== "hcl" && x !== "lab") throw new Error(`Unknown color space: "${i.colorSpace}"`);
                var x;
                let A, M, F;
                if (g === "exponential") A = un;
                else if (g === "interval") A = Fo;
                else if (g === "categorical") {
                    A = sr, M = Object.create(null);
                    for (const D of i.stops) M[D[0]] = D[1];
                    F = typeof i.stops[0][0]
                } else {
                    if (g !== "identity") throw new Error(`Unknown function type "${g}"`);
                    A = Gl
                }
                if (l) {
                    const D = {},
                        U = [];
                    for (let X = 0; X < i.stops.length; X++) {
                        const ne = i.stops[X],
                            le = ne[0].zoom;
                        D[le] === void 0 && (D[le] = {
                            zoom: le,
                            type: i.type,
                            property: i.property,
                            default: i.default,
                            stops: []
                        }, U.push(le)), D[le].stops.push([ne[0].value, ne[1]])
                    }
                    const N = [];
                    for (const X of U) N.push([D[X].zoom, ar(D[X], t)]);
                    const H = {
                        name: "linear"
                    };
                    return {
                        kind: "composite",
                        interpolationType: H,
                        interpolationFactor: Bi.interpolationFactor.bind(void 0, H),
                        zoomStops: N.map(X => X[0]),
                        evaluate: ({
                            zoom: X
                        }, ne) => un({
                            stops: N,
                            base: i.base
                        }, t, X).evaluate(X, ne)
                    }
                }
                if (d) {
                    const D = g === "exponential" ? {
                        name: "exponential",
                        base: i.base !== void 0 ? i.base : 1
                    } : null;
                    return {
                        kind: "camera",
                        interpolationType: D,
                        interpolationFactor: Bi.interpolationFactor.bind(void 0, D),
                        zoomStops: i.stops.map(U => U[0]),
                        evaluate: ({
                            zoom: U
                        }) => A(i, t, U, M, F)
                    }
                }
                return {
                    kind: "source",
                    evaluate(D, U) {
                        const N = U && U.properties ? U.properties[i.property] : void 0;
                        return N === void 0 ? Ds(i.default, t.default) : A(i, t, N, M, F)
                    }
                }
            }

            function Ds(i, t, a) {
                return i !== void 0 ? i : t !== void 0 ? t : a !== void 0 ? a : void 0
            }

            function sr(i, t, a, l, d) {
                return Ds(typeof a === d ? l[a] : void 0, i.default, t.default)
            }

            function Fo(i, t, a) {
                if (Mn(a) !== "number") return Ds(i.default, t.default);
                const l = i.stops.length;
                if (l === 1 || a <= i.stops[0][0]) return i.stops[0][1];
                if (a >= i.stops[l - 1][0]) return i.stops[l - 1][1];
                const d = Pi(i.stops.map(g => g[0]), a);
                return i.stops[d][1]
            }

            function un(i, t, a) {
                const l = i.base !== void 0 ? i.base : 1;
                if (Mn(a) !== "number") return Ds(i.default, t.default);
                const d = i.stops.length;
                if (d === 1 || a <= i.stops[0][0]) return i.stops[0][1];
                if (a >= i.stops[d - 1][0]) return i.stops[d - 1][1];
                const g = Pi(i.stops.map(D => D[0]), a),
                    x = function(D, U, N, H) {
                        const X = H - N,
                            ne = D - N;
                        return X === 0 ? 0 : U === 1 ? ne / X : (Math.pow(U, ne) - 1) / (Math.pow(U, X) - 1)
                    }(a, l, i.stops[g][0], i.stops[g + 1][0]),
                    A = i.stops[g][1],
                    M = i.stops[g + 1][1],
                    F = en[t.type] || Vl;
                return typeof A.evaluate == "function" ? {
                    evaluate(...D) {
                        const U = A.evaluate.apply(void 0, D),
                            N = M.evaluate.apply(void 0, D);
                        if (U !== void 0 && N !== void 0) return F(U, N, x, i.colorSpace)
                    }
                } : F(A, M, x, i.colorSpace)
            }

            function Gl(i, t, a) {
                switch (t.type) {
                    case "color":
                        a = _n.parse(a);
                        break;
                    case "formatted":
                        a = rr.fromString(a.toString());
                        break;
                    case "resolvedImage":
                        a = $r.fromString(a.toString());
                        break;
                    case "padding":
                        a = Fr.parse(a);
                        break;
                    default:
                        Mn(a) === t.type || t.type === "enum" && t.values[a] || (a = void 0)
                }
                return Ds(a, i.default, t.default)
            }
            ti.register(Ua, {
                error: [{
                        kind: "error"
                    },
                    [Si], (i, [t]) => {
                        throw new Ln(t.evaluate(i))
                    }
                ],
                typeof: [Si, [ge], (i, [t]) => Ae(or(t.evaluate(i)))],
                "to-rgba": [fe(yi, 4), [Nn], (i, [t]) => {
                    const [a, l, d, g] = t.evaluate(i).rgb;
                    return [255 * a, 255 * l, 255 * d, g]
                }],
                rgb: [Nn, [yi, yi, yi], ys],
                rgba: [Nn, [yi, yi, yi, yi], ys],
                has: {
                    type: qi,
                    overloads: [
                        [
                            [Si], (i, [t]) => Ol(t.evaluate(i), i.properties())
                        ],
                        [
                            [Si, Bn], (i, [t, a]) => Ol(t.evaluate(i), a.evaluate(i))
                        ]
                    ]
                },
                get: {
                    type: ge,
                    overloads: [
                        [
                            [Si], (i, [t]) => hl(t.evaluate(i), i.properties())
                        ],
                        [
                            [Si, Bn], (i, [t, a]) => hl(t.evaluate(i), a.evaluate(i))
                        ]
                    ]
                },
                "feature-state": [ge, [Si], (i, [t]) => hl(t.evaluate(i), i.featureState || {})],
                properties: [Bn, [], i => i.properties()],
                "geometry-type": [Si, [], i => i.geometryType()],
                id: [ge, [], i => i.id()],
                zoom: [yi, [], i => i.globals.zoom],
                "heatmap-density": [yi, [], i => i.globals.heatmapDensity || 0],
                "line-progress": [yi, [], i => i.globals.lineProgress || 0],
                accumulated: [ge, [], i => i.globals.accumulated === void 0 ? null : i.globals.accumulated],
                "+": [yi, vs(yi), (i, t) => {
                    let a = 0;
                    for (const l of t) a += l.evaluate(i);
                    return a
                }],
                "*": [yi, vs(yi), (i, t) => {
                    let a = 1;
                    for (const l of t) a *= l.evaluate(i);
                    return a
                }],
                "-": {
                    type: yi,
                    overloads: [
                        [
                            [yi, yi], (i, [t, a]) => t.evaluate(i) - a.evaluate(i)
                        ],
                        [
                            [yi], (i, [t]) => -t.evaluate(i)
                        ]
                    ]
                },
                "/": [yi, [yi, yi], (i, [t, a]) => t.evaluate(i) / a.evaluate(i)],
                "%": [yi, [yi, yi], (i, [t, a]) => t.evaluate(i) % a.evaluate(i)],
                ln2: [yi, [], () => Math.LN2],
                pi: [yi, [], () => Math.PI],
                e: [yi, [], () => Math.E],
                "^": [yi, [yi, yi], (i, [t, a]) => Math.pow(t.evaluate(i), a.evaluate(i))],
                sqrt: [yi, [yi], (i, [t]) => Math.sqrt(t.evaluate(i))],
                log10: [yi, [yi], (i, [t]) => Math.log(t.evaluate(i)) / Math.LN10],
                ln: [yi, [yi], (i, [t]) => Math.log(t.evaluate(i))],
                log2: [yi, [yi], (i, [t]) => Math.log(t.evaluate(i)) / Math.LN2],
                sin: [yi, [yi], (i, [t]) => Math.sin(t.evaluate(i))],
                cos: [yi, [yi], (i, [t]) => Math.cos(t.evaluate(i))],
                tan: [yi, [yi], (i, [t]) => Math.tan(t.evaluate(i))],
                asin: [yi, [yi], (i, [t]) => Math.asin(t.evaluate(i))],
                acos: [yi, [yi], (i, [t]) => Math.acos(t.evaluate(i))],
                atan: [yi, [yi], (i, [t]) => Math.atan(t.evaluate(i))],
                min: [yi, vs(yi), (i, t) => Math.min(...t.map(a => a.evaluate(i)))],
                max: [yi, vs(yi), (i, t) => Math.max(...t.map(a => a.evaluate(i)))],
                abs: [yi, [yi], (i, [t]) => Math.abs(t.evaluate(i))],
                round: [yi, [yi], (i, [t]) => {
                    const a = t.evaluate(i);
                    return a < 0 ? -Math.round(-a) : Math.round(a)
                }],
                floor: [yi, [yi], (i, [t]) => Math.floor(t.evaluate(i))],
                ceil: [yi, [yi], (i, [t]) => Math.ceil(t.evaluate(i))],
                "filter-==": [qi, [Si, ge], (i, [t, a]) => i.properties()[t.value] === a.value],
                "filter-id-==": [qi, [ge], (i, [t]) => i.id() === t.value],
                "filter-type-==": [qi, [Si], (i, [t]) => i.geometryType() === t.value],
                "filter-<": [qi, [Si, ge], (i, [t, a]) => {
                    const l = i.properties()[t.value],
                        d = a.value;
                    return typeof l == typeof d && l < d
                }],
                "filter-id-<": [qi, [ge], (i, [t]) => {
                    const a = i.id(),
                        l = t.value;
                    return typeof a == typeof l && a < l
                }],
                "filter->": [qi, [Si, ge], (i, [t, a]) => {
                    const l = i.properties()[t.value],
                        d = a.value;
                    return typeof l == typeof d && l > d
                }],
                "filter-id->": [qi, [ge], (i, [t]) => {
                    const a = i.id(),
                        l = t.value;
                    return typeof a == typeof l && a > l
                }],
                "filter-<=": [qi, [Si, ge], (i, [t, a]) => {
                    const l = i.properties()[t.value],
                        d = a.value;
                    return typeof l == typeof d && l <= d
                }],
                "filter-id-<=": [qi, [ge], (i, [t]) => {
                    const a = i.id(),
                        l = t.value;
                    return typeof a == typeof l && a <= l
                }],
                "filter->=": [qi, [Si, ge], (i, [t, a]) => {
                    const l = i.properties()[t.value],
                        d = a.value;
                    return typeof l == typeof d && l >= d
                }],
                "filter-id->=": [qi, [ge], (i, [t]) => {
                    const a = i.id(),
                        l = t.value;
                    return typeof a == typeof l && a >= l
                }],
                "filter-has": [qi, [ge], (i, [t]) => t.value in i.properties()],
                "filter-has-id": [qi, [], i => i.id() !== null && i.id() !== void 0],
                "filter-type-in": [qi, [fe(Si)], (i, [t]) => t.value.indexOf(i.geometryType()) >= 0],
                "filter-id-in": [qi, [fe(ge)], (i, [t]) => t.value.indexOf(i.id()) >= 0],
                "filter-in-small": [qi, [Si, fe(ge)], (i, [t, a]) => a.value.indexOf(i.properties()[t.value]) >= 0],
                "filter-in-large": [qi, [Si, fe(ge)], (i, [t, a]) => function(l, d, g, x) {
                    for (; g <= x;) {
                        const A = g + x >> 1;
                        if (d[A] === l) return !0;
                        d[A] > l ? x = A - 1 : g = A + 1
                    }
                    return !1
                }(i.properties()[t.value], a.value, 0, a.value.length - 1)],
                all: {
                    type: qi,
                    overloads: [
                        [
                            [qi, qi], (i, [t, a]) => t.evaluate(i) && a.evaluate(i)
                        ],
                        [vs(qi), (i, t) => {
                            for (const a of t)
                                if (!a.evaluate(i)) return !1;
                            return !0
                        }]
                    ]
                },
                any: {
                    type: qi,
                    overloads: [
                        [
                            [qi, qi], (i, [t, a]) => t.evaluate(i) || a.evaluate(i)
                        ],
                        [vs(qi), (i, t) => {
                            for (const a of t)
                                if (a.evaluate(i)) return !0;
                            return !1
                        }]
                    ]
                },
                "!": [qi, [qi], (i, [t]) => !t.evaluate(i)],
                "is-supported-script": [qi, [Si], (i, [t]) => {
                    const a = i.globals && i.globals.isSupportedScript;
                    return !a || a(t.evaluate(i))
                }],
                upcase: [Si, [Si], (i, [t]) => t.evaluate(i).toUpperCase()],
                downcase: [Si, [Si], (i, [t]) => t.evaluate(i).toLowerCase()],
                concat: [Si, vs(ge), (i, t) => t.map(a => wa(a.evaluate(i))).join("")],
                "resolved-locale": [Si, [ga], (i, [t]) => t.evaluate(i).resolvedLocale()]
            });
            class Cn {
                constructor(t, a) {
                    var l;
                    this.expression = t, this._warningHistory = {}, this._evaluator = new Qn, this._defaultValue = a ? (l = a).type === "color" && Ro(l.default) ? new _n(0, 0, 0, 0) : l.type === "color" ? _n.parse(l.default) || null : l.type === "padding" ? Fr.parse(l.default) || null : l.type === "variableAnchorOffsetCollection" ? ra.parse(l.default) || null : l.default === void 0 ? null : l.default : null, this._enumValues = a && a.type === "enum" ? a.values : null
                }
                evaluateWithoutErrorHandling(t, a, l, d, g, x) {
                    return this._evaluator.globals = t, this._evaluator.feature = a, this._evaluator.featureState = l, this._evaluator.canonical = d, this._evaluator.availableImages = g || null, this._evaluator.formattedSection = x, this.expression.evaluate(this._evaluator)
                }
                evaluate(t, a, l, d, g, x) {
                    this._evaluator.globals = t, this._evaluator.feature = a || null, this._evaluator.featureState = l || null, this._evaluator.canonical = d, this._evaluator.availableImages = g || null, this._evaluator.formattedSection = x || null;
                    try {
                        const A = this.expression.evaluate(this._evaluator);
                        if (A == null || typeof A == "number" && A != A) return this._defaultValue;
                        if (this._enumValues && !(A in this._enumValues)) throw new Ln(`Expected value to be one of ${Object.keys(this._enumValues).map(M=>JSON.stringify(M)).join(", ")}, but found ${JSON.stringify(A)} instead.`);
                        return A
                    } catch (A) {
                        return this._warningHistory[A.message] || (this._warningHistory[A.message] = !0, typeof console != "undefined" && console.warn(A.message)), this._defaultValue
                    }
                }
            }

            function Dn(i) {
                return Array.isArray(i) && i.length > 0 && typeof i[0] == "string" && i[0] in Ua
            }

            function dr(i, t) {
                const a = new os(Ua, ni, [], t ? function(d) {
                        const g = {
                            color: Nn,
                            string: Si,
                            number: yi,
                            enum: Si,
                            boolean: qi,
                            formatted: On,
                            padding: Te,
                            resolvedImage: te,
                            variableAnchorOffsetCollection: he
                        };
                        return d.type === "array" ? fe(g[d.value] || ge, d.length) : g[d.type]
                    }(t) : void 0),
                    l = a.parse(i, void 0, void 0, void 0, t && t.type === "string" ? {
                        typeAnnotation: "coerce"
                    } : void 0);
                return l ? ul(new Cn(l, t)) : _s(a.errors)
            }
            class bs {
                constructor(t, a) {
                    this.kind = t, this._styleExpression = a, this.isStateDependent = t !== "constant" && !Wi(a.expression)
                }
                evaluateWithoutErrorHandling(t, a, l, d, g, x) {
                    return this._styleExpression.evaluateWithoutErrorHandling(t, a, l, d, g, x)
                }
                evaluate(t, a, l, d, g, x) {
                    return this._styleExpression.evaluate(t, a, l, d, g, x)
                }
            }
            class Lo {
                constructor(t, a, l, d) {
                    this.kind = t, this.zoomStops = l, this._styleExpression = a, this.isStateDependent = t !== "camera" && !Wi(a.expression), this.interpolationType = d
                }
                evaluateWithoutErrorHandling(t, a, l, d, g, x) {
                    return this._styleExpression.evaluateWithoutErrorHandling(t, a, l, d, g, x)
                }
                evaluate(t, a, l, d, g, x) {
                    return this._styleExpression.evaluate(t, a, l, d, g, x)
                }
                interpolationFactor(t, a, l) {
                    return this.interpolationType ? Bi.interpolationFactor(this.interpolationType, t, a, l) : 0
                }
            }

            function ao(i, t) {
                const a = dr(i, t);
                if (a.result === "error") return a;
                const l = a.value.expression,
                    d = ri(l);
                if (!d && !xs(t)) return _s([new ji("", "data expressions not supported")]);
                const g = Ci(l, ["zoom"]);
                if (!g && !dl(t)) return _s([new ji("", "zoom expressions not supported")]);
                const x = ws(l);
                return x || g ? x instanceof ji ? _s([x]) : x instanceof Bi && !Bo(t) ? _s([new ji("", '"interpolate" expressions cannot be used with this property')]) : ul(x ? new Lo(d ? "camera" : "composite", a.value, x.labels, x instanceof Bi ? x.interpolation : void 0) : new bs(d ? "constant" : "source", a.value)) : _s([new ji("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')])
            }
            class so {
                constructor(t, a) {
                    this._parameters = t, this._specification = a, qn(this, ar(this._parameters, this._specification))
                }
                static deserialize(t) {
                    return new so(t._parameters, t._specification)
                }
                static serialize(t) {
                    return {
                        _parameters: t._parameters,
                        _specification: t._specification
                    }
                }
            }

            function ws(i) {
                let t = null;
                if (i instanceof lr) t = ws(i.result);
                else if (i instanceof Un) {
                    for (const a of i.args)
                        if (t = ws(a), t) break
                } else(i instanceof ai || i instanceof Bi) && i.input instanceof ti && i.input.name === "zoom" && (t = i);
                return t instanceof ji || i.eachChild(a => {
                    const l = ws(a);
                    l instanceof ji ? t = l : !t && l ? t = new ji("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && l && t !== l && (t = new ji("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))
                }), t
            }

            function Es(i) {
                if (i === !0 || i === !1) return !0;
                if (!Array.isArray(i) || i.length === 0) return !1;
                switch (i[0]) {
                    case "has":
                        return i.length >= 2 && i[1] !== "$id" && i[1] !== "$type";
                    case "in":
                        return i.length >= 3 && (typeof i[1] != "string" || Array.isArray(i[2]));
                    case "!in":
                    case "!has":
                    case "none":
                        return !1;
                    case "==":
                    case "!=":
                    case ">":
                    case ">=":
                    case "<":
                    case "<=":
                        return i.length !== 3 || Array.isArray(i[1]) || Array.isArray(i[2]);
                    case "any":
                    case "all":
                        for (const t of i.slice(1))
                            if (!Es(t) && typeof t != "boolean") return !1;
                        return !0;
                    default:
                        return !0
                }
            }
            const pl = {
                type: "boolean",
                default: !1,
                transition: !1,
                "property-type": "data-driven",
                expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"]
                }
            };

            function Us(i) {
                if (i == null) return {
                    filter: () => !0,
                    needGeometry: !1
                };
                Es(i) || (i = Is(i));
                const t = dr(i, pl);
                if (t.result === "error") throw new Error(t.value.map(a => `${a.key}: ${a.message}`).join(", "));
                return {
                    filter: (a, l, d) => t.value.evaluate(a, l, {}, d),
                    needGeometry: Hl(i)
                }
            }

            function Pc(i, t) {
                return i < t ? -1 : i > t ? 1 : 0
            }

            function Hl(i) {
                if (!Array.isArray(i)) return !1;
                if (i[0] === "within") return !0;
                for (let t = 1; t < i.length; t++)
                    if (Hl(i[t])) return !0;
                return !1
            }

            function Is(i) {
                if (!i) return !0;
                const t = i[0];
                return i.length <= 1 ? t !== "any" : t === "==" ? An(i[1], i[2], "==") : t === "!=" ? Wl(An(i[1], i[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? An(i[1], i[2], t) : t === "any" ? (a = i.slice(1), ["any"].concat(a.map(Is))) : t === "all" ? ["all"].concat(i.slice(1).map(Is)) : t === "none" ? ["all"].concat(i.slice(1).map(Is).map(Wl)) : t === "in" ? Oi(i[1], i.slice(2)) : t === "!in" ? Wl(Oi(i[1], i.slice(2))) : t === "has" ? Ga(i[1]) : t === "!has" ? Wl(Ga(i[1])) : t !== "within" || i;
                var a
            }

            function An(i, t, a) {
                switch (i) {
                    case "$type":
                        return [`filter-type-${a}`, t];
                    case "$id":
                        return [`filter-id-${a}`, t];
                    default:
                        return [`filter-${a}`, i, t]
                }
            }

            function Oi(i, t) {
                if (t.length === 0) return !1;
                switch (i) {
                    case "$type":
                        return ["filter-type-in", ["literal", t]];
                    case "$id":
                        return ["filter-id-in", ["literal", t]];
                    default:
                        return t.length > 200 && !t.some(a => typeof a != typeof t[0]) ? ["filter-in-large", i, ["literal", t.sort(Pc)]] : ["filter-in-small", i, ["literal", t]]
                }
            }

            function Ga(i) {
                switch (i) {
                    case "$type":
                        return !0;
                    case "$id":
                        return ["filter-has-id"];
                    default:
                        return ["filter-has", i]
                }
            }

            function Wl(i) {
                return ["!", i]
            }

            function kc(i) {
                const t = typeof i;
                if (t === "number" || t === "boolean" || t === "string" || i == null) return JSON.stringify(i);
                if (Array.isArray(i)) {
                    let d = "[";
                    for (const g of i) d += `${kc(g)},`;
                    return `${d}]`
                }
                const a = Object.keys(i).sort();
                let l = "{";
                for (let d = 0; d < a.length; d++) l += `${JSON.stringify(a[d])}:${kc(i[a[d]])},`;
                return `${l}}`
            }

            function Qu(i) {
                let t = "";
                for (const a of Ot) t += `/${kc(i[a])}`;
                return t
            }

            function Ph(i) {
                const t = i.value;
                return t ? [new Pt(i.key, t, "constants have been deprecated as of v8")] : []
            }

            function Sr(i) {
                return i instanceof Number || i instanceof String || i instanceof Boolean ? i.valueOf() : i
            }

            function zs(i) {
                if (Array.isArray(i)) return i.map(zs);
                if (i instanceof Object && !(i instanceof Number || i instanceof String || i instanceof Boolean)) {
                    const t = {};
                    for (const a in i) t[a] = zs(i[a]);
                    return t
                }
                return Sr(i)
            }

            function Sa(i) {
                const t = i.key,
                    a = i.value,
                    l = i.valueSpec || {},
                    d = i.objectElementValidators || {},
                    g = i.style,
                    x = i.styleSpec,
                    A = i.validateSpec;
                let M = [];
                const F = Mn(a);
                if (F !== "object") return [new Pt(t, a, `object expected, ${F} found`)];
                for (const D in a) {
                    const U = D.split(".")[0],
                        N = l[U] || l["*"];
                    let H;
                    if (d[U]) H = d[U];
                    else if (l[U]) H = A;
                    else if (d["*"]) H = d["*"];
                    else {
                        if (!l["*"]) {
                            M.push(new Pt(t, a[D], `unknown property "${D}"`));
                            continue
                        }
                        H = A
                    }
                    M = M.concat(H({
                        key: (t && `${t}.`) + D,
                        value: a[D],
                        valueSpec: N,
                        style: g,
                        styleSpec: x,
                        object: a,
                        objectKey: D,
                        validateSpec: A
                    }, a))
                }
                for (const D in l) d[D] || l[D].required && l[D].default === void 0 && a[D] === void 0 && M.push(new Pt(t, a, `missing required property "${D}"`));
                return M
            }

            function Dc(i) {
                const t = i.value,
                    a = i.valueSpec,
                    l = i.style,
                    d = i.styleSpec,
                    g = i.key,
                    x = i.arrayElementValidator || i.validateSpec;
                if (Mn(t) !== "array") return [new Pt(g, t, `array expected, ${Mn(t)} found`)];
                if (a.length && t.length !== a.length) return [new Pt(g, t, `array length ${a.length} expected, length ${t.length} found`)];
                if (a["min-length"] && t.length < a["min-length"]) return [new Pt(g, t, `array length at least ${a["min-length"]} expected, length ${t.length} found`)];
                let A = {
                    type: a.value,
                    values: a.values
                };
                d.$version < 7 && (A.function = a.function), Mn(a.value) === "object" && (A = a.value);
                let M = [];
                for (let F = 0; F < t.length; F++) M = M.concat(x({
                    array: t,
                    arrayIndex: F,
                    value: t[F],
                    valueSpec: A,
                    validateSpec: i.validateSpec,
                    style: l,
                    styleSpec: d,
                    key: `${g}[${F}]`
                }));
                return M
            }

            function Jl(i) {
                const t = i.key,
                    a = i.value,
                    l = i.valueSpec;
                let d = Mn(a);
                return d === "number" && a != a && (d = "NaN"), d !== "number" ? [new Pt(t, a, `number expected, ${d} found`)] : "minimum" in l && a < l.minimum ? [new Pt(t, a, `${a} is less than the minimum value ${l.minimum}`)] : "maximum" in l && a > l.maximum ? [new Pt(t, a, `${a} is greater than the maximum value ${l.maximum}`)] : []
            }

            function kh(i) {
                const t = i.valueSpec,
                    a = Sr(i.value.type);
                let l, d, g, x = {};
                const A = a !== "categorical" && i.value.property === void 0,
                    M = !A,
                    F = Mn(i.value.stops) === "array" && Mn(i.value.stops[0]) === "array" && Mn(i.value.stops[0][0]) === "object",
                    D = Sa({
                        key: i.key,
                        value: i.value,
                        valueSpec: i.styleSpec.function,
                        validateSpec: i.validateSpec,
                        style: i.style,
                        styleSpec: i.styleSpec,
                        objectElementValidators: {
                            stops: function(H) {
                                if (a === "identity") return [new Pt(H.key, H.value, 'identity function may not have a "stops" property')];
                                let X = [];
                                const ne = H.value;
                                return X = X.concat(Dc({
                                    key: H.key,
                                    value: ne,
                                    valueSpec: H.valueSpec,
                                    validateSpec: H.validateSpec,
                                    style: H.style,
                                    styleSpec: H.styleSpec,
                                    arrayElementValidator: U
                                })), Mn(ne) === "array" && ne.length === 0 && X.push(new Pt(H.key, ne, "array must have at least one stop")), X
                            },
                            default: function(H) {
                                return H.validateSpec({
                                    key: H.key,
                                    value: H.value,
                                    valueSpec: t,
                                    validateSpec: H.validateSpec,
                                    style: H.style,
                                    styleSpec: H.styleSpec
                                })
                            }
                        }
                    });
                return a === "identity" && A && D.push(new Pt(i.key, i.value, 'missing required property "property"')), a === "identity" || i.value.stops || D.push(new Pt(i.key, i.value, 'missing required property "stops"')), a === "exponential" && i.valueSpec.expression && !Bo(i.valueSpec) && D.push(new Pt(i.key, i.value, "exponential functions not supported")), i.styleSpec.$version >= 8 && (M && !xs(i.valueSpec) ? D.push(new Pt(i.key, i.value, "property functions not supported")) : A && !dl(i.valueSpec) && D.push(new Pt(i.key, i.value, "zoom functions not supported"))), a !== "categorical" && !F || i.value.property !== void 0 || D.push(new Pt(i.key, i.value, '"property" property is required')), D;

                function U(H) {
                    let X = [];
                    const ne = H.value,
                        le = H.key;
                    if (Mn(ne) !== "array") return [new Pt(le, ne, `array expected, ${Mn(ne)} found`)];
                    if (ne.length !== 2) return [new Pt(le, ne, `array length 2 expected, length ${ne.length} found`)];
                    if (F) {
                        if (Mn(ne[0]) !== "object") return [new Pt(le, ne, `object expected, ${Mn(ne[0])} found`)];
                        if (ne[0].zoom === void 0) return [new Pt(le, ne, "object stop key must have zoom")];
                        if (ne[0].value === void 0) return [new Pt(le, ne, "object stop key must have value")];
                        if (g && g > Sr(ne[0].zoom)) return [new Pt(le, ne[0].zoom, "stop zoom values must appear in ascending order")];
                        Sr(ne[0].zoom) !== g && (g = Sr(ne[0].zoom), d = void 0, x = {}), X = X.concat(Sa({
                            key: `${le}[0]`,
                            value: ne[0],
                            valueSpec: {
                                zoom: {}
                            },
                            validateSpec: H.validateSpec,
                            style: H.style,
                            styleSpec: H.styleSpec,
                            objectElementValidators: {
                                zoom: Jl,
                                value: N
                            }
                        }))
                    } else X = X.concat(N({
                        key: `${le}[0]`,
                        value: ne[0],
                        valueSpec: {},
                        validateSpec: H.validateSpec,
                        style: H.style,
                        styleSpec: H.styleSpec
                    }, ne));
                    return Dn(zs(ne[1])) ? X.concat([new Pt(`${le}[1]`, ne[1], "expressions are not allowed in function stops.")]) : X.concat(H.validateSpec({
                        key: `${le}[1]`,
                        value: ne[1],
                        valueSpec: t,
                        validateSpec: H.validateSpec,
                        style: H.style,
                        styleSpec: H.styleSpec
                    }))
                }

                function N(H, X) {
                    const ne = Mn(H.value),
                        le = Sr(H.value),
                        ce = H.value !== null ? H.value : X;
                    if (l) {
                        if (ne !== l) return [new Pt(H.key, ce, `${ne} stop domain type must match previous stop domain type ${l}`)]
                    } else l = ne;
                    if (ne !== "number" && ne !== "string" && ne !== "boolean") return [new Pt(H.key, ce, "stop domain value must be a number, string, or boolean")];
                    if (ne !== "number" && a !== "categorical") {
                        let Qe = `number expected, ${ne} found`;
                        return xs(t) && a === void 0 && (Qe += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Pt(H.key, ce, Qe)]
                    }
                    return a !== "categorical" || ne !== "number" || isFinite(le) && Math.floor(le) === le ? a !== "categorical" && ne === "number" && d !== void 0 && le < d ? [new Pt(H.key, ce, "stop domain values must appear in ascending order")] : (d = le, a === "categorical" && le in x ? [new Pt(H.key, ce, "stop domain values must be unique")] : (x[le] = !0, [])) : [new Pt(H.key, ce, `integer expected, found ${le}`)]
                }
            }

            function Ns(i) {
                const t = (i.expressionContext === "property" ? ao : dr)(zs(i.value), i.valueSpec);
                if (t.result === "error") return t.value.map(l => new Pt(`${i.key}${l.key}`, i.value, l.message));
                const a = t.value.expression || t.value._styleExpression.expression;
                if (i.expressionContext === "property" && i.propertyKey === "text-font" && !a.outputDefined()) return [new Pt(i.key, i.value, `Invalid data expression for "${i.propertyKey}". Output values must be contained as literals within the expression.`)];
                if (i.expressionContext === "property" && i.propertyType === "layout" && !Wi(a)) return [new Pt(i.key, i.value, '"feature-state" data expressions are not supported with layout properties.')];
                if (i.expressionContext === "filter" && !Wi(a)) return [new Pt(i.key, i.value, '"feature-state" data expressions are not supported with filters.')];
                if (i.expressionContext && i.expressionContext.indexOf("cluster") === 0) {
                    if (!Ci(a, ["zoom", "feature-state"])) return [new Pt(i.key, i.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
                    if (i.expressionContext === "cluster-initial" && !ri(a)) return [new Pt(i.key, i.value, "Feature data expressions are not supported with initial expression part of cluster properties.")]
                }
                return []
            }

            function Os(i) {
                const t = i.key,
                    a = i.value,
                    l = i.valueSpec,
                    d = [];
                return Array.isArray(l.values) ? l.values.indexOf(Sr(a)) === -1 && d.push(new Pt(t, a, `expected one of [${l.values.join(", ")}], ${JSON.stringify(a)} found`)) : Object.keys(l.values).indexOf(Sr(a)) === -1 && d.push(new Pt(t, a, `expected one of [${Object.keys(l.values).join(", ")}], ${JSON.stringify(a)} found`)), d
            }

            function Qo(i) {
                return Es(zs(i.value)) ? Ns(qn({}, i, {
                    expressionContext: "filter",
                    valueSpec: {
                        value: "boolean"
                    }
                })) : Zl(i)
            }

            function Zl(i) {
                const t = i.value,
                    a = i.key;
                if (Mn(t) !== "array") return [new Pt(a, t, `array expected, ${Mn(t)} found`)];
                const l = i.styleSpec;
                let d, g = [];
                if (t.length < 1) return [new Pt(a, t, "filter array must have at least 1 element")];
                switch (g = g.concat(Os({
                        key: `${a}[0]`,
                        value: t[0],
                        valueSpec: l.filter_operator,
                        style: i.style,
                        styleSpec: i.styleSpec
                    })), Sr(t[0])) {
                    case "<":
                    case "<=":
                    case ">":
                    case ">=":
                        t.length >= 2 && Sr(t[1]) === "$type" && g.push(new Pt(a, t, `"$type" cannot be use with operator "${t[0]}"`));
                    case "==":
                    case "!=":
                        t.length !== 3 && g.push(new Pt(a, t, `filter array for operator "${t[0]}" must have 3 elements`));
                    case "in":
                    case "!in":
                        t.length >= 2 && (d = Mn(t[1]), d !== "string" && g.push(new Pt(`${a}[1]`, t[1], `string expected, ${d} found`)));
                        for (let x = 2; x < t.length; x++) d = Mn(t[x]), Sr(t[1]) === "$type" ? g = g.concat(Os({
                            key: `${a}[${x}]`,
                            value: t[x],
                            valueSpec: l.geometry_type,
                            style: i.style,
                            styleSpec: i.styleSpec
                        })) : d !== "string" && d !== "number" && d !== "boolean" && g.push(new Pt(`${a}[${x}]`, t[x], `string, number, or boolean expected, ${d} found`));
                        break;
                    case "any":
                    case "all":
                    case "none":
                        for (let x = 1; x < t.length; x++) g = g.concat(Zl({
                            key: `${a}[${x}]`,
                            value: t[x],
                            style: i.style,
                            styleSpec: i.styleSpec
                        }));
                        break;
                    case "has":
                    case "!has":
                        d = Mn(t[1]), t.length !== 2 ? g.push(new Pt(a, t, `filter array for "${t[0]}" operator must have 2 elements`)) : d !== "string" && g.push(new Pt(`${a}[1]`, t[1], `string expected, ${d} found`));
                        break;
                    case "within":
                        d = Mn(t[1]), t.length !== 2 ? g.push(new Pt(a, t, `filter array for "${t[0]}" operator must have 2 elements`)) : d !== "object" && g.push(new Pt(`${a}[1]`, t[1], `object expected, ${d} found`))
                }
                return g
            }

            function fl(i, t) {
                const a = i.key,
                    l = i.validateSpec,
                    d = i.style,
                    g = i.styleSpec,
                    x = i.value,
                    A = i.objectKey,
                    M = g[`${t}_${i.layerType}`];
                if (!M) return [];
                const F = A.match(/^(.*)-transition$/);
                if (t === "paint" && F && M[F[1]] && M[F[1]].transition) return l({
                    key: a,
                    value: x,
                    valueSpec: g.transition,
                    style: d,
                    styleSpec: g
                });
                const D = i.valueSpec || M[A];
                if (!D) return [new Pt(a, x, `unknown property "${A}"`)];
                let U;
                if (Mn(x) === "string" && xs(D) && !D.tokens && (U = /^{([^}]+)}$/.exec(x))) return [new Pt(a, x, `"${A}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(U[1])} }\`.`)];
                const N = [];
                return i.layerType === "symbol" && (A === "text-field" && d && !d.glyphs && N.push(new Pt(a, x, 'use of "text-field" requires a style "glyphs" property')), A === "text-font" && Ro(zs(x)) && Sr(x.type) === "identity" && N.push(new Pt(a, x, '"text-font" does not support identity functions'))), N.concat(l({
                    key: i.key,
                    value: x,
                    valueSpec: D,
                    style: d,
                    styleSpec: g,
                    expressionContext: "property",
                    propertyType: t,
                    propertyKey: A
                }))
            }

            function ml(i) {
                return fl(i, "paint")
            }

            function Po(i) {
                return fl(i, "layout")
            }

            function Dh(i) {
                let t = [];
                const a = i.value,
                    l = i.key,
                    d = i.style,
                    g = i.styleSpec;
                a.type || a.ref || t.push(new Pt(l, a, 'either "type" or "ref" is required'));
                let x = Sr(a.type);
                const A = Sr(a.ref);
                if (a.id) {
                    const M = Sr(a.id);
                    for (let F = 0; F < i.arrayIndex; F++) {
                        const D = d.layers[F];
                        Sr(D.id) === M && t.push(new Pt(l, a.id, `duplicate layer id "${a.id}", previously used at line ${D.id.__line__}`))
                    }
                }
                if ("ref" in a) {
                    let M;
                    ["type", "source", "source-layer", "filter", "layout"].forEach(F => {
                        F in a && t.push(new Pt(l, a[F], `"${F}" is prohibited for ref layers`))
                    }), d.layers.forEach(F => {
                        Sr(F.id) === A && (M = F)
                    }), M ? M.ref ? t.push(new Pt(l, a.ref, "ref cannot reference another ref layer")) : x = Sr(M.type) : t.push(new Pt(l, a.ref, `ref layer "${A}" not found`))
                } else if (x !== "background")
                    if (a.source) {
                        const M = d.sources && d.sources[a.source],
                            F = M && Sr(M.type);
                        M ? F === "vector" && x === "raster" ? t.push(new Pt(l, a.source, `layer "${a.id}" requires a raster source`)) : F !== "raster-dem" && x === "hillshade" ? t.push(new Pt(l, a.source, `layer "${a.id}" requires a raster-dem source`)) : F === "raster" && x !== "raster" ? t.push(new Pt(l, a.source, `layer "${a.id}" requires a vector source`)) : F !== "vector" || a["source-layer"] ? F === "raster-dem" && x !== "hillshade" ? t.push(new Pt(l, a.source, "raster-dem source can only be used with layer type 'hillshade'.")) : x !== "line" || !a.paint || !a.paint["line-gradient"] || F === "geojson" && M.lineMetrics || t.push(new Pt(l, a, `layer "${a.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new Pt(l, a, `layer "${a.id}" must specify a "source-layer"`)) : t.push(new Pt(l, a.source, `source "${a.source}" not found`))
                    } else t.push(new Pt(l, a, 'missing required property "source"'));
                return t = t.concat(Sa({
                    key: l,
                    value: a,
                    valueSpec: g.layer,
                    style: i.style,
                    styleSpec: i.styleSpec,
                    validateSpec: i.validateSpec,
                    objectElementValidators: {
                        "*": () => [],
                        type: () => i.validateSpec({
                            key: `${l}.type`,
                            value: a.type,
                            valueSpec: g.layer.type,
                            style: i.style,
                            styleSpec: i.styleSpec,
                            validateSpec: i.validateSpec,
                            object: a,
                            objectKey: "type"
                        }),
                        filter: Qo,
                        layout: M => Sa({
                            layer: a,
                            key: M.key,
                            value: M.value,
                            style: M.style,
                            styleSpec: M.styleSpec,
                            validateSpec: M.validateSpec,
                            objectElementValidators: {
                                "*": F => Po(qn({
                                    layerType: x
                                }, F))
                            }
                        }),
                        paint: M => Sa({
                            layer: a,
                            key: M.key,
                            value: M.value,
                            style: M.style,
                            styleSpec: M.styleSpec,
                            validateSpec: M.validateSpec,
                            objectElementValidators: {
                                "*": F => ml(qn({
                                    layerType: x
                                }, F))
                            }
                        })
                    }
                })), t
            }

            function oo(i) {
                const t = i.value,
                    a = i.key,
                    l = Mn(t);
                return l !== "string" ? [new Pt(a, t, `string expected, ${l} found`)] : []
            }
            const Uc = {
                promoteId: function({
                    key: i,
                    value: t
                }) {
                    if (Mn(t) === "string") return oo({
                        key: i,
                        value: t
                    });
                    {
                        const a = [];
                        for (const l in t) a.push(...oo({
                            key: `${i}.${l}`,
                            value: t[l]
                        }));
                        return a
                    }
                }
            };

            function Ic(i) {
                const t = i.value,
                    a = i.key,
                    l = i.styleSpec,
                    d = i.style,
                    g = i.validateSpec;
                if (!t.type) return [new Pt(a, t, '"type" is required')];
                const x = Sr(t.type);
                let A;
                switch (x) {
                    case "vector":
                    case "raster":
                        return A = Sa({
                            key: a,
                            value: t,
                            valueSpec: l[`source_${x.replace("-","_")}`],
                            style: i.style,
                            styleSpec: l,
                            objectElementValidators: Uc,
                            validateSpec: g
                        }), A;
                    case "raster-dem":
                        return A = function(M) {
                            var F;
                            const D = (F = M.sourceName) !== null && F !== void 0 ? F : "",
                                U = M.value,
                                N = M.styleSpec,
                                H = N.source_raster_dem,
                                X = M.style;
                            let ne = [];
                            const le = Mn(U);
                            if (U === void 0) return ne;
                            if (le !== "object") return ne.push(new Pt("source_raster_dem", U, `object expected, ${le} found`)), ne;
                            const ce = Sr(U.encoding) === "custom",
                                Qe = ["redFactor", "greenFactor", "blueFactor", "baseShift"],
                                Se = M.value.encoding ? `"${M.value.encoding}"` : "Default";
                            for (const Re in U) !ce && Qe.includes(Re) ? ne.push(new Pt(Re, U[Re], `In "${D}": "${Re}" is only valid when "encoding" is set to "custom". ${Se} encoding found`)) : H[Re] ? ne = ne.concat(M.validateSpec({
                                key: Re,
                                value: U[Re],
                                valueSpec: H[Re],
                                validateSpec: M.validateSpec,
                                style: X,
                                styleSpec: N
                            })) : ne.push(new Pt(Re, U[Re], `unknown property "${Re}"`));
                            return ne
                        }({
                            sourceName: a,
                            value: t,
                            style: i.style,
                            styleSpec: l,
                            validateSpec: g
                        }), A;
                    case "geojson":
                        if (A = Sa({
                                key: a,
                                value: t,
                                valueSpec: l.source_geojson,
                                style: d,
                                styleSpec: l,
                                validateSpec: g,
                                objectElementValidators: Uc
                            }), t.cluster)
                            for (const M in t.clusterProperties) {
                                const [F, D] = t.clusterProperties[M], U = typeof F == "string" ? [F, ["accumulated"],
                                    ["get", M]
                                ] : F;
                                A.push(...Ns({
                                    key: `${a}.${M}.map`,
                                    value: D,
                                    validateSpec: g,
                                    expressionContext: "cluster-map"
                                })), A.push(...Ns({
                                    key: `${a}.${M}.reduce`,
                                    value: U,
                                    validateSpec: g,
                                    expressionContext: "cluster-reduce"
                                }))
                            }
                        return A;
                    case "video":
                        return Sa({
                            key: a,
                            value: t,
                            valueSpec: l.source_video,
                            style: d,
                            validateSpec: g,
                            styleSpec: l
                        });
                    case "image":
                        return Sa({
                            key: a,
                            value: t,
                            valueSpec: l.source_image,
                            style: d,
                            validateSpec: g,
                            styleSpec: l
                        });
                    case "canvas":
                        return [new Pt(a, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
                    default:
                        return Os({
                            key: `${a}.type`,
                            value: t.type,
                            valueSpec: {
                                values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]
                            },
                            style: d,
                            validateSpec: g,
                            styleSpec: l
                        })
                }
            }

            function zc(i) {
                const t = i.value,
                    a = i.styleSpec,
                    l = a.light,
                    d = i.style;
                let g = [];
                const x = Mn(t);
                if (t === void 0) return g;
                if (x !== "object") return g = g.concat([new Pt("light", t, `object expected, ${x} found`)]), g;
                for (const A in t) {
                    const M = A.match(/^(.*)-transition$/);
                    g = g.concat(M && l[M[1]] && l[M[1]].transition ? i.validateSpec({
                        key: A,
                        value: t[A],
                        valueSpec: a.transition,
                        validateSpec: i.validateSpec,
                        style: d,
                        styleSpec: a
                    }) : l[A] ? i.validateSpec({
                        key: A,
                        value: t[A],
                        valueSpec: l[A],
                        validateSpec: i.validateSpec,
                        style: d,
                        styleSpec: a
                    }) : [new Pt(A, t[A], `unknown property "${A}"`)])
                }
                return g
            }

            function ko(i) {
                const t = i.value,
                    a = i.styleSpec,
                    l = a.sky,
                    d = i.style,
                    g = Mn(t);
                if (t === void 0) return [];
                if (g !== "object") return [new Pt("sky", t, `object expected, ${g} found`)];
                let x = [];
                for (const A in t) x = x.concat(l[A] ? Vr({
                    key: A,
                    value: t[A],
                    valueSpec: l[A],
                    style: d,
                    styleSpec: a
                }) : [new Pt(A, t[A], `unknown property "${A}"`)]);
                return x
            }

            function Do(i) {
                const t = i.value,
                    a = i.styleSpec,
                    l = a.terrain,
                    d = i.style;
                let g = [];
                const x = Mn(t);
                if (t === void 0) return g;
                if (x !== "object") return g = g.concat([new Pt("terrain", t, `object expected, ${x} found`)]), g;
                for (const A in t) g = g.concat(l[A] ? i.validateSpec({
                    key: A,
                    value: t[A],
                    valueSpec: l[A],
                    validateSpec: i.validateSpec,
                    style: d,
                    styleSpec: a
                }) : [new Pt(A, t[A], `unknown property "${A}"`)]);
                return g
            }

            function Aa(i) {
                let t = [];
                const a = i.value,
                    l = i.key;
                if (Array.isArray(a)) {
                    const d = [],
                        g = [];
                    for (const x in a) a[x].id && d.includes(a[x].id) && t.push(new Pt(l, a, `all the sprites' ids must be unique, but ${a[x].id} is duplicated`)), d.push(a[x].id), a[x].url && g.includes(a[x].url) && t.push(new Pt(l, a, `all the sprites' URLs must be unique, but ${a[x].url} is duplicated`)), g.push(a[x].url), t = t.concat(Sa({
                        key: `${l}[${x}]`,
                        value: a[x],
                        valueSpec: {
                            id: {
                                type: "string",
                                required: !0
                            },
                            url: {
                                type: "string",
                                required: !0
                            }
                        },
                        validateSpec: i.validateSpec
                    }));
                    return t
                }
                return oo({
                    key: l,
                    value: a
                })
            }
            const Ya = {
                "*": () => [],
                array: Dc,
                boolean: function(i) {
                    const t = i.value,
                        a = i.key,
                        l = Mn(t);
                    return l !== "boolean" ? [new Pt(a, t, `boolean expected, ${l} found`)] : []
                },
                number: Jl,
                color: function(i) {
                    const t = i.key,
                        a = i.value,
                        l = Mn(a);
                    return l !== "string" ? [new Pt(t, a, `color expected, ${l} found`)] : _n.parse(String(a)) ? [] : [new Pt(t, a, `color expected, "${a}" found`)]
                },
                constants: Ph,
                enum: Os,
                filter: Qo,
                function: kh,
                layer: Dh,
                object: Sa,
                source: Ic,
                light: zc,
                sky: ko,
                terrain: Do,
                string: oo,
                formatted: function(i) {
                    return oo(i).length === 0 ? [] : Ns(i)
                },
                resolvedImage: function(i) {
                    return oo(i).length === 0 ? [] : Ns(i)
                },
                padding: function(i) {
                    const t = i.key,
                        a = i.value;
                    if (Mn(a) === "array") {
                        if (a.length < 1 || a.length > 4) return [new Pt(t, a, `padding requires 1 to 4 values; ${a.length} values found`)];
                        const l = {
                            type: "number"
                        };
                        let d = [];
                        for (let g = 0; g < a.length; g++) d = d.concat(i.validateSpec({
                            key: `${t}[${g}]`,
                            value: a[g],
                            validateSpec: i.validateSpec,
                            valueSpec: l
                        }));
                        return d
                    }
                    return Jl({
                        key: t,
                        value: a,
                        valueSpec: {}
                    })
                },
                variableAnchorOffsetCollection: function(i) {
                    const t = i.key,
                        a = i.value,
                        l = Mn(a),
                        d = i.styleSpec;
                    if (l !== "array" || a.length < 1 || a.length % 2 != 0) return [new Pt(t, a, "variableAnchorOffsetCollection requires a non-empty array of even length")];
                    let g = [];
                    for (let x = 0; x < a.length; x += 2) g = g.concat(Os({
                        key: `${t}[${x}]`,
                        value: a[x],
                        valueSpec: d.layout_symbol["text-anchor"]
                    })), g = g.concat(Dc({
                        key: `${t}[${x+1}]`,
                        value: a[x + 1],
                        valueSpec: {
                            length: 2,
                            value: "number"
                        },
                        validateSpec: i.validateSpec,
                        style: i.style,
                        styleSpec: d
                    }));
                    return g
                },
                sprite: Aa
            };

            function Vr(i) {
                const t = i.value,
                    a = i.valueSpec,
                    l = i.styleSpec;
                return i.validateSpec = Vr, a.expression && Ro(Sr(t)) ? kh(i) : a.expression && Dn(zs(t)) ? Ns(i) : a.type && Ya[a.type] ? Ya[a.type](i) : Sa(qn({}, i, {
                    valueSpec: a.type ? l[a.type] : a
                }))
            }

            function ha(i) {
                const t = i.value,
                    a = i.key,
                    l = oo(i);
                return l.length || (t.indexOf("{fontstack}") === -1 && l.push(new Pt(a, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && l.push(new Pt(a, t, '"glyphs" url must include a "{range}" token'))), l
            }

            function Ha(i, t = Le) {
                let a = [];
                return a = a.concat(Vr({
                    key: "",
                    value: i,
                    valueSpec: t.$root,
                    styleSpec: t,
                    style: i,
                    validateSpec: Vr,
                    objectElementValidators: {
                        glyphs: ha,
                        "*": () => []
                    }
                })), i.constants && (a = a.concat(Ph({
                    key: "constants",
                    value: i.constants,
                    style: i,
                    styleSpec: t,
                    validateSpec: Vr
                }))), Nc(a)
            }

            function Fa(i) {
                return function(t) {
                    return i(jp(Xp({}, t), {
                        validateSpec: Vr
                    }))
                }
            }

            function Nc(i) {
                return [].concat(i).sort((t, a) => t.line - a.line)
            }

            function Wa(i) {
                return function(...t) {
                    return Nc(i.apply(this, t))
                }
            }
            Ha.source = Wa(Fa(Ic)), Ha.sprite = Wa(Fa(Aa)), Ha.glyphs = Wa(Fa(ha)), Ha.light = Wa(Fa(zc)), Ha.sky = Wa(Fa(ko)), Ha.terrain = Wa(Fa(Do)), Ha.layer = Wa(Fa(Dh)), Ha.filter = Wa(Fa(Qo)), Ha.paintProperty = Wa(Fa(ml)), Ha.layoutProperty = Wa(Fa(Po));
            const gl = Ha,
                Oc = gl.light,
                Pu = gl.paintProperty,
                yl = gl.layoutProperty;

            function Uh(i, t) {
                let a = !1;
                if (t && t.length)
                    for (const l of t) i.fire(new tt(new Error(l.message))), a = !0;
                return a
            }
            class lo {
                constructor(t, a, l) {
                    const d = this.cells = [];
                    if (t instanceof ArrayBuffer) {
                        this.arrayBuffer = t;
                        const x = new Int32Array(this.arrayBuffer);
                        t = x[0], this.d = (a = x[1]) + 2 * (l = x[2]);
                        for (let M = 0; M < this.d * this.d; M++) {
                            const F = x[3 + M],
                                D = x[3 + M + 1];
                            d.push(F === D ? null : x.subarray(F, D))
                        }
                        const A = x[3 + d.length + 1];
                        this.keys = x.subarray(x[3 + d.length], A), this.bboxes = x.subarray(A), this.insert = this._insertReadonly
                    } else {
                        this.d = a + 2 * l;
                        for (let x = 0; x < this.d * this.d; x++) d.push([]);
                        this.keys = [], this.bboxes = []
                    }
                    this.n = a, this.extent = t, this.padding = l, this.scale = a / t, this.uid = 0;
                    const g = l / a * t;
                    this.min = -g, this.max = t + g
                }
                insert(t, a, l, d, g) {
                    this._forEachCell(a, l, d, g, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(a), this.bboxes.push(l), this.bboxes.push(d), this.bboxes.push(g)
                }
                _insertReadonly() {
                    throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.")
                }
                _insertCell(t, a, l, d, g, x) {
                    this.cells[g].push(x)
                }
                query(t, a, l, d, g) {
                    const x = this.min,
                        A = this.max;
                    if (t <= x && a <= x && A <= l && A <= d && !g) return Array.prototype.slice.call(this.keys);
                    {
                        const M = [];
                        return this._forEachCell(t, a, l, d, this._queryCell, M, {}, g), M
                    }
                }
                _queryCell(t, a, l, d, g, x, A, M) {
                    const F = this.cells[g];
                    if (F !== null) {
                        const D = this.keys,
                            U = this.bboxes;
                        for (let N = 0; N < F.length; N++) {
                            const H = F[N];
                            if (A[H] === void 0) {
                                const X = 4 * H;
                                (M ? M(U[X + 0], U[X + 1], U[X + 2], U[X + 3]) : t <= U[X + 2] && a <= U[X + 3] && l >= U[X + 0] && d >= U[X + 1]) ? (A[H] = !0, x.push(D[H])) : A[H] = !1
                            }
                        }
                    }
                }
                _forEachCell(t, a, l, d, g, x, A, M) {
                    const F = this._convertToCellCoord(t),
                        D = this._convertToCellCoord(a),
                        U = this._convertToCellCoord(l),
                        N = this._convertToCellCoord(d);
                    for (let H = F; H <= U; H++)
                        for (let X = D; X <= N; X++) {
                            const ne = this.d * X + H;
                            if ((!M || M(this._convertFromCellCoord(H), this._convertFromCellCoord(X), this._convertFromCellCoord(H + 1), this._convertFromCellCoord(X + 1))) && g.call(this, t, a, l, d, ne, x, A, M)) return
                        }
                }
                _convertFromCellCoord(t) {
                    return (t - this.padding) / this.scale
                }
                _convertToCellCoord(t) {
                    return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding))
                }
                toArrayBuffer() {
                    if (this.arrayBuffer) return this.arrayBuffer;
                    const t = this.cells,
                        a = 3 + this.cells.length + 1 + 1;
                    let l = 0;
                    for (let x = 0; x < this.cells.length; x++) l += this.cells[x].length;
                    const d = new Int32Array(a + l + this.keys.length + this.bboxes.length);
                    d[0] = this.extent, d[1] = this.n, d[2] = this.padding;
                    let g = a;
                    for (let x = 0; x < t.length; x++) {
                        const A = t[x];
                        d[3 + x] = g, d.set(A, g), g += A.length
                    }
                    return d[3 + t.length] = g, d.set(this.keys, g), g += this.keys.length, d[3 + t.length + 1] = g, d.set(this.bboxes, g), g += this.bboxes.length, d.buffer
                }
                static serialize(t, a) {
                    const l = t.toArrayBuffer();
                    return a && a.push(l), {
                        buffer: l
                    }
                }
                static deserialize(t) {
                    return new lo(t.buffer)
                }
            }
            const Ss = {};

            function Ii(i, t, a = {}) {
                if (Ss[i]) throw new Error(`${i} is already registered.`);
                Object.defineProperty(t, "_classRegistryKey", {
                    value: i,
                    writeable: !1
                }), Ss[i] = {
                    klass: t,
                    omit: a.omit || [],
                    shallow: a.shallow || []
                }
            }
            Ii("Object", Object), Ii("TransferableGridIndex", lo), Ii("Color", _n), Ii("Error", Error), Ii("AJAXError", oe), Ii("ResolvedImage", $r), Ii("StylePropertyFunction", so), Ii("StyleExpression", Cn, {
                omit: ["_evaluator"]
            }), Ii("ZoomDependentExpression", Lo), Ii("ZoomConstantExpression", bs), Ii("CompoundExpression", ti, {
                omit: ["_evaluate"]
            });
            for (const i in Ua) Ua[i]._classRegistryKey || Ii(`Expression_${i}`, Ua[i]);

            function Vc(i) {
                return i && typeof ArrayBuffer != "undefined" && (i instanceof ArrayBuffer || i.constructor && i.constructor.name === "ArrayBuffer")
            }

            function Uo(i, t) {
                if (i == null || typeof i == "boolean" || typeof i == "number" || typeof i == "string" || i instanceof Boolean || i instanceof Number || i instanceof String || i instanceof Date || i instanceof RegExp || i instanceof Blob || i instanceof Error) return i;
                if (Vc(i) || xe(i)) return t && t.push(i), i;
                if (ArrayBuffer.isView(i)) {
                    const a = i;
                    return t && t.push(a.buffer), a
                }
                if (i instanceof ImageData) return t && t.push(i.data.buffer), i;
                if (Array.isArray(i)) {
                    const a = [];
                    for (const l of i) a.push(Uo(l, t));
                    return a
                }
                if (typeof i == "object") {
                    const a = i.constructor,
                        l = a._classRegistryKey;
                    if (!l) throw new Error(`can't serialize object of unregistered class ${a.name}`);
                    if (!Ss[l]) throw new Error(`${l} is not registered.`);
                    const d = a.serialize ? a.serialize(i, t) : {};
                    if (a.serialize) {
                        if (t && d === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property")
                    } else {
                        for (const g in i) {
                            if (!i.hasOwnProperty(g) || Ss[l].omit.indexOf(g) >= 0) continue;
                            const x = i[g];
                            d[g] = Ss[l].shallow.indexOf(g) >= 0 ? x : Uo(x, t)
                        }
                        i instanceof Error && (d.message = i.message)
                    }
                    if (d.$name) throw new Error("$name property is reserved for worker serialization logic.");
                    return l !== "Object" && (d.$name = l), d
                }
                throw new Error("can't serialize object of type " + typeof i)
            }

            function vl(i) {
                if (i == null || typeof i == "boolean" || typeof i == "number" || typeof i == "string" || i instanceof Boolean || i instanceof Number || i instanceof String || i instanceof Date || i instanceof RegExp || i instanceof Blob || i instanceof Error || Vc(i) || xe(i) || ArrayBuffer.isView(i) || i instanceof ImageData) return i;
                if (Array.isArray(i)) return i.map(vl);
                if (typeof i == "object") {
                    const t = i.$name || "Object";
                    if (!Ss[t]) throw new Error(`can't deserialize unregistered class ${t}`);
                    const {
                        klass: a
                    } = Ss[t];
                    if (!a) throw new Error(`can't deserialize unregistered class ${t}`);
                    if (a.deserialize) return a.deserialize(i);
                    const l = Object.create(a.prototype);
                    for (const d of Object.keys(i)) {
                        if (d === "$name") continue;
                        const g = i[d];
                        l[d] = Ss[t].shallow.indexOf(d) >= 0 ? g : vl(g)
                    }
                    return l
                }
                throw new Error("can't deserialize object of type " + typeof i)
            }
            class Xl {
                constructor() {
                    this.first = !0
                }
                update(t, a) {
                    const l = Math.floor(t);
                    return this.first ? (this.first = !1, this.lastIntegerZoom = l, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = l, !0) : (this.lastFloorZoom > l ? (this.lastIntegerZoom = l + 1, this.lastIntegerZoomTime = a) : this.lastFloorZoom < l && (this.lastIntegerZoom = l, this.lastIntegerZoomTime = a), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = l, !0))
                }
            }
            const Ti = {
                "Latin-1 Supplement": i => i >= 128 && i <= 255,
                Arabic: i => i >= 1536 && i <= 1791,
                "Arabic Supplement": i => i >= 1872 && i <= 1919,
                "Arabic Extended-A": i => i >= 2208 && i <= 2303,
                "Hangul Jamo": i => i >= 4352 && i <= 4607,
                "Unified Canadian Aboriginal Syllabics": i => i >= 5120 && i <= 5759,
                Khmer: i => i >= 6016 && i <= 6143,
                "Unified Canadian Aboriginal Syllabics Extended": i => i >= 6320 && i <= 6399,
                "General Punctuation": i => i >= 8192 && i <= 8303,
                "Letterlike Symbols": i => i >= 8448 && i <= 8527,
                "Number Forms": i => i >= 8528 && i <= 8591,
                "Miscellaneous Technical": i => i >= 8960 && i <= 9215,
                "Control Pictures": i => i >= 9216 && i <= 9279,
                "Optical Character Recognition": i => i >= 9280 && i <= 9311,
                "Enclosed Alphanumerics": i => i >= 9312 && i <= 9471,
                "Geometric Shapes": i => i >= 9632 && i <= 9727,
                "Miscellaneous Symbols": i => i >= 9728 && i <= 9983,
                "Miscellaneous Symbols and Arrows": i => i >= 11008 && i <= 11263,
                "CJK Radicals Supplement": i => i >= 11904 && i <= 12031,
                "Kangxi Radicals": i => i >= 12032 && i <= 12255,
                "Ideographic Description Characters": i => i >= 12272 && i <= 12287,
                "CJK Symbols and Punctuation": i => i >= 12288 && i <= 12351,
                Hiragana: i => i >= 12352 && i <= 12447,
                Katakana: i => i >= 12448 && i <= 12543,
                Bopomofo: i => i >= 12544 && i <= 12591,
                "Hangul Compatibility Jamo": i => i >= 12592 && i <= 12687,
                Kanbun: i => i >= 12688 && i <= 12703,
                "Bopomofo Extended": i => i >= 12704 && i <= 12735,
                "CJK Strokes": i => i >= 12736 && i <= 12783,
                "Katakana Phonetic Extensions": i => i >= 12784 && i <= 12799,
                "Enclosed CJK Letters and Months": i => i >= 12800 && i <= 13055,
                "CJK Compatibility": i => i >= 13056 && i <= 13311,
                "CJK Unified Ideographs Extension A": i => i >= 13312 && i <= 19903,
                "Yijing Hexagram Symbols": i => i >= 19904 && i <= 19967,
                "CJK Unified Ideographs": i => i >= 19968 && i <= 40959,
                "Yi Syllables": i => i >= 40960 && i <= 42127,
                "Yi Radicals": i => i >= 42128 && i <= 42191,
                "Hangul Jamo Extended-A": i => i >= 43360 && i <= 43391,
                "Hangul Syllables": i => i >= 44032 && i <= 55215,
                "Hangul Jamo Extended-B": i => i >= 55216 && i <= 55295,
                "Private Use Area": i => i >= 57344 && i <= 63743,
                "CJK Compatibility Ideographs": i => i >= 63744 && i <= 64255,
                "Arabic Presentation Forms-A": i => i >= 64336 && i <= 65023,
                "Vertical Forms": i => i >= 65040 && i <= 65055,
                "CJK Compatibility Forms": i => i >= 65072 && i <= 65103,
                "Small Form Variants": i => i >= 65104 && i <= 65135,
                "Arabic Presentation Forms-B": i => i >= 65136 && i <= 65279,
                "Halfwidth and Fullwidth Forms": i => i >= 65280 && i <= 65519
            };

            function jl(i) {
                for (const t of i)
                    if (Yl(t.charCodeAt(0))) return !0;
                return !1
            }

            function Ih(i) {
                for (const t of i)
                    if (!zh(t.charCodeAt(0))) return !1;
                return !0
            }

            function zh(i) {
                return !(Ti.Arabic(i) || Ti["Arabic Supplement"](i) || Ti["Arabic Extended-A"](i) || Ti["Arabic Presentation Forms-A"](i) || Ti["Arabic Presentation Forms-B"](i))
            }

            function Yl(i) {
                return !(i !== 746 && i !== 747 && (i < 4352 || !(Ti["Bopomofo Extended"](i) || Ti.Bopomofo(i) || Ti["CJK Compatibility Forms"](i) && !(i >= 65097 && i <= 65103) || Ti["CJK Compatibility Ideographs"](i) || Ti["CJK Compatibility"](i) || Ti["CJK Radicals Supplement"](i) || Ti["CJK Strokes"](i) || !(!Ti["CJK Symbols and Punctuation"](i) || i >= 12296 && i <= 12305 || i >= 12308 && i <= 12319 || i === 12336) || Ti["CJK Unified Ideographs Extension A"](i) || Ti["CJK Unified Ideographs"](i) || Ti["Enclosed CJK Letters and Months"](i) || Ti["Hangul Compatibility Jamo"](i) || Ti["Hangul Jamo Extended-A"](i) || Ti["Hangul Jamo Extended-B"](i) || Ti["Hangul Jamo"](i) || Ti["Hangul Syllables"](i) || Ti.Hiragana(i) || Ti["Ideographic Description Characters"](i) || Ti.Kanbun(i) || Ti["Kangxi Radicals"](i) || Ti["Katakana Phonetic Extensions"](i) || Ti.Katakana(i) && i !== 12540 || !(!Ti["Halfwidth and Fullwidth Forms"](i) || i === 65288 || i === 65289 || i === 65293 || i >= 65306 && i <= 65310 || i === 65339 || i === 65341 || i === 65343 || i >= 65371 && i <= 65503 || i === 65507 || i >= 65512 && i <= 65519) || !(!Ti["Small Form Variants"](i) || i >= 65112 && i <= 65118 || i >= 65123 && i <= 65126) || Ti["Unified Canadian Aboriginal Syllabics"](i) || Ti["Unified Canadian Aboriginal Syllabics Extended"](i) || Ti["Vertical Forms"](i) || Ti["Yijing Hexagram Symbols"](i) || Ti["Yi Syllables"](i) || Ti["Yi Radicals"](i))))
            }

            function ql(i) {
                return !(Yl(i) || function(t) {
                    return !!(Ti["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || Ti["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || Ti["Letterlike Symbols"](t) || Ti["Number Forms"](t) || Ti["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || Ti["Control Pictures"](t) && t !== 9251 || Ti["Optical Character Recognition"](t) || Ti["Enclosed Alphanumerics"](t) || Ti["Geometric Shapes"](t) || Ti["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || Ti["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || Ti["CJK Symbols and Punctuation"](t) || Ti.Katakana(t) || Ti["Private Use Area"](t) || Ti["CJK Compatibility Forms"](t) || Ti["Small Form Variants"](t) || Ti["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533)
                }(i))
            }

            function Gc(i) {
                return i >= 1424 && i <= 2303 || Ti["Arabic Presentation Forms-A"](i) || Ti["Arabic Presentation Forms-B"](i)
            }

            function ku(i, t) {
                return !(!t && Gc(i) || i >= 2304 && i <= 3583 || i >= 3840 && i <= 4255 || Ti.Khmer(i))
            }

            function Nh(i) {
                for (const t of i)
                    if (Gc(t.charCodeAt(0))) return !0;
                return !1
            }
            const co = new class {
                constructor() {
                    this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null
                }
                setState(i) {
                    this.pluginStatus = i.pluginStatus, this.pluginURL = i.pluginURL
                }
                setMethods(i) {
                    this.applyArabicShaping = i.applyArabicShaping, this.processBidirectionalText = i.processBidirectionalText, this.processStyledBidirectionalText = i.processStyledBidirectionalText
                }
                isParsed() {
                    return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null
                }
                getPluginURL() {
                    return this.pluginURL
                }
                getRTLTextPluginStatus() {
                    return this.pluginStatus
                }
            };
            class cr {
                constructor(t, a) {
                    this.zoom = t, a ? (this.now = a.now, this.fadeDuration = a.fadeDuration, this.zoomHistory = a.zoomHistory, this.transition = a.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Xl, this.transition = {})
                }
                isSupportedScript(t) {
                    return function(a, l) {
                        for (const d of a)
                            if (!ku(d.charCodeAt(0), l)) return !1;
                        return !0
                    }(t, co.getRTLTextPluginStatus() === "loaded")
                }
                crossFadingFactor() {
                    return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1)
                }
                getCrossfadeParameters() {
                    const t = this.zoom,
                        a = t - Math.floor(t),
                        l = this.crossFadingFactor();
                    return t > this.zoomHistory.lastIntegerZoom ? {
                        fromScale: 2,
                        toScale: 1,
                        t: a + (1 - a) * l
                    } : {
                        fromScale: .5,
                        toScale: 1,
                        t: 1 - (1 - l) * a
                    }
                }
            }
            class _l {
                constructor(t, a) {
                    this.property = t, this.value = a, this.expression = function(l, d) {
                        if (Ro(l)) return new so(l, d);
                        if (Dn(l)) {
                            const g = ao(l, d);
                            if (g.result === "error") throw new Error(g.value.map(x => `${x.key}: ${x.message}`).join(", "));
                            return g.value
                        } {
                            let g = l;
                            return d.type === "color" && typeof l == "string" ? g = _n.parse(l) : d.type !== "padding" || typeof l != "number" && !Array.isArray(l) ? d.type === "variableAnchorOffsetCollection" && Array.isArray(l) && (g = ra.parse(l)) : g = Fr.parse(l), {
                                kind: "constant",
                                evaluate: () => g
                            }
                        }
                    }(a === void 0 ? t.specification.default : a, t.specification)
                }
                isDataDriven() {
                    return this.expression.kind === "source" || this.expression.kind === "composite"
                }
                possiblyEvaluate(t, a, l) {
                    return this.property.possiblyEvaluate(this, t, a, l)
                }
            }
            class $l {
                constructor(t) {
                    this.property = t, this.value = new _l(t, void 0)
                }
                transitioned(t, a) {
                    return new Vh(this.property, this.value, a, Kt({}, t.transition, this.transition), t.now)
                }
                untransitioned() {
                    return new Vh(this.property, this.value, null, {}, 0)
                }
            }
            class Oh {
                constructor(t) {
                    this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues)
                }
                getValue(t) {
                    return ct(this._values[t].value.value)
                }
                setValue(t, a) {
                    Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new $l(this._values[t].property)), this._values[t].value = new _l(this._values[t].property, a === null ? void 0 : ct(a))
                }
                getTransition(t) {
                    return ct(this._values[t].transition)
                }
                setTransition(t, a) {
                    Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new $l(this._values[t].property)), this._values[t].transition = ct(a) || void 0
                }
                serialize() {
                    const t = {};
                    for (const a of Object.keys(this._values)) {
                        const l = this.getValue(a);
                        l !== void 0 && (t[a] = l);
                        const d = this.getTransition(a);
                        d !== void 0 && (t[`${a}-transition`] = d)
                    }
                    return t
                }
                transitioned(t, a) {
                    const l = new Hc(this._properties);
                    for (const d of Object.keys(this._values)) l._values[d] = this._values[d].transitioned(t, a._values[d]);
                    return l
                }
                untransitioned() {
                    const t = new Hc(this._properties);
                    for (const a of Object.keys(this._values)) t._values[a] = this._values[a].untransitioned();
                    return t
                }
            }
            class Vh {
                constructor(t, a, l, d, g) {
                    this.property = t, this.value = a, this.begin = g + d.delay || 0, this.end = this.begin + d.duration || 0, t.specification.transition && (d.delay || d.duration) && (this.prior = l)
                }
                possiblyEvaluate(t, a, l) {
                    const d = t.now || 0,
                        g = this.value.possiblyEvaluate(t, a, l),
                        x = this.prior;
                    if (x) {
                        if (d > this.end) return this.prior = null, g;
                        if (this.value.isDataDriven()) return this.prior = null, g;
                        if (d < this.begin) return x.possiblyEvaluate(t, a, l);
                        {
                            const A = (d - this.begin) / (this.end - this.begin);
                            return this.property.interpolate(x.possiblyEvaluate(t, a, l), g, function(M) {
                                if (M <= 0) return 0;
                                if (M >= 1) return 1;
                                const F = M * M,
                                    D = F * M;
                                return 4 * (M < .5 ? D : 3 * (M - F) + D - .75)
                            }(A))
                        }
                    }
                    return g
                }
            }
            class Hc {
                constructor(t) {
                    this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues)
                }
                possiblyEvaluate(t, a, l) {
                    const d = new xl(this._properties);
                    for (const g of Object.keys(this._values)) d._values[g] = this._values[g].possiblyEvaluate(t, a, l);
                    return d
                }
                hasTransition() {
                    for (const t of Object.keys(this._values))
                        if (this._values[t].prior) return !0;
                    return !1
                }
            }
            class Gh {
                constructor(t) {
                    this._properties = t, this._values = Object.create(t.defaultPropertyValues)
                }
                hasValue(t) {
                    return this._values[t].value !== void 0
                }
                getValue(t) {
                    return ct(this._values[t].value)
                }
                setValue(t, a) {
                    this._values[t] = new _l(this._values[t].property, a === null ? void 0 : ct(a))
                }
                serialize() {
                    const t = {};
                    for (const a of Object.keys(this._values)) {
                        const l = this.getValue(a);
                        l !== void 0 && (t[a] = l)
                    }
                    return t
                }
                possiblyEvaluate(t, a, l) {
                    const d = new xl(this._properties);
                    for (const g of Object.keys(this._values)) d._values[g] = this._values[g].possiblyEvaluate(t, a, l);
                    return d
                }
            }
            class qa {
                constructor(t, a, l) {
                    this.property = t, this.value = a, this.parameters = l
                }
                isConstant() {
                    return this.value.kind === "constant"
                }
                constantOr(t) {
                    return this.value.kind === "constant" ? this.value.value : t
                }
                evaluate(t, a, l, d) {
                    return this.property.evaluate(this.value, this.parameters, t, a, l, d)
                }
            }
            class xl {
                constructor(t) {
                    this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues)
                }
                get(t) {
                    return this._values[t]
                }
            }
            class Ji {
                constructor(t) {
                    this.specification = t
                }
                possiblyEvaluate(t, a) {
                    if (t.isDataDriven()) throw new Error("Value should not be data driven");
                    return t.expression.evaluate(a)
                }
                interpolate(t, a, l) {
                    const d = en[this.specification.type];
                    return d ? d(t, a, l) : t
                }
            }
            class ln {
                constructor(t, a) {
                    this.specification = t, this.overrides = a
                }
                possiblyEvaluate(t, a, l, d) {
                    return new qa(this, t.expression.kind === "constant" || t.expression.kind === "camera" ? {
                        kind: "constant",
                        value: t.expression.evaluate(a, null, {}, l, d)
                    } : t.expression, a)
                }
                interpolate(t, a, l) {
                    if (t.value.kind !== "constant" || a.value.kind !== "constant") return t;
                    if (t.value.value === void 0 || a.value.value === void 0) return new qa(this, {
                        kind: "constant",
                        value: void 0
                    }, t.parameters);
                    const d = en[this.specification.type];
                    if (d) {
                        const g = d(t.value.value, a.value.value, l);
                        return new qa(this, {
                            kind: "constant",
                            value: g
                        }, t.parameters)
                    }
                    return t
                }
                evaluate(t, a, l, d, g, x) {
                    return t.kind === "constant" ? t.value : t.evaluate(a, l, d, g, x)
                }
            }
            class Io extends ln {
                possiblyEvaluate(t, a, l, d) {
                    if (t.value === void 0) return new qa(this, {
                        kind: "constant",
                        value: void 0
                    }, a);
                    if (t.expression.kind === "constant") {
                        const g = t.expression.evaluate(a, null, {}, l, d),
                            x = t.property.specification.type === "resolvedImage" && typeof g != "string" ? g.name : g,
                            A = this._calculate(x, x, x, a);
                        return new qa(this, {
                            kind: "constant",
                            value: A
                        }, a)
                    }
                    if (t.expression.kind === "camera") {
                        const g = this._calculate(t.expression.evaluate({
                            zoom: a.zoom - 1
                        }), t.expression.evaluate({
                            zoom: a.zoom
                        }), t.expression.evaluate({
                            zoom: a.zoom + 1
                        }), a);
                        return new qa(this, {
                            kind: "constant",
                            value: g
                        }, a)
                    }
                    return new qa(this, t.expression, a)
                }
                evaluate(t, a, l, d, g, x) {
                    if (t.kind === "source") {
                        const A = t.evaluate(a, l, d, g, x);
                        return this._calculate(A, A, A, a)
                    }
                    return t.kind === "composite" ? this._calculate(t.evaluate({
                        zoom: Math.floor(a.zoom) - 1
                    }, l, d), t.evaluate({
                        zoom: Math.floor(a.zoom)
                    }, l, d), t.evaluate({
                        zoom: Math.floor(a.zoom) + 1
                    }, l, d), a) : t.value
                }
                _calculate(t, a, l, d) {
                    return d.zoom > d.zoomHistory.lastIntegerZoom ? {
                        from: t,
                        to: a
                    } : {
                        from: l,
                        to: a
                    }
                }
                interpolate(t) {
                    return t
                }
            }
            class Kl {
                constructor(t) {
                    this.specification = t
                }
                possiblyEvaluate(t, a, l, d) {
                    if (t.value !== void 0) {
                        if (t.expression.kind === "constant") {
                            const g = t.expression.evaluate(a, null, {}, l, d);
                            return this._calculate(g, g, g, a)
                        }
                        return this._calculate(t.expression.evaluate(new cr(Math.floor(a.zoom - 1), a)), t.expression.evaluate(new cr(Math.floor(a.zoom), a)), t.expression.evaluate(new cr(Math.floor(a.zoom + 1), a)), a)
                    }
                }
                _calculate(t, a, l, d) {
                    return d.zoom > d.zoomHistory.lastIntegerZoom ? {
                        from: t,
                        to: a
                    } : {
                        from: l,
                        to: a
                    }
                }
                interpolate(t) {
                    return t
                }
            }
            class ec {
                constructor(t) {
                    this.specification = t
                }
                possiblyEvaluate(t, a, l, d) {
                    return !!t.expression.evaluate(a, null, {}, l, d)
                }
                interpolate() {
                    return !1
                }
            }
            class ua {
                constructor(t) {
                    this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
                    for (const a in t) {
                        const l = t[a];
                        l.specification.overridable && this.overridableProperties.push(a);
                        const d = this.defaultPropertyValues[a] = new _l(l, void 0),
                            g = this.defaultTransitionablePropertyValues[a] = new $l(l);
                        this.defaultTransitioningPropertyValues[a] = g.untransitioned(), this.defaultPossiblyEvaluatedValues[a] = d.possiblyEvaluate({})
                    }
                }
            }
            Ii("DataDrivenProperty", ln), Ii("DataConstantProperty", Ji), Ii("CrossFadedDataDrivenProperty", Io), Ii("CrossFadedProperty", Kl), Ii("ColorRampProperty", ec);
            const tc = "-transition";
            class $a extends Bt {
                constructor(t, a) {
                    if (super(), this.id = t.id, this.type = t.type, this._featureFilter = {
                            filter: () => !0,
                            needGeometry: !1
                        }, t.type !== "custom" && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, t.type !== "background" && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter), a.layout && (this._unevaluatedLayout = new Gh(a.layout)), a.paint)) {
                        this._transitionablePaint = new Oh(a.paint);
                        for (const l in t.paint) this.setPaintProperty(l, t.paint[l], {
                            validate: !1
                        });
                        for (const l in t.layout) this.setLayoutProperty(l, t.layout[l], {
                            validate: !1
                        });
                        this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new xl(a.paint)
                    }
                }
                getCrossfadeParameters() {
                    return this._crossfadeParameters
                }
                getLayoutProperty(t) {
                    return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t)
                }
                setLayoutProperty(t, a, l = {}) {
                    a != null && this._validate(yl, `layers.${this.id}.layout.${t}`, t, a, l) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, a) : this.visibility = a)
                }
                getPaintProperty(t) {
                    return t.endsWith(tc) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t)
                }
                setPaintProperty(t, a, l = {}) {
                    if (a != null && this._validate(Pu, `layers.${this.id}.paint.${t}`, t, a, l)) return !1;
                    if (t.endsWith(tc)) return this._transitionablePaint.setTransition(t.slice(0, -11), a || void 0), !1;
                    {
                        const d = this._transitionablePaint._values[t],
                            g = d.property.specification["property-type"] === "cross-faded-data-driven",
                            x = d.value.isDataDriven(),
                            A = d.value;
                        this._transitionablePaint.setValue(t, a), this._handleSpecialPaintPropertyUpdate(t);
                        const M = this._transitionablePaint._values[t].value;
                        return M.isDataDriven() || x || g || this._handleOverridablePaintPropertyUpdate(t, A, M)
                    }
                }
                _handleSpecialPaintPropertyUpdate(t) {}
                _handleOverridablePaintPropertyUpdate(t, a, l) {
                    return !1
                }
                isHidden(t) {
                    return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none"
                }
                updateTransitions(t) {
                    this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint)
                }
                hasTransition() {
                    return this._transitioningPaint.hasTransition()
                }
                recalculate(t, a) {
                    t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, a)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, a)
                }
                serialize() {
                    const t = {
                        id: this.id,
                        type: this.type,
                        source: this.source,
                        "source-layer": this.sourceLayer,
                        metadata: this.metadata,
                        minzoom: this.minzoom,
                        maxzoom: this.maxzoom,
                        filter: this.filter,
                        layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
                        paint: this._transitionablePaint && this._transitionablePaint.serialize()
                    };
                    return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), Ei(t, (a, l) => !(a === void 0 || l === "layout" && !Object.keys(a).length || l === "paint" && !Object.keys(a).length))
                }
                _validate(t, a, l, d, g = {}) {
                    return (!g || g.validate !== !1) && Uh(this, t.call(gl, {
                        key: a,
                        layerType: this.type,
                        objectKey: l,
                        value: d,
                        styleSpec: Le,
                        style: {
                            glyphs: !0,
                            sprite: !0
                        }
                    }))
                }
                is3D() {
                    return !1
                }
                isTileClipped() {
                    return !1
                }
                hasOffscreenPass() {
                    return !1
                }
                resize() {}
                isStateDependent() {
                    for (const t in this.paint._values) {
                        const a = this.paint.get(t);
                        if (a instanceof qa && xs(a.property.specification) && (a.value.kind === "source" || a.value.kind === "composite") && a.value.isStateDependent) return !0
                    }
                    return !1
                }
            }
            const Vs = {
                Int8: Int8Array,
                Uint8: Uint8Array,
                Int16: Int16Array,
                Uint16: Uint16Array,
                Int32: Int32Array,
                Uint32: Uint32Array,
                Float32: Float32Array
            };
            class zo {
                constructor(t, a) {
                    this._structArray = t, this._pos1 = a * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8
                }
            }
            class Ar {
                constructor() {
                    this.isTransferred = !1, this.capacity = -1, this.resize(0)
                }
                static serialize(t, a) {
                    return t._trim(), a && (t.isTransferred = !0, a.push(t.arrayBuffer)), {
                        length: t.length,
                        arrayBuffer: t.arrayBuffer
                    }
                }
                static deserialize(t) {
                    const a = Object.create(this.prototype);
                    return a.arrayBuffer = t.arrayBuffer, a.length = t.length, a.capacity = t.arrayBuffer.byteLength / a.bytesPerElement, a._refreshViews(), a
                }
                _trim() {
                    this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews())
                }
                clear() {
                    this.length = 0
                }
                resize(t) {
                    this.reserve(t), this.length = t
                }
                reserve(t) {
                    if (t > this.capacity) {
                        this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                        const a = this.uint8;
                        this._refreshViews(), a && this.uint8.set(a)
                    }
                }
                _refreshViews() {
                    throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")
                }
            }

            function kr(i, t = 1) {
                let a = 0,
                    l = 0;
                return {
                    members: i.map(d => {
                        const g = Vs[d.type].BYTES_PER_ELEMENT,
                            x = a = Wc(a, Math.max(t, g)),
                            A = d.components || 1;
                        return l = Math.max(l, g), a += g * A, {
                            name: d.name,
                            type: d.type,
                            components: A,
                            offset: x
                        }
                    }),
                    size: Wc(a, Math.max(l, t)),
                    alignment: t
                }
            }

            function Wc(i, t) {
                return Math.ceil(i / t) * t
            }
            class La extends Ar {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
                }
                emplaceBack(t, a) {
                    const l = this.length;
                    return this.resize(l + 1), this.emplace(l, t, a)
                }
                emplace(t, a, l) {
                    const d = 2 * t;
                    return this.int16[d + 0] = a, this.int16[d + 1] = l, t
                }
            }
            La.prototype.bytesPerElement = 4, Ii("StructArrayLayout2i4", La);
            class ic extends Ar {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
                }
                emplaceBack(t, a, l) {
                    const d = this.length;
                    return this.resize(d + 1), this.emplace(d, t, a, l)
                }
                emplace(t, a, l, d) {
                    const g = 3 * t;
                    return this.int16[g + 0] = a, this.int16[g + 1] = l, this.int16[g + 2] = d, t
                }
            }
            ic.prototype.bytesPerElement = 6, Ii("StructArrayLayout3i6", ic);
            class Jc extends Ar {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
                }
                emplaceBack(t, a, l, d) {
                    const g = this.length;
                    return this.resize(g + 1), this.emplace(g, t, a, l, d)
                }
                emplace(t, a, l, d, g) {
                    const x = 4 * t;
                    return this.int16[x + 0] = a, this.int16[x + 1] = l, this.int16[x + 2] = d, this.int16[x + 3] = g, t
                }
            }
            Jc.prototype.bytesPerElement = 8, Ii("StructArrayLayout4i8", Jc);
            class ho extends Ar {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
                }
                emplaceBack(t, a, l, d, g, x) {
                    const A = this.length;
                    return this.resize(A + 1), this.emplace(A, t, a, l, d, g, x)
                }
                emplace(t, a, l, d, g, x, A) {
                    const M = 6 * t;
                    return this.int16[M + 0] = a, this.int16[M + 1] = l, this.int16[M + 2] = d, this.int16[M + 3] = g, this.int16[M + 4] = x, this.int16[M + 5] = A, t
                }
            }
            ho.prototype.bytesPerElement = 12, Ii("StructArrayLayout2i4i12", ho);
            class nc extends Ar {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
                }
                emplaceBack(t, a, l, d, g, x) {
                    const A = this.length;
                    return this.resize(A + 1), this.emplace(A, t, a, l, d, g, x)
                }
                emplace(t, a, l, d, g, x, A) {
                    const M = 4 * t,
                        F = 8 * t;
                    return this.int16[M + 0] = a, this.int16[M + 1] = l, this.uint8[F + 4] = d, this.uint8[F + 5] = g, this.uint8[F + 6] = x, this.uint8[F + 7] = A, t
                }
            }
            nc.prototype.bytesPerElement = 8, Ii("StructArrayLayout2i4ub8", nc);
            class uo extends Ar {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }
                emplaceBack(t, a) {
                    const l = this.length;
                    return this.resize(l + 1), this.emplace(l, t, a)
                }
                emplace(t, a, l) {
                    const d = 2 * t;
                    return this.float32[d + 0] = a, this.float32[d + 1] = l, t
                }
            }
            uo.prototype.bytesPerElement = 8, Ii("StructArrayLayout2f8", uo);
            class Zc extends Ar {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
                }
                emplaceBack(t, a, l, d, g, x, A, M, F, D) {
                    const U = this.length;
                    return this.resize(U + 1), this.emplace(U, t, a, l, d, g, x, A, M, F, D)
                }
                emplace(t, a, l, d, g, x, A, M, F, D, U) {
                    const N = 10 * t;
                    return this.uint16[N + 0] = a, this.uint16[N + 1] = l, this.uint16[N + 2] = d, this.uint16[N + 3] = g, this.uint16[N + 4] = x, this.uint16[N + 5] = A, this.uint16[N + 6] = M, this.uint16[N + 7] = F, this.uint16[N + 8] = D, this.uint16[N + 9] = U, t
                }
            }
            Zc.prototype.bytesPerElement = 20, Ii("StructArrayLayout10ui20", Zc);
            class bl extends Ar {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
                }
                emplaceBack(t, a, l, d, g, x, A, M, F, D, U, N) {
                    const H = this.length;
                    return this.resize(H + 1), this.emplace(H, t, a, l, d, g, x, A, M, F, D, U, N)
                }
                emplace(t, a, l, d, g, x, A, M, F, D, U, N, H) {
                    const X = 12 * t;
                    return this.int16[X + 0] = a, this.int16[X + 1] = l, this.int16[X + 2] = d, this.int16[X + 3] = g, this.uint16[X + 4] = x, this.uint16[X + 5] = A, this.uint16[X + 6] = M, this.uint16[X + 7] = F, this.int16[X + 8] = D, this.int16[X + 9] = U, this.int16[X + 10] = N, this.int16[X + 11] = H, t
                }
            }
            bl.prototype.bytesPerElement = 24, Ii("StructArrayLayout4i4ui4i24", bl);
            class As extends Ar {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }
                emplaceBack(t, a, l) {
                    const d = this.length;
                    return this.resize(d + 1), this.emplace(d, t, a, l)
                }
                emplace(t, a, l, d) {
                    const g = 3 * t;
                    return this.float32[g + 0] = a, this.float32[g + 1] = l, this.float32[g + 2] = d, t
                }
            }
            As.prototype.bytesPerElement = 12, Ii("StructArrayLayout3f12", As);
            class rc extends Ar {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer)
                }
                emplaceBack(t) {
                    const a = this.length;
                    return this.resize(a + 1), this.emplace(a, t)
                }
                emplace(t, a) {
                    return this.uint32[1 * t + 0] = a, t
                }
            }
            rc.prototype.bytesPerElement = 4, Ii("StructArrayLayout1ul4", rc);
            class wl extends Ar {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
                }
                emplaceBack(t, a, l, d, g, x, A, M, F) {
                    const D = this.length;
                    return this.resize(D + 1), this.emplace(D, t, a, l, d, g, x, A, M, F)
                }
                emplace(t, a, l, d, g, x, A, M, F, D) {
                    const U = 10 * t,
                        N = 5 * t;
                    return this.int16[U + 0] = a, this.int16[U + 1] = l, this.int16[U + 2] = d, this.int16[U + 3] = g, this.int16[U + 4] = x, this.int16[U + 5] = A, this.uint32[N + 3] = M, this.uint16[U + 8] = F, this.uint16[U + 9] = D, t
                }
            }
            wl.prototype.bytesPerElement = 20, Ii("StructArrayLayout6i1ul2ui20", wl);
            class El extends Ar {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
                }
                emplaceBack(t, a, l, d, g, x) {
                    const A = this.length;
                    return this.resize(A + 1), this.emplace(A, t, a, l, d, g, x)
                }
                emplace(t, a, l, d, g, x, A) {
                    const M = 6 * t;
                    return this.int16[M + 0] = a, this.int16[M + 1] = l, this.int16[M + 2] = d, this.int16[M + 3] = g, this.int16[M + 4] = x, this.int16[M + 5] = A, t
                }
            }
            El.prototype.bytesPerElement = 12, Ii("StructArrayLayout2i2i2i12", El);
            class Sl extends Ar {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
                }
                emplaceBack(t, a, l, d, g) {
                    const x = this.length;
                    return this.resize(x + 1), this.emplace(x, t, a, l, d, g)
                }
                emplace(t, a, l, d, g, x) {
                    const A = 4 * t,
                        M = 8 * t;
                    return this.float32[A + 0] = a, this.float32[A + 1] = l, this.float32[A + 2] = d, this.int16[M + 6] = g, this.int16[M + 7] = x, t
                }
            }
            Sl.prototype.bytesPerElement = 16, Ii("StructArrayLayout2f1f2i16", Sl);
            class ac extends Ar {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }
                emplaceBack(t, a, l, d) {
                    const g = this.length;
                    return this.resize(g + 1), this.emplace(g, t, a, l, d)
                }
                emplace(t, a, l, d, g) {
                    const x = 12 * t,
                        A = 3 * t;
                    return this.uint8[x + 0] = a, this.uint8[x + 1] = l, this.float32[A + 1] = d, this.float32[A + 2] = g, t
                }
            }
            ac.prototype.bytesPerElement = 12, Ii("StructArrayLayout2ub2f12", ac);
            class Gs extends Ar {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
                }
                emplaceBack(t, a, l) {
                    const d = this.length;
                    return this.resize(d + 1), this.emplace(d, t, a, l)
                }
                emplace(t, a, l, d) {
                    const g = 3 * t;
                    return this.uint16[g + 0] = a, this.uint16[g + 1] = l, this.uint16[g + 2] = d, t
                }
            }
            Gs.prototype.bytesPerElement = 6, Ii("StructArrayLayout3ui6", Gs);
            class po extends Ar {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }
                emplaceBack(t, a, l, d, g, x, A, M, F, D, U, N, H, X, ne, le, ce) {
                    const Qe = this.length;
                    return this.resize(Qe + 1), this.emplace(Qe, t, a, l, d, g, x, A, M, F, D, U, N, H, X, ne, le, ce)
                }
                emplace(t, a, l, d, g, x, A, M, F, D, U, N, H, X, ne, le, ce, Qe) {
                    const Se = 24 * t,
                        Re = 12 * t,
                        ot = 48 * t;
                    return this.int16[Se + 0] = a, this.int16[Se + 1] = l, this.uint16[Se + 2] = d, this.uint16[Se + 3] = g, this.uint32[Re + 2] = x, this.uint32[Re + 3] = A, this.uint32[Re + 4] = M, this.uint16[Se + 10] = F, this.uint16[Se + 11] = D, this.uint16[Se + 12] = U, this.float32[Re + 7] = N, this.float32[Re + 8] = H, this.uint8[ot + 36] = X, this.uint8[ot + 37] = ne, this.uint8[ot + 38] = le, this.uint32[Re + 10] = ce, this.int16[Se + 22] = Qe, t
                }
            }
            po.prototype.bytesPerElement = 48, Ii("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", po);
            class Xc extends Ar {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }
                emplaceBack(t, a, l, d, g, x, A, M, F, D, U, N, H, X, ne, le, ce, Qe, Se, Re, ot, dt, Ct, Nt, qt, Fe, Be, mt) {
                    const lt = this.length;
                    return this.resize(lt + 1), this.emplace(lt, t, a, l, d, g, x, A, M, F, D, U, N, H, X, ne, le, ce, Qe, Se, Re, ot, dt, Ct, Nt, qt, Fe, Be, mt)
                }
                emplace(t, a, l, d, g, x, A, M, F, D, U, N, H, X, ne, le, ce, Qe, Se, Re, ot, dt, Ct, Nt, qt, Fe, Be, mt, lt) {
                    const Xe = 32 * t,
                        Zt = 16 * t;
                    return this.int16[Xe + 0] = a, this.int16[Xe + 1] = l, this.int16[Xe + 2] = d, this.int16[Xe + 3] = g, this.int16[Xe + 4] = x, this.int16[Xe + 5] = A, this.int16[Xe + 6] = M, this.int16[Xe + 7] = F, this.uint16[Xe + 8] = D, this.uint16[Xe + 9] = U, this.uint16[Xe + 10] = N, this.uint16[Xe + 11] = H, this.uint16[Xe + 12] = X, this.uint16[Xe + 13] = ne, this.uint16[Xe + 14] = le, this.uint16[Xe + 15] = ce, this.uint16[Xe + 16] = Qe, this.uint16[Xe + 17] = Se, this.uint16[Xe + 18] = Re, this.uint16[Xe + 19] = ot, this.uint16[Xe + 20] = dt, this.uint16[Xe + 21] = Ct, this.uint16[Xe + 22] = Nt, this.uint32[Zt + 12] = qt, this.float32[Zt + 13] = Fe, this.float32[Zt + 14] = Be, this.uint16[Xe + 30] = mt, this.uint16[Xe + 31] = lt, t
                }
            }
            Xc.prototype.bytesPerElement = 64, Ii("StructArrayLayout8i15ui1ul2f2ui64", Xc);
            class Al extends Ar {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }
                emplaceBack(t) {
                    const a = this.length;
                    return this.resize(a + 1), this.emplace(a, t)
                }
                emplace(t, a) {
                    return this.float32[1 * t + 0] = a, t
                }
            }
            Al.prototype.bytesPerElement = 4, Ii("StructArrayLayout1f4", Al);
            class fo extends Ar {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }
                emplaceBack(t, a, l) {
                    const d = this.length;
                    return this.resize(d + 1), this.emplace(d, t, a, l)
                }
                emplace(t, a, l, d) {
                    const g = 3 * t;
                    return this.uint16[6 * t + 0] = a, this.float32[g + 1] = l, this.float32[g + 2] = d, t
                }
            }
            fo.prototype.bytesPerElement = 12, Ii("StructArrayLayout1ui2f12", fo);
            class jc extends Ar {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
                }
                emplaceBack(t, a, l) {
                    const d = this.length;
                    return this.resize(d + 1), this.emplace(d, t, a, l)
                }
                emplace(t, a, l, d) {
                    const g = 4 * t;
                    return this.uint32[2 * t + 0] = a, this.uint16[g + 2] = l, this.uint16[g + 3] = d, t
                }
            }
            jc.prototype.bytesPerElement = 8, Ii("StructArrayLayout1ul2ui8", jc);
            class sc extends Ar {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
                }
                emplaceBack(t, a) {
                    const l = this.length;
                    return this.resize(l + 1), this.emplace(l, t, a)
                }
                emplace(t, a, l) {
                    const d = 2 * t;
                    return this.uint16[d + 0] = a, this.uint16[d + 1] = l, t
                }
            }
            sc.prototype.bytesPerElement = 4, Ii("StructArrayLayout2ui4", sc);
            class oc extends Ar {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
                }
                emplaceBack(t) {
                    const a = this.length;
                    return this.resize(a + 1), this.emplace(a, t)
                }
                emplace(t, a) {
                    return this.uint16[1 * t + 0] = a, t
                }
            }
            oc.prototype.bytesPerElement = 2, Ii("StructArrayLayout1ui2", oc);
            class Yc extends Ar {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }
                emplaceBack(t, a, l, d) {
                    const g = this.length;
                    return this.resize(g + 1), this.emplace(g, t, a, l, d)
                }
                emplace(t, a, l, d, g) {
                    const x = 4 * t;
                    return this.float32[x + 0] = a, this.float32[x + 1] = l, this.float32[x + 2] = d, this.float32[x + 3] = g, t
                }
            }
            Yc.prototype.bytesPerElement = 16, Ii("StructArrayLayout4f16", Yc);
            class b extends zo {
                get anchorPointX() {
                    return this._structArray.int16[this._pos2 + 0]
                }
                get anchorPointY() {
                    return this._structArray.int16[this._pos2 + 1]
                }
                get x1() {
                    return this._structArray.int16[this._pos2 + 2]
                }
                get y1() {
                    return this._structArray.int16[this._pos2 + 3]
                }
                get x2() {
                    return this._structArray.int16[this._pos2 + 4]
                }
                get y2() {
                    return this._structArray.int16[this._pos2 + 5]
                }
                get featureIndex() {
                    return this._structArray.uint32[this._pos4 + 3]
                }
                get sourceLayerIndex() {
                    return this._structArray.uint16[this._pos2 + 8]
                }
                get bucketIndex() {
                    return this._structArray.uint16[this._pos2 + 9]
                }
                get anchorPoint() {
                    return new be(this.anchorPointX, this.anchorPointY)
                }
            }
            b.prototype.size = 20;
            class n extends wl {
                get(t) {
                    return new b(this, t)
                }
            }
            Ii("CollisionBoxArray", n);
            class u extends zo {
                get anchorX() {
                    return this._structArray.int16[this._pos2 + 0]
                }
                get anchorY() {
                    return this._structArray.int16[this._pos2 + 1]
                }
                get glyphStartIndex() {
                    return this._structArray.uint16[this._pos2 + 2]
                }
                get numGlyphs() {
                    return this._structArray.uint16[this._pos2 + 3]
                }
                get vertexStartIndex() {
                    return this._structArray.uint32[this._pos4 + 2]
                }
                get lineStartIndex() {
                    return this._structArray.uint32[this._pos4 + 3]
                }
                get lineLength() {
                    return this._structArray.uint32[this._pos4 + 4]
                }
                get segment() {
                    return this._structArray.uint16[this._pos2 + 10]
                }
                get lowerSize() {
                    return this._structArray.uint16[this._pos2 + 11]
                }
                get upperSize() {
                    return this._structArray.uint16[this._pos2 + 12]
                }
                get lineOffsetX() {
                    return this._structArray.float32[this._pos4 + 7]
                }
                get lineOffsetY() {
                    return this._structArray.float32[this._pos4 + 8]
                }
                get writingMode() {
                    return this._structArray.uint8[this._pos1 + 36]
                }
                get placedOrientation() {
                    return this._structArray.uint8[this._pos1 + 37]
                }
                set placedOrientation(t) {
                    this._structArray.uint8[this._pos1 + 37] = t
                }
                get hidden() {
                    return this._structArray.uint8[this._pos1 + 38]
                }
                set hidden(t) {
                    this._structArray.uint8[this._pos1 + 38] = t
                }
                get crossTileID() {
                    return this._structArray.uint32[this._pos4 + 10]
                }
                set crossTileID(t) {
                    this._structArray.uint32[this._pos4 + 10] = t
                }
                get associatedIconIndex() {
                    return this._structArray.int16[this._pos2 + 22]
                }
            }
            u.prototype.size = 48;
            class f extends po {
                get(t) {
                    return new u(this, t)
                }
            }
            Ii("PlacedSymbolArray", f);
            class _ extends zo {
                get anchorX() {
                    return this._structArray.int16[this._pos2 + 0]
                }
                get anchorY() {
                    return this._structArray.int16[this._pos2 + 1]
                }
                get rightJustifiedTextSymbolIndex() {
                    return this._structArray.int16[this._pos2 + 2]
                }
                get centerJustifiedTextSymbolIndex() {
                    return this._structArray.int16[this._pos2 + 3]
                }
                get leftJustifiedTextSymbolIndex() {
                    return this._structArray.int16[this._pos2 + 4]
                }
                get verticalPlacedTextSymbolIndex() {
                    return this._structArray.int16[this._pos2 + 5]
                }
                get placedIconSymbolIndex() {
                    return this._structArray.int16[this._pos2 + 6]
                }
                get verticalPlacedIconSymbolIndex() {
                    return this._structArray.int16[this._pos2 + 7]
                }
                get key() {
                    return this._structArray.uint16[this._pos2 + 8]
                }
                get textBoxStartIndex() {
                    return this._structArray.uint16[this._pos2 + 9]
                }
                get textBoxEndIndex() {
                    return this._structArray.uint16[this._pos2 + 10]
                }
                get verticalTextBoxStartIndex() {
                    return this._structArray.uint16[this._pos2 + 11]
                }
                get verticalTextBoxEndIndex() {
                    return this._structArray.uint16[this._pos2 + 12]
                }
                get iconBoxStartIndex() {
                    return this._structArray.uint16[this._pos2 + 13]
                }
                get iconBoxEndIndex() {
                    return this._structArray.uint16[this._pos2 + 14]
                }
                get verticalIconBoxStartIndex() {
                    return this._structArray.uint16[this._pos2 + 15]
                }
                get verticalIconBoxEndIndex() {
                    return this._structArray.uint16[this._pos2 + 16]
                }
                get featureIndex() {
                    return this._structArray.uint16[this._pos2 + 17]
                }
                get numHorizontalGlyphVertices() {
                    return this._structArray.uint16[this._pos2 + 18]
                }
                get numVerticalGlyphVertices() {
                    return this._structArray.uint16[this._pos2 + 19]
                }
                get numIconVertices() {
                    return this._structArray.uint16[this._pos2 + 20]
                }
                get numVerticalIconVertices() {
                    return this._structArray.uint16[this._pos2 + 21]
                }
                get useRuntimeCollisionCircles() {
                    return this._structArray.uint16[this._pos2 + 22]
                }
                get crossTileID() {
                    return this._structArray.uint32[this._pos4 + 12]
                }
                set crossTileID(t) {
                    this._structArray.uint32[this._pos4 + 12] = t
                }
                get textBoxScale() {
                    return this._structArray.float32[this._pos4 + 13]
                }
                get collisionCircleDiameter() {
                    return this._structArray.float32[this._pos4 + 14]
                }
                get textAnchorOffsetStartIndex() {
                    return this._structArray.uint16[this._pos2 + 30]
                }
                get textAnchorOffsetEndIndex() {
                    return this._structArray.uint16[this._pos2 + 31]
                }
            }
            _.prototype.size = 64;
            class S extends Xc {
                get(t) {
                    return new _(this, t)
                }
            }
            Ii("SymbolInstanceArray", S);
            class L extends Al {
                getoffsetX(t) {
                    return this.float32[1 * t + 0]
                }
            }
            Ii("GlyphOffsetArray", L);
            class P extends ic {
                getx(t) {
                    return this.int16[3 * t + 0]
                }
                gety(t) {
                    return this.int16[3 * t + 1]
                }
                gettileUnitDistanceFromAnchor(t) {
                    return this.int16[3 * t + 2]
                }
            }
            Ii("SymbolLineVertexArray", P);
            class I extends zo {
                get textAnchor() {
                    return this._structArray.uint16[this._pos2 + 0]
                }
                get textOffset0() {
                    return this._structArray.float32[this._pos4 + 1]
                }
                get textOffset1() {
                    return this._structArray.float32[this._pos4 + 2]
                }
            }
            I.prototype.size = 12;
            class G extends fo {
                get(t) {
                    return new I(this, t)
                }
            }
            Ii("TextAnchorOffsetArray", G);
            class j extends zo {
                get featureIndex() {
                    return this._structArray.uint32[this._pos4 + 0]
                }
                get sourceLayerIndex() {
                    return this._structArray.uint16[this._pos2 + 2]
                }
                get bucketIndex() {
                    return this._structArray.uint16[this._pos2 + 3]
                }
            }
            j.prototype.size = 8;
            class ee extends jc {
                get(t) {
                    return new j(this, t)
                }
            }
            Ii("FeatureIndexArray", ee);
            class pe extends La {}
            class Ce extends La {}
            class Me extends La {}
            class ke extends ho {}
            class we extends nc {}
            class nt extends uo {}
            class bt extends Zc {}
            class ze extends bl {}
            class ut extends As {}
            class St extends rc {}
            class yt extends El {}
            class Vt extends ac {}
            class ci extends Gs {}
            class $t extends sc {}
            const gi = kr([{
                    name: "a_pos",
                    components: 2,
                    type: "Int16"
                }], 4),
                {
                    members: Ri
                } = gi;
            class Ki {
                constructor(t = []) {
                    this.segments = t
                }
                prepareSegment(t, a, l, d) {
                    let g = this.segments[this.segments.length - 1];
                    return t > Ki.MAX_VERTEX_ARRAY_LENGTH && li(`Max vertices per segment is ${Ki.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}`), (!g || g.vertexLength + t > Ki.MAX_VERTEX_ARRAY_LENGTH || g.sortKey !== d) && (g = {
                        vertexOffset: a.length,
                        primitiveOffset: l.length,
                        vertexLength: 0,
                        primitiveLength: 0
                    }, d !== void 0 && (g.sortKey = d), this.segments.push(g)), g
                }
                get() {
                    return this.segments
                }
                destroy() {
                    for (const t of this.segments)
                        for (const a in t.vaos) t.vaos[a].destroy()
                }
                static simpleSegment(t, a, l, d) {
                    return new Ki([{
                        vertexOffset: t,
                        primitiveOffset: a,
                        vertexLength: l,
                        primitiveLength: d,
                        vaos: {},
                        sortKey: 0
                    }])
                }
            }

            function wi(i, t) {
                return 256 * (i = $e(Math.floor(i), 0, 255)) + $e(Math.floor(t), 0, 255)
            }
            Ki.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Ii("SegmentVector", Ki);
            const $i = kr([{
                name: "a_pattern_from",
                components: 4,
                type: "Uint16"
            }, {
                name: "a_pattern_to",
                components: 4,
                type: "Uint16"
            }, {
                name: "a_pixel_ratio_from",
                components: 1,
                type: "Uint16"
            }, {
                name: "a_pixel_ratio_to",
                components: 1,
                type: "Uint16"
            }]);
            var Vi = {
                    exports: {}
                },
                Jn = {
                    exports: {}
                };
            Jn.exports = function(i, t) {
                var a, l, d, g, x, A, M, F;
                for (l = i.length - (a = 3 & i.length), d = t, x = 3432918353, A = 461845907, F = 0; F < l;) M = 255 & i.charCodeAt(F) | (255 & i.charCodeAt(++F)) << 8 | (255 & i.charCodeAt(++F)) << 16 | (255 & i.charCodeAt(++F)) << 24, ++F, d = 27492 + (65535 & (g = 5 * (65535 & (d = (d ^= M = (65535 & (M = (M = (65535 & M) * x + (((M >>> 16) * x & 65535) << 16) & 4294967295) << 15 | M >>> 17)) * A + (((M >>> 16) * A & 65535) << 16) & 4294967295) << 13 | d >>> 19)) + ((5 * (d >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (g >>> 16) & 65535) << 16);
                switch (M = 0, a) {
                    case 3:
                        M ^= (255 & i.charCodeAt(F + 2)) << 16;
                    case 2:
                        M ^= (255 & i.charCodeAt(F + 1)) << 8;
                    case 1:
                        d ^= M = (65535 & (M = (M = (65535 & (M ^= 255 & i.charCodeAt(F))) * x + (((M >>> 16) * x & 65535) << 16) & 4294967295) << 15 | M >>> 17)) * A + (((M >>> 16) * A & 65535) << 16) & 4294967295
                }
                return d ^= i.length, d = 2246822507 * (65535 & (d ^= d >>> 16)) + ((2246822507 * (d >>> 16) & 65535) << 16) & 4294967295, d = 3266489909 * (65535 & (d ^= d >>> 13)) + ((3266489909 * (d >>> 16) & 65535) << 16) & 4294967295, (d ^= d >>> 16) >>> 0
            };
            var xn = Jn.exports,
                mn = {
                    exports: {}
                };
            mn.exports = function(i, t) {
                for (var a, l = i.length, d = t ^ l, g = 0; l >= 4;) a = 1540483477 * (65535 & (a = 255 & i.charCodeAt(g) | (255 & i.charCodeAt(++g)) << 8 | (255 & i.charCodeAt(++g)) << 16 | (255 & i.charCodeAt(++g)) << 24)) + ((1540483477 * (a >>> 16) & 65535) << 16), d = 1540483477 * (65535 & d) + ((1540483477 * (d >>> 16) & 65535) << 16) ^ (a = 1540483477 * (65535 & (a ^= a >>> 24)) + ((1540483477 * (a >>> 16) & 65535) << 16)), l -= 4, ++g;
                switch (l) {
                    case 3:
                        d ^= (255 & i.charCodeAt(g + 2)) << 16;
                    case 2:
                        d ^= (255 & i.charCodeAt(g + 1)) << 8;
                    case 1:
                        d = 1540483477 * (65535 & (d ^= 255 & i.charCodeAt(g))) + ((1540483477 * (d >>> 16) & 65535) << 16)
                }
                return d = 1540483477 * (65535 & (d ^= d >>> 13)) + ((1540483477 * (d >>> 16) & 65535) << 16), (d ^= d >>> 15) >>> 0
            };
            var wn = xn,
                Tr = mn.exports;
            Vi.exports = wn, Vi.exports.murmur3 = wn, Vi.exports.murmur2 = Tr;
            var Hn = se(Vi.exports);
            class sa {
                constructor() {
                    this.ids = [], this.positions = [], this.indexed = !1
                }
                add(t, a, l, d) {
                    this.ids.push(Gr(t)), this.positions.push(a, l, d)
                }
                getPositions(t) {
                    if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
                    const a = Gr(t);
                    let l = 0,
                        d = this.ids.length - 1;
                    for (; l < d;) {
                        const x = l + d >> 1;
                        this.ids[x] >= a ? d = x : l = x + 1
                    }
                    const g = [];
                    for (; this.ids[l] === a;) g.push({
                        index: this.positions[3 * l],
                        start: this.positions[3 * l + 1],
                        end: this.positions[3 * l + 2]
                    }), l++;
                    return g
                }
                static serialize(t, a) {
                    const l = new Float64Array(t.ids),
                        d = new Uint32Array(t.positions);
                    return hr(l, d, 0, l.length - 1), a && a.push(l.buffer, d.buffer), {
                        ids: l,
                        positions: d
                    }
                }
                static deserialize(t) {
                    const a = new sa;
                    return a.ids = t.ids, a.positions = t.positions, a.indexed = !0, a
                }
            }

            function Gr(i) {
                const t = +i;
                return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : Hn(String(i))
            }

            function hr(i, t, a, l) {
                for (; a < l;) {
                    const d = i[a + l >> 1];
                    let g = a - 1,
                        x = l + 1;
                    for (;;) {
                        do g++; while (i[g] < d);
                        do x--; while (i[x] > d);
                        if (g >= x) break;
                        da(i, g, x), da(t, 3 * g, 3 * x), da(t, 3 * g + 1, 3 * x + 1), da(t, 3 * g + 2, 3 * x + 2)
                    }
                    x - a < l - x ? (hr(i, t, a, x), a = x + 1) : (hr(i, t, x + 1, l), l = x)
                }
            }

            function da(i, t, a) {
                const l = i[t];
                i[t] = i[a], i[a] = l
            }
            Ii("FeaturePositionMap", sa);
            class pa {
                constructor(t, a) {
                    this.gl = t.gl, this.location = a
                }
            }
            class Ia extends pa {
                constructor(t, a) {
                    super(t, a), this.current = 0
                }
                set(t) {
                    this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t))
                }
            }
            class Ts extends pa {
                constructor(t, a) {
                    super(t, a), this.current = [0, 0, 0, 0]
                }
                set(t) {
                    t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]))
                }
            }
            class mo extends pa {
                constructor(t, a) {
                    super(t, a), this.current = _n.transparent
                }
                set(t) {
                    t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a))
                }
            }
            const No = new Float32Array(16);

            function Ms(i) {
                return [wi(255 * i.r, 255 * i.g), wi(255 * i.b, 255 * i.a)]
            }
            class Mr {
                constructor(t, a, l) {
                    this.value = t, this.uniformNames = a.map(d => `u_${d}`), this.type = l
                }
                setUniform(t, a, l) {
                    t.set(l.constantOr(this.value))
                }
                getBinding(t, a, l) {
                    return this.type === "color" ? new mo(t, a) : new Ia(t, a)
                }
            }
            class pr {
                constructor(t, a) {
                    this.uniformNames = a.map(l => `u_${l}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1
                }
                setConstantPatternPositions(t, a) {
                    this.pixelRatioFrom = a.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = a.tlbr, this.patternTo = t.tlbr
                }
                setUniform(t, a, l, d) {
                    const g = d === "u_pattern_to" ? this.patternTo : d === "u_pattern_from" ? this.patternFrom : d === "u_pixel_ratio_to" ? this.pixelRatioTo : d === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
                    g && t.set(g)
                }
                getBinding(t, a, l) {
                    return l.substr(0, 9) === "u_pattern" ? new Ts(t, a) : new Ia(t, a)
                }
            }
            class yr {
                constructor(t, a, l, d) {
                    this.expression = t, this.type = l, this.maxValue = 0, this.paintVertexAttributes = a.map(g => ({
                        name: `a_${g}`,
                        type: "Float32",
                        components: l === "color" ? 2 : 1,
                        offset: 0
                    })), this.paintVertexArray = new d
                }
                populatePaintArray(t, a, l, d, g) {
                    const x = this.paintVertexArray.length,
                        A = this.expression.evaluate(new cr(0), a, {}, d, [], g);
                    this.paintVertexArray.resize(t), this._setPaintValue(x, t, A)
                }
                updatePaintArray(t, a, l, d) {
                    const g = this.expression.evaluate({
                        zoom: 0
                    }, l, d);
                    this._setPaintValue(t, a, g)
                }
                _setPaintValue(t, a, l) {
                    if (this.type === "color") {
                        const d = Ms(l);
                        for (let g = t; g < a; g++) this.paintVertexArray.emplace(g, d[0], d[1])
                    } else {
                        for (let d = t; d < a; d++) this.paintVertexArray.emplace(d, l);
                        this.maxValue = Math.max(this.maxValue, Math.abs(l))
                    }
                }
                upload(t) {
                    this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
                }
                destroy() {
                    this.paintVertexBuffer && this.paintVertexBuffer.destroy()
                }
            }
            class Ta {
                constructor(t, a, l, d, g, x) {
                    this.expression = t, this.uniformNames = a.map(A => `u_${A}_t`), this.type = l, this.useIntegerZoom = d, this.zoom = g, this.maxValue = 0, this.paintVertexAttributes = a.map(A => ({
                        name: `a_${A}`,
                        type: "Float32",
                        components: l === "color" ? 4 : 2,
                        offset: 0
                    })), this.paintVertexArray = new x
                }
                populatePaintArray(t, a, l, d, g) {
                    const x = this.expression.evaluate(new cr(this.zoom), a, {}, d, [], g),
                        A = this.expression.evaluate(new cr(this.zoom + 1), a, {}, d, [], g),
                        M = this.paintVertexArray.length;
                    this.paintVertexArray.resize(t), this._setPaintValue(M, t, x, A)
                }
                updatePaintArray(t, a, l, d) {
                    const g = this.expression.evaluate({
                            zoom: this.zoom
                        }, l, d),
                        x = this.expression.evaluate({
                            zoom: this.zoom + 1
                        }, l, d);
                    this._setPaintValue(t, a, g, x)
                }
                _setPaintValue(t, a, l, d) {
                    if (this.type === "color") {
                        const g = Ms(l),
                            x = Ms(d);
                        for (let A = t; A < a; A++) this.paintVertexArray.emplace(A, g[0], g[1], x[0], x[1])
                    } else {
                        for (let g = t; g < a; g++) this.paintVertexArray.emplace(g, l, d);
                        this.maxValue = Math.max(this.maxValue, Math.abs(l), Math.abs(d))
                    }
                }
                upload(t) {
                    this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
                }
                destroy() {
                    this.paintVertexBuffer && this.paintVertexBuffer.destroy()
                }
                setUniform(t, a) {
                    const l = this.useIntegerZoom ? Math.floor(a.zoom) : a.zoom,
                        d = $e(this.expression.interpolationFactor(l, this.zoom, this.zoom + 1), 0, 1);
                    t.set(d)
                }
                getBinding(t, a, l) {
                    return new Ia(t, a)
                }
            }
            class Zn {
                constructor(t, a, l, d, g, x) {
                    this.expression = t, this.type = a, this.useIntegerZoom = l, this.zoom = d, this.layerId = x, this.zoomInPaintVertexArray = new g, this.zoomOutPaintVertexArray = new g
                }
                populatePaintArray(t, a, l) {
                    const d = this.zoomInPaintVertexArray.length;
                    this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(d, t, a.patterns && a.patterns[this.layerId], l)
                }
                updatePaintArray(t, a, l, d, g) {
                    this._setPaintValues(t, a, l.patterns && l.patterns[this.layerId], g)
                }
                _setPaintValues(t, a, l, d) {
                    if (!d || !l) return;
                    const {
                        min: g,
                        mid: x,
                        max: A
                    } = l, M = d[g], F = d[x], D = d[A];
                    if (M && F && D)
                        for (let U = t; U < a; U++) this.zoomInPaintVertexArray.emplace(U, F.tl[0], F.tl[1], F.br[0], F.br[1], M.tl[0], M.tl[1], M.br[0], M.br[1], F.pixelRatio, M.pixelRatio), this.zoomOutPaintVertexArray.emplace(U, F.tl[0], F.tl[1], F.br[0], F.br[1], D.tl[0], D.tl[1], D.br[0], D.br[1], F.pixelRatio, D.pixelRatio)
                }
                upload(t) {
                    this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, $i.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, $i.members, this.expression.isStateDependent))
                }
                destroy() {
                    this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy()
                }
            }
            class Zr {
                constructor(t, a, l) {
                    this.binders = {}, this._buffers = [];
                    const d = [];
                    for (const g in t.paint._values) {
                        if (!l(g)) continue;
                        const x = t.paint.get(g);
                        if (!(x instanceof qa && xs(x.property.specification))) continue;
                        const A = Dr(g, t.type),
                            M = x.value,
                            F = x.property.specification.type,
                            D = x.property.useIntegerZoom,
                            U = x.property.specification["property-type"],
                            N = U === "cross-faded" || U === "cross-faded-data-driven";
                        if (M.kind === "constant") this.binders[g] = N ? new pr(M.value, A) : new Mr(M.value, A, F), d.push(`/u_${g}`);
                        else if (M.kind === "source" || N) {
                            const H = Oo(g, F, "source");
                            this.binders[g] = N ? new Zn(M, F, D, a, H, t.id) : new yr(M, A, F, H), d.push(`/a_${g}`)
                        } else {
                            const H = Oo(g, F, "composite");
                            this.binders[g] = new Ta(M, A, F, D, a, H), d.push(`/z_${g}`)
                        }
                    }
                    this.cacheKey = d.sort().join("")
                }
                getMaxValue(t) {
                    const a = this.binders[t];
                    return a instanceof yr || a instanceof Ta ? a.maxValue : 0
                }
                populatePaintArrays(t, a, l, d, g) {
                    for (const x in this.binders) {
                        const A = this.binders[x];
                        (A instanceof yr || A instanceof Ta || A instanceof Zn) && A.populatePaintArray(t, a, l, d, g)
                    }
                }
                setConstantPatternPositions(t, a) {
                    for (const l in this.binders) {
                        const d = this.binders[l];
                        d instanceof pr && d.setConstantPatternPositions(t, a)
                    }
                }
                updatePaintArrays(t, a, l, d, g) {
                    let x = !1;
                    for (const A in t) {
                        const M = a.getPositions(A);
                        for (const F of M) {
                            const D = l.feature(F.index);
                            for (const U in this.binders) {
                                const N = this.binders[U];
                                if ((N instanceof yr || N instanceof Ta || N instanceof Zn) && N.expression.isStateDependent === !0) {
                                    const H = d.paint.get(U);
                                    N.expression = H.value, N.updatePaintArray(F.start, F.end, D, t[A], g), x = !0
                                }
                            }
                        }
                    }
                    return x
                }
                defines() {
                    const t = [];
                    for (const a in this.binders) {
                        const l = this.binders[a];
                        (l instanceof Mr || l instanceof pr) && t.push(...l.uniformNames.map(d => `#define HAS_UNIFORM_${d}`))
                    }
                    return t
                }
                getBinderAttributes() {
                    const t = [];
                    for (const a in this.binders) {
                        const l = this.binders[a];
                        if (l instanceof yr || l instanceof Ta)
                            for (let d = 0; d < l.paintVertexAttributes.length; d++) t.push(l.paintVertexAttributes[d].name);
                        else if (l instanceof Zn)
                            for (let d = 0; d < $i.members.length; d++) t.push($i.members[d].name)
                    }
                    return t
                }
                getBinderUniforms() {
                    const t = [];
                    for (const a in this.binders) {
                        const l = this.binders[a];
                        if (l instanceof Mr || l instanceof pr || l instanceof Ta)
                            for (const d of l.uniformNames) t.push(d)
                    }
                    return t
                }
                getPaintVertexBuffers() {
                    return this._buffers
                }
                getUniforms(t, a) {
                    const l = [];
                    for (const d in this.binders) {
                        const g = this.binders[d];
                        if (g instanceof Mr || g instanceof pr || g instanceof Ta) {
                            for (const x of g.uniformNames)
                                if (a[x]) {
                                    const A = g.getBinding(t, a[x], x);
                                    l.push({
                                        name: x,
                                        property: d,
                                        binding: A
                                    })
                                }
                        }
                    }
                    return l
                }
                setUniforms(t, a, l, d) {
                    for (const {
                            name: g,
                            property: x,
                            binding: A
                        }
                        of a) this.binders[x].setUniform(A, d, l.get(x), g)
                }
                updatePaintBuffers(t) {
                    this._buffers = [];
                    for (const a in this.binders) {
                        const l = this.binders[a];
                        if (t && l instanceof Zn) {
                            const d = t.fromScale === 2 ? l.zoomInPaintVertexBuffer : l.zoomOutPaintVertexBuffer;
                            d && this._buffers.push(d)
                        } else(l instanceof yr || l instanceof Ta) && l.paintVertexBuffer && this._buffers.push(l.paintVertexBuffer)
                    }
                }
                upload(t) {
                    for (const a in this.binders) {
                        const l = this.binders[a];
                        (l instanceof yr || l instanceof Ta || l instanceof Zn) && l.upload(t)
                    }
                    this.updatePaintBuffers()
                }
                destroy() {
                    for (const t in this.binders) {
                        const a = this.binders[t];
                        (a instanceof yr || a instanceof Ta || a instanceof Zn) && a.destroy()
                    }
                }
            }
            class ea {
                constructor(t, a, l = () => !0) {
                    this.programConfigurations = {};
                    for (const d of t) this.programConfigurations[d.id] = new Zr(d, a, l);
                    this.needsUpload = !1, this._featureMap = new sa, this._bufferOffset = 0
                }
                populatePaintArrays(t, a, l, d, g, x) {
                    for (const A in this.programConfigurations) this.programConfigurations[A].populatePaintArrays(t, a, d, g, x);
                    a.id !== void 0 && this._featureMap.add(a.id, l, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0
                }
                updatePaintArrays(t, a, l, d) {
                    for (const g of l) this.needsUpload = this.programConfigurations[g.id].updatePaintArrays(t, this._featureMap, a, g, d) || this.needsUpload
                }
                get(t) {
                    return this.programConfigurations[t]
                }
                upload(t) {
                    if (this.needsUpload) {
                        for (const a in this.programConfigurations) this.programConfigurations[a].upload(t);
                        this.needsUpload = !1
                    }
                }
                destroy() {
                    for (const t in this.programConfigurations) this.programConfigurations[t].destroy()
                }
            }

            function Dr(i, t) {
                return {
                    "text-opacity": ["opacity"],
                    "icon-opacity": ["opacity"],
                    "text-color": ["fill_color"],
                    "icon-color": ["fill_color"],
                    "text-halo-color": ["halo_color"],
                    "icon-halo-color": ["halo_color"],
                    "text-halo-blur": ["halo_blur"],
                    "icon-halo-blur": ["halo_blur"],
                    "text-halo-width": ["halo_width"],
                    "icon-halo-width": ["halo_width"],
                    "line-gap-width": ["gapwidth"],
                    "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
                    "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
                    "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"]
                } [i] || [i.replace(`${t}-`, "").replace(/-/g, "_")]
            }

            function Oo(i, t, a) {
                const l = {
                        color: {
                            source: uo,
                            composite: Yc
                        },
                        number: {
                            source: Al,
                            composite: uo
                        }
                    },
                    d = function(g) {
                        return {
                            "line-pattern": {
                                source: bt,
                                composite: bt
                            },
                            "fill-pattern": {
                                source: bt,
                                composite: bt
                            },
                            "fill-extrusion-pattern": {
                                source: bt,
                                composite: bt
                            }
                        } [g]
                    }(i);
                return d && d[a] || l[t][a]
            }
            Ii("ConstantBinder", Mr), Ii("CrossFadedConstantBinder", pr), Ii("SourceExpressionBinder", yr), Ii("CrossFadedCompositeBinder", Zn), Ii("CompositeExpressionBinder", Ta), Ii("ProgramConfiguration", Zr, {
                omit: ["_buffers"]
            }), Ii("ProgramConfigurationSet", ea);
            const fr = 8192,
                Xr = Math.pow(2, 14) - 1,
                qc = -Xr - 1;

            function Hs(i) {
                const t = fr / i.extent,
                    a = i.loadGeometry();
                for (let l = 0; l < a.length; l++) {
                    const d = a[l];
                    for (let g = 0; g < d.length; g++) {
                        const x = d[g],
                            A = Math.round(x.x * t),
                            M = Math.round(x.y * t);
                        x.x = $e(A, qc, Xr), x.y = $e(M, qc, Xr), (A < x.x || A > x.x + 1 || M < x.y || M > x.y + 1) && li("Geometry exceeds allowed extent, reduce your vector tile buffer size")
                    }
                }
                return a
            }

            function Ws(i, t) {
                return {
                    type: i.type,
                    id: i.id,
                    properties: i.properties,
                    geometry: t ? Hs(i) : []
                }
            }

            function Ka(i, t, a, l, d) {
                i.emplaceBack(2 * t + (l + 1) / 2, 2 * a + (d + 1) / 2)
            }
            class go {
                constructor(t) {
                    this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(a => a.id), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new Ce, this.indexArray = new ci, this.segments = new Ki, this.programConfigurations = new ea(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter(a => a.isStateDependent()).map(a => a.id)
                }
                populate(t, a, l) {
                    const d = this.layers[0],
                        g = [];
                    let x = null,
                        A = !1;
                    d.type === "circle" && (x = d.layout.get("circle-sort-key"), A = !x.isConstant());
                    for (const {
                            feature: M,
                            id: F,
                            index: D,
                            sourceLayerIndex: U
                        }
                        of t) {
                        const N = this.layers[0]._featureFilter.needGeometry,
                            H = Ws(M, N);
                        if (!this.layers[0]._featureFilter.filter(new cr(this.zoom), H, l)) continue;
                        const X = A ? x.evaluate(H, {}, l) : void 0,
                            ne = {
                                id: F,
                                properties: M.properties,
                                type: M.type,
                                sourceLayerIndex: U,
                                index: D,
                                geometry: N ? H.geometry : Hs(M),
                                patterns: {},
                                sortKey: X
                            };
                        g.push(ne)
                    }
                    A && g.sort((M, F) => M.sortKey - F.sortKey);
                    for (const M of g) {
                        const {
                            geometry: F,
                            index: D,
                            sourceLayerIndex: U
                        } = M, N = t[D].feature;
                        this.addFeature(M, F, D, l), a.featureIndex.insert(N, F, D, U, this.index)
                    }
                }
                update(t, a, l) {
                    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, a, this.stateDependentLayers, l)
                }
                isEmpty() {
                    return this.layoutVertexArray.length === 0
                }
                uploadPending() {
                    return !this.uploaded || this.programConfigurations.needsUpload
                }
                upload(t) {
                    this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ri), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
                }
                destroy() {
                    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
                }
                addFeature(t, a, l, d) {
                    for (const g of a)
                        for (const x of g) {
                            const A = x.x,
                                M = x.y;
                            if (A < 0 || A >= fr || M < 0 || M >= fr) continue;
                            const F = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t.sortKey),
                                D = F.vertexLength;
                            Ka(this.layoutVertexArray, A, M, -1, -1), Ka(this.layoutVertexArray, A, M, 1, -1), Ka(this.layoutVertexArray, A, M, 1, 1), Ka(this.layoutVertexArray, A, M, -1, 1), this.indexArray.emplaceBack(D, D + 1, D + 2), this.indexArray.emplaceBack(D, D + 3, D + 2), F.vertexLength += 4, F.primitiveLength += 2
                        }
                    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, l, {}, d)
                }
            }

            function za(i, t) {
                for (let a = 0; a < i.length; a++)
                    if (vo(t, i[a])) return !0;
                for (let a = 0; a < t.length; a++)
                    if (vo(i, t[a])) return !0;
                return !!yo(i, t)
            }

            function $c(i, t, a) {
                return !!vo(i, t) || !!Hh(t, i, a)
            }

            function Tl(i, t) {
                if (i.length === 1) return Kc(t, i[0]);
                for (let a = 0; a < t.length; a++) {
                    const l = t[a];
                    for (let d = 0; d < l.length; d++)
                        if (vo(i, l[d])) return !0
                }
                for (let a = 0; a < i.length; a++)
                    if (Kc(t, i[a])) return !0;
                for (let a = 0; a < t.length; a++)
                    if (yo(i, t[a])) return !0;
                return !1
            }

            function xa(i, t, a) {
                if (i.length > 1) {
                    if (yo(i, t)) return !0;
                    for (let l = 0; l < t.length; l++)
                        if (Hh(t[l], i, a)) return !0
                }
                for (let l = 0; l < i.length; l++)
                    if (Hh(i[l], t, a)) return !0;
                return !1
            }

            function yo(i, t) {
                if (i.length === 0 || t.length === 0) return !1;
                for (let a = 0; a < i.length - 1; a++) {
                    const l = i[a],
                        d = i[a + 1];
                    for (let g = 0; g < t.length - 1; g++)
                        if (Ml(l, d, t[g], t[g + 1])) return !0
                }
                return !1
            }

            function Ml(i, t, a, l) {
                return O(i, a, l) !== O(t, a, l) && O(i, t, a) !== O(i, t, l)
            }

            function Hh(i, t, a) {
                const l = a * a;
                if (t.length === 1) return i.distSqr(t[0]) < l;
                for (let d = 1; d < t.length; d++)
                    if (Wh(i, t[d - 1], t[d]) < l) return !0;
                return !1
            }

            function Wh(i, t, a) {
                const l = t.distSqr(a);
                if (l === 0) return i.distSqr(t);
                const d = ((i.x - t.x) * (a.x - t.x) + (i.y - t.y) * (a.y - t.y)) / l;
                return i.distSqr(d < 0 ? t : d > 1 ? a : a.sub(t)._mult(d)._add(t))
            }

            function Kc(i, t) {
                let a, l, d, g = !1;
                for (let x = 0; x < i.length; x++) {
                    a = i[x];
                    for (let A = 0, M = a.length - 1; A < a.length; M = A++) l = a[A], d = a[M], l.y > t.y != d.y > t.y && t.x < (d.x - l.x) * (t.y - l.y) / (d.y - l.y) + l.x && (g = !g)
                }
                return g
            }

            function vo(i, t) {
                let a = !1;
                for (let l = 0, d = i.length - 1; l < i.length; d = l++) {
                    const g = i[l],
                        x = i[d];
                    g.y > t.y != x.y > t.y && t.x < (x.x - g.x) * (t.y - g.y) / (x.y - g.y) + g.x && (a = !a)
                }
                return a
            }

            function lc(i, t, a) {
                const l = a[0],
                    d = a[2];
                if (i.x < l.x && t.x < l.x || i.x > d.x && t.x > d.x || i.y < l.y && t.y < l.y || i.y > d.y && t.y > d.y) return !1;
                const g = O(i, t, a[0]);
                return g !== O(i, t, a[1]) || g !== O(i, t, a[2]) || g !== O(i, t, a[3])
            }

            function cc(i, t, a) {
                const l = t.paint.get(i).value;
                return l.kind === "constant" ? l.value : a.programConfigurations.get(t.id).getMaxValue(i)
            }

            function eh(i) {
                return Math.sqrt(i[0] * i[0] + i[1] * i[1])
            }

            function hc(i, t, a, l, d) {
                if (!t[0] && !t[1]) return i;
                const g = be.convert(t)._mult(d);
                a === "viewport" && g._rotate(-l);
                const x = [];
                for (let A = 0; A < i.length; A++) x.push(i[A].sub(g));
                return x
            }
            let Du, Uu;
            Ii("CircleBucket", go, {
                omit: ["layers"]
            });
            var Jh = {
                    get paint() {
                        return Uu = Uu || new ua({
                            "circle-radius": new ln(Le.paint_circle["circle-radius"]),
                            "circle-color": new ln(Le.paint_circle["circle-color"]),
                            "circle-blur": new ln(Le.paint_circle["circle-blur"]),
                            "circle-opacity": new ln(Le.paint_circle["circle-opacity"]),
                            "circle-translate": new Ji(Le.paint_circle["circle-translate"]),
                            "circle-translate-anchor": new Ji(Le.paint_circle["circle-translate-anchor"]),
                            "circle-pitch-scale": new Ji(Le.paint_circle["circle-pitch-scale"]),
                            "circle-pitch-alignment": new Ji(Le.paint_circle["circle-pitch-alignment"]),
                            "circle-stroke-width": new ln(Le.paint_circle["circle-stroke-width"]),
                            "circle-stroke-color": new ln(Le.paint_circle["circle-stroke-color"]),
                            "circle-stroke-opacity": new ln(Le.paint_circle["circle-stroke-opacity"])
                        })
                    },
                    get layout() {
                        return Du = Du || new ua({
                            "circle-sort-key": new ln(Le.layout_circle["circle-sort-key"])
                        })
                    }
                },
                ta = 1e-6,
                _o = typeof Float32Array != "undefined" ? Float32Array : Array;

            function Js(i) {
                return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i
            }

            function th(i, t, a) {
                var l = t[0],
                    d = t[1],
                    g = t[2],
                    x = t[3],
                    A = t[4],
                    M = t[5],
                    F = t[6],
                    D = t[7],
                    U = t[8],
                    N = t[9],
                    H = t[10],
                    X = t[11],
                    ne = t[12],
                    le = t[13],
                    ce = t[14],
                    Qe = t[15],
                    Se = a[0],
                    Re = a[1],
                    ot = a[2],
                    dt = a[3];
                return i[0] = Se * l + Re * A + ot * U + dt * ne, i[1] = Se * d + Re * M + ot * N + dt * le, i[2] = Se * g + Re * F + ot * H + dt * ce, i[3] = Se * x + Re * D + ot * X + dt * Qe, i[4] = (Se = a[4]) * l + (Re = a[5]) * A + (ot = a[6]) * U + (dt = a[7]) * ne, i[5] = Se * d + Re * M + ot * N + dt * le, i[6] = Se * g + Re * F + ot * H + dt * ce, i[7] = Se * x + Re * D + ot * X + dt * Qe, i[8] = (Se = a[8]) * l + (Re = a[9]) * A + (ot = a[10]) * U + (dt = a[11]) * ne, i[9] = Se * d + Re * M + ot * N + dt * le, i[10] = Se * g + Re * F + ot * H + dt * ce, i[11] = Se * x + Re * D + ot * X + dt * Qe, i[12] = (Se = a[12]) * l + (Re = a[13]) * A + (ot = a[14]) * U + (dt = a[15]) * ne, i[13] = Se * d + Re * M + ot * N + dt * le, i[14] = Se * g + Re * F + ot * H + dt * ce, i[15] = Se * x + Re * D + ot * X + dt * Qe, i
            }
            Math.hypot || (Math.hypot = function() {
                for (var i = 0, t = arguments.length; t--;) i += arguments[t] * arguments[t];
                return Math.sqrt(i)
            });
            var Vo, Zh = th;

            function uc(i, t, a) {
                var l = t[0],
                    d = t[1],
                    g = t[2],
                    x = t[3];
                return i[0] = a[0] * l + a[4] * d + a[8] * g + a[12] * x, i[1] = a[1] * l + a[5] * d + a[9] * g + a[13] * x, i[2] = a[2] * l + a[6] * d + a[10] * g + a[14] * x, i[3] = a[3] * l + a[7] * d + a[11] * g + a[15] * x, i
            }
            Vo = new _o(4), _o != Float32Array && (Vo[0] = 0, Vo[1] = 0, Vo[2] = 0, Vo[3] = 0);
            class Xh extends $a {
                constructor(t) {
                    super(t, Jh)
                }
                createBucket(t) {
                    return new go(t)
                }
                queryRadius(t) {
                    const a = t;
                    return cc("circle-radius", this, a) + cc("circle-stroke-width", this, a) + eh(this.paint.get("circle-translate"))
                }
                queryIntersectsFeature(t, a, l, d, g, x, A, M) {
                    const F = hc(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), x.angle, A),
                        D = this.paint.get("circle-radius").evaluate(a, l) + this.paint.get("circle-stroke-width").evaluate(a, l),
                        U = this.paint.get("circle-pitch-alignment") === "map",
                        N = U ? F : function(X, ne) {
                            return X.map(le => jh(le, ne))
                        }(F, M),
                        H = U ? D * A : D;
                    for (const X of d)
                        for (const ne of X) {
                            const le = U ? ne : jh(ne, M);
                            let ce = H;
                            const Qe = uc([], [ne.x, ne.y, 0, 1], M);
                            if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? ce *= Qe[3] / x.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (ce *= x.cameraToCenterDistance / Qe[3]), $c(N, le, ce)) return !0
                        }
                    return !1
                }
            }

            function jh(i, t) {
                const a = uc([], [i.x, i.y, 0, 1], t);
                return new be(a[0] / a[3], a[1] / a[3])
            }
            class zd extends go {}
            let Iu;
            Ii("HeatmapBucket", zd, {
                omit: ["layers"]
            });
            var Go = {
                get paint() {
                    return Iu = Iu || new ua({
                        "heatmap-radius": new ln(Le.paint_heatmap["heatmap-radius"]),
                        "heatmap-weight": new ln(Le.paint_heatmap["heatmap-weight"]),
                        "heatmap-intensity": new Ji(Le.paint_heatmap["heatmap-intensity"]),
                        "heatmap-color": new ec(Le.paint_heatmap["heatmap-color"]),
                        "heatmap-opacity": new Ji(Le.paint_heatmap["heatmap-opacity"])
                    })
                }
            };

            function Cl(i, {
                width: t,
                height: a
            }, l, d) {
                if (d) {
                    if (d instanceof Uint8ClampedArray) d = new Uint8Array(d.buffer);
                    else if (d.length !== t * a * l) throw new RangeError(`mismatched image size. expected: ${d.length} but got: ${t*a*l}`)
                } else d = new Uint8Array(t * a * l);
                return i.width = t, i.height = a, i.data = d, i
            }

            function Nd(i, {
                width: t,
                height: a
            }, l) {
                if (t === i.width && a === i.height) return;
                const d = Cl({}, {
                    width: t,
                    height: a
                }, l);
                zu(i, d, {
                    x: 0,
                    y: 0
                }, {
                    x: 0,
                    y: 0
                }, {
                    width: Math.min(i.width, t),
                    height: Math.min(i.height, a)
                }, l), i.width = t, i.height = a, i.data = d.data
            }

            function zu(i, t, a, l, d, g) {
                if (d.width === 0 || d.height === 0) return t;
                if (d.width > i.width || d.height > i.height || a.x > i.width - d.width || a.y > i.height - d.height) throw new RangeError("out of range source coordinates for image copy");
                if (d.width > t.width || d.height > t.height || l.x > t.width - d.width || l.y > t.height - d.height) throw new RangeError("out of range destination coordinates for image copy");
                const x = i.data,
                    A = t.data;
                if (x === A) throw new Error("srcData equals dstData, so image is already copied");
                for (let M = 0; M < d.height; M++) {
                    const F = ((a.y + M) * i.width + a.x) * g,
                        D = ((l.y + M) * t.width + l.x) * g;
                    for (let U = 0; U < d.width * g; U++) A[D + U] = x[F + U]
                }
                return t
            }
            class ih {
                constructor(t, a) {
                    Cl(this, t, 1, a)
                }
                resize(t) {
                    Nd(this, t, 1)
                }
                clone() {
                    return new ih({
                        width: this.width,
                        height: this.height
                    }, new Uint8Array(this.data))
                }
                static copy(t, a, l, d, g) {
                    zu(t, a, l, d, g, 1)
                }
            }
            class es {
                constructor(t, a) {
                    Cl(this, t, 4, a)
                }
                resize(t) {
                    Nd(this, t, 4)
                }
                replace(t, a) {
                    a ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t
                }
                clone() {
                    return new es({
                        width: this.width,
                        height: this.height
                    }, new Uint8Array(this.data))
                }
                static copy(t, a, l, d, g) {
                    zu(t, a, l, d, g, 4)
                }
            }

            function Od(i) {
                const t = {},
                    a = i.resolution || 256,
                    l = i.clips ? i.clips.length : 1,
                    d = i.image || new es({
                        width: a,
                        height: l
                    });
                if (Math.log(a) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${a}`);
                const g = (x, A, M) => {
                    t[i.evaluationKey] = M;
                    const F = i.expression.evaluate(t);
                    d.data[x + A + 0] = Math.floor(255 * F.r / F.a), d.data[x + A + 1] = Math.floor(255 * F.g / F.a), d.data[x + A + 2] = Math.floor(255 * F.b / F.a), d.data[x + A + 3] = Math.floor(255 * F.a)
                };
                if (i.clips)
                    for (let x = 0, A = 0; x < l; ++x, A += 4 * a)
                        for (let M = 0, F = 0; M < a; M++, F += 4) {
                            const D = M / (a - 1),
                                {
                                    start: U,
                                    end: N
                                } = i.clips[x];
                            g(A, F, U * (1 - D) + N * D)
                        } else
                            for (let x = 0, A = 0; x < a; x++, A += 4) g(0, A, x / (a - 1));
                return d
            }
            Ii("AlphaImage", ih), Ii("RGBAImage", es);
            class xp extends $a {
                createBucket(t) {
                    return new zd(t)
                }
                constructor(t) {
                    super(t, Go), this._updateColorRamp()
                }
                _handleSpecialPaintPropertyUpdate(t) {
                    t === "heatmap-color" && this._updateColorRamp()
                }
                _updateColorRamp() {
                    this.colorRamp = Od({
                        expression: this._transitionablePaint._values["heatmap-color"].value.expression,
                        evaluationKey: "heatmapDensity",
                        image: this.colorRamp
                    }), this.colorRampTexture = null
                }
                resize() {
                    this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null)
                }
                queryRadius() {
                    return 0
                }
                queryIntersectsFeature() {
                    return !1
                }
                hasOffscreenPass() {
                    return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none"
                }
            }
            let Vd;
            var Nu = {
                get paint() {
                    return Vd = Vd || new ua({
                        "hillshade-illumination-direction": new Ji(Le.paint_hillshade["hillshade-illumination-direction"]),
                        "hillshade-illumination-anchor": new Ji(Le.paint_hillshade["hillshade-illumination-anchor"]),
                        "hillshade-exaggeration": new Ji(Le.paint_hillshade["hillshade-exaggeration"]),
                        "hillshade-shadow-color": new Ji(Le.paint_hillshade["hillshade-shadow-color"]),
                        "hillshade-highlight-color": new Ji(Le.paint_hillshade["hillshade-highlight-color"]),
                        "hillshade-accent-color": new Ji(Le.paint_hillshade["hillshade-accent-color"])
                    })
                }
            };
            class bp extends $a {
                constructor(t) {
                    super(t, Nu)
                }
                hasOffscreenPass() {
                    return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none"
                }
            }
            const dc = kr([{
                    name: "a_pos",
                    components: 2,
                    type: "Int16"
                }], 4),
                {
                    members: wp
                } = dc;
            var Cr = {
                exports: {}
            };

            function Bl(i, t, a) {
                a = a || 2;
                var l, d, g, x, A, M, F, D = t && t.length,
                    U = D ? t[0] * a : i.length,
                    N = Ou(i, 0, U, a, !0),
                    H = [];
                if (!N || N.next === N.prev) return H;
                if (D && (N = function(ne, le, ce, Qe) {
                        var Se, Re, ot, dt = [];
                        for (Se = 0, Re = le.length; Se < Re; Se++)(ot = Ou(ne, le[Se] * Qe, Se < Re - 1 ? le[Se + 1] * Qe : ne.length, Qe, !1)) === ot.next && (ot.steiner = !0), dt.push(bo(ot));
                        for (dt.sort(Vu), Se = 0; Se < dt.length; Se++) ce = xo(dt[Se], ce);
                        return ce
                    }(i, t, N, a)), i.length > 80 * a) {
                    l = g = i[0], d = x = i[1];
                    for (var X = a; X < U; X += a)(A = i[X]) < l && (l = A), (M = i[X + 1]) < d && (d = M), A > g && (g = A), M > x && (x = M);
                    F = (F = Math.max(g - l, x - d)) !== 0 ? 32767 / F : 0
                }
                return Ho(N, H, a, l, d, F, 0), H
            }

            function Ou(i, t, a, l, d) {
                var g, x;
                if (d === mc(i, t, a, l) > 0)
                    for (g = t; g < a; g += l) x = sh(g, i[g], i[g + 1], x);
                else
                    for (g = a - l; g >= t; g -= l) x = sh(g, i[g], i[g + 1], x);
                return x && Wo(x, x.next) && (Xo(x), x = x.next), x
            }

            function Zs(i, t) {
                if (!i) return i;
                t || (t = i);
                var a, l = i;
                do
                    if (a = !1, l.steiner || !Wo(l, l.next) && vr(l.prev, l, l.next) !== 0) l = l.next;
                    else {
                        if (Xo(l), (l = t = l.prev) === l.next) break;
                        a = !0
                    } while (a || l !== t);
                return t
            }

            function Ho(i, t, a, l, d, g, x) {
                if (i) {
                    !x && g && function(D, U, N, H) {
                        var X = D;
                        do X.z === 0 && (X.z = Yh(X.x, X.y, U, N, H)), X.prevZ = X.prev, X.nextZ = X.next, X = X.next; while (X !== D);
                        X.prevZ.nextZ = null, X.prevZ = null,
                            function(ne) {
                                var le, ce, Qe, Se, Re, ot, dt, Ct, Nt = 1;
                                do {
                                    for (ce = ne, ne = null, Re = null, ot = 0; ce;) {
                                        for (ot++, Qe = ce, dt = 0, le = 0; le < Nt && (dt++, Qe = Qe.nextZ); le++);
                                        for (Ct = Nt; dt > 0 || Ct > 0 && Qe;) dt !== 0 && (Ct === 0 || !Qe || ce.z <= Qe.z) ? (Se = ce, ce = ce.nextZ, dt--) : (Se = Qe, Qe = Qe.nextZ, Ct--), Re ? Re.nextZ = Se : ne = Se, Se.prevZ = Re, Re = Se;
                                        ce = Qe
                                    }
                                    Re.nextZ = null, Nt *= 2
                                } while (ot > 1)
                            }(X)
                    }(i, l, d, g);
                    for (var A, M, F = i; i.prev !== i.next;)
                        if (A = i.prev, M = i.next, g ? Gd(i, l, d, g) : nh(i)) t.push(A.i / a | 0), t.push(i.i / a | 0), t.push(M.i / a | 0), Xo(i), i = M.next, F = M.next;
                        else if ((i = M) === F) {
                        x ? x === 1 ? Ho(i = Hd(Zs(i), t, a), t, a, l, d, g, 2) : x === 2 && rh(i, t, a, l, d, g) : Ho(Zs(i), t, a, l, d, g, 1);
                        break
                    }
                }
            }

            function nh(i) {
                var t = i.prev,
                    a = i,
                    l = i.next;
                if (vr(t, a, l) >= 0) return !1;
                for (var d = t.x, g = a.x, x = l.x, A = t.y, M = a.y, F = l.y, D = d < g ? d < x ? d : x : g < x ? g : x, U = A < M ? A < F ? A : F : M < F ? M : F, N = d > g ? d > x ? d : x : g > x ? g : x, H = A > M ? A > F ? A : F : M > F ? M : F, X = l.next; X !== t;) {
                    if (X.x >= D && X.x <= N && X.y >= U && X.y <= H && pc(d, A, g, M, x, F, X.x, X.y) && vr(X.prev, X, X.next) >= 0) return !1;
                    X = X.next
                }
                return !0
            }

            function Gd(i, t, a, l) {
                var d = i.prev,
                    g = i,
                    x = i.next;
                if (vr(d, g, x) >= 0) return !1;
                for (var A = d.x, M = g.x, F = x.x, D = d.y, U = g.y, N = x.y, H = A < M ? A < F ? A : F : M < F ? M : F, X = D < U ? D < N ? D : N : U < N ? U : N, ne = A > M ? A > F ? A : F : M > F ? M : F, le = D > U ? D > N ? D : N : U > N ? U : N, ce = Yh(H, X, t, a, l), Qe = Yh(ne, le, t, a, l), Se = i.prevZ, Re = i.nextZ; Se && Se.z >= ce && Re && Re.z <= Qe;) {
                    if (Se.x >= H && Se.x <= ne && Se.y >= X && Se.y <= le && Se !== d && Se !== x && pc(A, D, M, U, F, N, Se.x, Se.y) && vr(Se.prev, Se, Se.next) >= 0 || (Se = Se.prevZ, Re.x >= H && Re.x <= ne && Re.y >= X && Re.y <= le && Re !== d && Re !== x && pc(A, D, M, U, F, N, Re.x, Re.y) && vr(Re.prev, Re, Re.next) >= 0)) return !1;
                    Re = Re.nextZ
                }
                for (; Se && Se.z >= ce;) {
                    if (Se.x >= H && Se.x <= ne && Se.y >= X && Se.y <= le && Se !== d && Se !== x && pc(A, D, M, U, F, N, Se.x, Se.y) && vr(Se.prev, Se, Se.next) >= 0) return !1;
                    Se = Se.prevZ
                }
                for (; Re && Re.z <= Qe;) {
                    if (Re.x >= H && Re.x <= ne && Re.y >= X && Re.y <= le && Re !== d && Re !== x && pc(A, D, M, U, F, N, Re.x, Re.y) && vr(Re.prev, Re, Re.next) >= 0) return !1;
                    Re = Re.nextZ
                }
                return !0
            }

            function Hd(i, t, a) {
                var l = i;
                do {
                    var d = l.prev,
                        g = l.next.next;
                    !Wo(d, g) && Jo(d, l, l.next, g) && wo(d, g) && wo(g, d) && (t.push(d.i / a | 0), t.push(l.i / a | 0), t.push(g.i / a | 0), Xo(l), Xo(l.next), l = i = g), l = l.next
                } while (l !== i);
                return Zs(l)
            }

            function rh(i, t, a, l, d, g) {
                var x = i;
                do {
                    for (var A = x.next.next; A !== x.prev;) {
                        if (x.i !== A.i && qh(x, A)) {
                            var M = ah(x, A);
                            return x = Zs(x, x.next), M = Zs(M, M.next), Ho(x, t, a, l, d, g, 0), void Ho(M, t, a, l, d, g, 0)
                        }
                        A = A.next
                    }
                    x = x.next
                } while (x !== i)
            }

            function Vu(i, t) {
                return i.x - t.x
            }

            function xo(i, t) {
                var a = function(d, g) {
                    var x, A = g,
                        M = d.x,
                        F = d.y,
                        D = -1 / 0;
                    do {
                        if (F <= A.y && F >= A.next.y && A.next.y !== A.y) {
                            var U = A.x + (F - A.y) * (A.next.x - A.x) / (A.next.y - A.y);
                            if (U <= M && U > D && (D = U, x = A.x < A.next.x ? A : A.next, U === M)) return x
                        }
                        A = A.next
                    } while (A !== g);
                    if (!x) return null;
                    var N, H = x,
                        X = x.x,
                        ne = x.y,
                        le = 1 / 0;
                    A = x;
                    do M >= A.x && A.x >= X && M !== A.x && pc(F < ne ? M : D, F, X, ne, F < ne ? D : M, F, A.x, A.y) && (N = Math.abs(F - A.y) / (M - A.x), wo(A, d) && (N < le || N === le && (A.x > x.x || A.x === x.x && Wd(x, A))) && (x = A, le = N)), A = A.next; while (A !== H);
                    return x
                }(i, t);
                if (!a) return t;
                var l = ah(a, i);
                return Zs(l, l.next), Zs(a, a.next)
            }

            function Wd(i, t) {
                return vr(i.prev, i, t.prev) < 0 && vr(t.next, i, i.next) < 0
            }

            function Yh(i, t, a, l, d) {
                return (i = 1431655765 & ((i = 858993459 & ((i = 252645135 & ((i = 16711935 & ((i = (i - a) * d | 0) | i << 8)) | i << 4)) | i << 2)) | i << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - l) * d | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
            }

            function bo(i) {
                var t = i,
                    a = i;
                do(t.x < a.x || t.x === a.x && t.y < a.y) && (a = t), t = t.next; while (t !== i);
                return a
            }

            function pc(i, t, a, l, d, g, x, A) {
                return (d - x) * (t - A) >= (i - x) * (g - A) && (i - x) * (l - A) >= (a - x) * (t - A) && (a - x) * (g - A) >= (d - x) * (l - A)
            }

            function qh(i, t) {
                return i.next.i !== t.i && i.prev.i !== t.i && ! function(a, l) {
                    var d = a;
                    do {
                        if (d.i !== a.i && d.next.i !== a.i && d.i !== l.i && d.next.i !== l.i && Jo(d, d.next, a, l)) return !0;
                        d = d.next
                    } while (d !== a);
                    return !1
                }(i, t) && (wo(i, t) && wo(t, i) && function(a, l) {
                    var d = a,
                        g = !1,
                        x = (a.x + l.x) / 2,
                        A = (a.y + l.y) / 2;
                    do d.y > A != d.next.y > A && d.next.y !== d.y && x < (d.next.x - d.x) * (A - d.y) / (d.next.y - d.y) + d.x && (g = !g), d = d.next; while (d !== a);
                    return g
                }(i, t) && (vr(i.prev, i, t.prev) || vr(i, t.prev, t)) || Wo(i, t) && vr(i.prev, i, i.next) > 0 && vr(t.prev, t, t.next) > 0)
            }

            function vr(i, t, a) {
                return (t.y - i.y) * (a.x - t.x) - (t.x - i.x) * (a.y - t.y)
            }

            function Wo(i, t) {
                return i.x === t.x && i.y === t.y
            }

            function Jo(i, t, a, l) {
                var d = Zo(vr(i, t, a)),
                    g = Zo(vr(i, t, l)),
                    x = Zo(vr(a, l, i)),
                    A = Zo(vr(a, l, t));
                return d !== g && x !== A || !(d !== 0 || !Rl(i, a, t)) || !(g !== 0 || !Rl(i, l, t)) || !(x !== 0 || !Rl(a, i, l)) || !(A !== 0 || !Rl(a, t, l))
            }

            function Rl(i, t, a) {
                return t.x <= Math.max(i.x, a.x) && t.x >= Math.min(i.x, a.x) && t.y <= Math.max(i.y, a.y) && t.y >= Math.min(i.y, a.y)
            }

            function Zo(i) {
                return i > 0 ? 1 : i < 0 ? -1 : 0
            }

            function wo(i, t) {
                return vr(i.prev, i, i.next) < 0 ? vr(i, t, i.next) >= 0 && vr(i, i.prev, t) >= 0 : vr(i, t, i.prev) < 0 || vr(i, i.next, t) < 0
            }

            function ah(i, t) {
                var a = new fc(i.i, i.x, i.y),
                    l = new fc(t.i, t.x, t.y),
                    d = i.next,
                    g = t.prev;
                return i.next = t, t.prev = i, a.next = d, d.prev = a, l.next = a, a.prev = l, g.next = l, l.prev = g, l
            }

            function sh(i, t, a, l) {
                var d = new fc(i, t, a);
                return l ? (d.next = l.next, d.prev = l, l.next.prev = d, l.next = d) : (d.prev = d, d.next = d), d
            }

            function Xo(i) {
                i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ)
            }

            function fc(i, t, a) {
                this.i = i, this.x = t, this.y = a, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }

            function mc(i, t, a, l) {
                for (var d = 0, g = t, x = a - l; g < a; g += l) d += (i[x] - i[g]) * (i[g + 1] + i[x + 1]), x = g;
                return d
            }
            Cr.exports = Bl, Cr.exports.default = Bl, Bl.deviation = function(i, t, a, l) {
                var d = t && t.length,
                    g = Math.abs(mc(i, 0, d ? t[0] * a : i.length, a));
                if (d)
                    for (var x = 0, A = t.length; x < A; x++) g -= Math.abs(mc(i, t[x] * a, x < A - 1 ? t[x + 1] * a : i.length, a));
                var M = 0;
                for (x = 0; x < l.length; x += 3) {
                    var F = l[x] * a,
                        D = l[x + 1] * a,
                        U = l[x + 2] * a;
                    M += Math.abs((i[F] - i[U]) * (i[D + 1] - i[F + 1]) - (i[F] - i[D]) * (i[U + 1] - i[F + 1]))
                }
                return g === 0 && M === 0 ? 0 : Math.abs((M - g) / g)
            }, Bl.flatten = function(i) {
                for (var t = i[0][0].length, a = {
                        vertices: [],
                        holes: [],
                        dimensions: t
                    }, l = 0, d = 0; d < i.length; d++) {
                    for (var g = 0; g < i[d].length; g++)
                        for (var x = 0; x < t; x++) a.vertices.push(i[d][g][x]);
                    d > 0 && a.holes.push(l += i[d - 1].length)
                }
                return a
            };
            var $h = se(Cr.exports);

            function Na(i, t, a, l, d) {
                Kh(i, t, a || 0, l || i.length - 1, d || js)
            }

            function Kh(i, t, a, l, d) {
                for (; l > a;) {
                    if (l - a > 600) {
                        var g = l - a + 1,
                            x = t - a + 1,
                            A = Math.log(g),
                            M = .5 * Math.exp(2 * A / 3),
                            F = .5 * Math.sqrt(A * M * (g - M) / g) * (x - g / 2 < 0 ? -1 : 1);
                        Kh(i, t, Math.max(a, Math.floor(t - x * M / g + F)), Math.min(l, Math.floor(t + (g - x) * M / g + F)), d)
                    }
                    var D = i[t],
                        U = a,
                        N = l;
                    for (Xs(i, a, t), d(i[l], D) > 0 && Xs(i, a, l); U < N;) {
                        for (Xs(i, U, N), U++, N--; d(i[U], D) < 0;) U++;
                        for (; d(i[N], D) > 0;) N--
                    }
                    d(i[a], D) === 0 ? Xs(i, a, N) : Xs(i, ++N, l), N <= t && (a = N + 1), t <= N && (l = N - 1)
                }
            }

            function Xs(i, t, a) {
                var l = i[t];
                i[t] = i[a], i[a] = l
            }

            function js(i, t) {
                return i < t ? -1 : i > t ? 1 : 0
            }

            function Ys(i, t) {
                const a = i.length;
                if (a <= 1) return [i];
                const l = [];
                let d, g;
                for (let x = 0; x < a; x++) {
                    const A = K(i[x]);
                    A !== 0 && (i[x].area = Math.abs(A), g === void 0 && (g = A < 0), g === A < 0 ? (d && l.push(d), d = [i[x]]) : d.push(i[x]))
                }
                if (d && l.push(d), t > 1)
                    for (let x = 0; x < l.length; x++) l[x].length <= t || (Na(l[x], t, 1, l[x].length - 1, Gu), l[x] = l[x].slice(0, t));
                return l
            }

            function Gu(i, t) {
                return t.area - i.area
            }

            function oh(i, t, a) {
                const l = a.patternDependencies;
                let d = !1;
                for (const g of t) {
                    const x = g.paint.get(`${i}-pattern`);
                    x.isConstant() || (d = !0);
                    const A = x.constantOr(null);
                    A && (d = !0, l[A.to] = !0, l[A.from] = !0)
                }
                return d
            }

            function lh(i, t, a, l, d) {
                const g = d.patternDependencies;
                for (const x of t) {
                    const A = x.paint.get(`${i}-pattern`).value;
                    if (A.kind !== "constant") {
                        let M = A.evaluate({
                                zoom: l - 1
                            }, a, {}, d.availableImages),
                            F = A.evaluate({
                                zoom: l
                            }, a, {}, d.availableImages),
                            D = A.evaluate({
                                zoom: l + 1
                            }, a, {}, d.availableImages);
                        M = M && M.name ? M.name : M, F = F && F.name ? F.name : F, D = D && D.name ? D.name : D, g[M] = !0, g[F] = !0, g[D] = !0, a.patterns[x.id] = {
                            min: M,
                            mid: F,
                            max: D
                        }
                    }
                }
                return a
            }
            class ch {
                constructor(t) {
                    this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(a => a.id), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new Me, this.indexArray = new ci, this.indexArray2 = new $t, this.programConfigurations = new ea(t.layers, t.zoom), this.segments = new Ki, this.segments2 = new Ki, this.stateDependentLayerIds = this.layers.filter(a => a.isStateDependent()).map(a => a.id)
                }
                populate(t, a, l) {
                    this.hasPattern = oh("fill", this.layers, a);
                    const d = this.layers[0].layout.get("fill-sort-key"),
                        g = !d.isConstant(),
                        x = [];
                    for (const {
                            feature: A,
                            id: M,
                            index: F,
                            sourceLayerIndex: D
                        }
                        of t) {
                        const U = this.layers[0]._featureFilter.needGeometry,
                            N = Ws(A, U);
                        if (!this.layers[0]._featureFilter.filter(new cr(this.zoom), N, l)) continue;
                        const H = g ? d.evaluate(N, {}, l, a.availableImages) : void 0,
                            X = {
                                id: M,
                                properties: A.properties,
                                type: A.type,
                                sourceLayerIndex: D,
                                index: F,
                                geometry: U ? N.geometry : Hs(A),
                                patterns: {},
                                sortKey: H
                            };
                        x.push(X)
                    }
                    g && x.sort((A, M) => A.sortKey - M.sortKey);
                    for (const A of x) {
                        const {
                            geometry: M,
                            index: F,
                            sourceLayerIndex: D
                        } = A;
                        if (this.hasPattern) {
                            const U = lh("fill", this.layers, A, this.zoom, a);
                            this.patternFeatures.push(U)
                        } else this.addFeature(A, M, F, l, {});
                        a.featureIndex.insert(t[F].feature, M, F, D, this.index)
                    }
                }
                update(t, a, l) {
                    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, a, this.stateDependentLayers, l)
                }
                addFeatures(t, a, l) {
                    for (const d of this.patternFeatures) this.addFeature(d, d.geometry, d.index, a, l)
                }
                isEmpty() {
                    return this.layoutVertexArray.length === 0
                }
                uploadPending() {
                    return !this.uploaded || this.programConfigurations.needsUpload
                }
                upload(t) {
                    this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, wp), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0
                }
                destroy() {
                    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy())
                }
                addFeature(t, a, l, d, g) {
                    for (const x of Ys(a, 500)) {
                        let A = 0;
                        for (const H of x) A += H.length;
                        const M = this.segments.prepareSegment(A, this.layoutVertexArray, this.indexArray),
                            F = M.vertexLength,
                            D = [],
                            U = [];
                        for (const H of x) {
                            if (H.length === 0) continue;
                            H !== x[0] && U.push(D.length / 2);
                            const X = this.segments2.prepareSegment(H.length, this.layoutVertexArray, this.indexArray2),
                                ne = X.vertexLength;
                            this.layoutVertexArray.emplaceBack(H[0].x, H[0].y), this.indexArray2.emplaceBack(ne + H.length - 1, ne), D.push(H[0].x), D.push(H[0].y);
                            for (let le = 1; le < H.length; le++) this.layoutVertexArray.emplaceBack(H[le].x, H[le].y), this.indexArray2.emplaceBack(ne + le - 1, ne + le), D.push(H[le].x), D.push(H[le].y);
                            X.vertexLength += H.length, X.primitiveLength += H.length
                        }
                        const N = $h(D, U);
                        for (let H = 0; H < N.length; H += 3) this.indexArray.emplaceBack(F + N[H], F + N[H + 1], F + N[H + 2]);
                        M.vertexLength += A, M.primitiveLength += N.length / 3
                    }
                    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, l, g, d)
                }
            }
            let eu, tu;
            Ii("FillBucket", ch, {
                omit: ["layers", "patternFeatures"]
            });
            var Ep = {
                get paint() {
                    return tu = tu || new ua({
                        "fill-antialias": new Ji(Le.paint_fill["fill-antialias"]),
                        "fill-opacity": new ln(Le.paint_fill["fill-opacity"]),
                        "fill-color": new ln(Le.paint_fill["fill-color"]),
                        "fill-outline-color": new ln(Le.paint_fill["fill-outline-color"]),
                        "fill-translate": new Ji(Le.paint_fill["fill-translate"]),
                        "fill-translate-anchor": new Ji(Le.paint_fill["fill-translate-anchor"]),
                        "fill-pattern": new Io(Le.paint_fill["fill-pattern"])
                    })
                },
                get layout() {
                    return eu = eu || new ua({
                        "fill-sort-key": new ln(Le.layout_fill["fill-sort-key"])
                    })
                }
            };
            class Br extends $a {
                constructor(t) {
                    super(t, Ep)
                }
                recalculate(t, a) {
                    super.recalculate(t, a);
                    const l = this.paint._values["fill-outline-color"];
                    l.value.kind === "constant" && l.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"])
                }
                createBucket(t) {
                    return new ch(t)
                }
                queryRadius() {
                    return eh(this.paint.get("fill-translate"))
                }
                queryIntersectsFeature(t, a, l, d, g, x, A) {
                    return Tl(hc(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), x.angle, A), d)
                }
                isTileClipped() {
                    return !0
                }
            }
            const ts = kr([{
                    name: "a_pos",
                    components: 2,
                    type: "Int16"
                }, {
                    name: "a_normal_ed",
                    components: 4,
                    type: "Int16"
                }], 4),
                iu = kr([{
                    name: "a_centroid",
                    components: 2,
                    type: "Int16"
                }], 4),
                {
                    members: hh
                } = ts;
            var Cs = {},
                Bs = ie,
                jo = Yo;

            function Yo(i, t, a, l, d) {
                this.properties = {}, this.extent = a, this.type = 0, this._pbf = i, this._geometry = -1, this._keys = l, this._values = d, i.readFields(uh, this, t)
            }

            function uh(i, t, a) {
                i == 1 ? t.id = a.readVarint() : i == 2 ? function(l, d) {
                    for (var g = l.readVarint() + l.pos; l.pos < g;) {
                        var x = d._keys[l.readVarint()],
                            A = d._values[l.readVarint()];
                        d.properties[x] = A
                    }
                }(a, t) : i == 3 ? t.type = a.readVarint() : i == 4 && (t._geometry = a.pos)
            }

            function nu(i) {
                for (var t, a, l = 0, d = 0, g = i.length, x = g - 1; d < g; x = d++) l += ((a = i[x]).x - (t = i[d]).x) * (t.y + a.y);
                return l
            }
            Yo.types = ["Unknown", "Point", "LineString", "Polygon"], Yo.prototype.loadGeometry = function() {
                var i = this._pbf;
                i.pos = this._geometry;
                for (var t, a = i.readVarint() + i.pos, l = 1, d = 0, g = 0, x = 0, A = []; i.pos < a;) {
                    if (d <= 0) {
                        var M = i.readVarint();
                        l = 7 & M, d = M >> 3
                    }
                    if (d--, l === 1 || l === 2) g += i.readSVarint(), x += i.readSVarint(), l === 1 && (t && A.push(t), t = []), t.push(new Bs(g, x));
                    else {
                        if (l !== 7) throw new Error("unknown command " + l);
                        t && t.push(t[0].clone())
                    }
                }
                return t && A.push(t), A
            }, Yo.prototype.bbox = function() {
                var i = this._pbf;
                i.pos = this._geometry;
                for (var t = i.readVarint() + i.pos, a = 1, l = 0, d = 0, g = 0, x = 1 / 0, A = -1 / 0, M = 1 / 0, F = -1 / 0; i.pos < t;) {
                    if (l <= 0) {
                        var D = i.readVarint();
                        a = 7 & D, l = D >> 3
                    }
                    if (l--, a === 1 || a === 2)(d += i.readSVarint()) < x && (x = d), d > A && (A = d), (g += i.readSVarint()) < M && (M = g), g > F && (F = g);
                    else if (a !== 7) throw new Error("unknown command " + a)
                }
                return [x, M, A, F]
            }, Yo.prototype.toGeoJSON = function(i, t, a) {
                var l, d, g = this.extent * Math.pow(2, a),
                    x = this.extent * i,
                    A = this.extent * t,
                    M = this.loadGeometry(),
                    F = Yo.types[this.type];

                function D(H) {
                    for (var X = 0; X < H.length; X++) {
                        var ne = H[X];
                        H[X] = [360 * (ne.x + x) / g - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (ne.y + A) / g) * Math.PI / 180)) - 90]
                    }
                }
                switch (this.type) {
                    case 1:
                        var U = [];
                        for (l = 0; l < M.length; l++) U[l] = M[l][0];
                        D(M = U);
                        break;
                    case 2:
                        for (l = 0; l < M.length; l++) D(M[l]);
                        break;
                    case 3:
                        for (M = function(H) {
                                var X = H.length;
                                if (X <= 1) return [H];
                                for (var ne, le, ce = [], Qe = 0; Qe < X; Qe++) {
                                    var Se = nu(H[Qe]);
                                    Se !== 0 && (le === void 0 && (le = Se < 0), le === Se < 0 ? (ne && ce.push(ne), ne = [H[Qe]]) : ne.push(H[Qe]))
                                }
                                return ne && ce.push(ne), ce
                            }(M), l = 0; l < M.length; l++)
                            for (d = 0; d < M[l].length; d++) D(M[l][d])
                }
                M.length === 1 ? M = M[0] : F = "Multi" + F;
                var N = {
                    type: "Feature",
                    geometry: {
                        type: F,
                        coordinates: M
                    },
                    properties: this.properties
                };
                return "id" in this && (N.id = this.id), N
            };
            var gc = jo,
                qo = yc;

            function yc(i, t) {
                this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = i, this._keys = [], this._values = [], this._features = [], i.readFields(dh, this, t), this.length = this._features.length
            }

            function dh(i, t, a) {
                i === 15 ? t.version = a.readVarint() : i === 1 ? t.name = a.readString() : i === 5 ? t.extent = a.readVarint() : i === 2 ? t._features.push(a.pos) : i === 3 ? t._keys.push(a.readString()) : i === 4 && t._values.push(function(l) {
                    for (var d = null, g = l.readVarint() + l.pos; l.pos < g;) {
                        var x = l.readVarint() >> 3;
                        d = x === 1 ? l.readString() : x === 2 ? l.readFloat() : x === 3 ? l.readDouble() : x === 4 ? l.readVarint64() : x === 5 ? l.readVarint() : x === 6 ? l.readSVarint() : x === 7 ? l.readBoolean() : null
                    }
                    return d
                }(a))
            }
            yc.prototype.feature = function(i) {
                if (i < 0 || i >= this._features.length) throw new Error("feature index out of bounds");
                this._pbf.pos = this._features[i];
                var t = this._pbf.readVarint() + this._pbf.pos;
                return new gc(this._pbf, t, this.extent, this._keys, this._values)
            };
            var Sp = qo;

            function Fl(i, t, a) {
                if (i === 3) {
                    var l = new Sp(a, a.readVarint() + a.pos);
                    l.length && (t[l.name] = l)
                }
            }
            Cs.VectorTile = function(i, t) {
                this.layers = i.readFields(Fl, {}, t)
            }, Cs.VectorTileFeature = jo, Cs.VectorTileLayer = qo;
            const Hu = Cs.VectorTileFeature.types,
                ru = Math.pow(2, 13);

            function _r(i, t, a, l, d, g, x, A) {
                i.emplaceBack(t, a, 2 * Math.floor(l * ru) + x, d * ru * 2, g * ru * 2, Math.round(A))
            }
            class is {
                constructor(t) {
                    this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(a => a.id), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new ke, this.centroidVertexArray = new pe, this.indexArray = new ci, this.programConfigurations = new ea(t.layers, t.zoom), this.segments = new Ki, this.stateDependentLayerIds = this.layers.filter(a => a.isStateDependent()).map(a => a.id)
                }
                populate(t, a, l) {
                    this.features = [], this.hasPattern = oh("fill-extrusion", this.layers, a);
                    for (const {
                            feature: d,
                            id: g,
                            index: x,
                            sourceLayerIndex: A
                        }
                        of t) {
                        const M = this.layers[0]._featureFilter.needGeometry,
                            F = Ws(d, M);
                        if (!this.layers[0]._featureFilter.filter(new cr(this.zoom), F, l)) continue;
                        const D = {
                            id: g,
                            sourceLayerIndex: A,
                            index: x,
                            geometry: M ? F.geometry : Hs(d),
                            properties: d.properties,
                            type: d.type,
                            patterns: {}
                        };
                        this.hasPattern ? this.features.push(lh("fill-extrusion", this.layers, D, this.zoom, a)) : this.addFeature(D, D.geometry, x, l, {}), a.featureIndex.insert(d, D.geometry, x, A, this.index, !0)
                    }
                }
                addFeatures(t, a, l) {
                    for (const d of this.features) {
                        const {
                            geometry: g
                        } = d;
                        this.addFeature(d, g, d.index, a, l)
                    }
                }
                update(t, a, l) {
                    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, a, this.stateDependentLayers, l)
                }
                isEmpty() {
                    return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0
                }
                uploadPending() {
                    return !this.uploaded || this.programConfigurations.needsUpload
                }
                upload(t) {
                    this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, hh), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, iu.members, !0), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
                }
                destroy() {
                    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy())
                }
                addFeature(t, a, l, d, g) {
                    const x = {
                        x: 0,
                        y: 0,
                        vertexCount: 0
                    };
                    for (const A of Ys(a, 500)) {
                        let M = 0;
                        for (const X of A) M += X.length;
                        let F = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
                        for (const X of A) {
                            if (X.length === 0 || Wu(X)) continue;
                            let ne = 0;
                            for (let le = 0; le < X.length; le++) {
                                const ce = X[le];
                                if (le >= 1) {
                                    const Qe = X[le - 1];
                                    if (!hs(ce, Qe)) {
                                        F.vertexLength + 4 > Ki.MAX_VERTEX_ARRAY_LENGTH && (F = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                                        const Se = ce.sub(Qe)._perp()._unit(),
                                            Re = Qe.dist(ce);
                                        ne + Re > 32768 && (ne = 0), _r(this.layoutVertexArray, ce.x, ce.y, Se.x, Se.y, 0, 0, ne), _r(this.layoutVertexArray, ce.x, ce.y, Se.x, Se.y, 0, 1, ne), x.x += 2 * ce.x, x.y += 2 * ce.y, x.vertexCount += 2, ne += Re, _r(this.layoutVertexArray, Qe.x, Qe.y, Se.x, Se.y, 0, 0, ne), _r(this.layoutVertexArray, Qe.x, Qe.y, Se.x, Se.y, 0, 1, ne), x.x += 2 * Qe.x, x.y += 2 * Qe.y, x.vertexCount += 2;
                                        const ot = F.vertexLength;
                                        this.indexArray.emplaceBack(ot, ot + 2, ot + 1), this.indexArray.emplaceBack(ot + 1, ot + 2, ot + 3), F.vertexLength += 4, F.primitiveLength += 2
                                    }
                                }
                            }
                        }
                        if (F.vertexLength + M > Ki.MAX_VERTEX_ARRAY_LENGTH && (F = this.segments.prepareSegment(M, this.layoutVertexArray, this.indexArray)), Hu[t.type] !== "Polygon") continue;
                        const D = [],
                            U = [],
                            N = F.vertexLength;
                        for (const X of A)
                            if (X.length !== 0) {
                                X !== A[0] && U.push(D.length / 2);
                                for (let ne = 0; ne < X.length; ne++) {
                                    const le = X[ne];
                                    _r(this.layoutVertexArray, le.x, le.y, 0, 0, 1, 1, 0), x.x += le.x, x.y += le.y, x.vertexCount += 1, D.push(le.x), D.push(le.y)
                                }
                            } const H = $h(D, U);
                        for (let X = 0; X < H.length; X += 3) this.indexArray.emplaceBack(N + H[X], N + H[X + 2], N + H[X + 1]);
                        F.primitiveLength += H.length / 3, F.vertexLength += M
                    }
                    for (let A = 0; A < x.vertexCount; A++) this.centroidVertexArray.emplaceBack(Math.floor(x.x / x.vertexCount), Math.floor(x.y / x.vertexCount));
                    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, l, g, d)
                }
            }

            function hs(i, t) {
                return i.x === t.x && (i.x < 0 || i.x > fr) || i.y === t.y && (i.y < 0 || i.y > fr)
            }

            function Wu(i) {
                return i.every(t => t.x < 0) || i.every(t => t.x > fr) || i.every(t => t.y < 0) || i.every(t => t.y > fr)
            }
            let ph;
            Ii("FillExtrusionBucket", is, {
                omit: ["layers", "features"]
            });
            var Jd = {
                get paint() {
                    return ph = ph || new ua({
                        "fill-extrusion-opacity": new Ji(Le["paint_fill-extrusion"]["fill-extrusion-opacity"]),
                        "fill-extrusion-color": new ln(Le["paint_fill-extrusion"]["fill-extrusion-color"]),
                        "fill-extrusion-translate": new Ji(Le["paint_fill-extrusion"]["fill-extrusion-translate"]),
                        "fill-extrusion-translate-anchor": new Ji(Le["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
                        "fill-extrusion-pattern": new Io(Le["paint_fill-extrusion"]["fill-extrusion-pattern"]),
                        "fill-extrusion-height": new ln(Le["paint_fill-extrusion"]["fill-extrusion-height"]),
                        "fill-extrusion-base": new ln(Le["paint_fill-extrusion"]["fill-extrusion-base"]),
                        "fill-extrusion-vertical-gradient": new Ji(Le["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
                    })
                }
            };
            class au extends $a {
                constructor(t) {
                    super(t, Jd)
                }
                createBucket(t) {
                    return new is(t)
                }
                queryRadius() {
                    return eh(this.paint.get("fill-extrusion-translate"))
                }
                is3D() {
                    return !0
                }
                queryIntersectsFeature(t, a, l, d, g, x, A, M) {
                    const F = hc(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), x.angle, A),
                        D = this.paint.get("fill-extrusion-height").evaluate(a, l),
                        U = this.paint.get("fill-extrusion-base").evaluate(a, l),
                        N = function(X, ne, le, ce) {
                            const Qe = [];
                            for (const Se of X) {
                                const Re = [Se.x, Se.y, 0, 1];
                                uc(Re, Re, ne), Qe.push(new be(Re[0] / Re[3], Re[1] / Re[3]))
                            }
                            return Qe
                        }(F, M),
                        H = function(X, ne, le, ce) {
                            const Qe = [],
                                Se = [],
                                Re = ce[8] * ne,
                                ot = ce[9] * ne,
                                dt = ce[10] * ne,
                                Ct = ce[11] * ne,
                                Nt = ce[8] * le,
                                qt = ce[9] * le,
                                Fe = ce[10] * le,
                                Be = ce[11] * le;
                            for (const mt of X) {
                                const lt = [],
                                    Xe = [];
                                for (const Zt of mt) {
                                    const Ie = Zt.x,
                                        pt = Zt.y,
                                        xt = ce[0] * Ie + ce[4] * pt + ce[12],
                                        Gt = ce[1] * Ie + ce[5] * pt + ce[13],
                                        Xt = ce[2] * Ie + ce[6] * pt + ce[14],
                                        hi = ce[3] * Ie + ce[7] * pt + ce[15],
                                        _i = Xt + dt,
                                        Di = hi + Ct,
                                        nn = xt + Nt,
                                        Fi = Gt + qt,
                                        tn = Xt + Fe,
                                        gn = hi + Be,
                                        Kn = new be((xt + Re) / Di, (Gt + ot) / Di);
                                    Kn.z = _i / Di, lt.push(Kn);
                                    const er = new be(nn / gn, Fi / gn);
                                    er.z = tn / gn, Xe.push(er)
                                }
                                Qe.push(lt), Se.push(Xe)
                            }
                            return [Qe, Se]
                        }(d, U, D, M);
                    return function(X, ne, le) {
                        let ce = 1 / 0;
                        Tl(le, ne) && (ce = Qa(le, ne[0]));
                        for (let Qe = 0; Qe < ne.length; Qe++) {
                            const Se = ne[Qe],
                                Re = X[Qe];
                            for (let ot = 0; ot < Se.length - 1; ot++) {
                                const dt = Se[ot],
                                    Ct = [dt, Se[ot + 1], Re[ot + 1], Re[ot], dt];
                                za(le, Ct) && (ce = Math.min(ce, Qa(le, Ct)))
                            }
                        }
                        return ce !== 1 / 0 && ce
                    }(H[0], H[1], N)
                }
            }

            function $o(i, t) {
                return i.x * t.x + i.y * t.y
            }

            function Qa(i, t) {
                if (i.length === 1) {
                    let a = 0;
                    const l = t[a++];
                    let d;
                    for (; !d || l.equals(d);)
                        if (d = t[a++], !d) return 1 / 0;
                    for (; a < t.length; a++) {
                        const g = t[a],
                            x = i[0],
                            A = d.sub(l),
                            M = g.sub(l),
                            F = x.sub(l),
                            D = $o(A, A),
                            U = $o(A, M),
                            N = $o(M, M),
                            H = $o(F, A),
                            X = $o(F, M),
                            ne = D * N - U * U,
                            le = (N * H - U * X) / ne,
                            ce = (D * X - U * H) / ne,
                            Qe = l.z * (1 - le - ce) + d.z * le + g.z * ce;
                        if (isFinite(Qe)) return Qe
                    }
                    return 1 / 0
                } {
                    let a = 1 / 0;
                    for (const l of t) a = Math.min(a, l.z);
                    return a
                }
            }
            const fh = kr([{
                    name: "a_pos_normal",
                    components: 2,
                    type: "Int16"
                }, {
                    name: "a_data",
                    components: 4,
                    type: "Uint8"
                }], 4),
                {
                    members: Ju
                } = fh,
                Zu = kr([{
                    name: "a_uv_x",
                    components: 1,
                    type: "Float32"
                }, {
                    name: "a_split_index",
                    components: 1,
                    type: "Float32"
                }]),
                {
                    members: su
                } = Zu,
                Xu = Cs.VectorTileFeature.types,
                ju = Math.cos(Math.PI / 180 * 37.5),
                ou = Math.pow(2, 14) / .5;
            class mh {
                constructor(t) {
                    this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(a => a.id), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(a => {
                        this.gradients[a.id] = {}
                    }), this.layoutVertexArray = new we, this.layoutVertexArray2 = new nt, this.indexArray = new ci, this.programConfigurations = new ea(t.layers, t.zoom), this.segments = new Ki, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(a => a.isStateDependent()).map(a => a.id)
                }
                populate(t, a, l) {
                    this.hasPattern = oh("line", this.layers, a);
                    const d = this.layers[0].layout.get("line-sort-key"),
                        g = !d.isConstant(),
                        x = [];
                    for (const {
                            feature: A,
                            id: M,
                            index: F,
                            sourceLayerIndex: D
                        }
                        of t) {
                        const U = this.layers[0]._featureFilter.needGeometry,
                            N = Ws(A, U);
                        if (!this.layers[0]._featureFilter.filter(new cr(this.zoom), N, l)) continue;
                        const H = g ? d.evaluate(N, {}, l) : void 0,
                            X = {
                                id: M,
                                properties: A.properties,
                                type: A.type,
                                sourceLayerIndex: D,
                                index: F,
                                geometry: U ? N.geometry : Hs(A),
                                patterns: {},
                                sortKey: H
                            };
                        x.push(X)
                    }
                    g && x.sort((A, M) => A.sortKey - M.sortKey);
                    for (const A of x) {
                        const {
                            geometry: M,
                            index: F,
                            sourceLayerIndex: D
                        } = A;
                        if (this.hasPattern) {
                            const U = lh("line", this.layers, A, this.zoom, a);
                            this.patternFeatures.push(U)
                        } else this.addFeature(A, M, F, l, {});
                        a.featureIndex.insert(t[F].feature, M, F, D, this.index)
                    }
                }
                update(t, a, l) {
                    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, a, this.stateDependentLayers, l)
                }
                addFeatures(t, a, l) {
                    for (const d of this.patternFeatures) this.addFeature(d, d.geometry, d.index, a, l)
                }
                isEmpty() {
                    return this.layoutVertexArray.length === 0
                }
                uploadPending() {
                    return !this.uploaded || this.programConfigurations.needsUpload
                }
                upload(t) {
                    this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, su)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ju), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
                }
                destroy() {
                    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
                }
                lineFeatureClips(t) {
                    if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return {
                        start: +t.properties.mapbox_clip_start,
                        end: +t.properties.mapbox_clip_end
                    }
                }
                addFeature(t, a, l, d, g) {
                    const x = this.layers[0].layout,
                        A = x.get("line-join").evaluate(t, {}),
                        M = x.get("line-cap"),
                        F = x.get("line-miter-limit"),
                        D = x.get("line-round-limit");
                    this.lineClips = this.lineFeatureClips(t);
                    for (const U of a) this.addLine(U, t, A, M, F, D);
                    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, l, g, d)
                }
                addLine(t, a, l, d, g, x) {
                    if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
                        this.lineClipsArray.push(this.lineClips);
                        for (let ce = 0; ce < t.length - 1; ce++) this.totalDistance += t[ce].dist(t[ce + 1]);
                        this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance)
                    }
                    const A = Xu[a.type] === "Polygon";
                    let M = t.length;
                    for (; M >= 2 && t[M - 1].equals(t[M - 2]);) M--;
                    let F = 0;
                    for (; F < M - 1 && t[F].equals(t[F + 1]);) F++;
                    if (M < (A ? 3 : 2)) return;
                    l === "bevel" && (g = 1.05);
                    const D = this.overscaling <= 16 ? 15 * fr / (512 * this.overscaling) : 0,
                        U = this.segments.prepareSegment(10 * M, this.layoutVertexArray, this.indexArray);
                    let N, H, X, ne, le;
                    this.e1 = this.e2 = -1, A && (N = t[M - 2], le = t[F].sub(N)._unit()._perp());
                    for (let ce = F; ce < M; ce++) {
                        if (X = ce === M - 1 ? A ? t[F + 1] : void 0 : t[ce + 1], X && t[ce].equals(X)) continue;
                        le && (ne = le), N && (H = N), N = t[ce], le = X ? X.sub(N)._unit()._perp() : ne, ne = ne || le;
                        let Qe = ne.add(le);
                        Qe.x === 0 && Qe.y === 0 || Qe._unit();
                        const Se = ne.x * le.x + ne.y * le.y,
                            Re = Qe.x * le.x + Qe.y * le.y,
                            ot = Re !== 0 ? 1 / Re : 1 / 0,
                            dt = 2 * Math.sqrt(2 - 2 * Re),
                            Ct = Re < ju && H && X,
                            Nt = ne.x * le.y - ne.y * le.x > 0;
                        if (Ct && ce > F) {
                            const Be = N.dist(H);
                            if (Be > 2 * D) {
                                const mt = N.sub(N.sub(H)._mult(D / Be)._round());
                                this.updateDistance(H, mt), this.addCurrentVertex(mt, ne, 0, 0, U), H = mt
                            }
                        }
                        const qt = H && X;
                        let Fe = qt ? l : A ? "butt" : d;
                        if (qt && Fe === "round" && (ot < x ? Fe = "miter" : ot <= 2 && (Fe = "fakeround")), Fe === "miter" && ot > g && (Fe = "bevel"), Fe === "bevel" && (ot > 2 && (Fe = "flipbevel"), ot < g && (Fe = "miter")), H && this.updateDistance(H, N), Fe === "miter") Qe._mult(ot), this.addCurrentVertex(N, Qe, 0, 0, U);
                        else if (Fe === "flipbevel") {
                            if (ot > 100) Qe = le.mult(-1);
                            else {
                                const Be = ot * ne.add(le).mag() / ne.sub(le).mag();
                                Qe._perp()._mult(Be * (Nt ? -1 : 1))
                            }
                            this.addCurrentVertex(N, Qe, 0, 0, U), this.addCurrentVertex(N, Qe.mult(-1), 0, 0, U)
                        } else if (Fe === "bevel" || Fe === "fakeround") {
                            const Be = -Math.sqrt(ot * ot - 1),
                                mt = Nt ? Be : 0,
                                lt = Nt ? 0 : Be;
                            if (H && this.addCurrentVertex(N, ne, mt, lt, U), Fe === "fakeround") {
                                const Xe = Math.round(180 * dt / Math.PI / 20);
                                for (let Zt = 1; Zt < Xe; Zt++) {
                                    let Ie = Zt / Xe;
                                    if (Ie !== .5) {
                                        const xt = Ie - .5;
                                        Ie += Ie * xt * (Ie - 1) * ((1.0904 + Se * (Se * (3.55645 - 1.43519 * Se) - 3.2452)) * xt * xt + (.848013 + Se * (.215638 * Se - 1.06021)))
                                    }
                                    const pt = le.sub(ne)._mult(Ie)._add(ne)._unit()._mult(Nt ? -1 : 1);
                                    this.addHalfVertex(N, pt.x, pt.y, !1, Nt, 0, U)
                                }
                            }
                            X && this.addCurrentVertex(N, le, -mt, -lt, U)
                        } else if (Fe === "butt") this.addCurrentVertex(N, Qe, 0, 0, U);
                        else if (Fe === "square") {
                            const Be = H ? 1 : -1;
                            this.addCurrentVertex(N, Qe, Be, Be, U)
                        } else Fe === "round" && (H && (this.addCurrentVertex(N, ne, 0, 0, U), this.addCurrentVertex(N, ne, 1, 1, U, !0)), X && (this.addCurrentVertex(N, le, -1, -1, U, !0), this.addCurrentVertex(N, le, 0, 0, U)));
                        if (Ct && ce < M - 1) {
                            const Be = N.dist(X);
                            if (Be > 2 * D) {
                                const mt = N.add(X.sub(N)._mult(D / Be)._round());
                                this.updateDistance(N, mt), this.addCurrentVertex(mt, le, 0, 0, U), N = mt
                            }
                        }
                    }
                }
                addCurrentVertex(t, a, l, d, g, x = !1) {
                    const A = a.y * d - a.x,
                        M = -a.y - a.x * d;
                    this.addHalfVertex(t, a.x + a.y * l, a.y - a.x * l, x, !1, l, g), this.addHalfVertex(t, A, M, x, !0, -d, g), this.distance > ou / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, a, l, d, g, x))
                }
                addHalfVertex({
                    x: t,
                    y: a
                }, l, d, g, x, A, M) {
                    const F = .5 * (this.lineClips ? this.scaledDistance * (ou - 1) : this.scaledDistance);
                    this.layoutVertexArray.emplaceBack((t << 1) + (g ? 1 : 0), (a << 1) + (x ? 1 : 0), Math.round(63 * l) + 128, Math.round(63 * d) + 128, 1 + (A === 0 ? 0 : A < 0 ? -1 : 1) | (63 & F) << 2, F >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
                    const D = M.vertexLength++;
                    this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, D), M.primitiveLength++), x ? this.e2 = D : this.e1 = D
                }
                updateScaledDistance() {
                    this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance
                }
                updateDistance(t, a) {
                    this.distance += t.dist(a), this.updateScaledDistance()
                }
            }
            let Yu, vc;
            Ii("LineBucket", mh, {
                omit: ["layers", "patternFeatures"]
            });
            var _c = {
                get paint() {
                    return vc = vc || new ua({
                        "line-opacity": new ln(Le.paint_line["line-opacity"]),
                        "line-color": new ln(Le.paint_line["line-color"]),
                        "line-translate": new Ji(Le.paint_line["line-translate"]),
                        "line-translate-anchor": new Ji(Le.paint_line["line-translate-anchor"]),
                        "line-width": new ln(Le.paint_line["line-width"]),
                        "line-gap-width": new ln(Le.paint_line["line-gap-width"]),
                        "line-offset": new ln(Le.paint_line["line-offset"]),
                        "line-blur": new ln(Le.paint_line["line-blur"]),
                        "line-dasharray": new Kl(Le.paint_line["line-dasharray"]),
                        "line-pattern": new Io(Le.paint_line["line-pattern"]),
                        "line-gradient": new ec(Le.paint_line["line-gradient"])
                    })
                },
                get layout() {
                    return Yu = Yu || new ua({
                        "line-cap": new Ji(Le.layout_line["line-cap"]),
                        "line-join": new ln(Le.layout_line["line-join"]),
                        "line-miter-limit": new Ji(Le.layout_line["line-miter-limit"]),
                        "line-round-limit": new Ji(Le.layout_line["line-round-limit"]),
                        "line-sort-key": new ln(Le.layout_line["line-sort-key"])
                    })
                }
            };
            class lu extends ln {
                possiblyEvaluate(t, a) {
                    return a = new cr(Math.floor(a.zoom), {
                        now: a.now,
                        fadeDuration: a.fadeDuration,
                        zoomHistory: a.zoomHistory,
                        transition: a.transition
                    }), super.possiblyEvaluate(t, a)
                }
                evaluate(t, a, l, d) {
                    return a = Kt({}, a, {
                        zoom: Math.floor(a.zoom)
                    }), super.evaluate(t, a, l, d)
                }
            }
            let xc;
            class gh extends $a {
                constructor(t) {
                    super(t, _c), this.gradientVersion = 0, xc || (xc = new lu(_c.paint.properties["line-width"].specification), xc.useIntegerZoom = !0)
                }
                _handleSpecialPaintPropertyUpdate(t) {
                    if (t === "line-gradient") {
                        const a = this.gradientExpression();
                        this.stepInterpolant = !! function(l) {
                            return l._styleExpression !== void 0
                        }(a) && a._styleExpression.expression instanceof ai, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER
                    }
                }
                gradientExpression() {
                    return this._transitionablePaint._values["line-gradient"].value.expression
                }
                recalculate(t, a) {
                    super.recalculate(t, a), this.paint._values["line-floorwidth"] = xc.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t)
                }
                createBucket(t) {
                    return new mh(t)
                }
                queryRadius(t) {
                    const a = t,
                        l = qu(cc("line-width", this, a), cc("line-gap-width", this, a)),
                        d = cc("line-offset", this, a);
                    return l / 2 + Math.abs(d) + eh(this.paint.get("line-translate"))
                }
                queryIntersectsFeature(t, a, l, d, g, x, A) {
                    const M = hc(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), x.angle, A),
                        F = A / 2 * qu(this.paint.get("line-width").evaluate(a, l), this.paint.get("line-gap-width").evaluate(a, l)),
                        D = this.paint.get("line-offset").evaluate(a, l);
                    return D && (d = function(U, N) {
                            const H = [];
                            for (let X = 0; X < U.length; X++) {
                                const ne = U[X],
                                    le = [];
                                for (let ce = 0; ce < ne.length; ce++) {
                                    const Qe = ne[ce - 1],
                                        Se = ne[ce],
                                        Re = ne[ce + 1],
                                        ot = ce === 0 ? new be(0, 0) : Se.sub(Qe)._unit()._perp(),
                                        dt = ce === ne.length - 1 ? new be(0, 0) : Re.sub(Se)._unit()._perp(),
                                        Ct = ot._add(dt)._unit(),
                                        Nt = Ct.x * dt.x + Ct.y * dt.y;
                                    Nt !== 0 && Ct._mult(1 / Nt), le.push(Ct._mult(N)._add(Se))
                                }
                                H.push(le)
                            }
                            return H
                        }(d, D * A)),
                        function(U, N, H) {
                            for (let X = 0; X < N.length; X++) {
                                const ne = N[X];
                                if (U.length >= 3) {
                                    for (let le = 0; le < ne.length; le++)
                                        if (vo(U, ne[le])) return !0
                                }
                                if (xa(U, ne, H)) return !0
                            }
                            return !1
                        }(M, d, F)
                }
                isTileClipped() {
                    return !0
                }
            }

            function qu(i, t) {
                return t > 0 ? t + 2 * i : i
            }
            const cu = kr([{
                    name: "a_pos_offset",
                    components: 4,
                    type: "Int16"
                }, {
                    name: "a_data",
                    components: 4,
                    type: "Uint16"
                }, {
                    name: "a_pixeloffset",
                    components: 4,
                    type: "Int16"
                }], 4),
                $u = kr([{
                    name: "a_projected_pos",
                    components: 3,
                    type: "Float32"
                }], 4);
            kr([{
                name: "a_fade_opacity",
                components: 1,
                type: "Uint32"
            }], 4);
            const hu = kr([{
                name: "a_placed",
                components: 2,
                type: "Uint8"
            }, {
                name: "a_shift",
                components: 2,
                type: "Float32"
            }]);
            kr([{
                type: "Int16",
                name: "anchorPointX"
            }, {
                type: "Int16",
                name: "anchorPointY"
            }, {
                type: "Int16",
                name: "x1"
            }, {
                type: "Int16",
                name: "y1"
            }, {
                type: "Int16",
                name: "x2"
            }, {
                type: "Int16",
                name: "y2"
            }, {
                type: "Uint32",
                name: "featureIndex"
            }, {
                type: "Uint16",
                name: "sourceLayerIndex"
            }, {
                type: "Uint16",
                name: "bucketIndex"
            }]);
            const uu = kr([{
                    name: "a_pos",
                    components: 2,
                    type: "Int16"
                }, {
                    name: "a_anchor_pos",
                    components: 2,
                    type: "Int16"
                }, {
                    name: "a_extrude",
                    components: 2,
                    type: "Int16"
                }], 4),
                Zd = kr([{
                    name: "a_pos",
                    components: 2,
                    type: "Float32"
                }, {
                    name: "a_radius",
                    components: 1,
                    type: "Float32"
                }, {
                    name: "a_flags",
                    components: 2,
                    type: "Int16"
                }], 4);

            function yh(i, t, a) {
                return i.sections.forEach(l => {
                    l.text = function(d, g, x) {
                        const A = g.layout.get("text-transform").evaluate(x, {});
                        return A === "uppercase" ? d = d.toLocaleUpperCase() : A === "lowercase" && (d = d.toLocaleLowerCase()), co.applyArabicShaping && (d = co.applyArabicShaping(d)), d
                    }(l.text, t, a)
                }), i
            }
            kr([{
                name: "triangle",
                components: 3,
                type: "Uint16"
            }]), kr([{
                type: "Int16",
                name: "anchorX"
            }, {
                type: "Int16",
                name: "anchorY"
            }, {
                type: "Uint16",
                name: "glyphStartIndex"
            }, {
                type: "Uint16",
                name: "numGlyphs"
            }, {
                type: "Uint32",
                name: "vertexStartIndex"
            }, {
                type: "Uint32",
                name: "lineStartIndex"
            }, {
                type: "Uint32",
                name: "lineLength"
            }, {
                type: "Uint16",
                name: "segment"
            }, {
                type: "Uint16",
                name: "lowerSize"
            }, {
                type: "Uint16",
                name: "upperSize"
            }, {
                type: "Float32",
                name: "lineOffsetX"
            }, {
                type: "Float32",
                name: "lineOffsetY"
            }, {
                type: "Uint8",
                name: "writingMode"
            }, {
                type: "Uint8",
                name: "placedOrientation"
            }, {
                type: "Uint8",
                name: "hidden"
            }, {
                type: "Uint32",
                name: "crossTileID"
            }, {
                type: "Int16",
                name: "associatedIconIndex"
            }]), kr([{
                type: "Int16",
                name: "anchorX"
            }, {
                type: "Int16",
                name: "anchorY"
            }, {
                type: "Int16",
                name: "rightJustifiedTextSymbolIndex"
            }, {
                type: "Int16",
                name: "centerJustifiedTextSymbolIndex"
            }, {
                type: "Int16",
                name: "leftJustifiedTextSymbolIndex"
            }, {
                type: "Int16",
                name: "verticalPlacedTextSymbolIndex"
            }, {
                type: "Int16",
                name: "placedIconSymbolIndex"
            }, {
                type: "Int16",
                name: "verticalPlacedIconSymbolIndex"
            }, {
                type: "Uint16",
                name: "key"
            }, {
                type: "Uint16",
                name: "textBoxStartIndex"
            }, {
                type: "Uint16",
                name: "textBoxEndIndex"
            }, {
                type: "Uint16",
                name: "verticalTextBoxStartIndex"
            }, {
                type: "Uint16",
                name: "verticalTextBoxEndIndex"
            }, {
                type: "Uint16",
                name: "iconBoxStartIndex"
            }, {
                type: "Uint16",
                name: "iconBoxEndIndex"
            }, {
                type: "Uint16",
                name: "verticalIconBoxStartIndex"
            }, {
                type: "Uint16",
                name: "verticalIconBoxEndIndex"
            }, {
                type: "Uint16",
                name: "featureIndex"
            }, {
                type: "Uint16",
                name: "numHorizontalGlyphVertices"
            }, {
                type: "Uint16",
                name: "numVerticalGlyphVertices"
            }, {
                type: "Uint16",
                name: "numIconVertices"
            }, {
                type: "Uint16",
                name: "numVerticalIconVertices"
            }, {
                type: "Uint16",
                name: "useRuntimeCollisionCircles"
            }, {
                type: "Uint32",
                name: "crossTileID"
            }, {
                type: "Float32",
                name: "textBoxScale"
            }, {
                type: "Float32",
                name: "collisionCircleDiameter"
            }, {
                type: "Uint16",
                name: "textAnchorOffsetStartIndex"
            }, {
                type: "Uint16",
                name: "textAnchorOffsetEndIndex"
            }]), kr([{
                type: "Float32",
                name: "offsetX"
            }]), kr([{
                type: "Int16",
                name: "x"
            }, {
                type: "Int16",
                name: "y"
            }, {
                type: "Int16",
                name: "tileUnitDistanceFromAnchor"
            }]), kr([{
                type: "Uint16",
                name: "textAnchor"
            }, {
                type: "Float32",
                components: 2,
                name: "textOffset"
            }]);
            const us = {
                "!": "",
                "#": "",
                $: "",
                "%": "",
                "&": "",
                "(": "",
                ")": "",
                "*": "",
                "+": "",
                ",": "",
                "-": "",
                ".": "",
                "/": "",
                ":": "",
                ";": "",
                "<": "",
                "=": "",
                ">": "",
                "?": "",
                "@": "",
                "[": "",
                "\\": "",
                "]": "",
                "^": "",
                _: "",
                "`": "",
                "{": "",
                "|": "",
                "}": "",
                "~": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": ""
            };
            var Xn = 24,
                du = Wn,
                Ku = function(i, t, a, l, d) {
                    var g, x, A = 8 * d - l - 1,
                        M = (1 << A) - 1,
                        F = M >> 1,
                        D = -7,
                        U = a ? d - 1 : 0,
                        N = a ? -1 : 1,
                        H = i[t + U];
                    for (U += N, g = H & (1 << -D) - 1, H >>= -D, D += A; D > 0; g = 256 * g + i[t + U], U += N, D -= 8);
                    for (x = g & (1 << -D) - 1, g >>= -D, D += l; D > 0; x = 256 * x + i[t + U], U += N, D -= 8);
                    if (g === 0) g = 1 - F;
                    else {
                        if (g === M) return x ? NaN : 1 / 0 * (H ? -1 : 1);
                        x += Math.pow(2, l), g -= F
                    }
                    return (H ? -1 : 1) * x * Math.pow(2, g - l)
                },
                ed = function(i, t, a, l, d, g) {
                    var x, A, M, F = 8 * g - d - 1,
                        D = (1 << F) - 1,
                        U = D >> 1,
                        N = d === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                        H = l ? 0 : g - 1,
                        X = l ? 1 : -1,
                        ne = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
                    for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (A = isNaN(t) ? 1 : 0, x = D) : (x = Math.floor(Math.log(t) / Math.LN2), t * (M = Math.pow(2, -x)) < 1 && (x--, M *= 2), (t += x + U >= 1 ? N / M : N * Math.pow(2, 1 - U)) * M >= 2 && (x++, M /= 2), x + U >= D ? (A = 0, x = D) : x + U >= 1 ? (A = (t * M - 1) * Math.pow(2, d), x += U) : (A = t * Math.pow(2, U - 1) * Math.pow(2, d), x = 0)); d >= 8; i[a + H] = 255 & A, H += X, A /= 256, d -= 8);
                    for (x = x << d | A, F += d; F > 0; i[a + H] = 255 & x, H += X, x /= 256, F -= 8);
                    i[a + H - X] |= 128 * ne
                };

            function Wn(i) {
                this.buf = ArrayBuffer.isView && ArrayBuffer.isView(i) ? i : new Uint8Array(i || 0), this.pos = 0, this.type = 0, this.length = this.buf.length
            }
            Wn.Varint = 0, Wn.Fixed64 = 1, Wn.Bytes = 2, Wn.Fixed32 = 5;
            var vh = 4294967296,
                td = 1 / vh,
                pu = typeof TextDecoder == "undefined" ? null : new TextDecoder("utf8");

            function qs(i) {
                return i.type === Wn.Bytes ? i.readVarint() + i.pos : i.pos + 1
            }

            function $s(i, t, a) {
                return a ? 4294967296 * t + (i >>> 0) : 4294967296 * (t >>> 0) + (i >>> 0)
            }

            function fu(i, t, a) {
                var l = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
                a.realloc(l);
                for (var d = a.pos - 1; d >= i; d--) a.buf[d + l] = a.buf[d]
            }

            function Xd(i, t) {
                for (var a = 0; a < i.length; a++) t.writeVarint(i[a])
            }

            function id(i, t) {
                for (var a = 0; a < i.length; a++) t.writeSVarint(i[a])
            }

            function _h(i, t) {
                for (var a = 0; a < i.length; a++) t.writeFloat(i[a])
            }

            function jd(i, t) {
                for (var a = 0; a < i.length; a++) t.writeDouble(i[a])
            }

            function nd(i, t) {
                for (var a = 0; a < i.length; a++) t.writeBoolean(i[a])
            }

            function rd(i, t) {
                for (var a = 0; a < i.length; a++) t.writeFixed32(i[a])
            }

            function ad(i, t) {
                for (var a = 0; a < i.length; a++) t.writeSFixed32(i[a])
            }

            function sd(i, t) {
                for (var a = 0; a < i.length; a++) t.writeFixed64(i[a])
            }

            function xh(i, t) {
                for (var a = 0; a < i.length; a++) t.writeSFixed64(i[a])
            }

            function bh(i, t) {
                return (i[t] | i[t + 1] << 8 | i[t + 2] << 16) + 16777216 * i[t + 3]
            }

            function Ko(i, t, a) {
                i[a] = t, i[a + 1] = t >>> 8, i[a + 2] = t >>> 16, i[a + 3] = t >>> 24
            }

            function bc(i, t) {
                return (i[t] | i[t + 1] << 8 | i[t + 2] << 16) + (i[t + 3] << 24)
            }
            Wn.prototype = {
                destroy: function() {
                    this.buf = null
                },
                readFields: function(i, t, a) {
                    for (a = a || this.length; this.pos < a;) {
                        var l = this.readVarint(),
                            d = l >> 3,
                            g = this.pos;
                        this.type = 7 & l, i(d, t, this), this.pos === g && this.skip(l)
                    }
                    return t
                },
                readMessage: function(i, t) {
                    return this.readFields(i, t, this.readVarint() + this.pos)
                },
                readFixed32: function() {
                    var i = bh(this.buf, this.pos);
                    return this.pos += 4, i
                },
                readSFixed32: function() {
                    var i = bc(this.buf, this.pos);
                    return this.pos += 4, i
                },
                readFixed64: function() {
                    var i = bh(this.buf, this.pos) + bh(this.buf, this.pos + 4) * vh;
                    return this.pos += 8, i
                },
                readSFixed64: function() {
                    var i = bh(this.buf, this.pos) + bc(this.buf, this.pos + 4) * vh;
                    return this.pos += 8, i
                },
                readFloat: function() {
                    var i = Ku(this.buf, this.pos, !0, 23, 4);
                    return this.pos += 4, i
                },
                readDouble: function() {
                    var i = Ku(this.buf, this.pos, !0, 52, 8);
                    return this.pos += 8, i
                },
                readVarint: function(i) {
                    var t, a, l = this.buf;
                    return t = 127 & (a = l[this.pos++]), a < 128 ? t : (t |= (127 & (a = l[this.pos++])) << 7, a < 128 ? t : (t |= (127 & (a = l[this.pos++])) << 14, a < 128 ? t : (t |= (127 & (a = l[this.pos++])) << 21, a < 128 ? t : function(d, g, x) {
                        var A, M, F = x.buf;
                        if (A = (112 & (M = F[x.pos++])) >> 4, M < 128 || (A |= (127 & (M = F[x.pos++])) << 3, M < 128) || (A |= (127 & (M = F[x.pos++])) << 10, M < 128) || (A |= (127 & (M = F[x.pos++])) << 17, M < 128) || (A |= (127 & (M = F[x.pos++])) << 24, M < 128) || (A |= (1 & (M = F[x.pos++])) << 31, M < 128)) return $s(d, A, g);
                        throw new Error("Expected varint not more than 10 bytes")
                    }(t |= (15 & (a = l[this.pos])) << 28, i, this))))
                },
                readVarint64: function() {
                    return this.readVarint(!0)
                },
                readSVarint: function() {
                    var i = this.readVarint();
                    return i % 2 == 1 ? (i + 1) / -2 : i / 2
                },
                readBoolean: function() {
                    return !!this.readVarint()
                },
                readString: function() {
                    var i = this.readVarint() + this.pos,
                        t = this.pos;
                    return this.pos = i, i - t >= 12 && pu ? function(a, l, d) {
                        return pu.decode(a.subarray(l, d))
                    }(this.buf, t, i) : function(a, l, d) {
                        for (var g = "", x = l; x < d;) {
                            var A, M, F, D = a[x],
                                U = null,
                                N = D > 239 ? 4 : D > 223 ? 3 : D > 191 ? 2 : 1;
                            if (x + N > d) break;
                            N === 1 ? D < 128 && (U = D) : N === 2 ? (192 & (A = a[x + 1])) == 128 && (U = (31 & D) << 6 | 63 & A) <= 127 && (U = null) : N === 3 ? (M = a[x + 2], (192 & (A = a[x + 1])) == 128 && (192 & M) == 128 && ((U = (15 & D) << 12 | (63 & A) << 6 | 63 & M) <= 2047 || U >= 55296 && U <= 57343) && (U = null)) : N === 4 && (M = a[x + 2], F = a[x + 3], (192 & (A = a[x + 1])) == 128 && (192 & M) == 128 && (192 & F) == 128 && ((U = (15 & D) << 18 | (63 & A) << 12 | (63 & M) << 6 | 63 & F) <= 65535 || U >= 1114112) && (U = null)), U === null ? (U = 65533, N = 1) : U > 65535 && (U -= 65536, g += String.fromCharCode(U >>> 10 & 1023 | 55296), U = 56320 | 1023 & U), g += String.fromCharCode(U), x += N
                        }
                        return g
                    }(this.buf, t, i)
                },
                readBytes: function() {
                    var i = this.readVarint() + this.pos,
                        t = this.buf.subarray(this.pos, i);
                    return this.pos = i, t
                },
                readPackedVarint: function(i, t) {
                    if (this.type !== Wn.Bytes) return i.push(this.readVarint(t));
                    var a = qs(this);
                    for (i = i || []; this.pos < a;) i.push(this.readVarint(t));
                    return i
                },
                readPackedSVarint: function(i) {
                    if (this.type !== Wn.Bytes) return i.push(this.readSVarint());
                    var t = qs(this);
                    for (i = i || []; this.pos < t;) i.push(this.readSVarint());
                    return i
                },
                readPackedBoolean: function(i) {
                    if (this.type !== Wn.Bytes) return i.push(this.readBoolean());
                    var t = qs(this);
                    for (i = i || []; this.pos < t;) i.push(this.readBoolean());
                    return i
                },
                readPackedFloat: function(i) {
                    if (this.type !== Wn.Bytes) return i.push(this.readFloat());
                    var t = qs(this);
                    for (i = i || []; this.pos < t;) i.push(this.readFloat());
                    return i
                },
                readPackedDouble: function(i) {
                    if (this.type !== Wn.Bytes) return i.push(this.readDouble());
                    var t = qs(this);
                    for (i = i || []; this.pos < t;) i.push(this.readDouble());
                    return i
                },
                readPackedFixed32: function(i) {
                    if (this.type !== Wn.Bytes) return i.push(this.readFixed32());
                    var t = qs(this);
                    for (i = i || []; this.pos < t;) i.push(this.readFixed32());
                    return i
                },
                readPackedSFixed32: function(i) {
                    if (this.type !== Wn.Bytes) return i.push(this.readSFixed32());
                    var t = qs(this);
                    for (i = i || []; this.pos < t;) i.push(this.readSFixed32());
                    return i
                },
                readPackedFixed64: function(i) {
                    if (this.type !== Wn.Bytes) return i.push(this.readFixed64());
                    var t = qs(this);
                    for (i = i || []; this.pos < t;) i.push(this.readFixed64());
                    return i
                },
                readPackedSFixed64: function(i) {
                    if (this.type !== Wn.Bytes) return i.push(this.readSFixed64());
                    var t = qs(this);
                    for (i = i || []; this.pos < t;) i.push(this.readSFixed64());
                    return i
                },
                skip: function(i) {
                    var t = 7 & i;
                    if (t === Wn.Varint)
                        for (; this.buf[this.pos++] > 127;);
                    else if (t === Wn.Bytes) this.pos = this.readVarint() + this.pos;
                    else if (t === Wn.Fixed32) this.pos += 4;
                    else {
                        if (t !== Wn.Fixed64) throw new Error("Unimplemented type: " + t);
                        this.pos += 8
                    }
                },
                writeTag: function(i, t) {
                    this.writeVarint(i << 3 | t)
                },
                realloc: function(i) {
                    for (var t = this.length || 16; t < this.pos + i;) t *= 2;
                    if (t !== this.length) {
                        var a = new Uint8Array(t);
                        a.set(this.buf), this.buf = a, this.length = t
                    }
                },
                finish: function() {
                    return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length)
                },
                writeFixed32: function(i) {
                    this.realloc(4), Ko(this.buf, i, this.pos), this.pos += 4
                },
                writeSFixed32: function(i) {
                    this.realloc(4), Ko(this.buf, i, this.pos), this.pos += 4
                },
                writeFixed64: function(i) {
                    this.realloc(8), Ko(this.buf, -1 & i, this.pos), Ko(this.buf, Math.floor(i * td), this.pos + 4), this.pos += 8
                },
                writeSFixed64: function(i) {
                    this.realloc(8), Ko(this.buf, -1 & i, this.pos), Ko(this.buf, Math.floor(i * td), this.pos + 4), this.pos += 8
                },
                writeVarint: function(i) {
                    (i = +i || 0) > 268435455 || i < 0 ? function(t, a) {
                        var l, d;
                        if (t >= 0 ? (l = t % 4294967296 | 0, d = t / 4294967296 | 0) : (d = ~(-t / 4294967296), 4294967295 ^ (l = ~(-t % 4294967296)) ? l = l + 1 | 0 : (l = 0, d = d + 1 | 0)), t >= 18446744073709552e3 || t < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
                        a.realloc(10),
                            function(g, x, A) {
                                A.buf[A.pos++] = 127 & g | 128, g >>>= 7, A.buf[A.pos++] = 127 & g | 128, g >>>= 7, A.buf[A.pos++] = 127 & g | 128, g >>>= 7, A.buf[A.pos++] = 127 & g | 128, A.buf[A.pos] = 127 & (g >>>= 7)
                            }(l, 0, a),
                            function(g, x) {
                                var A = (7 & g) << 4;
                                x.buf[x.pos++] |= A | ((g >>>= 3) ? 128 : 0), g && (x.buf[x.pos++] = 127 & g | ((g >>>= 7) ? 128 : 0), g && (x.buf[x.pos++] = 127 & g | ((g >>>= 7) ? 128 : 0), g && (x.buf[x.pos++] = 127 & g | ((g >>>= 7) ? 128 : 0), g && (x.buf[x.pos++] = 127 & g | ((g >>>= 7) ? 128 : 0), g && (x.buf[x.pos++] = 127 & g)))))
                            }(d, a)
                    }(i, this) : (this.realloc(4), this.buf[this.pos++] = 127 & i | (i > 127 ? 128 : 0), i <= 127 || (this.buf[this.pos++] = 127 & (i >>>= 7) | (i > 127 ? 128 : 0), i <= 127 || (this.buf[this.pos++] = 127 & (i >>>= 7) | (i > 127 ? 128 : 0), i <= 127 || (this.buf[this.pos++] = i >>> 7 & 127))))
                },
                writeSVarint: function(i) {
                    this.writeVarint(i < 0 ? 2 * -i - 1 : 2 * i)
                },
                writeBoolean: function(i) {
                    this.writeVarint(!!i)
                },
                writeString: function(i) {
                    i = String(i), this.realloc(4 * i.length), this.pos++;
                    var t = this.pos;
                    this.pos = function(l, d, g) {
                        for (var x, A, M = 0; M < d.length; M++) {
                            if ((x = d.charCodeAt(M)) > 55295 && x < 57344) {
                                if (!A) {
                                    x > 56319 || M + 1 === d.length ? (l[g++] = 239, l[g++] = 191, l[g++] = 189) : A = x;
                                    continue
                                }
                                if (x < 56320) {
                                    l[g++] = 239, l[g++] = 191, l[g++] = 189, A = x;
                                    continue
                                }
                                x = A - 55296 << 10 | x - 56320 | 65536, A = null
                            } else A && (l[g++] = 239, l[g++] = 191, l[g++] = 189, A = null);
                            x < 128 ? l[g++] = x : (x < 2048 ? l[g++] = x >> 6 | 192 : (x < 65536 ? l[g++] = x >> 12 | 224 : (l[g++] = x >> 18 | 240, l[g++] = x >> 12 & 63 | 128), l[g++] = x >> 6 & 63 | 128), l[g++] = 63 & x | 128)
                        }
                        return g
                    }(this.buf, i, this.pos);
                    var a = this.pos - t;
                    a >= 128 && fu(t, a, this), this.pos = t - 1, this.writeVarint(a), this.pos += a
                },
                writeFloat: function(i) {
                    this.realloc(4), ed(this.buf, i, this.pos, !0, 23, 4), this.pos += 4
                },
                writeDouble: function(i) {
                    this.realloc(8), ed(this.buf, i, this.pos, !0, 52, 8), this.pos += 8
                },
                writeBytes: function(i) {
                    var t = i.length;
                    this.writeVarint(t), this.realloc(t);
                    for (var a = 0; a < t; a++) this.buf[this.pos++] = i[a]
                },
                writeRawMessage: function(i, t) {
                    this.pos++;
                    var a = this.pos;
                    i(t, this);
                    var l = this.pos - a;
                    l >= 128 && fu(a, l, this), this.pos = a - 1, this.writeVarint(l), this.pos += l
                },
                writeMessage: function(i, t, a) {
                    this.writeTag(i, Wn.Bytes), this.writeRawMessage(t, a)
                },
                writePackedVarint: function(i, t) {
                    t.length && this.writeMessage(i, Xd, t)
                },
                writePackedSVarint: function(i, t) {
                    t.length && this.writeMessage(i, id, t)
                },
                writePackedBoolean: function(i, t) {
                    t.length && this.writeMessage(i, nd, t)
                },
                writePackedFloat: function(i, t) {
                    t.length && this.writeMessage(i, _h, t)
                },
                writePackedDouble: function(i, t) {
                    t.length && this.writeMessage(i, jd, t)
                },
                writePackedFixed32: function(i, t) {
                    t.length && this.writeMessage(i, rd, t)
                },
                writePackedSFixed32: function(i, t) {
                    t.length && this.writeMessage(i, ad, t)
                },
                writePackedFixed64: function(i, t) {
                    t.length && this.writeMessage(i, sd, t)
                },
                writePackedSFixed64: function(i, t) {
                    t.length && this.writeMessage(i, xh, t)
                },
                writeBytesField: function(i, t) {
                    this.writeTag(i, Wn.Bytes), this.writeBytes(t)
                },
                writeFixed32Field: function(i, t) {
                    this.writeTag(i, Wn.Fixed32), this.writeFixed32(t)
                },
                writeSFixed32Field: function(i, t) {
                    this.writeTag(i, Wn.Fixed32), this.writeSFixed32(t)
                },
                writeFixed64Field: function(i, t) {
                    this.writeTag(i, Wn.Fixed64), this.writeFixed64(t)
                },
                writeSFixed64Field: function(i, t) {
                    this.writeTag(i, Wn.Fixed64), this.writeSFixed64(t)
                },
                writeVarintField: function(i, t) {
                    this.writeTag(i, Wn.Varint), this.writeVarint(t)
                },
                writeSVarintField: function(i, t) {
                    this.writeTag(i, Wn.Varint), this.writeSVarint(t)
                },
                writeStringField: function(i, t) {
                    this.writeTag(i, Wn.Bytes), this.writeString(t)
                },
                writeFloatField: function(i, t) {
                    this.writeTag(i, Wn.Fixed32), this.writeFloat(t)
                },
                writeDoubleField: function(i, t) {
                    this.writeTag(i, Wn.Fixed64), this.writeDouble(t)
                },
                writeBooleanField: function(i, t) {
                    this.writeVarintField(i, !!t)
                }
            };
            var wc = se(du);
            const mu = 3;

            function Ap(i, t, a) {
                i === 1 && a.readMessage(Yd, t)
            }

            function Yd(i, t, a) {
                if (i === 3) {
                    const {
                        id: l,
                        bitmap: d,
                        width: g,
                        height: x,
                        left: A,
                        top: M,
                        advance: F
                    } = a.readMessage(qd, {});
                    t.push({
                        id: l,
                        bitmap: new ih({
                            width: g + 2 * mu,
                            height: x + 2 * mu
                        }, d),
                        metrics: {
                            width: g,
                            height: x,
                            left: A,
                            top: M,
                            advance: F
                        }
                    })
                }
            }

            function qd(i, t, a) {
                i === 1 ? t.id = a.readVarint() : i === 2 ? t.bitmap = a.readBytes() : i === 3 ? t.width = a.readVarint() : i === 4 ? t.height = a.readVarint() : i === 5 ? t.left = a.readSVarint() : i === 6 ? t.top = a.readSVarint() : i === 7 && (t.advance = a.readVarint())
            }
            const gu = mu;

            function od(i) {
                let t = 0,
                    a = 0;
                for (const x of i) t += x.w * x.h, a = Math.max(a, x.w);
                i.sort((x, A) => A.h - x.h);
                const l = [{
                    x: 0,
                    y: 0,
                    w: Math.max(Math.ceil(Math.sqrt(t / .95)), a),
                    h: 1 / 0
                }];
                let d = 0,
                    g = 0;
                for (const x of i)
                    for (let A = l.length - 1; A >= 0; A--) {
                        const M = l[A];
                        if (!(x.w > M.w || x.h > M.h)) {
                            if (x.x = M.x, x.y = M.y, g = Math.max(g, x.y + x.h), d = Math.max(d, x.x + x.w), x.w === M.w && x.h === M.h) {
                                const F = l.pop();
                                A < l.length && (l[A] = F)
                            } else x.h === M.h ? (M.x += x.w, M.w -= x.w) : x.w === M.w ? (M.y += x.h, M.h -= x.h) : (l.push({
                                x: M.x + x.w,
                                y: M.y,
                                w: M.w - x.w,
                                h: x.h
                            }), M.y += x.h, M.h -= x.h);
                            break
                        }
                    }
                return {
                    w: d,
                    h: g,
                    fill: t / (d * g) || 0
                }
            }
            const Ma = 1;
            class ld {
                constructor(t, {
                    pixelRatio: a,
                    version: l,
                    stretchX: d,
                    stretchY: g,
                    content: x
                }) {
                    this.paddedRect = t, this.pixelRatio = a, this.stretchX = d, this.stretchY = g, this.content = x, this.version = l
                }
                get tl() {
                    return [this.paddedRect.x + Ma, this.paddedRect.y + Ma]
                }
                get br() {
                    return [this.paddedRect.x + this.paddedRect.w - Ma, this.paddedRect.y + this.paddedRect.h - Ma]
                }
                get tlbr() {
                    return this.tl.concat(this.br)
                }
                get displaySize() {
                    return [(this.paddedRect.w - 2 * Ma) / this.pixelRatio, (this.paddedRect.h - 2 * Ma) / this.pixelRatio]
                }
            }
            class wh {
                constructor(t, a) {
                    const l = {},
                        d = {};
                    this.haveRenderCallbacks = [];
                    const g = [];
                    this.addImages(t, l, g), this.addImages(a, d, g);
                    const {
                        w: x,
                        h: A
                    } = od(g), M = new es({
                        width: x || 1,
                        height: A || 1
                    });
                    for (const F in t) {
                        const D = t[F],
                            U = l[F].paddedRect;
                        es.copy(D.data, M, {
                            x: 0,
                            y: 0
                        }, {
                            x: U.x + Ma,
                            y: U.y + Ma
                        }, D.data)
                    }
                    for (const F in a) {
                        const D = a[F],
                            U = d[F].paddedRect,
                            N = U.x + Ma,
                            H = U.y + Ma,
                            X = D.data.width,
                            ne = D.data.height;
                        es.copy(D.data, M, {
                            x: 0,
                            y: 0
                        }, {
                            x: N,
                            y: H
                        }, D.data), es.copy(D.data, M, {
                            x: 0,
                            y: ne - 1
                        }, {
                            x: N,
                            y: H - 1
                        }, {
                            width: X,
                            height: 1
                        }), es.copy(D.data, M, {
                            x: 0,
                            y: 0
                        }, {
                            x: N,
                            y: H + ne
                        }, {
                            width: X,
                            height: 1
                        }), es.copy(D.data, M, {
                            x: X - 1,
                            y: 0
                        }, {
                            x: N - 1,
                            y: H
                        }, {
                            width: 1,
                            height: ne
                        }), es.copy(D.data, M, {
                            x: 0,
                            y: 0
                        }, {
                            x: N + X,
                            y: H
                        }, {
                            width: 1,
                            height: ne
                        })
                    }
                    this.image = M, this.iconPositions = l, this.patternPositions = d
                }
                addImages(t, a, l) {
                    for (const d in t) {
                        const g = t[d],
                            x = {
                                x: 0,
                                y: 0,
                                w: g.data.width + 2 * Ma,
                                h: g.data.height + 2 * Ma
                            };
                        l.push(x), a[d] = new ld(x, g), g.hasRenderCallback && this.haveRenderCallbacks.push(d)
                    }
                }
                patchUpdatedImages(t, a) {
                    t.dispatchRenderCallbacks(this.haveRenderCallbacks);
                    for (const l in t.updatedImages) this.patchUpdatedImage(this.iconPositions[l], t.getImage(l), a), this.patchUpdatedImage(this.patternPositions[l], t.getImage(l), a)
                }
                patchUpdatedImage(t, a, l) {
                    if (!t || !a || t.version === a.version) return;
                    t.version = a.version;
                    const [d, g] = t.tl;
                    l.update(a.data, void 0, {
                        x: d,
                        y: g
                    })
                }
            }
            var Ks;
            Ii("ImagePosition", ld), Ii("ImageAtlas", wh), C.ah = void 0, (Ks = C.ah || (C.ah = {}))[Ks.none = 0] = "none", Ks[Ks.horizontal = 1] = "horizontal", Ks[Ks.vertical = 2] = "vertical", Ks[Ks.horizontalOnly = 3] = "horizontalOnly";
            const Ec = -17;
            class Sc {
                constructor() {
                    this.scale = 1, this.fontStack = "", this.imageName = null
                }
                static forText(t, a) {
                    const l = new Sc;
                    return l.scale = t || 1, l.fontStack = a, l
                }
                static forImage(t) {
                    const a = new Sc;
                    return a.imageName = t, a
                }
            }
            class Ll {
                constructor() {
                    this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null
                }
                static fromFeature(t, a) {
                    const l = new Ll;
                    for (let d = 0; d < t.sections.length; d++) {
                        const g = t.sections[d];
                        g.image ? l.addImageSection(g) : l.addTextSection(g, a)
                    }
                    return l
                }
                length() {
                    return this.text.length
                }
                getSection(t) {
                    return this.sections[this.sectionIndex[t]]
                }
                getSectionIndex(t) {
                    return this.sectionIndex[t]
                }
                getCharCode(t) {
                    return this.text.charCodeAt(t)
                }
                verticalizePunctuation() {
                    this.text = function(t) {
                        let a = "";
                        for (let l = 0; l < t.length; l++) {
                            const d = t.charCodeAt(l + 1) || null,
                                g = t.charCodeAt(l - 1) || null;
                            a += d && ql(d) && !us[t[l + 1]] || g && ql(g) && !us[t[l - 1]] || !us[t[l]] ? t[l] : us[t[l]]
                        }
                        return a
                    }(this.text)
                }
                trim() {
                    let t = 0;
                    for (let l = 0; l < this.text.length && Sh[this.text.charCodeAt(l)]; l++) t++;
                    let a = this.text.length;
                    for (let l = this.text.length - 1; l >= 0 && l >= t && Sh[this.text.charCodeAt(l)]; l--) a--;
                    this.text = this.text.substring(t, a), this.sectionIndex = this.sectionIndex.slice(t, a)
                }
                substring(t, a) {
                    const l = new Ll;
                    return l.text = this.text.substring(t, a), l.sectionIndex = this.sectionIndex.slice(t, a), l.sections = this.sections, l
                }
                toString() {
                    return this.text
                }
                getMaxScale() {
                    return this.sectionIndex.reduce((t, a) => Math.max(t, this.sections[a].scale), 0)
                }
                addTextSection(t, a) {
                    this.text += t.text, this.sections.push(Sc.forText(t.scale, t.fontStack || a));
                    const l = this.sections.length - 1;
                    for (let d = 0; d < t.text.length; ++d) this.sectionIndex.push(l)
                }
                addImageSection(t) {
                    const a = t.image ? t.image.name : "";
                    if (a.length === 0) return void li("Can't add FormattedSection with an empty image.");
                    const l = this.getNextImageSectionCharCode();
                    l ? (this.text += String.fromCharCode(l), this.sections.push(Sc.forImage(a)), this.sectionIndex.push(this.sections.length - 1)) : li("Reached maximum number of images 6401")
                }
                getNextImageSectionCharCode() {
                    return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID)
                }
            }

            function Eh(i, t, a, l, d, g, x, A, M, F, D, U, N, H, X, ne) {
                const le = Ll.fromFeature(i, d);
                let ce;
                U === C.ah.vertical && le.verticalizePunctuation();
                const {
                    processBidirectionalText: Qe,
                    processStyledBidirectionalText: Se
                } = co;
                if (Qe && le.sections.length === 1) {
                    ce = [];
                    const dt = Qe(le.toString(), Ah(le, F, g, t, l, H, X));
                    for (const Ct of dt) {
                        const Nt = new Ll;
                        Nt.text = Ct, Nt.sections = le.sections;
                        for (let qt = 0; qt < Ct.length; qt++) Nt.sectionIndex.push(0);
                        ce.push(Nt)
                    }
                } else if (Se) {
                    ce = [];
                    const dt = Se(le.text, le.sectionIndex, Ah(le, F, g, t, l, H, X));
                    for (const Ct of dt) {
                        const Nt = new Ll;
                        Nt.text = Ct[0], Nt.sectionIndex = Ct[1], Nt.sections = le.sections, ce.push(Nt)
                    }
                } else ce = function(dt, Ct) {
                    const Nt = [],
                        qt = dt.text;
                    let Fe = 0;
                    for (const Be of Ct) Nt.push(dt.substring(Fe, Be)), Fe = Be;
                    return Fe < qt.length && Nt.push(dt.substring(Fe, qt.length)), Nt
                }(le, Ah(le, F, g, t, l, H, X));
                const Re = [],
                    ot = {
                        positionedLines: Re,
                        text: le.toString(),
                        top: D[1],
                        bottom: D[1],
                        left: D[0],
                        right: D[0],
                        writingMode: U,
                        iconsInText: !1,
                        verticalizable: !1
                    };
                return function(dt, Ct, Nt, qt, Fe, Be, mt, lt, Xe, Zt, Ie, pt) {
                    let xt = 0,
                        Gt = Ec,
                        Xt = 0,
                        hi = 0;
                    const _i = lt === "right" ? 1 : lt === "left" ? 0 : .5;
                    let Di = 0;
                    for (const Kn of Fe) {
                        Kn.trim();
                        const er = Kn.getMaxScale(),
                            ia = (er - 1) * Xn,
                            oa = {
                                positionedGlyphs: [],
                                lineOffset: 0
                            };
                        dt.positionedLines[Di] = oa;
                        const tr = oa.positionedGlyphs;
                        let jn = 0;
                        if (!Kn.length()) {
                            Gt += Be, ++Di;
                            continue
                        }
                        for (let Yr = 0; Yr < Kn.length(); Yr++) {
                            const Tn = Kn.getSection(Yr),
                                mr = Kn.getSectionIndex(Yr),
                                fa = Kn.getCharCode(Yr);
                            let qr = 0,
                                rs = null,
                                as = null,
                                ps = null,
                                to = Xn;
                            const ba = !(Xe === C.ah.horizontal || !Ie && !Yl(fa) || Ie && (Sh[fa] || (nn = fa, Ti.Arabic(nn) || Ti["Arabic Supplement"](nn) || Ti["Arabic Extended-A"](nn) || Ti["Arabic Presentation Forms-A"](nn) || Ti["Arabic Presentation Forms-B"](nn))));
                            if (Tn.imageName) {
                                const Za = qt[Tn.imageName];
                                if (!Za) continue;
                                ps = Tn.imageName, dt.iconsInText = dt.iconsInText || !0, as = Za.paddedRect;
                                const Pa = Za.displaySize;
                                Tn.scale = Tn.scale * Xn / pt, rs = {
                                    width: Pa[0],
                                    height: Pa[1],
                                    left: Ma,
                                    top: -gu,
                                    advance: ba ? Pa[1] : Pa[0]
                                }, qr = ia + (Xn - Pa[1] * Tn.scale), to = rs.advance;
                                const io = ba ? Pa[0] * Tn.scale - Xn * er : Pa[1] * Tn.scale - Xn * er;
                                io > 0 && io > jn && (jn = io)
                            } else {
                                const Za = Nt[Tn.fontStack],
                                    Pa = Za && Za[fa];
                                if (Pa && Pa.rect) as = Pa.rect, rs = Pa.metrics;
                                else {
                                    const io = Ct[Tn.fontStack],
                                        Dl = io && io[fa];
                                    if (!Dl) continue;
                                    rs = Dl.metrics
                                }
                                qr = (er - Tn.scale) * Xn
                            }
                            ba ? (dt.verticalizable = !0, tr.push({
                                glyph: fa,
                                imageName: ps,
                                x: xt,
                                y: Gt + qr,
                                vertical: ba,
                                scale: Tn.scale,
                                fontStack: Tn.fontStack,
                                sectionIndex: mr,
                                metrics: rs,
                                rect: as
                            }), xt += to * Tn.scale + Zt) : (tr.push({
                                glyph: fa,
                                imageName: ps,
                                x: xt,
                                y: Gt + qr,
                                vertical: ba,
                                scale: Tn.scale,
                                fontStack: Tn.fontStack,
                                sectionIndex: mr,
                                metrics: rs,
                                rect: as
                            }), xt += rs.advance * Tn.scale + Zt)
                        }
                        tr.length !== 0 && (Xt = Math.max(xt - Zt, Xt), tp(tr, 0, tr.length - 1, _i, jn)), xt = 0;
                        const fi = Be * er + jn;
                        oa.lineOffset = Math.max(jn, ia), Gt += fi, hi = Math.max(fi, hi), ++Di
                    }
                    var nn;
                    const Fi = Gt - Ec,
                        {
                            horizontalAlign: tn,
                            verticalAlign: gn
                        } = Eo(mt);
                    (function(Kn, er, ia, oa, tr, jn, fi, Yr, Tn) {
                        const mr = (er - ia) * tr;
                        let fa = 0;
                        fa = jn !== fi ? -Yr * oa - Ec : (-oa * Tn + .5) * fi;
                        for (const qr of Kn)
                            for (const rs of qr.positionedGlyphs) rs.x += mr, rs.y += fa
                    })(dt.positionedLines, _i, tn, gn, Xt, hi, Be, Fi, Fe.length), dt.top += -gn * Fi, dt.bottom = dt.top + Fi, dt.left += -tn * Xt, dt.right = dt.left + Xt
                }(ot, t, a, l, ce, x, A, M, U, F, N, ne), ! function(dt) {
                    for (const Ct of dt)
                        if (Ct.positionedGlyphs.length !== 0) return !1;
                    return !0
                }(Re) && ot
            }
            const Sh = {
                    9: !0,
                    10: !0,
                    11: !0,
                    12: !0,
                    13: !0,
                    32: !0
                },
                $d = {
                    10: !0,
                    32: !0,
                    38: !0,
                    40: !0,
                    41: !0,
                    43: !0,
                    45: !0,
                    47: !0,
                    173: !0,
                    183: !0,
                    8203: !0,
                    8208: !0,
                    8211: !0,
                    8231: !0
                };

            function cd(i, t, a, l, d, g) {
                if (t.imageName) {
                    const x = l[t.imageName];
                    return x ? x.displaySize[0] * t.scale * Xn / g + d : 0
                } {
                    const x = a[t.fontStack],
                        A = x && x[i];
                    return A ? A.metrics.advance * t.scale + d : 0
                }
            }

            function el(i, t, a, l) {
                const d = Math.pow(i - t, 2);
                return l ? i < t ? d / 2 : 2 * d : d + Math.abs(a) * a
            }

            function Kd(i, t, a) {
                let l = 0;
                return i === 10 && (l -= 1e4), a && (l += 150), i !== 40 && i !== 65288 || (l += 50), t !== 41 && t !== 65289 || (l += 50), l
            }

            function ep(i, t, a, l, d, g) {
                let x = null,
                    A = el(t, a, d, g);
                for (const M of l) {
                    const F = el(t - M.x, a, d, g) + M.badness;
                    F <= A && (x = M, A = F)
                }
                return {
                    index: i,
                    x: t,
                    priorBreak: x,
                    badness: A
                }
            }

            function tl(i) {
                return i ? tl(i.priorBreak).concat(i.index) : []
            }

            function Ah(i, t, a, l, d, g, x) {
                if (g !== "point") return [];
                if (!i) return [];
                const A = [],
                    M = function(N, H, X, ne, le, ce) {
                        let Qe = 0;
                        for (let Se = 0; Se < N.length(); Se++) {
                            const Re = N.getSection(Se);
                            Qe += cd(N.getCharCode(Se), Re, ne, le, H, ce)
                        }
                        return Qe / Math.max(1, Math.ceil(Qe / X))
                    }(i, t, a, l, d, x),
                    F = i.text.indexOf("") >= 0;
                let D = 0;
                for (let N = 0; N < i.length(); N++) {
                    const H = i.getSection(N),
                        X = i.getCharCode(N);
                    if (Sh[X] || (D += cd(X, H, l, d, t, x)), N < i.length() - 1) {
                        const ne = !((U = X) < 11904 || !(Ti["Bopomofo Extended"](U) || Ti.Bopomofo(U) || Ti["CJK Compatibility Forms"](U) || Ti["CJK Compatibility Ideographs"](U) || Ti["CJK Compatibility"](U) || Ti["CJK Radicals Supplement"](U) || Ti["CJK Strokes"](U) || Ti["CJK Symbols and Punctuation"](U) || Ti["CJK Unified Ideographs Extension A"](U) || Ti["CJK Unified Ideographs"](U) || Ti["Enclosed CJK Letters and Months"](U) || Ti["Halfwidth and Fullwidth Forms"](U) || Ti.Hiragana(U) || Ti["Ideographic Description Characters"](U) || Ti["Kangxi Radicals"](U) || Ti["Katakana Phonetic Extensions"](U) || Ti.Katakana(U) || Ti["Vertical Forms"](U) || Ti["Yi Radicals"](U) || Ti["Yi Syllables"](U)));
                        ($d[X] || ne || H.imageName) && A.push(ep(N + 1, D, M, A, Kd(X, i.getCharCode(N + 1), ne && F), !1))
                    }
                }
                var U;
                return tl(ep(i.length(), D, M, A, 0, !0))
            }

            function Eo(i) {
                let t = .5,
                    a = .5;
                switch (i) {
                    case "right":
                    case "top-right":
                    case "bottom-right":
                        t = 1;
                        break;
                    case "left":
                    case "top-left":
                    case "bottom-left":
                        t = 0
                }
                switch (i) {
                    case "bottom":
                    case "bottom-right":
                    case "bottom-left":
                        a = 1;
                        break;
                    case "top":
                    case "top-right":
                    case "top-left":
                        a = 0
                }
                return {
                    horizontalAlign: t,
                    verticalAlign: a
                }
            }

            function tp(i, t, a, l, d) {
                if (!l && !d) return;
                const g = i[a],
                    x = (i[a].x + g.metrics.advance * g.scale) * l;
                for (let A = t; A <= a; A++) i[A].x -= x, i[A].y += d
            }

            function Tp(i, t, a) {
                const {
                    horizontalAlign: l,
                    verticalAlign: d
                } = Eo(a), g = t[0] - i.displaySize[0] * l, x = t[1] - i.displaySize[1] * d;
                return {
                    image: i,
                    top: x,
                    bottom: x + i.displaySize[1],
                    left: g,
                    right: g + i.displaySize[0]
                }
            }

            function il(i, t, a, l, d, g) {
                const x = i.image;
                let A;
                if (x.content) {
                    const le = x.content,
                        ce = x.pixelRatio || 1;
                    A = [le[0] / ce, le[1] / ce, x.displaySize[0] - le[2] / ce, x.displaySize[1] - le[3] / ce]
                }
                const M = t.left * g,
                    F = t.right * g;
                let D, U, N, H;
                a === "width" || a === "both" ? (H = d[0] + M - l[3], U = d[0] + F + l[1]) : (H = d[0] + (M + F - x.displaySize[0]) / 2, U = H + x.displaySize[0]);
                const X = t.top * g,
                    ne = t.bottom * g;
                return a === "height" || a === "both" ? (D = d[1] + X - l[0], N = d[1] + ne + l[2]) : (D = d[1] + (X + ne - x.displaySize[1]) / 2, N = D + x.displaySize[1]), {
                    image: x,
                    top: D,
                    right: U,
                    bottom: N,
                    left: H,
                    collisionPadding: A
                }
            }
            const Ac = 255,
                Rs = 128,
                nl = Ac * Rs;

            function ip(i, t) {
                const {
                    expression: a
                } = t;
                if (a.kind === "constant") return {
                    kind: "constant",
                    layoutSize: a.evaluate(new cr(i + 1))
                };
                if (a.kind === "source") return {
                    kind: "source"
                };
                {
                    const {
                        zoomStops: l,
                        interpolationType: d
                    } = a;
                    let g = 0;
                    for (; g < l.length && l[g] <= i;) g++;
                    g = Math.max(0, g - 1);
                    let x = g;
                    for (; x < l.length && l[x] < i + 1;) x++;
                    x = Math.min(l.length - 1, x);
                    const A = l[g],
                        M = l[x];
                    return a.kind === "composite" ? {
                        kind: "composite",
                        minZoom: A,
                        maxZoom: M,
                        interpolationType: d
                    } : {
                        kind: "camera",
                        minZoom: A,
                        maxZoom: M,
                        minSize: a.evaluate(new cr(A)),
                        maxSize: a.evaluate(new cr(M)),
                        interpolationType: d
                    }
                }
            }

            function Th(i, t, a) {
                let l = "never";
                const d = i.get(t);
                return d ? l = d : i.get(a) && (l = "always"), l
            }
            const Mp = Cs.VectorTileFeature.types,
                Cp = [{
                    name: "a_fade_opacity",
                    components: 1,
                    type: "Uint8",
                    offset: 0
                }];

            function yu(i, t, a, l, d, g, x, A, M, F, D, U, N) {
                const H = A ? Math.min(nl, Math.round(A[0])) : 0,
                    X = A ? Math.min(nl, Math.round(A[1])) : 0;
                i.emplaceBack(t, a, Math.round(32 * l), Math.round(32 * d), g, x, (H << 1) + (M ? 1 : 0), X, 16 * F, 16 * D, 256 * U, 256 * N)
            }

            function hd(i, t, a) {
                i.emplaceBack(t.x, t.y, a), i.emplaceBack(t.x, t.y, a), i.emplaceBack(t.x, t.y, a), i.emplaceBack(t.x, t.y, a)
            }

            function Bp(i) {
                for (const t of i.sections)
                    if (Nh(t.text)) return !0;
                return !1
            }
            class ud {
                constructor(t) {
                    this.layoutVertexArray = new ze, this.indexArray = new ci, this.programConfigurations = t, this.segments = new Ki, this.dynamicLayoutVertexArray = new ut, this.opacityVertexArray = new St, this.hasVisibleVertices = !1, this.placedSymbolArray = new f
                }
                isEmpty() {
                    return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0
                }
                upload(t, a, l, d) {
                    this.isEmpty() || (l && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, cu.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, a), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, $u.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, Cp, !0), this.opacityVertexBuffer.itemSize = 1), (l || d) && this.programConfigurations.upload(t))
                }
                destroy() {
                    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy())
                }
            }
            Ii("SymbolBuffers", ud);
            class dd {
                constructor(t, a, l) {
                    this.layoutVertexArray = new t, this.layoutAttributes = a, this.indexArray = new l, this.segments = new Ki, this.collisionVertexArray = new Vt
                }
                upload(t) {
                    this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, hu.members, !0)
                }
                destroy() {
                    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy())
                }
            }
            Ii("CollisionBuffers", dd);
            class Ql {
                constructor(t) {
                    this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(x => x.id), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = Js([]), this.placementViewportMatrix = Js([]);
                    const a = this.layers[0]._unevaluatedLayout._values;
                    this.textSizeData = ip(this.zoom, a["text-size"]), this.iconSizeData = ip(this.zoom, a["icon-size"]);
                    const l = this.layers[0].layout,
                        d = l.get("symbol-sort-key"),
                        g = l.get("symbol-z-order");
                    this.canOverlap = Th(l, "text-overlap", "text-allow-overlap") !== "never" || Th(l, "icon-overlap", "icon-allow-overlap") !== "never" || l.get("text-ignore-placement") || l.get("icon-ignore-placement"), this.sortFeaturesByKey = g !== "viewport-y" && !d.isConstant(), this.sortFeaturesByY = (g === "viewport-y" || g === "auto" && !this.sortFeaturesByKey) && this.canOverlap, l.get("symbol-placement") === "point" && (this.writingModes = l.get("text-writing-mode").map(x => C.ah[x])), this.stateDependentLayerIds = this.layers.filter(x => x.isStateDependent()).map(x => x.id), this.sourceID = t.sourceID
                }
                createArrays() {
                    this.text = new ud(new ea(this.layers, this.zoom, t => /^text/.test(t))), this.icon = new ud(new ea(this.layers, this.zoom, t => /^icon/.test(t))), this.glyphOffsetArray = new L, this.lineVertexArray = new P, this.symbolInstances = new S, this.textAnchorOffsets = new G
                }
                calculateGlyphDependencies(t, a, l, d, g) {
                    for (let x = 0; x < t.length; x++)
                        if (a[t.charCodeAt(x)] = !0, (l || d) && g) {
                            const A = us[t.charAt(x)];
                            A && (a[A.charCodeAt(0)] = !0)
                        }
                }
                populate(t, a, l) {
                    const d = this.layers[0],
                        g = d.layout,
                        x = g.get("text-font"),
                        A = g.get("text-field"),
                        M = g.get("icon-image"),
                        F = (A.value.kind !== "constant" || A.value.value instanceof rr && !A.value.value.isEmpty() || A.value.value.toString().length > 0) && (x.value.kind !== "constant" || x.value.value.length > 0),
                        D = M.value.kind !== "constant" || !!M.value.value || Object.keys(M.parameters).length > 0,
                        U = g.get("symbol-sort-key");
                    if (this.features = [], !F && !D) return;
                    const N = a.iconDependencies,
                        H = a.glyphDependencies,
                        X = a.availableImages,
                        ne = new cr(this.zoom);
                    for (const {
                            feature: le,
                            id: ce,
                            index: Qe,
                            sourceLayerIndex: Se
                        }
                        of t) {
                        const Re = d._featureFilter.needGeometry,
                            ot = Ws(le, Re);
                        if (!d._featureFilter.filter(ne, ot, l)) continue;
                        let dt, Ct;
                        if (Re || (ot.geometry = Hs(le)), F) {
                            const qt = d.getValueAndResolveTokens("text-field", ot, l, X),
                                Fe = rr.factory(qt);
                            Bp(Fe) && (this.hasRTLText = !0), (!this.hasRTLText || co.getRTLTextPluginStatus() === "unavailable" || this.hasRTLText && co.isParsed()) && (dt = yh(Fe, d, ot))
                        }
                        if (D) {
                            const qt = d.getValueAndResolveTokens("icon-image", ot, l, X);
                            Ct = qt instanceof $r ? qt : $r.fromString(qt)
                        }
                        if (!dt && !Ct) continue;
                        const Nt = this.sortFeaturesByKey ? U.evaluate(ot, {}, l) : void 0;
                        if (this.features.push({
                                id: ce,
                                text: dt,
                                icon: Ct,
                                index: Qe,
                                sourceLayerIndex: Se,
                                geometry: ot.geometry,
                                properties: le.properties,
                                type: Mp[le.type],
                                sortKey: Nt
                            }), Ct && (N[Ct.name] = !0), dt) {
                            const qt = x.evaluate(ot, {}, l).join(","),
                                Fe = g.get("text-rotation-alignment") !== "viewport" && g.get("symbol-placement") !== "point";
                            this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(C.ah.vertical) >= 0;
                            for (const Be of dt.sections)
                                if (Be.image) N[Be.image.name] = !0;
                                else {
                                    const mt = jl(dt.toString()),
                                        lt = Be.fontStack || qt,
                                        Xe = H[lt] = H[lt] || {};
                                    this.calculateGlyphDependencies(Be.text, Xe, Fe, this.allowVerticalPlacement, mt)
                                }
                        }
                    }
                    g.get("symbol-placement") === "line" && (this.features = function(le) {
                        const ce = {},
                            Qe = {},
                            Se = [];
                        let Re = 0;

                        function ot(qt) {
                            Se.push(le[qt]), Re++
                        }

                        function dt(qt, Fe, Be) {
                            const mt = Qe[qt];
                            return delete Qe[qt], Qe[Fe] = mt, Se[mt].geometry[0].pop(), Se[mt].geometry[0] = Se[mt].geometry[0].concat(Be[0]), mt
                        }

                        function Ct(qt, Fe, Be) {
                            const mt = ce[Fe];
                            return delete ce[Fe], ce[qt] = mt, Se[mt].geometry[0].shift(), Se[mt].geometry[0] = Be[0].concat(Se[mt].geometry[0]), mt
                        }

                        function Nt(qt, Fe, Be) {
                            const mt = Be ? Fe[0][Fe[0].length - 1] : Fe[0][0];
                            return `${qt}:${mt.x}:${mt.y}`
                        }
                        for (let qt = 0; qt < le.length; qt++) {
                            const Fe = le[qt],
                                Be = Fe.geometry,
                                mt = Fe.text ? Fe.text.toString() : null;
                            if (!mt) {
                                ot(qt);
                                continue
                            }
                            const lt = Nt(mt, Be),
                                Xe = Nt(mt, Be, !0);
                            if (lt in Qe && Xe in ce && Qe[lt] !== ce[Xe]) {
                                const Zt = Ct(lt, Xe, Be),
                                    Ie = dt(lt, Xe, Se[Zt].geometry);
                                delete ce[lt], delete Qe[Xe], Qe[Nt(mt, Se[Ie].geometry, !0)] = Ie, Se[Zt].geometry = null
                            } else lt in Qe ? dt(lt, Xe, Be) : Xe in ce ? Ct(lt, Xe, Be) : (ot(qt), ce[lt] = Re - 1, Qe[Xe] = Re - 1)
                        }
                        return Se.filter(qt => qt.geometry)
                    }(this.features)), this.sortFeaturesByKey && this.features.sort((le, ce) => le.sortKey - ce.sortKey)
                }
                update(t, a, l) {
                    this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, a, this.layers, l), this.icon.programConfigurations.updatePaintArrays(t, a, this.layers, l))
                }
                isEmpty() {
                    return this.symbolInstances.length === 0 && !this.hasRTLText
                }
                uploadPending() {
                    return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload
                }
                upload(t) {
                    !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0
                }
                destroyDebugData() {
                    this.textCollisionBox.destroy(), this.iconCollisionBox.destroy()
                }
                destroy() {
                    this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData()
                }
                addToLineVertexArray(t, a) {
                    const l = this.lineVertexArray.length;
                    if (t.segment !== void 0) {
                        let d = t.dist(a[t.segment + 1]),
                            g = t.dist(a[t.segment]);
                        const x = {};
                        for (let A = t.segment + 1; A < a.length; A++) x[A] = {
                            x: a[A].x,
                            y: a[A].y,
                            tileUnitDistanceFromAnchor: d
                        }, A < a.length - 1 && (d += a[A + 1].dist(a[A]));
                        for (let A = t.segment || 0; A >= 0; A--) x[A] = {
                            x: a[A].x,
                            y: a[A].y,
                            tileUnitDistanceFromAnchor: g
                        }, A > 0 && (g += a[A - 1].dist(a[A]));
                        for (let A = 0; A < a.length; A++) {
                            const M = x[A];
                            this.lineVertexArray.emplaceBack(M.x, M.y, M.tileUnitDistanceFromAnchor)
                        }
                    }
                    return {
                        lineStartIndex: l,
                        lineLength: this.lineVertexArray.length - l
                    }
                }
                addSymbols(t, a, l, d, g, x, A, M, F, D, U, N) {
                    const H = t.indexArray,
                        X = t.layoutVertexArray,
                        ne = t.segments.prepareSegment(4 * a.length, X, H, this.canOverlap ? x.sortKey : void 0),
                        le = this.glyphOffsetArray.length,
                        ce = ne.vertexLength,
                        Qe = this.allowVerticalPlacement && A === C.ah.vertical ? Math.PI / 2 : 0,
                        Se = x.text && x.text.sections;
                    for (let Re = 0; Re < a.length; Re++) {
                        const {
                            tl: ot,
                            tr: dt,
                            bl: Ct,
                            br: Nt,
                            tex: qt,
                            pixelOffsetTL: Fe,
                            pixelOffsetBR: Be,
                            minFontScaleX: mt,
                            minFontScaleY: lt,
                            glyphOffset: Xe,
                            isSDF: Zt,
                            sectionIndex: Ie
                        } = a[Re], pt = ne.vertexLength, xt = Xe[1];
                        yu(X, M.x, M.y, ot.x, xt + ot.y, qt.x, qt.y, l, Zt, Fe.x, Fe.y, mt, lt), yu(X, M.x, M.y, dt.x, xt + dt.y, qt.x + qt.w, qt.y, l, Zt, Be.x, Fe.y, mt, lt), yu(X, M.x, M.y, Ct.x, xt + Ct.y, qt.x, qt.y + qt.h, l, Zt, Fe.x, Be.y, mt, lt), yu(X, M.x, M.y, Nt.x, xt + Nt.y, qt.x + qt.w, qt.y + qt.h, l, Zt, Be.x, Be.y, mt, lt), hd(t.dynamicLayoutVertexArray, M, Qe), H.emplaceBack(pt, pt + 1, pt + 2), H.emplaceBack(pt + 1, pt + 2, pt + 3), ne.vertexLength += 4, ne.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(Xe[0]), Re !== a.length - 1 && Ie === a[Re + 1].sectionIndex || t.programConfigurations.populatePaintArrays(X.length, x, x.index, {}, N, Se && Se[Ie])
                    }
                    t.placedSymbolArray.emplaceBack(M.x, M.y, le, this.glyphOffsetArray.length - le, ce, F, D, M.segment, l ? l[0] : 0, l ? l[1] : 0, d[0], d[1], A, 0, !1, 0, U)
                }
                _addCollisionDebugVertex(t, a, l, d, g, x) {
                    return a.emplaceBack(0, 0), t.emplaceBack(l.x, l.y, d, g, Math.round(x.x), Math.round(x.y))
                }
                addCollisionDebugVertices(t, a, l, d, g, x, A) {
                    const M = g.segments.prepareSegment(4, g.layoutVertexArray, g.indexArray),
                        F = M.vertexLength,
                        D = g.layoutVertexArray,
                        U = g.collisionVertexArray,
                        N = A.anchorX,
                        H = A.anchorY;
                    this._addCollisionDebugVertex(D, U, x, N, H, new be(t, a)), this._addCollisionDebugVertex(D, U, x, N, H, new be(l, a)), this._addCollisionDebugVertex(D, U, x, N, H, new be(l, d)), this._addCollisionDebugVertex(D, U, x, N, H, new be(t, d)), M.vertexLength += 4;
                    const X = g.indexArray;
                    X.emplaceBack(F, F + 1), X.emplaceBack(F + 1, F + 2), X.emplaceBack(F + 2, F + 3), X.emplaceBack(F + 3, F), M.primitiveLength += 4
                }
                addDebugCollisionBoxes(t, a, l, d) {
                    for (let g = t; g < a; g++) {
                        const x = this.collisionBoxArray.get(g);
                        this.addCollisionDebugVertices(x.x1, x.y1, x.x2, x.y2, d ? this.textCollisionBox : this.iconCollisionBox, x.anchorPoint, l)
                    }
                }
                generateCollisionDebugBuffers() {
                    this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new dd(yt, uu.members, $t), this.iconCollisionBox = new dd(yt, uu.members, $t);
                    for (let t = 0; t < this.symbolInstances.length; t++) {
                        const a = this.symbolInstances.get(t);
                        this.addDebugCollisionBoxes(a.textBoxStartIndex, a.textBoxEndIndex, a, !0), this.addDebugCollisionBoxes(a.verticalTextBoxStartIndex, a.verticalTextBoxEndIndex, a, !0), this.addDebugCollisionBoxes(a.iconBoxStartIndex, a.iconBoxEndIndex, a, !1), this.addDebugCollisionBoxes(a.verticalIconBoxStartIndex, a.verticalIconBoxEndIndex, a, !1)
                    }
                }
                _deserializeCollisionBoxesForSymbol(t, a, l, d, g, x, A, M, F) {
                    const D = {};
                    for (let U = a; U < l; U++) {
                        const N = t.get(U);
                        D.textBox = {
                            x1: N.x1,
                            y1: N.y1,
                            x2: N.x2,
                            y2: N.y2,
                            anchorPointX: N.anchorPointX,
                            anchorPointY: N.anchorPointY
                        }, D.textFeatureIndex = N.featureIndex;
                        break
                    }
                    for (let U = d; U < g; U++) {
                        const N = t.get(U);
                        D.verticalTextBox = {
                            x1: N.x1,
                            y1: N.y1,
                            x2: N.x2,
                            y2: N.y2,
                            anchorPointX: N.anchorPointX,
                            anchorPointY: N.anchorPointY
                        }, D.verticalTextFeatureIndex = N.featureIndex;
                        break
                    }
                    for (let U = x; U < A; U++) {
                        const N = t.get(U);
                        D.iconBox = {
                            x1: N.x1,
                            y1: N.y1,
                            x2: N.x2,
                            y2: N.y2,
                            anchorPointX: N.anchorPointX,
                            anchorPointY: N.anchorPointY
                        }, D.iconFeatureIndex = N.featureIndex;
                        break
                    }
                    for (let U = M; U < F; U++) {
                        const N = t.get(U);
                        D.verticalIconBox = {
                            x1: N.x1,
                            y1: N.y1,
                            x2: N.x2,
                            y2: N.y2,
                            anchorPointX: N.anchorPointX,
                            anchorPointY: N.anchorPointY
                        }, D.verticalIconFeatureIndex = N.featureIndex;
                        break
                    }
                    return D
                }
                deserializeCollisionBoxes(t) {
                    this.collisionArrays = [];
                    for (let a = 0; a < this.symbolInstances.length; a++) {
                        const l = this.symbolInstances.get(a);
                        this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, l.textBoxStartIndex, l.textBoxEndIndex, l.verticalTextBoxStartIndex, l.verticalTextBoxEndIndex, l.iconBoxStartIndex, l.iconBoxEndIndex, l.verticalIconBoxStartIndex, l.verticalIconBoxEndIndex))
                    }
                }
                hasTextData() {
                    return this.text.segments.get().length > 0
                }
                hasIconData() {
                    return this.icon.segments.get().length > 0
                }
                hasDebugData() {
                    return this.textCollisionBox && this.iconCollisionBox
                }
                hasTextCollisionBoxData() {
                    return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0
                }
                hasIconCollisionBoxData() {
                    return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0
                }
                addIndicesForPlacedSymbol(t, a) {
                    const l = t.placedSymbolArray.get(a),
                        d = l.vertexStartIndex + 4 * l.numGlyphs;
                    for (let g = l.vertexStartIndex; g < d; g += 4) t.indexArray.emplaceBack(g, g + 1, g + 2), t.indexArray.emplaceBack(g + 1, g + 2, g + 3)
                }
                getSortedSymbolIndexes(t) {
                    if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
                    const a = Math.sin(t),
                        l = Math.cos(t),
                        d = [],
                        g = [],
                        x = [];
                    for (let A = 0; A < this.symbolInstances.length; ++A) {
                        x.push(A);
                        const M = this.symbolInstances.get(A);
                        d.push(0 | Math.round(a * M.anchorX + l * M.anchorY)), g.push(M.featureIndex)
                    }
                    return x.sort((A, M) => d[A] - d[M] || g[M] - g[A]), x
                }
                addToSortKeyRanges(t, a) {
                    const l = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                    l && l.sortKey === a ? l.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({
                        sortKey: a,
                        symbolInstanceStart: t,
                        symbolInstanceEnd: t + 1
                    })
                }
                sortFeatures(t) {
                    if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                        this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
                        for (const a of this.symbolInstanceIndexes) {
                            const l = this.symbolInstances.get(a);
                            this.featureSortOrder.push(l.featureIndex), [l.rightJustifiedTextSymbolIndex, l.centerJustifiedTextSymbolIndex, l.leftJustifiedTextSymbolIndex].forEach((d, g, x) => {
                                d >= 0 && x.indexOf(d) === g && this.addIndicesForPlacedSymbol(this.text, d)
                            }), l.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, l.verticalPlacedTextSymbolIndex), l.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, l.placedIconSymbolIndex), l.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, l.verticalPlacedIconSymbolIndex)
                        }
                        this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray)
                    }
                }
            }
            let Ca, pd;
            Ii("SymbolBucket", Ql, {
                omit: ["layers", "collisionBoxArray", "features", "compareText"]
            }), Ql.MAX_GLYPHS = 65535, Ql.addDynamicAttributes = hd;
            var fd = {
                get paint() {
                    return pd = pd || new ua({
                        "icon-opacity": new ln(Le.paint_symbol["icon-opacity"]),
                        "icon-color": new ln(Le.paint_symbol["icon-color"]),
                        "icon-halo-color": new ln(Le.paint_symbol["icon-halo-color"]),
                        "icon-halo-width": new ln(Le.paint_symbol["icon-halo-width"]),
                        "icon-halo-blur": new ln(Le.paint_symbol["icon-halo-blur"]),
                        "icon-translate": new Ji(Le.paint_symbol["icon-translate"]),
                        "icon-translate-anchor": new Ji(Le.paint_symbol["icon-translate-anchor"]),
                        "text-opacity": new ln(Le.paint_symbol["text-opacity"]),
                        "text-color": new ln(Le.paint_symbol["text-color"], {
                            runtimeType: Nn,
                            getOverride: i => i.textColor,
                            hasOverride: i => !!i.textColor
                        }),
                        "text-halo-color": new ln(Le.paint_symbol["text-halo-color"]),
                        "text-halo-width": new ln(Le.paint_symbol["text-halo-width"]),
                        "text-halo-blur": new ln(Le.paint_symbol["text-halo-blur"]),
                        "text-translate": new Ji(Le.paint_symbol["text-translate"]),
                        "text-translate-anchor": new Ji(Le.paint_symbol["text-translate-anchor"])
                    })
                },
                get layout() {
                    return Ca = Ca || new ua({
                        "symbol-placement": new Ji(Le.layout_symbol["symbol-placement"]),
                        "symbol-spacing": new Ji(Le.layout_symbol["symbol-spacing"]),
                        "symbol-avoid-edges": new Ji(Le.layout_symbol["symbol-avoid-edges"]),
                        "symbol-sort-key": new ln(Le.layout_symbol["symbol-sort-key"]),
                        "symbol-z-order": new Ji(Le.layout_symbol["symbol-z-order"]),
                        "icon-allow-overlap": new Ji(Le.layout_symbol["icon-allow-overlap"]),
                        "icon-overlap": new Ji(Le.layout_symbol["icon-overlap"]),
                        "icon-ignore-placement": new Ji(Le.layout_symbol["icon-ignore-placement"]),
                        "icon-optional": new Ji(Le.layout_symbol["icon-optional"]),
                        "icon-rotation-alignment": new Ji(Le.layout_symbol["icon-rotation-alignment"]),
                        "icon-size": new ln(Le.layout_symbol["icon-size"]),
                        "icon-text-fit": new Ji(Le.layout_symbol["icon-text-fit"]),
                        "icon-text-fit-padding": new Ji(Le.layout_symbol["icon-text-fit-padding"]),
                        "icon-image": new ln(Le.layout_symbol["icon-image"]),
                        "icon-rotate": new ln(Le.layout_symbol["icon-rotate"]),
                        "icon-padding": new ln(Le.layout_symbol["icon-padding"]),
                        "icon-keep-upright": new Ji(Le.layout_symbol["icon-keep-upright"]),
                        "icon-offset": new ln(Le.layout_symbol["icon-offset"]),
                        "icon-anchor": new ln(Le.layout_symbol["icon-anchor"]),
                        "icon-pitch-alignment": new Ji(Le.layout_symbol["icon-pitch-alignment"]),
                        "text-pitch-alignment": new Ji(Le.layout_symbol["text-pitch-alignment"]),
                        "text-rotation-alignment": new Ji(Le.layout_symbol["text-rotation-alignment"]),
                        "text-field": new ln(Le.layout_symbol["text-field"]),
                        "text-font": new ln(Le.layout_symbol["text-font"]),
                        "text-size": new ln(Le.layout_symbol["text-size"]),
                        "text-max-width": new ln(Le.layout_symbol["text-max-width"]),
                        "text-line-height": new Ji(Le.layout_symbol["text-line-height"]),
                        "text-letter-spacing": new ln(Le.layout_symbol["text-letter-spacing"]),
                        "text-justify": new ln(Le.layout_symbol["text-justify"]),
                        "text-radial-offset": new ln(Le.layout_symbol["text-radial-offset"]),
                        "text-variable-anchor": new Ji(Le.layout_symbol["text-variable-anchor"]),
                        "text-variable-anchor-offset": new ln(Le.layout_symbol["text-variable-anchor-offset"]),
                        "text-anchor": new ln(Le.layout_symbol["text-anchor"]),
                        "text-max-angle": new Ji(Le.layout_symbol["text-max-angle"]),
                        "text-writing-mode": new Ji(Le.layout_symbol["text-writing-mode"]),
                        "text-rotate": new ln(Le.layout_symbol["text-rotate"]),
                        "text-padding": new Ji(Le.layout_symbol["text-padding"]),
                        "text-keep-upright": new Ji(Le.layout_symbol["text-keep-upright"]),
                        "text-transform": new ln(Le.layout_symbol["text-transform"]),
                        "text-offset": new ln(Le.layout_symbol["text-offset"]),
                        "text-allow-overlap": new Ji(Le.layout_symbol["text-allow-overlap"]),
                        "text-overlap": new Ji(Le.layout_symbol["text-overlap"]),
                        "text-ignore-placement": new Ji(Le.layout_symbol["text-ignore-placement"]),
                        "text-optional": new Ji(Le.layout_symbol["text-optional"])
                    })
                }
            };
            class md {
                constructor(t) {
                    if (t.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
                    this.type = t.property.overrides ? t.property.overrides.runtimeType : cn, this.defaultValue = t
                }
                evaluate(t) {
                    if (t.formattedSection) {
                        const a = this.defaultValue.property.overrides;
                        if (a && a.hasOverride(t.formattedSection)) return a.getOverride(t.formattedSection)
                    }
                    return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default
                }
                eachChild(t) {
                    this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression)
                }
                outputDefined() {
                    return !1
                }
                serialize() {
                    return null
                }
            }
            Ii("FormatSectionOverride", md, {
                omit: ["defaultValue"]
            });
            class Pl extends $a {
                constructor(t) {
                    super(t, fd)
                }
                recalculate(t, a) {
                    if (super.recalculate(t, a), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
                        const l = this.layout.get("text-writing-mode");
                        if (l) {
                            const d = [];
                            for (const g of l) d.indexOf(g) < 0 && d.push(g);
                            this.layout._values["text-writing-mode"] = d
                        } else this.layout._values["text-writing-mode"] = ["horizontal"]
                    }
                    this._setPaintOverrides()
                }
                getValueAndResolveTokens(t, a, l, d) {
                    const g = this.layout.get(t).evaluate(a, {}, l, d),
                        x = this._unevaluatedLayout._values[t];
                    return x.isDataDriven() || Dn(x.value) || !g ? g : function(A, M) {
                        return M.replace(/{([^{}]+)}/g, (F, D) => A && D in A ? String(A[D]) : "")
                    }(a.properties, g)
                }
                createBucket(t) {
                    return new Ql(t)
                }
                queryRadius() {
                    return 0
                }
                queryIntersectsFeature() {
                    throw new Error("Should take a different path in FeatureIndex")
                }
                _setPaintOverrides() {
                    for (const t of fd.paint.overridableProperties) {
                        if (!Pl.hasPaintOverride(this.layout, t)) continue;
                        const a = this.paint.get(t),
                            l = new md(a),
                            d = new Cn(l, a.property.specification);
                        let g = null;
                        g = a.value.kind === "constant" || a.value.kind === "source" ? new bs("source", d) : new Lo("composite", d, a.value.zoomStops), this.paint._values[t] = new qa(a.property, g, a.parameters)
                    }
                }
                _handleOverridablePaintPropertyUpdate(t, a, l) {
                    return !(!this.layout || a.isDataDriven() || l.isDataDriven()) && Pl.hasPaintOverride(this.layout, t)
                }
                static hasPaintOverride(t, a) {
                    const l = t.get("text-field"),
                        d = fd.paint.properties[a];
                    let g = !1;
                    const x = A => {
                        for (const M of A)
                            if (d.overrides && d.overrides.hasOverride(M)) return void(g = !0)
                    };
                    if (l.value.kind === "constant" && l.value.value instanceof rr) x(l.value.value.sections);
                    else if (l.value.kind === "source") {
                        const A = F => {
                                g || (F instanceof la && or(F.value) === On ? x(F.value.sections) : F instanceof gs ? x(F.sections) : F.eachChild(A))
                            },
                            M = l.value;
                        M._styleExpression && A(M._styleExpression.expression)
                    }
                    return g
                }
            }
            let vu;
            var gd = {
                get paint() {
                    return vu = vu || new ua({
                        "background-color": new Ji(Le.paint_background["background-color"]),
                        "background-pattern": new Kl(Le.paint_background["background-pattern"]),
                        "background-opacity": new Ji(Le.paint_background["background-opacity"])
                    })
                }
            };
            class yd extends $a {
                constructor(t) {
                    super(t, gd)
                }
            }
            let vd;
            var _d = {
                get paint() {
                    return vd = vd || new ua({
                        "raster-opacity": new Ji(Le.paint_raster["raster-opacity"]),
                        "raster-hue-rotate": new Ji(Le.paint_raster["raster-hue-rotate"]),
                        "raster-brightness-min": new Ji(Le.paint_raster["raster-brightness-min"]),
                        "raster-brightness-max": new Ji(Le.paint_raster["raster-brightness-max"]),
                        "raster-saturation": new Ji(Le.paint_raster["raster-saturation"]),
                        "raster-contrast": new Ji(Le.paint_raster["raster-contrast"]),
                        "raster-resampling": new Ji(Le.paint_raster["raster-resampling"]),
                        "raster-fade-duration": new Ji(Le.paint_raster["raster-fade-duration"])
                    })
                }
            };
            class np extends $a {
                constructor(t) {
                    super(t, _d)
                }
            }
            class Tc extends $a {
                constructor(t) {
                    super(t, {}), this.onAdd = a => {
                        this.implementation.onAdd && this.implementation.onAdd(a, a.painter.context.gl)
                    }, this.onRemove = a => {
                        this.implementation.onRemove && this.implementation.onRemove(a, a.painter.context.gl)
                    }, this.implementation = t
                }
                is3D() {
                    return this.implementation.renderingMode === "3d"
                }
                hasOffscreenPass() {
                    return this.implementation.prerender !== void 0
                }
                recalculate() {}
                updateTransitions() {}
                hasTransition() {
                    return !1
                }
                serialize() {
                    throw new Error("Custom layers cannot be serialized")
                }
            }
            class rp {
                constructor(t) {
                    this._methodToThrottle = t, this._triggered = !1, typeof MessageChannel != "undefined" && (this._channel = new MessageChannel, this._channel.port2.onmessage = () => {
                        this._triggered = !1, this._methodToThrottle()
                    })
                }
                trigger() {
                    this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
                        this._triggered = !1, this._methodToThrottle()
                    }, 0))
                }
                remove() {
                    delete this._channel, this._methodToThrottle = () => {}
                }
            }
            const Mc = 63710088e-1;
            class So {
                constructor(t, a) {
                    if (isNaN(t) || isNaN(a)) throw new Error(`Invalid LngLat object: (${t}, ${a})`);
                    if (this.lng = +t, this.lat = +a, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90")
                }
                wrap() {
                    return new So(vt(this.lng, -180, 180), this.lat)
                }
                toArray() {
                    return [this.lng, this.lat]
                }
                toString() {
                    return `LngLat(${this.lng}, ${this.lat})`
                }
                distanceTo(t) {
                    const a = Math.PI / 180,
                        l = this.lat * a,
                        d = t.lat * a,
                        g = Math.sin(l) * Math.sin(d) + Math.cos(l) * Math.cos(d) * Math.cos((t.lng - this.lng) * a);
                    return Mc * Math.acos(Math.min(g, 1))
                }
                static convert(t) {
                    if (t instanceof So) return t;
                    if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new So(Number(t[0]), Number(t[1]));
                    if (!Array.isArray(t) && typeof t == "object" && t !== null) return new So(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
                    throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")
                }
            }
            const Cc = 2 * Math.PI * Mc;

            function xd(i) {
                return Cc * Math.cos(i * Math.PI / 180)
            }

            function Ao(i) {
                return (180 + i) / 360
            }

            function Mh(i) {
                return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i * Math.PI / 360))) / 360
            }

            function _u(i, t) {
                return i / xd(t)
            }

            function xu(i) {
                return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * i) * Math.PI / 180)) - 90
            }
            class Ch {
                constructor(t, a, l = 0) {
                    this.x = +t, this.y = +a, this.z = +l
                }
                static fromLngLat(t, a = 0) {
                    const l = So.convert(t);
                    return new Ch(Ao(l.lng), Mh(l.lat), _u(a, l.lat))
                }
                toLngLat() {
                    return new So(360 * this.x - 180, xu(this.y))
                }
                toAltitude() {
                    return this.z * xd(xu(this.y))
                }
                meterInMercatorCoordinateUnits() {
                    return 1 / Cc * (t = xu(this.y), 1 / Math.cos(t * Math.PI / 180));
                    var t
                }
            }

            function ap(i, t, a) {
                var l = 2 * Math.PI * 6378137 / 256 / Math.pow(2, a);
                return [i * l - 2 * Math.PI * 6378137 / 2, t * l - 2 * Math.PI * 6378137 / 2]
            }
            class bu {
                constructor(t, a, l) {
                    if (t < 0 || t > 25 || l < 0 || l >= Math.pow(2, t) || a < 0 || a >= Math.pow(2, t)) throw new Error(`x=${a}, y=${l}, z=${t} outside of bounds. 0<=x<${Math.pow(2,t)}, 0<=y<${Math.pow(2,t)} 0<=z<=25 `);
                    this.z = t, this.x = a, this.y = l, this.key = Bc(0, t, t, a, l)
                }
                equals(t) {
                    return this.z === t.z && this.x === t.x && this.y === t.y
                }
                url(t, a, l) {
                    const d = (x = this.y, A = this.z, M = ap(256 * (g = this.x), 256 * (x = Math.pow(2, A) - x - 1), A), F = ap(256 * (g + 1), 256 * (x + 1), A), M[0] + "," + M[1] + "," + F[0] + "," + F[1]);
                    var g, x, A, M, F;
                    const D = function(U, N, H) {
                        let X, ne = "";
                        for (let le = U; le > 0; le--) X = 1 << le - 1, ne += (N & X ? 1 : 0) + (H & X ? 2 : 0);
                        return ne
                    }(this.z, this.x, this.y);
                    return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(l === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, a > 1 ? "@2x" : "").replace(/{quadkey}/g, D).replace(/{bbox-epsg-3857}/g, d)
                }
                isChildOf(t) {
                    const a = this.z - t.z;
                    return a > 0 && t.x === this.x >> a && t.y === this.y >> a
                }
                getTilePoint(t) {
                    const a = Math.pow(2, this.z);
                    return new be((t.x * a - this.x) * fr, (t.y * a - this.y) * fr)
                }
                toString() {
                    return `${this.z}/${this.x}/${this.y}`
                }
            }
            class bd {
                constructor(t, a) {
                    this.wrap = t, this.canonical = a, this.key = Bc(t, a.z, a.z, a.x, a.y)
                }
            }
            class Ja {
                constructor(t, a, l, d, g) {
                    if (t < l) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${l}`);
                    this.overscaledZ = t, this.wrap = a, this.canonical = new bu(l, +d, +g), this.key = Bc(a, t, l, d, g)
                }
                clone() {
                    return new Ja(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)
                }
                equals(t) {
                    return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical)
                }
                scaledTo(t) {
                    if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
                    const a = this.canonical.z - t;
                    return t > this.canonical.z ? new Ja(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Ja(t, this.wrap, t, this.canonical.x >> a, this.canonical.y >> a)
                }
                calculateScaledKey(t, a) {
                    if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
                    const l = this.canonical.z - t;
                    return t > this.canonical.z ? Bc(this.wrap * +a, t, this.canonical.z, this.canonical.x, this.canonical.y) : Bc(this.wrap * +a, t, t, this.canonical.x >> l, this.canonical.y >> l)
                }
                isChildOf(t) {
                    if (t.wrap !== this.wrap) return !1;
                    const a = this.canonical.z - t.canonical.z;
                    return t.overscaledZ === 0 || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> a && t.canonical.y === this.canonical.y >> a
                }
                children(t) {
                    if (this.overscaledZ >= t) return [new Ja(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
                    const a = this.canonical.z + 1,
                        l = 2 * this.canonical.x,
                        d = 2 * this.canonical.y;
                    return [new Ja(a, this.wrap, a, l, d), new Ja(a, this.wrap, a, l + 1, d), new Ja(a, this.wrap, a, l, d + 1), new Ja(a, this.wrap, a, l + 1, d + 1)]
                }
                isLessThan(t) {
                    return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y))
                }
                wrapped() {
                    return new Ja(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y)
                }
                unwrapTo(t) {
                    return new Ja(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y)
                }
                overscaleFactor() {
                    return Math.pow(2, this.overscaledZ - this.canonical.z)
                }
                toUnwrapped() {
                    return new bd(this.wrap, this.canonical)
                }
                toString() {
                    return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`
                }
                getTilePoint(t) {
                    return this.canonical.getTilePoint(new Ch(t.x - this.wrap, t.y))
                }
            }

            function Bc(i, t, a, l, d) {
                (i *= 2) < 0 && (i = -1 * i - 1);
                const g = 1 << a;
                return (g * g * i + g * d + l).toString(36) + a.toString(36) + t.toString(36)
            }
            Ii("CanonicalTileID", bu), Ii("OverscaledTileID", Ja, {
                omit: ["posMatrix"]
            });
            class Bh {
                constructor(t, a, l, d = 1, g = 1, x = 1, A = 0) {
                    if (this.uid = t, a.height !== a.width) throw new RangeError("DEM tiles must be square");
                    if (l && !["mapbox", "terrarium", "custom"].includes(l)) return void li(`"${l}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
                    this.stride = a.height;
                    const M = this.dim = a.height - 2;
                    switch (this.data = new Uint32Array(a.data.buffer), l) {
                        case "terrarium":
                            this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                            break;
                        case "custom":
                            this.redFactor = d, this.greenFactor = g, this.blueFactor = x, this.baseShift = A;
                            break;
                        default:
                            this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = .1, this.baseShift = 1e4
                    }
                    for (let F = 0; F < M; F++) this.data[this._idx(-1, F)] = this.data[this._idx(0, F)], this.data[this._idx(M, F)] = this.data[this._idx(M - 1, F)], this.data[this._idx(F, -1)] = this.data[this._idx(F, 0)], this.data[this._idx(F, M)] = this.data[this._idx(F, M - 1)];
                    this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(M, -1)] = this.data[this._idx(M - 1, 0)], this.data[this._idx(-1, M)] = this.data[this._idx(0, M - 1)], this.data[this._idx(M, M)] = this.data[this._idx(M - 1, M - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
                    for (let F = 0; F < M; F++)
                        for (let D = 0; D < M; D++) {
                            const U = this.get(F, D);
                            U > this.max && (this.max = U), U < this.min && (this.min = U)
                        }
                }
                get(t, a) {
                    const l = new Uint8Array(this.data.buffer),
                        d = 4 * this._idx(t, a);
                    return this.unpack(l[d], l[d + 1], l[d + 2])
                }
                getUnpackVector() {
                    return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift]
                }
                _idx(t, a) {
                    if (t < -1 || t >= this.dim + 1 || a < -1 || a >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
                    return (a + 1) * this.stride + (t + 1)
                }
                unpack(t, a, l) {
                    return t * this.redFactor + a * this.greenFactor + l * this.blueFactor - this.baseShift
                }
                getPixels() {
                    return new es({
                        width: this.stride,
                        height: this.stride
                    }, new Uint8Array(this.data.buffer))
                }
                backfillBorder(t, a, l) {
                    if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
                    let d = a * this.dim,
                        g = a * this.dim + this.dim,
                        x = l * this.dim,
                        A = l * this.dim + this.dim;
                    switch (a) {
                        case -1:
                            d = g - 1;
                            break;
                        case 1:
                            g = d + 1
                    }
                    switch (l) {
                        case -1:
                            x = A - 1;
                            break;
                        case 1:
                            A = x + 1
                    }
                    const M = -a * this.dim,
                        F = -l * this.dim;
                    for (let D = x; D < A; D++)
                        for (let U = d; U < g; U++) this.data[this._idx(U, D)] = t.data[this._idx(U + M, D + F)]
                }
            }
            Ii("DEMData", Bh);
            class wd {
                constructor(t) {
                    this._stringToNumber = {}, this._numberToString = [];
                    for (let a = 0; a < t.length; a++) {
                        const l = t[a];
                        this._stringToNumber[l] = a, this._numberToString[a] = l
                    }
                }
                encode(t) {
                    return this._stringToNumber[t]
                }
                decode(t) {
                    if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
                    return this._numberToString[t]
                }
            }
            class Rh {
                constructor(t, a, l, d, g) {
                    this.type = "Feature", this._vectorTileFeature = t, t._z = a, t._x = l, t._y = d, this.properties = t.properties, this.id = g
                }
                get geometry() {
                    return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry
                }
                set geometry(t) {
                    this._geometry = t
                }
                toJSON() {
                    const t = {
                        geometry: this.geometry
                    };
                    for (const a in this) a !== "_geometry" && a !== "_vectorTileFeature" && (t[a] = this[a]);
                    return t
                }
            }
            class Hr {
                constructor(t, a) {
                    this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new lo(fr, 16, 0), this.grid3D = new lo(fr, 16, 0), this.featureIndexArray = new ee, this.promoteId = a
                }
                insert(t, a, l, d, g, x) {
                    const A = this.featureIndexArray.length;
                    this.featureIndexArray.emplaceBack(l, d, g);
                    const M = x ? this.grid3D : this.grid;
                    for (let F = 0; F < a.length; F++) {
                        const D = a[F],
                            U = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                        for (let N = 0; N < D.length; N++) {
                            const H = D[N];
                            U[0] = Math.min(U[0], H.x), U[1] = Math.min(U[1], H.y), U[2] = Math.max(U[2], H.x), U[3] = Math.max(U[3], H.y)
                        }
                        U[0] < fr && U[1] < fr && U[2] >= 0 && U[3] >= 0 && M.insert(A, U[0], U[1], U[2], U[3])
                    }
                }
                loadVTLayers() {
                    return this.vtLayers || (this.vtLayers = new Cs.VectorTile(new wc(this.rawTileData)).layers, this.sourceLayerCoder = new wd(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers
                }
                query(t, a, l, d) {
                    this.loadVTLayers();
                    const g = t.params || {},
                        x = fr / t.tileSize / t.scale,
                        A = Us(g.filter),
                        M = t.queryGeometry,
                        F = t.queryPadding * x,
                        D = Fh(M),
                        U = this.grid.query(D.minX - F, D.minY - F, D.maxX + F, D.maxY + F),
                        N = Fh(t.cameraQueryGeometry),
                        H = this.grid3D.query(N.minX - F, N.minY - F, N.maxX + F, N.maxY + F, (le, ce, Qe, Se) => function(Re, ot, dt, Ct, Nt) {
                            for (const Fe of Re)
                                if (ot <= Fe.x && dt <= Fe.y && Ct >= Fe.x && Nt >= Fe.y) return !0;
                            const qt = [new be(ot, dt), new be(ot, Nt), new be(Ct, Nt), new be(Ct, dt)];
                            if (Re.length > 2) {
                                for (const Fe of qt)
                                    if (vo(Re, Fe)) return !0
                            }
                            for (let Fe = 0; Fe < Re.length - 1; Fe++)
                                if (lc(Re[Fe], Re[Fe + 1], qt)) return !0;
                            return !1
                        }(t.cameraQueryGeometry, le - F, ce - F, Qe + F, Se + F));
                    for (const le of H) U.push(le);
                    U.sort(sp);
                    const X = {};
                    let ne;
                    for (let le = 0; le < U.length; le++) {
                        const ce = U[le];
                        if (ce === ne) continue;
                        ne = ce;
                        const Qe = this.featureIndexArray.get(ce);
                        let Se = null;
                        this.loadMatchingFeature(X, Qe.bucketIndex, Qe.sourceLayerIndex, Qe.featureIndex, A, g.layers, g.availableImages, a, l, d, (Re, ot, dt) => (Se || (Se = Hs(Re)), ot.queryIntersectsFeature(M, Re, dt, Se, this.z, t.transform, x, t.pixelPosMatrix)))
                    }
                    return X
                }
                loadMatchingFeature(t, a, l, d, g, x, A, M, F, D, U) {
                    const N = this.bucketLayerIDs[a];
                    if (x && ! function(le, ce) {
                            for (let Qe = 0; Qe < le.length; Qe++)
                                if (ce.indexOf(le[Qe]) >= 0) return !0;
                            return !1
                        }(x, N)) return;
                    const H = this.sourceLayerCoder.decode(l),
                        X = this.vtLayers[H].feature(d);
                    if (g.needGeometry) {
                        const le = Ws(X, !0);
                        if (!g.filter(new cr(this.tileID.overscaledZ), le, this.tileID.canonical)) return
                    } else if (!g.filter(new cr(this.tileID.overscaledZ), X)) return;
                    const ne = this.getId(X, H);
                    for (let le = 0; le < N.length; le++) {
                        const ce = N[le];
                        if (x && x.indexOf(ce) < 0) continue;
                        const Qe = M[ce];
                        if (!Qe) continue;
                        let Se = {};
                        ne && D && (Se = D.getState(Qe.sourceLayer || "_geojsonTileLayer", ne));
                        const Re = Kt({}, F[ce]);
                        Re.paint = jr(Re.paint, Qe.paint, X, Se, A), Re.layout = jr(Re.layout, Qe.layout, X, Se, A);
                        const ot = !U || U(X, Qe, Se);
                        if (!ot) continue;
                        const dt = new Rh(X, this.z, this.x, this.y, ne);
                        dt.layer = Re;
                        let Ct = t[ce];
                        Ct === void 0 && (Ct = t[ce] = []), Ct.push({
                            featureIndex: d,
                            feature: dt,
                            intersectionZ: ot
                        })
                    }
                }
                lookupSymbolFeatures(t, a, l, d, g, x, A, M) {
                    const F = {};
                    this.loadVTLayers();
                    const D = Us(g);
                    for (const U of t) this.loadMatchingFeature(F, l, d, U, D, x, A, M, a);
                    return F
                }
                hasLayer(t) {
                    for (const a of this.bucketLayerIDs)
                        for (const l of a)
                            if (t === l) return !0;
                    return !1
                }
                getId(t, a) {
                    let l = t.id;
                    return this.promoteId && (l = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[a]], typeof l == "boolean" && (l = Number(l))), l
                }
            }

            function jr(i, t, a, l, d) {
                return Li(i, (g, x) => {
                    const A = t instanceof xl ? t.get(x) : null;
                    return A && A.evaluate ? A.evaluate(a, l, d) : A
                })
            }

            function Fh(i) {
                let t = 1 / 0,
                    a = 1 / 0,
                    l = -1 / 0,
                    d = -1 / 0;
                for (const g of i) t = Math.min(t, g.x), a = Math.min(a, g.y), l = Math.max(l, g.x), d = Math.max(d, g.y);
                return {
                    minX: t,
                    minY: a,
                    maxX: l,
                    maxY: d
                }
            }

            function sp(i, t) {
                return t - i
            }

            function Ed(i, t, a, l, d) {
                const g = [];
                for (let x = 0; x < i.length; x++) {
                    const A = i[x];
                    let M;
                    for (let F = 0; F < A.length - 1; F++) {
                        let D = A[F],
                            U = A[F + 1];
                        D.x < t && U.x < t || (D.x < t ? D = new be(t, D.y + (t - D.x) / (U.x - D.x) * (U.y - D.y))._round() : U.x < t && (U = new be(t, D.y + (t - D.x) / (U.x - D.x) * (U.y - D.y))._round()), D.y < a && U.y < a || (D.y < a ? D = new be(D.x + (a - D.y) / (U.y - D.y) * (U.x - D.x), a)._round() : U.y < a && (U = new be(D.x + (a - D.y) / (U.y - D.y) * (U.x - D.x), a)._round()), D.x >= l && U.x >= l || (D.x >= l ? D = new be(l, D.y + (l - D.x) / (U.x - D.x) * (U.y - D.y))._round() : U.x >= l && (U = new be(l, D.y + (l - D.x) / (U.x - D.x) * (U.y - D.y))._round()), D.y >= d && U.y >= d || (D.y >= d ? D = new be(D.x + (d - D.y) / (U.y - D.y) * (U.x - D.x), d)._round() : U.y >= d && (U = new be(D.x + (d - D.y) / (U.y - D.y) * (U.x - D.x), d)._round()), M && D.equals(M[M.length - 1]) || (M = [D], g.push(M)), M.push(U)))))
                    }
                }
                return g
            }
            Ii("FeatureIndex", Hr, {
                omit: ["rawTileData", "sourceLayerCoder"]
            });
            class Fs extends be {
                constructor(t, a, l, d) {
                    super(t, a), this.angle = l, d !== void 0 && (this.segment = d)
                }
                clone() {
                    return new Fs(this.x, this.y, this.angle, this.segment)
                }
            }

            function wu(i, t, a, l, d) {
                if (t.segment === void 0 || a === 0) return !0;
                let g = t,
                    x = t.segment + 1,
                    A = 0;
                for (; A > -a / 2;) {
                    if (x--, x < 0) return !1;
                    A -= i[x].dist(g), g = i[x]
                }
                A += i[x].dist(i[x + 1]), x++;
                const M = [];
                let F = 0;
                for (; A < a / 2;) {
                    const D = i[x],
                        U = i[x + 1];
                    if (!U) return !1;
                    let N = i[x - 1].angleTo(D) - D.angleTo(U);
                    for (N = Math.abs((N + 3 * Math.PI) % (2 * Math.PI) - Math.PI), M.push({
                            distance: A,
                            angleDelta: N
                        }), F += N; A - M[0].distance > l;) F -= M.shift().angleDelta;
                    if (F > d) return !1;
                    x++, A += D.dist(U)
                }
                return !0
            }

            function Sd(i) {
                let t = 0;
                for (let a = 0; a < i.length - 1; a++) t += i[a].dist(i[a + 1]);
                return t
            }

            function Ad(i, t, a) {
                return i ? .6 * t * a : 0
            }

            function op(i, t) {
                return Math.max(i ? i.right - i.left : 0, t ? t.right - t.left : 0)
            }

            function Rp(i, t, a, l, d, g) {
                const x = Ad(a, d, g),
                    A = op(a, l) * g;
                let M = 0;
                const F = Sd(i) / 2;
                for (let D = 0; D < i.length - 1; D++) {
                    const U = i[D],
                        N = i[D + 1],
                        H = U.dist(N);
                    if (M + H > F) {
                        const X = (F - M) / H,
                            ne = en.number(U.x, N.x, X),
                            le = en.number(U.y, N.y, X),
                            ce = new Fs(ne, le, N.angleTo(U), D);
                        return ce._round(), !x || wu(i, ce, A, x, t) ? ce : void 0
                    }
                    M += H
                }
            }

            function eo(i, t, a, l, d, g, x, A, M) {
                const F = Ad(l, g, x),
                    D = op(l, d),
                    U = D * x,
                    N = i[0].x === 0 || i[0].x === M || i[0].y === 0 || i[0].y === M;
                return t - U < t / 4 && (t = U + t / 4), Td(i, N ? t / 2 * A % t : (D / 2 + 2 * g) * x * A % t, t, F, a, U, N, !1, M)
            }

            function Td(i, t, a, l, d, g, x, A, M) {
                const F = g / 2,
                    D = Sd(i);
                let U = 0,
                    N = t - a,
                    H = [];
                for (let X = 0; X < i.length - 1; X++) {
                    const ne = i[X],
                        le = i[X + 1],
                        ce = ne.dist(le),
                        Qe = le.angleTo(ne);
                    for (; N + a < U + ce;) {
                        N += a;
                        const Se = (N - U) / ce,
                            Re = en.number(ne.x, le.x, Se),
                            ot = en.number(ne.y, le.y, Se);
                        if (Re >= 0 && Re < M && ot >= 0 && ot < M && N - F >= 0 && N + F <= D) {
                            const dt = new Fs(Re, ot, Qe, X);
                            dt._round(), l && !wu(i, dt, g, l, d) || H.push(dt)
                        }
                    }
                    U += ce
                }
                return A || H.length || x || (H = Td(i, U / 2, a, l, d, g, x, !0, M)), H
            }
            Ii("Anchor", Fs);
            const kl = Ma;

            function Lh(i, t, a, l) {
                const d = [],
                    g = i.image,
                    x = g.pixelRatio,
                    A = g.paddedRect.w - 2 * kl,
                    M = g.paddedRect.h - 2 * kl,
                    F = i.right - i.left,
                    D = i.bottom - i.top,
                    U = g.stretchX || [
                        [0, A]
                    ],
                    N = g.stretchY || [
                        [0, M]
                    ],
                    H = (Be, mt) => Be + mt[1] - mt[0],
                    X = U.reduce(H, 0),
                    ne = N.reduce(H, 0),
                    le = A - X,
                    ce = M - ne;
                let Qe = 0,
                    Se = X,
                    Re = 0,
                    ot = ne,
                    dt = 0,
                    Ct = le,
                    Nt = 0,
                    qt = ce;
                if (g.content && l) {
                    const Be = g.content;
                    Qe = ns(U, 0, Be[0]), Re = ns(N, 0, Be[1]), Se = ns(U, Be[0], Be[2]), ot = ns(N, Be[1], Be[3]), dt = Be[0] - Qe, Nt = Be[1] - Re, Ct = Be[2] - Be[0] - Se, qt = Be[3] - Be[1] - ot
                }
                const Fe = (Be, mt, lt, Xe) => {
                    const Zt = Eu(Be.stretch - Qe, Se, F, i.left),
                        Ie = Rc(Be.fixed - dt, Ct, Be.stretch, X),
                        pt = Eu(mt.stretch - Re, ot, D, i.top),
                        xt = Rc(mt.fixed - Nt, qt, mt.stretch, ne),
                        Gt = Eu(lt.stretch - Qe, Se, F, i.left),
                        Xt = Rc(lt.fixed - dt, Ct, lt.stretch, X),
                        hi = Eu(Xe.stretch - Re, ot, D, i.top),
                        _i = Rc(Xe.fixed - Nt, qt, Xe.stretch, ne),
                        Di = new be(Zt, pt),
                        nn = new be(Gt, pt),
                        Fi = new be(Gt, hi),
                        tn = new be(Zt, hi),
                        gn = new be(Ie / x, xt / x),
                        Kn = new be(Xt / x, _i / x),
                        er = t * Math.PI / 180;
                    if (er) {
                        const tr = Math.sin(er),
                            jn = Math.cos(er),
                            fi = [jn, -tr, tr, jn];
                        Di._matMult(fi), nn._matMult(fi), tn._matMult(fi), Fi._matMult(fi)
                    }
                    const ia = Be.stretch + Be.fixed,
                        oa = mt.stretch + mt.fixed;
                    return {
                        tl: Di,
                        tr: nn,
                        bl: tn,
                        br: Fi,
                        tex: {
                            x: g.paddedRect.x + kl + ia,
                            y: g.paddedRect.y + kl + oa,
                            w: lt.stretch + lt.fixed - ia,
                            h: Xe.stretch + Xe.fixed - oa
                        },
                        writingMode: void 0,
                        glyphOffset: [0, 0],
                        sectionIndex: 0,
                        pixelOffsetTL: gn,
                        pixelOffsetBR: Kn,
                        minFontScaleX: Ct / x / F,
                        minFontScaleY: qt / x / D,
                        isSDF: a
                    }
                };
                if (l && (g.stretchX || g.stretchY)) {
                    const Be = rl(U, le, X),
                        mt = rl(N, ce, ne);
                    for (let lt = 0; lt < Be.length - 1; lt++) {
                        const Xe = Be[lt],
                            Zt = Be[lt + 1];
                        for (let Ie = 0; Ie < mt.length - 1; Ie++) d.push(Fe(Xe, mt[Ie], Zt, mt[Ie + 1]))
                    }
                } else d.push(Fe({
                    fixed: 0,
                    stretch: -1
                }, {
                    fixed: 0,
                    stretch: -1
                }, {
                    fixed: 0,
                    stretch: A + 1
                }, {
                    fixed: 0,
                    stretch: M + 1
                }));
                return d
            }

            function ns(i, t, a) {
                let l = 0;
                for (const d of i) l += Math.max(t, Math.min(a, d[1])) - Math.max(t, Math.min(a, d[0]));
                return l
            }

            function rl(i, t, a) {
                const l = [{
                    fixed: -kl,
                    stretch: 0
                }];
                for (const [d, g] of i) {
                    const x = l[l.length - 1];
                    l.push({
                        fixed: d - x.stretch,
                        stretch: x.stretch
                    }), l.push({
                        fixed: d - x.stretch,
                        stretch: x.stretch + (g - d)
                    })
                }
                return l.push({
                    fixed: t + kl,
                    stretch: a
                }), l
            }

            function Eu(i, t, a, l) {
                return i / t * a + l
            }

            function Rc(i, t, a, l) {
                return i - t * a / l
            }
            class al {
                constructor(t, a, l, d, g, x, A, M, F, D) {
                    if (this.boxStartIndex = t.length, F) {
                        let U = x.top,
                            N = x.bottom;
                        const H = x.collisionPadding;
                        H && (U -= H[1], N += H[3]);
                        let X = N - U;
                        X > 0 && (X = Math.max(10, X), this.circleDiameter = X)
                    } else {
                        let U = x.top * A - M[0],
                            N = x.bottom * A + M[2],
                            H = x.left * A - M[3],
                            X = x.right * A + M[1];
                        const ne = x.collisionPadding;
                        if (ne && (H -= ne[0] * A, U -= ne[1] * A, X += ne[2] * A, N += ne[3] * A), D) {
                            const le = new be(H, U),
                                ce = new be(X, U),
                                Qe = new be(H, N),
                                Se = new be(X, N),
                                Re = D * Math.PI / 180;
                            le._rotate(Re), ce._rotate(Re), Qe._rotate(Re), Se._rotate(Re), H = Math.min(le.x, ce.x, Qe.x, Se.x), X = Math.max(le.x, ce.x, Qe.x, Se.x), U = Math.min(le.y, ce.y, Qe.y, Se.y), N = Math.max(le.y, ce.y, Qe.y, Se.y)
                        }
                        t.emplaceBack(a.x, a.y, H, U, X, N, l, d, g)
                    }
                    this.boxEndIndex = t.length
                }
            }
            class lp {
                constructor(t = [], a = Su) {
                    if (this.data = t, this.length = this.data.length, this.compare = a, this.length > 0)
                        for (let l = (this.length >> 1) - 1; l >= 0; l--) this._down(l)
                }
                push(t) {
                    this.data.push(t), this.length++, this._up(this.length - 1)
                }
                pop() {
                    if (this.length === 0) return;
                    const t = this.data[0],
                        a = this.data.pop();
                    return this.length--, this.length > 0 && (this.data[0] = a, this._down(0)), t
                }
                peek() {
                    return this.data[0]
                }
                _up(t) {
                    const {
                        data: a,
                        compare: l
                    } = this, d = a[t];
                    for (; t > 0;) {
                        const g = t - 1 >> 1,
                            x = a[g];
                        if (l(d, x) >= 0) break;
                        a[t] = x, t = g
                    }
                    a[t] = d
                }
                _down(t) {
                    const {
                        data: a,
                        compare: l
                    } = this, d = this.length >> 1, g = a[t];
                    for (; t < d;) {
                        let x = 1 + (t << 1),
                            A = a[x];
                        const M = x + 1;
                        if (M < this.length && l(a[M], A) < 0 && (x = M, A = a[M]), l(A, g) >= 0) break;
                        a[t] = A, t = x
                    }
                    a[t] = g
                }
            }

            function Su(i, t) {
                return i < t ? -1 : i > t ? 1 : 0
            }

            function cp(i, t = 1, a = !1) {
                let l = 1 / 0,
                    d = 1 / 0,
                    g = -1 / 0,
                    x = -1 / 0;
                const A = i[0];
                for (let H = 0; H < A.length; H++) {
                    const X = A[H];
                    (!H || X.x < l) && (l = X.x), (!H || X.y < d) && (d = X.y), (!H || X.x > g) && (g = X.x), (!H || X.y > x) && (x = X.y)
                }
                const M = Math.min(g - l, x - d);
                let F = M / 2;
                const D = new lp([], Md);
                if (M === 0) return new be(l, d);
                for (let H = l; H < g; H += M)
                    for (let X = d; X < x; X += M) D.push(new ds(H + F, X + F, F, i));
                let U = function(H) {
                        let X = 0,
                            ne = 0,
                            le = 0;
                        const ce = H[0];
                        for (let Qe = 0, Se = ce.length, Re = Se - 1; Qe < Se; Re = Qe++) {
                            const ot = ce[Qe],
                                dt = ce[Re],
                                Ct = ot.x * dt.y - dt.x * ot.y;
                            ne += (ot.x + dt.x) * Ct, le += (ot.y + dt.y) * Ct, X += 3 * Ct
                        }
                        return new ds(ne / X, le / X, 0, H)
                    }(i),
                    N = D.length;
                for (; D.length;) {
                    const H = D.pop();
                    (H.d > U.d || !U.d) && (U = H, a && console.log("found best %d after %d probes", Math.round(1e4 * H.d) / 1e4, N)), H.max - U.d <= t || (F = H.h / 2, D.push(new ds(H.p.x - F, H.p.y - F, F, i)), D.push(new ds(H.p.x + F, H.p.y - F, F, i)), D.push(new ds(H.p.x - F, H.p.y + F, F, i)), D.push(new ds(H.p.x + F, H.p.y + F, F, i)), N += 4)
                }
                return a && (console.log(`num probes: ${N}`), console.log(`best distance: ${U.d}`)), U.p
            }

            function Md(i, t) {
                return t.max - i.max
            }

            function ds(i, t, a, l) {
                this.p = new be(i, t), this.h = a, this.d = function(d, g) {
                    let x = !1,
                        A = 1 / 0;
                    for (let M = 0; M < g.length; M++) {
                        const F = g[M];
                        for (let D = 0, U = F.length, N = U - 1; D < U; N = D++) {
                            const H = F[D],
                                X = F[N];
                            H.y > d.y != X.y > d.y && d.x < (X.x - H.x) * (d.y - H.y) / (X.y - H.y) + H.x && (x = !x), A = Math.min(A, Wh(d, H, X))
                        }
                    }
                    return (x ? 1 : -1) * Math.sqrt(A)
                }(this.p, l), this.max = this.d + this.h * Math.SQRT2
            }
            var Wr;
            C.ap = void 0, (Wr = C.ap || (C.ap = {}))[Wr.center = 1] = "center", Wr[Wr.left = 2] = "left", Wr[Wr.right = 3] = "right", Wr[Wr.top = 4] = "top", Wr[Wr.bottom = 5] = "bottom", Wr[Wr["top-left"] = 6] = "top-left", Wr[Wr["top-right"] = 7] = "top-right", Wr[Wr["bottom-left"] = 8] = "bottom-left", Wr[Wr["bottom-right"] = 9] = "bottom-right";
            const To = 7,
                Au = Number.POSITIVE_INFINITY;

            function hp(i, t) {
                return t[1] !== Au ? function(a, l, d) {
                    let g = 0,
                        x = 0;
                    switch (l = Math.abs(l), d = Math.abs(d), a) {
                        case "top-right":
                        case "top-left":
                        case "top":
                            x = d - To;
                            break;
                        case "bottom-right":
                        case "bottom-left":
                        case "bottom":
                            x = -d + To
                    }
                    switch (a) {
                        case "top-right":
                        case "bottom-right":
                        case "right":
                            g = -l;
                            break;
                        case "top-left":
                        case "bottom-left":
                        case "left":
                            g = l
                    }
                    return [g, x]
                }(i, t[0], t[1]) : function(a, l) {
                    let d = 0,
                        g = 0;
                    l < 0 && (l = 0);
                    const x = l / Math.SQRT2;
                    switch (a) {
                        case "top-right":
                        case "top-left":
                            g = x - To;
                            break;
                        case "bottom-right":
                        case "bottom-left":
                            g = -x + To;
                            break;
                        case "bottom":
                            g = -l + To;
                            break;
                        case "top":
                            g = l - To
                    }
                    switch (a) {
                        case "top-right":
                        case "bottom-right":
                            d = -x;
                            break;
                        case "top-left":
                        case "bottom-left":
                            d = x;
                            break;
                        case "left":
                            d = l;
                            break;
                        case "right":
                            d = -l
                    }
                    return [d, g]
                }(i, t[0])
            }

            function up(i, t, a) {
                var l;
                const d = i.layout,
                    g = (l = d.get("text-variable-anchor-offset")) === null || l === void 0 ? void 0 : l.evaluate(t, {}, a);
                if (g) {
                    const A = g.values,
                        M = [];
                    for (let F = 0; F < A.length; F += 2) {
                        const D = M[F] = A[F],
                            U = A[F + 1].map(N => N * Xn);
                        D.startsWith("top") ? U[1] -= To : D.startsWith("bottom") && (U[1] += To), M[F + 1] = U
                    }
                    return new ra(M)
                }
                const x = d.get("text-variable-anchor");
                if (x) {
                    let A;
                    A = i._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [d.get("text-radial-offset").evaluate(t, {}, a) * Xn, Au] : d.get("text-offset").evaluate(t, {}, a).map(F => F * Xn);
                    const M = [];
                    for (const F of x) M.push(F, hp(F, A));
                    return new ra(M)
                }
                return null
            }

            function Tu(i) {
                switch (i) {
                    case "right":
                    case "top-right":
                    case "bottom-right":
                        return "right";
                    case "left":
                    case "top-left":
                    case "bottom-left":
                        return "left"
                }
                return "center"
            }

            function Mu(i, t, a, l, d, g, x, A, M, F, D) {
                let U = g.textMaxSize.evaluate(t, {});
                U === void 0 && (U = x);
                const N = i.layers[0].layout,
                    H = N.get("icon-offset").evaluate(t, {}, D),
                    X = Bd(a.horizontal),
                    ne = x / 24,
                    le = i.tilePixelRatio * ne,
                    ce = i.tilePixelRatio * U / 24,
                    Qe = i.tilePixelRatio * A,
                    Se = i.tilePixelRatio * N.get("symbol-spacing"),
                    Re = N.get("text-padding") * i.tilePixelRatio,
                    ot = function(Xe, Zt, Ie, pt = 1) {
                        const xt = Xe.get("icon-padding").evaluate(Zt, {}, Ie),
                            Gt = xt && xt.values;
                        return [Gt[0] * pt, Gt[1] * pt, Gt[2] * pt, Gt[3] * pt]
                    }(N, t, D, i.tilePixelRatio),
                    dt = N.get("text-max-angle") / 180 * Math.PI,
                    Ct = N.get("text-rotation-alignment") !== "viewport" && N.get("symbol-placement") !== "point",
                    Nt = N.get("icon-rotation-alignment") === "map" && N.get("symbol-placement") !== "point",
                    qt = N.get("symbol-placement"),
                    Fe = Se / 2,
                    Be = N.get("icon-text-fit");
                let mt;
                l && Be !== "none" && (i.allowVerticalPlacement && a.vertical && (mt = il(l, a.vertical, Be, N.get("icon-text-fit-padding"), H, ne)), X && (l = il(l, X, Be, N.get("icon-text-fit-padding"), H, ne)));
                const lt = (Xe, Zt) => {
                    Zt.x < 0 || Zt.x >= fr || Zt.y < 0 || Zt.y >= fr || function(Ie, pt, xt, Gt, Xt, hi, _i, Di, nn, Fi, tn, gn, Kn, er, ia, oa, tr, jn, fi, Yr, Tn, mr, fa, qr, rs) {
                        const as = Ie.addToLineVertexArray(pt, xt);
                        let ps, to, ba, Za, Pa = 0,
                            io = 0,
                            Dl = 0,
                            Ld = 0,
                            Bu = -1,
                            Ge = -1;
                        const oi = {};
                        let kt = Hn("");
                        if (Ie.allowVerticalPlacement && Gt.vertical) {
                            const Yn = Di.layout.get("text-rotate").evaluate(Tn, {}, qr) + 90;
                            ba = new al(nn, pt, Fi, tn, gn, Gt.vertical, Kn, er, ia, Yn), _i && (Za = new al(nn, pt, Fi, tn, gn, _i, tr, jn, ia, Yn))
                        }
                        if (Xt) {
                            const Yn = Di.layout.get("icon-rotate").evaluate(Tn, {}),
                                Rr = Di.layout.get("icon-text-fit") !== "none",
                                xr = Lh(Xt, Yn, fa, Rr),
                                Ba = _i ? Lh(_i, Yn, fa, Rr) : void 0;
                            to = new al(nn, pt, Fi, tn, gn, Xt, tr, jn, !1, Yn), Pa = 4 * xr.length;
                            const Oa = Ie.iconSizeData;
                            let fs = null;
                            Oa.kind === "source" ? (fs = [Rs * Di.layout.get("icon-size").evaluate(Tn, {})], fs[0] > nl && li(`${Ie.layerIds[0]}: Value for "icon-size" is >= ${Ac}. Reduce your "icon-size".`)) : Oa.kind === "composite" && (fs = [Rs * mr.compositeIconSizes[0].evaluate(Tn, {}, qr), Rs * mr.compositeIconSizes[1].evaluate(Tn, {}, qr)], (fs[0] > nl || fs[1] > nl) && li(`${Ie.layerIds[0]}: Value for "icon-size" is >= ${Ac}. Reduce your "icon-size".`)), Ie.addSymbols(Ie.icon, xr, fs, Yr, fi, Tn, C.ah.none, pt, as.lineStartIndex, as.lineLength, -1, qr), Bu = Ie.icon.placedSymbolArray.length - 1, Ba && (io = 4 * Ba.length, Ie.addSymbols(Ie.icon, Ba, fs, Yr, fi, Tn, C.ah.vertical, pt, as.lineStartIndex, as.lineLength, -1, qr), Ge = Ie.icon.placedSymbolArray.length - 1)
                        }
                        const ui = Object.keys(Gt.horizontal);
                        for (const Yn of ui) {
                            const Rr = Gt.horizontal[Yn];
                            if (!ps) {
                                kt = Hn(Rr.text);
                                const Ba = Di.layout.get("text-rotate").evaluate(Tn, {}, qr);
                                ps = new al(nn, pt, Fi, tn, gn, Rr, Kn, er, ia, Ba)
                            }
                            const xr = Rr.positionedLines.length === 1;
                            if (Dl += Cd(Ie, pt, Rr, hi, Di, ia, Tn, oa, as, Gt.vertical ? C.ah.horizontal : C.ah.horizontalOnly, xr ? ui : [Yn], oi, Bu, mr, qr), xr) break
                        }
                        Gt.vertical && (Ld += Cd(Ie, pt, Gt.vertical, hi, Di, ia, Tn, oa, as, C.ah.vertical, ["vertical"], oi, Ge, mr, qr));
                        const Ni = ps ? ps.boxStartIndex : Ie.collisionBoxArray.length,
                            Rn = ps ? ps.boxEndIndex : Ie.collisionBoxArray.length,
                            En = ba ? ba.boxStartIndex : Ie.collisionBoxArray.length,
                            In = ba ? ba.boxEndIndex : Ie.collisionBoxArray.length,
                            ir = to ? to.boxStartIndex : Ie.collisionBoxArray.length,
                            Sn = to ? to.boxEndIndex : Ie.collisionBoxArray.length,
                            nr = Za ? Za.boxStartIndex : Ie.collisionBoxArray.length,
                            bn = Za ? Za.boxEndIndex : Ie.collisionBoxArray.length;
                        let zn = -1;
                        const ss = (Yn, Rr) => Yn && Yn.circleDiameter ? Math.max(Yn.circleDiameter, Rr) : Rr;
                        zn = ss(ps, zn), zn = ss(ba, zn), zn = ss(to, zn), zn = ss(Za, zn);
                        const Ur = zn > -1 ? 1 : 0;
                        Ur && (zn *= rs / Xn), Ie.glyphOffsetArray.length >= Ql.MAX_GLYPHS && li("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), Tn.sortKey !== void 0 && Ie.addToSortKeyRanges(Ie.symbolInstances.length, Tn.sortKey);
                        const Ul = up(Di, Tn, qr),
                            [ma, Il] = function(Yn, Rr) {
                                const xr = Yn.length,
                                    Ba = Rr == null ? void 0 : Rr.values;
                                if ((Ba == null ? void 0 : Ba.length) > 0)
                                    for (let Oa = 0; Oa < Ba.length; Oa += 2) {
                                        const fs = Ba[Oa + 1];
                                        Yn.emplaceBack(C.ap[Ba[Oa]], fs[0], fs[1])
                                    }
                                return [xr, Yn.length]
                            }(Ie.textAnchorOffsets, Ul);
                        Ie.symbolInstances.emplaceBack(pt.x, pt.y, oi.right >= 0 ? oi.right : -1, oi.center >= 0 ? oi.center : -1, oi.left >= 0 ? oi.left : -1, oi.vertical || -1, Bu, Ge, kt, Ni, Rn, En, In, ir, Sn, nr, bn, Fi, Dl, Ld, Pa, io, Ur, 0, Kn, zn, ma, Il)
                    }(i, Zt, Xe, a, l, d, mt, i.layers[0], i.collisionBoxArray, t.index, t.sourceLayerIndex, i.index, le, [Re, Re, Re, Re], Ct, M, Qe, ot, Nt, H, t, g, F, D, x)
                };
                if (qt === "line")
                    for (const Xe of Ed(t.geometry, 0, 0, fr, fr)) {
                        const Zt = eo(Xe, Se, dt, a.vertical || X, l, 24, ce, i.overscaling, fr);
                        for (const Ie of Zt) X && Rd(i, X.text, Fe, Ie) || lt(Xe, Ie)
                    } else if (qt === "line-center") {
                        for (const Xe of t.geometry)
                            if (Xe.length > 1) {
                                const Zt = Rp(Xe, dt, a.vertical || X, l, 24, ce);
                                Zt && lt(Xe, Zt)
                            }
                    } else if (t.type === "Polygon")
                    for (const Xe of Ys(t.geometry, 0)) {
                        const Zt = cp(Xe, 16);
                        lt(Xe[0], new Fs(Zt.x, Zt.y, 0))
                    } else if (t.type === "LineString")
                        for (const Xe of t.geometry) lt(Xe, new Fs(Xe[0].x, Xe[0].y, 0));
                    else if (t.type === "Point")
                    for (const Xe of t.geometry)
                        for (const Zt of Xe) lt([Zt], new Fs(Zt.x, Zt.y, 0))
            }

            function Cd(i, t, a, l, d, g, x, A, M, F, D, U, N, H, X) {
                const ne = function(Qe, Se, Re, ot, dt, Ct, Nt, qt) {
                        const Fe = ot.layout.get("text-rotate").evaluate(Ct, {}) * Math.PI / 180,
                            Be = [];
                        for (const mt of Se.positionedLines)
                            for (const lt of mt.positionedGlyphs) {
                                if (!lt.rect) continue;
                                const Xe = lt.rect || {};
                                let Zt = gu + 1,
                                    Ie = !0,
                                    pt = 1,
                                    xt = 0;
                                const Gt = (dt || qt) && lt.vertical,
                                    Xt = lt.metrics.advance * lt.scale / 2;
                                if (qt && Se.verticalizable && (xt = mt.lineOffset / 2 - (lt.imageName ? -(Xn - lt.metrics.width * lt.scale) / 2 : (lt.scale - 1) * Xn)), lt.imageName) {
                                    const Yr = Nt[lt.imageName];
                                    Ie = Yr.sdf, pt = Yr.pixelRatio, Zt = Ma / pt
                                }
                                const hi = dt ? [lt.x + Xt, lt.y] : [0, 0];
                                let _i = dt ? [0, 0] : [lt.x + Xt + Re[0], lt.y + Re[1] - xt],
                                    Di = [0, 0];
                                Gt && (Di = _i, _i = [0, 0]);
                                const nn = lt.metrics.isDoubleResolution ? 2 : 1,
                                    Fi = (lt.metrics.left - Zt) * lt.scale - Xt + _i[0],
                                    tn = (-lt.metrics.top - Zt) * lt.scale + _i[1],
                                    gn = Fi + Xe.w / nn * lt.scale / pt,
                                    Kn = tn + Xe.h / nn * lt.scale / pt,
                                    er = new be(Fi, tn),
                                    ia = new be(gn, tn),
                                    oa = new be(Fi, Kn),
                                    tr = new be(gn, Kn);
                                if (Gt) {
                                    const Yr = new be(-Xt, Xt - Ec),
                                        Tn = -Math.PI / 2,
                                        mr = Xn / 2 - Xt,
                                        fa = new be(5 - Ec - mr, -(lt.imageName ? mr : 0)),
                                        qr = new be(...Di);
                                    er._rotateAround(Tn, Yr)._add(fa)._add(qr), ia._rotateAround(Tn, Yr)._add(fa)._add(qr), oa._rotateAround(Tn, Yr)._add(fa)._add(qr), tr._rotateAround(Tn, Yr)._add(fa)._add(qr)
                                }
                                if (Fe) {
                                    const Yr = Math.sin(Fe),
                                        Tn = Math.cos(Fe),
                                        mr = [Tn, -Yr, Yr, Tn];
                                    er._matMult(mr), ia._matMult(mr), oa._matMult(mr), tr._matMult(mr)
                                }
                                const jn = new be(0, 0),
                                    fi = new be(0, 0);
                                Be.push({
                                    tl: er,
                                    tr: ia,
                                    bl: oa,
                                    br: tr,
                                    tex: Xe,
                                    writingMode: Se.writingMode,
                                    glyphOffset: hi,
                                    sectionIndex: lt.sectionIndex,
                                    isSDF: Ie,
                                    pixelOffsetTL: jn,
                                    pixelOffsetBR: fi,
                                    minFontScaleX: 0,
                                    minFontScaleY: 0
                                })
                            }
                        return Be
                    }(0, a, A, d, g, x, l, i.allowVerticalPlacement),
                    le = i.textSizeData;
                let ce = null;
                le.kind === "source" ? (ce = [Rs * d.layout.get("text-size").evaluate(x, {})], ce[0] > nl && li(`${i.layerIds[0]}: Value for "text-size" is >= ${Ac}. Reduce your "text-size".`)) : le.kind === "composite" && (ce = [Rs * H.compositeTextSizes[0].evaluate(x, {}, X), Rs * H.compositeTextSizes[1].evaluate(x, {}, X)], (ce[0] > nl || ce[1] > nl) && li(`${i.layerIds[0]}: Value for "text-size" is >= ${Ac}. Reduce your "text-size".`)), i.addSymbols(i.text, ne, ce, A, g, x, F, t, M.lineStartIndex, M.lineLength, N, X);
                for (const Qe of D) U[Qe] = i.text.placedSymbolArray.length - 1;
                return 4 * ne.length
            }

            function Bd(i) {
                for (const t in i) return i[t];
                return null
            }

            function Rd(i, t, a, l) {
                const d = i.compareText;
                if (t in d) {
                    const g = d[t];
                    for (let x = g.length - 1; x >= 0; x--)
                        if (l.dist(g[x]) < a) return !0
                } else d[t] = [];
                return d[t].push(l), !1
            }
            const Cu = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
            class Fd {
                static from(t) {
                    if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
                    const [a, l] = new Uint8Array(t, 0, 2);
                    if (a !== 219) throw new Error("Data does not appear to be in a KDBush format.");
                    const d = l >> 4;
                    if (d !== 1) throw new Error(`Got v${d} data when expected v1.`);
                    const g = Cu[15 & l];
                    if (!g) throw new Error("Unrecognized array type.");
                    const [x] = new Uint16Array(t, 2, 1), [A] = new Uint32Array(t, 4, 1);
                    return new Fd(A, x, g, t)
                }
                constructor(t, a = 64, l = Float64Array, d) {
                    if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
                    this.numItems = +t, this.nodeSize = Math.min(Math.max(+a, 2), 65535), this.ArrayType = l, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
                    const g = Cu.indexOf(this.ArrayType),
                        x = 2 * t * this.ArrayType.BYTES_PER_ELEMENT,
                        A = t * this.IndexArrayType.BYTES_PER_ELEMENT,
                        M = (8 - A % 8) % 8;
                    if (g < 0) throw new Error(`Unexpected typed array class: ${l}.`);
                    d && d instanceof ArrayBuffer ? (this.data = d, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + A + M, 2 * t), this._pos = 2 * t, this._finished = !0) : (this.data = new ArrayBuffer(8 + x + A + M), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + A + M, 2 * t), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + g]), new Uint16Array(this.data, 2, 1)[0] = a, new Uint32Array(this.data, 4, 1)[0] = t)
                }
                add(t, a) {
                    const l = this._pos >> 1;
                    return this.ids[l] = l, this.coords[this._pos++] = t, this.coords[this._pos++] = a, l
                }
                finish() {
                    const t = this._pos >> 1;
                    if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
                    return s(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this
                }
                range(t, a, l, d) {
                    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
                    const {
                        ids: g,
                        coords: x,
                        nodeSize: A
                    } = this, M = [0, g.length - 1, 0], F = [];
                    for (; M.length;) {
                        const D = M.pop() || 0,
                            U = M.pop() || 0,
                            N = M.pop() || 0;
                        if (U - N <= A) {
                            for (let le = N; le <= U; le++) {
                                const ce = x[2 * le],
                                    Qe = x[2 * le + 1];
                                ce >= t && ce <= l && Qe >= a && Qe <= d && F.push(g[le])
                            }
                            continue
                        }
                        const H = N + U >> 1,
                            X = x[2 * H],
                            ne = x[2 * H + 1];
                        X >= t && X <= l && ne >= a && ne <= d && F.push(g[H]), (D === 0 ? t <= X : a <= ne) && (M.push(N), M.push(H - 1), M.push(1 - D)), (D === 0 ? l >= X : d >= ne) && (M.push(H + 1), M.push(U), M.push(1 - D))
                    }
                    return F
                }
                within(t, a, l) {
                    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
                    const {
                        ids: d,
                        coords: g,
                        nodeSize: x
                    } = this, A = [0, d.length - 1, 0], M = [], F = l * l;
                    for (; A.length;) {
                        const D = A.pop() || 0,
                            U = A.pop() || 0,
                            N = A.pop() || 0;
                        if (U - N <= x) {
                            for (let le = N; le <= U; le++) c(g[2 * le], g[2 * le + 1], t, a) <= F && M.push(d[le]);
                            continue
                        }
                        const H = N + U >> 1,
                            X = g[2 * H],
                            ne = g[2 * H + 1];
                        c(X, ne, t, a) <= F && M.push(d[H]), (D === 0 ? t - l <= X : a - l <= ne) && (A.push(N), A.push(H - 1), A.push(1 - D)), (D === 0 ? t + l >= X : a + l >= ne) && (A.push(H + 1), A.push(U), A.push(1 - D))
                    }
                    return M
                }
            }

            function s(i, t, a, l, d, g) {
                if (d - l <= a) return;
                const x = l + d >> 1;
                e(i, t, x, l, d, g), s(i, t, a, l, x - 1, 1 - g), s(i, t, a, x + 1, d, 1 - g)
            }

            function e(i, t, a, l, d, g) {
                for (; d > l;) {
                    if (d - l > 600) {
                        const F = d - l + 1,
                            D = a - l + 1,
                            U = Math.log(F),
                            N = .5 * Math.exp(2 * U / 3),
                            H = .5 * Math.sqrt(U * N * (F - N) / F) * (D - F / 2 < 0 ? -1 : 1);
                        e(i, t, a, Math.max(l, Math.floor(a - D * N / F + H)), Math.min(d, Math.floor(a + (F - D) * N / F + H)), g)
                    }
                    const x = t[2 * a + g];
                    let A = l,
                        M = d;
                    for (r(i, t, l, a), t[2 * d + g] > x && r(i, t, l, d); A < M;) {
                        for (r(i, t, A, M), A++, M--; t[2 * A + g] < x;) A++;
                        for (; t[2 * M + g] > x;) M--
                    }
                    t[2 * l + g] === x ? r(i, t, l, M) : (M++, r(i, t, M, d)), M <= a && (l = M + 1), a <= M && (d = M - 1)
                }
            }

            function r(i, t, a, l) {
                h(i, a, l), h(t, 2 * a, 2 * l), h(t, 2 * a + 1, 2 * l + 1)
            }

            function h(i, t, a) {
                const l = i[t];
                i[t] = i[a], i[a] = l
            }

            function c(i, t, a, l) {
                const d = i - a,
                    g = t - l;
                return d * d + g * g
            }
            var v;
            C.bc = void 0, (v = C.bc || (C.bc = {})).create = "create", v.load = "load", v.fullLoad = "fullLoad";
            let w = null,
                E = [];
            const T = 1e3 / 60,
                B = "loadTime",
                Q = "fullLoadTime",
                k = {
                    mark(i) {
                        performance.mark(i)
                    },
                    frame(i) {
                        const t = i;
                        w != null && E.push(t - w), w = t
                    },
                    clearMetrics() {
                        w = null, E = [], performance.clearMeasures(B), performance.clearMeasures(Q);
                        for (const i in C.bc) performance.clearMarks(C.bc[i])
                    },
                    getPerformanceMetrics() {
                        performance.measure(B, C.bc.create, C.bc.load), performance.measure(Q, C.bc.create, C.bc.fullLoad);
                        const i = performance.getEntriesByName(B)[0].duration,
                            t = performance.getEntriesByName(Q)[0].duration,
                            a = E.length,
                            l = 1 / (E.reduce((g, x) => g + x, 0) / a / 1e3),
                            d = E.filter(g => g > T).reduce((g, x) => g + (x - T) / T, 0);
                        return {
                            loadTime: i,
                            fullLoadTime: t,
                            fps: l,
                            percentDroppedFrames: d / (a + d) * 100,
                            totalFrames: a
                        }
                    }
                };
            C.$ = Ki, C.A = _o, C.B = function(i) {
                if (_e == null) {
                    const t = i.navigator ? i.navigator.userAgent : null;
                    _e = !!i.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")))
                }
                return _e
            }, C.C = class {
                constructor(i, t) {
                    this.target = i, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new rp(() => this.process()), this.subscription = function(a, l, d, g) {
                        return a.addEventListener(l, d, !1), {
                            unsubscribe: () => {
                                a.removeEventListener(l, d, !1)
                            }
                        }
                    }(this.target, "message", a => this.receive(a)), this.globalScope = ae(self) ? i : window
                }
                registerMessageHandler(i, t) {
                    this.messageHandlers[i] = t
                }
                sendAsync(i, t) {
                    return new Promise((a, l) => {
                        const d = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
                        this.resolveRejects[d] = {
                            resolve: a,
                            reject: l
                        }, t && t.signal.addEventListener("abort", () => {
                            delete this.resolveRejects[d];
                            const A = {
                                id: d,
                                type: "<cancel>",
                                origin: location.origin,
                                targetMapId: i.targetMapId,
                                sourceMapId: this.mapId
                            };
                            this.target.postMessage(A)
                        }, {
                            once: !0
                        });
                        const g = [],
                            x = Object.assign(Object.assign({}, i), {
                                id: d,
                                sourceMapId: this.mapId,
                                origin: location.origin,
                                data: Uo(i.data, g)
                            });
                        this.target.postMessage(x, {
                            transfer: g
                        })
                    })
                }
                receive(i) {
                    const t = i.data,
                        a = t.id;
                    if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
                        if (t.type === "<cancel>") {
                            delete this.tasks[a];
                            const l = this.abortControllers[a];
                            return delete this.abortControllers[a], void(l && l.abort())
                        }
                        if (ae(self) || t.mustQueue) return this.tasks[a] = t, this.taskQueue.push(a), void this.invoker.trigger();
                        this.processTask(a, t)
                    }
                }
                process() {
                    if (this.taskQueue.length === 0) return;
                    const i = this.taskQueue.shift(),
                        t = this.tasks[i];
                    delete this.tasks[i], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(i, t)
                }
                processTask(i, t) {
                    return p(this, void 0, void 0, function*() {
                        if (t.type === "<response>") {
                            const d = this.resolveRejects[i];
                            return delete this.resolveRejects[i], d ? void(t.error ? d.reject(vl(t.error)) : d.resolve(vl(t.data))) : void 0
                        }
                        if (!this.messageHandlers[t.type]) return void this.completeTask(i, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
                        const a = vl(t.data),
                            l = new AbortController;
                        this.abortControllers[i] = l;
                        try {
                            const d = yield this.messageHandlers[t.type](t.sourceMapId, a, l);
                            this.completeTask(i, null, d)
                        } catch (d) {
                            this.completeTask(i, d)
                        }
                    })
                }
                completeTask(i, t, a) {
                    const l = [];
                    delete this.abortControllers[i];
                    const d = {
                        id: i,
                        type: "<response>",
                        sourceMapId: this.mapId,
                        origin: location.origin,
                        error: t ? Uo(t) : null,
                        data: Uo(a, l)
                    };
                    this.target.postMessage(d, {
                        transfer: l
                    })
                }
                remove() {
                    this.invoker.remove(), this.subscription.unsubscribe()
                }
            }, C.D = Ji, C.E = Bt, C.F = function() {
                var i = new _o(16);
                return _o != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0), i[0] = 1, i[5] = 1, i[10] = 1, i[15] = 1, i
            }, C.G = xi, C.H = function(i, t, a) {
                var l, d, g, x, A, M, F, D, U, N, H, X, ne = a[0],
                    le = a[1],
                    ce = a[2];
                return t === i ? (i[12] = t[0] * ne + t[4] * le + t[8] * ce + t[12], i[13] = t[1] * ne + t[5] * le + t[9] * ce + t[13], i[14] = t[2] * ne + t[6] * le + t[10] * ce + t[14], i[15] = t[3] * ne + t[7] * le + t[11] * ce + t[15]) : (d = t[1], g = t[2], x = t[3], A = t[4], M = t[5], F = t[6], D = t[7], U = t[8], N = t[9], H = t[10], X = t[11], i[0] = l = t[0], i[1] = d, i[2] = g, i[3] = x, i[4] = A, i[5] = M, i[6] = F, i[7] = D, i[8] = U, i[9] = N, i[10] = H, i[11] = X, i[12] = l * ne + A * le + U * ce + t[12], i[13] = d * ne + M * le + N * ce + t[13], i[14] = g * ne + F * le + H * ce + t[14], i[15] = x * ne + D * le + X * ce + t[15]), i
            }, C.I = ld, C.J = function(i, t, a) {
                var l = a[0],
                    d = a[1],
                    g = a[2];
                return i[0] = t[0] * l, i[1] = t[1] * l, i[2] = t[2] * l, i[3] = t[3] * l, i[4] = t[4] * d, i[5] = t[5] * d, i[6] = t[6] * d, i[7] = t[7] * d, i[8] = t[8] * g, i[9] = t[9] * g, i[10] = t[10] * g, i[11] = t[11] * g, i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i
            }, C.K = th, C.L = function(i, t) {
                const a = {};
                for (let l = 0; l < t.length; l++) {
                    const d = t[l];
                    d in i && (a[d] = i[d])
                }
                return a
            }, C.M = So, C.N = Ao, C.O = Mh, C.P = be, C.Q = Ja, C.R = es, C.S = Ke, C.T = Oh, C.U = Ye, C.V = st, C.W = fr, C.X = kr, C.Y = Ch, C.Z = class extends Jc {}, C._ = p, C.a = Dt, C.a$ = function(i, t) {
                return i[0] * t[0] + i[1] * t[1] + i[2] * t[2] + i[3] * t[3]
            }, C.a0 = bu, C.a1 = Pt, C.a2 = i => {
                const t = window.document.createElement("video");
                return t.muted = !0, new Promise(a => {
                    t.onloadstart = () => {
                        a(t)
                    };
                    for (const l of i) {
                        const d = window.document.createElement("source");
                        Ue(l) || (t.crossOrigin = "Anonymous"), d.src = l, t.appendChild(d)
                    }
                })
            }, C.a3 = function() {
                return vi++
            }, C.a4 = n, C.a5 = Ql, C.a6 = Us, C.a7 = Ws, C.a8 = cr, C.a9 = Rh, C.aA = ct, C.aB = function(i, t) {
                if (!i) return [{
                    command: "setStyle",
                    args: [t]
                }];
                let a = [];
                try {
                    if (!Wt(i.version, t.version)) return [{
                        command: "setStyle",
                        args: [t]
                    }];
                    Wt(i.center, t.center) || a.push({
                        command: "setCenter",
                        args: [t.center]
                    }), Wt(i.zoom, t.zoom) || a.push({
                        command: "setZoom",
                        args: [t.zoom]
                    }), Wt(i.bearing, t.bearing) || a.push({
                        command: "setBearing",
                        args: [t.bearing]
                    }), Wt(i.pitch, t.pitch) || a.push({
                        command: "setPitch",
                        args: [t.pitch]
                    }), Wt(i.sprite, t.sprite) || a.push({
                        command: "setSprite",
                        args: [t.sprite]
                    }), Wt(i.glyphs, t.glyphs) || a.push({
                        command: "setGlyphs",
                        args: [t.glyphs]
                    }), Wt(i.transition, t.transition) || a.push({
                        command: "setTransition",
                        args: [t.transition]
                    }), Wt(i.light, t.light) || a.push({
                        command: "setLight",
                        args: [t.light]
                    }), Wt(i.terrain, t.terrain) || a.push({
                        command: "setTerrain",
                        args: [t.terrain]
                    }), Wt(i.sky, t.sky) || a.push({
                        command: "setSky",
                        args: [t.sky]
                    });
                    const l = {},
                        d = [];
                    (function(x, A, M, F) {
                        let D;
                        for (D in A = A || {}, x = x || {}) Object.prototype.hasOwnProperty.call(x, D) && (Object.prototype.hasOwnProperty.call(A, D) || sn(D, M, F));
                        for (D in A) Object.prototype.hasOwnProperty.call(A, D) && (Object.prototype.hasOwnProperty.call(x, D) ? Wt(x[D], A[D]) || (x[D].type === "geojson" && A[D].type === "geojson" && Yi(x, A, D) ? bi(M, {
                            command: "setGeoJSONSourceData",
                            args: [D, A[D].data]
                        }) : yn(D, A, M, F)) : Qi(D, A, M))
                    })(i.sources, t.sources, d, l);
                    const g = [];
                    i.layers && i.layers.forEach(x => {
                            "source" in x && l[x.source] ? a.push({
                                command: "removeLayer",
                                args: [x.id]
                            }) : g.push(x)
                        }), a = a.concat(d),
                        function(x, A, M) {
                            A = A || [];
                            const F = (x = x || []).map(Mi),
                                D = A.map(Mi),
                                U = x.reduce(Ht, {}),
                                N = A.reduce(Ht, {}),
                                H = F.slice(),
                                X = Object.create(null);
                            let ne, le, ce, Qe, Se;
                            for (let Re = 0, ot = 0; Re < F.length; Re++) ne = F[Re], Object.prototype.hasOwnProperty.call(N, ne) ? ot++ : (bi(M, {
                                command: "removeLayer",
                                args: [ne]
                            }), H.splice(H.indexOf(ne, ot), 1));
                            for (let Re = 0, ot = 0; Re < D.length; Re++) ne = D[D.length - 1 - Re], H[H.length - 1 - Re] !== ne && (Object.prototype.hasOwnProperty.call(U, ne) ? (bi(M, {
                                command: "removeLayer",
                                args: [ne]
                            }), H.splice(H.lastIndexOf(ne, H.length - ot), 1)) : ot++, Qe = H[H.length - Re], bi(M, {
                                command: "addLayer",
                                args: [N[ne], Qe]
                            }), H.splice(H.length - Re, 0, ne), X[ne] = !0);
                            for (let Re = 0; Re < D.length; Re++)
                                if (ne = D[Re], le = U[ne], ce = N[ne], !X[ne] && !Wt(le, ce))
                                    if (Wt(le.source, ce.source) && Wt(le["source-layer"], ce["source-layer"]) && Wt(le.type, ce.type)) {
                                        for (Se in rn(le.layout, ce.layout, M, ne, null, "setLayoutProperty"), rn(le.paint, ce.paint, M, ne, null, "setPaintProperty"), Wt(le.filter, ce.filter) || bi(M, {
                                                command: "setFilter",
                                                args: [ne, ce.filter]
                                            }), Wt(le.minzoom, ce.minzoom) && Wt(le.maxzoom, ce.maxzoom) || bi(M, {
                                                command: "setLayerZoomRange",
                                                args: [ne, ce.minzoom, ce.maxzoom]
                                            }), le) Object.prototype.hasOwnProperty.call(le, Se) && Se !== "layout" && Se !== "paint" && Se !== "filter" && Se !== "metadata" && Se !== "minzoom" && Se !== "maxzoom" && (Se.indexOf("paint.") === 0 ? rn(le[Se], ce[Se], M, ne, Se.slice(6), "setPaintProperty") : Wt(le[Se], ce[Se]) || bi(M, {
                                            command: "setLayerProperty",
                                            args: [ne, Se, ce[Se]]
                                        }));
                                        for (Se in ce) Object.prototype.hasOwnProperty.call(ce, Se) && !Object.prototype.hasOwnProperty.call(le, Se) && Se !== "layout" && Se !== "paint" && Se !== "filter" && Se !== "metadata" && Se !== "minzoom" && Se !== "maxzoom" && (Se.indexOf("paint.") === 0 ? rn(le[Se], ce[Se], M, ne, Se.slice(6), "setPaintProperty") : Wt(le[Se], ce[Se]) || bi(M, {
                                            command: "setLayerProperty",
                                            args: [ne, Se, ce[Se]]
                                        }))
                                    } else bi(M, {
                                        command: "removeLayer",
                                        args: [ne]
                                    }), Qe = H[H.lastIndexOf(ne) + 1], bi(M, {
                                        command: "addLayer",
                                        args: [ce, Qe]
                                    })
                        }(g, t.layers, a)
                } catch (l) {
                    console.warn("Unable to compute style diff:", l), a = [{
                        command: "setStyle",
                        args: [t]
                    }]
                }
                return a
            }, C.aC = function(i) {
                const t = [],
                    a = i.id;
                return a === void 0 && t.push({
                    message: `layers.${a}: missing required property "id"`
                }), i.render === void 0 && t.push({
                    message: `layers.${a}: missing required method "render"`
                }), i.renderingMode && i.renderingMode !== "2d" && i.renderingMode !== "3d" && t.push({
                    message: `layers.${a}: property "renderingMode" must be either "2d" or "3d"`
                }), t
            }, C.aD = function i(t, a) {
                if (Array.isArray(t)) {
                    if (!Array.isArray(a) || t.length !== a.length) return !1;
                    for (let l = 0; l < t.length; l++)
                        if (!i(t[l], a[l])) return !1;
                    return !0
                }
                if (typeof t == "object" && t !== null && a !== null) {
                    if (typeof a != "object" || Object.keys(t).length !== Object.keys(a).length) return !1;
                    for (const l in t)
                        if (!i(t[l], a[l])) return !1;
                    return !0
                }
                return t === a
            }, C.aE = Li, C.aF = Ei, C.aG = class extends pa {
                constructor(i, t) {
                    super(i, t), this.current = 0
                }
                set(i) {
                    this.current !== i && (this.current = i, this.gl.uniform1i(this.location, i))
                }
            }, C.aH = Ia, C.aI = class extends pa {
                constructor(i, t) {
                    super(i, t), this.current = No
                }
                set(i) {
                    if (i[12] !== this.current[12] || i[0] !== this.current[0]) return this.current = i, void this.gl.uniformMatrix4fv(this.location, !1, i);
                    for (let t = 1; t < 16; t++)
                        if (i[t] !== this.current[t]) {
                            this.current = i, this.gl.uniformMatrix4fv(this.location, !1, i);
                            break
                        }
                }
            }, C.aJ = Ts, C.aK = class extends pa {
                constructor(i, t) {
                    super(i, t), this.current = [0, 0, 0]
                }
                set(i) {
                    i[0] === this.current[0] && i[1] === this.current[1] && i[2] === this.current[2] || (this.current = i, this.gl.uniform3f(this.location, i[0], i[1], i[2]))
                }
            }, C.aL = class extends pa {
                constructor(i, t) {
                    super(i, t), this.current = [0, 0]
                }
                set(i) {
                    i[0] === this.current[0] && i[1] === this.current[1] || (this.current = i, this.gl.uniform2f(this.location, i[0], i[1]))
                }
            }, C.aM = mo, C.aN = function(i, t, a, l, d, g, x) {
                var A = 1 / (t - a),
                    M = 1 / (l - d),
                    F = 1 / (g - x);
                return i[0] = -2 * A, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = -2 * M, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 2 * F, i[11] = 0, i[12] = (t + a) * A, i[13] = (d + l) * M, i[14] = (x + g) * F, i[15] = 1, i
            }, C.aO = _n, C.aP = Zh, C.aQ = class extends Sl {}, C.aR = Zd, C.aS = class extends Gs {}, C.aT = function(i) {
                return i <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(i) / Math.LN2))
            }, C.aU = Od, C.aV = pe, C.aW = class extends oc {}, C.aX = ci, C.aY = function(i, t) {
                var a = i[0],
                    l = i[1],
                    d = i[2],
                    g = i[3],
                    x = i[4],
                    A = i[5],
                    M = i[6],
                    F = i[7],
                    D = i[8],
                    U = i[9],
                    N = i[10],
                    H = i[11],
                    X = i[12],
                    ne = i[13],
                    le = i[14],
                    ce = i[15],
                    Qe = t[0],
                    Se = t[1],
                    Re = t[2],
                    ot = t[3],
                    dt = t[4],
                    Ct = t[5],
                    Nt = t[6],
                    qt = t[7],
                    Fe = t[8],
                    Be = t[9],
                    mt = t[10],
                    lt = t[11],
                    Xe = t[12],
                    Zt = t[13],
                    Ie = t[14],
                    pt = t[15];
                return Math.abs(a - Qe) <= ta * Math.max(1, Math.abs(a), Math.abs(Qe)) && Math.abs(l - Se) <= ta * Math.max(1, Math.abs(l), Math.abs(Se)) && Math.abs(d - Re) <= ta * Math.max(1, Math.abs(d), Math.abs(Re)) && Math.abs(g - ot) <= ta * Math.max(1, Math.abs(g), Math.abs(ot)) && Math.abs(x - dt) <= ta * Math.max(1, Math.abs(x), Math.abs(dt)) && Math.abs(A - Ct) <= ta * Math.max(1, Math.abs(A), Math.abs(Ct)) && Math.abs(M - Nt) <= ta * Math.max(1, Math.abs(M), Math.abs(Nt)) && Math.abs(F - qt) <= ta * Math.max(1, Math.abs(F), Math.abs(qt)) && Math.abs(D - Fe) <= ta * Math.max(1, Math.abs(D), Math.abs(Fe)) && Math.abs(U - Be) <= ta * Math.max(1, Math.abs(U), Math.abs(Be)) && Math.abs(N - mt) <= ta * Math.max(1, Math.abs(N), Math.abs(mt)) && Math.abs(H - lt) <= ta * Math.max(1, Math.abs(H), Math.abs(lt)) && Math.abs(X - Xe) <= ta * Math.max(1, Math.abs(X), Math.abs(Xe)) && Math.abs(ne - Zt) <= ta * Math.max(1, Math.abs(ne), Math.abs(Zt)) && Math.abs(le - Ie) <= ta * Math.max(1, Math.abs(le), Math.abs(Ie)) && Math.abs(ce - pt) <= ta * Math.max(1, Math.abs(ce), Math.abs(pt))
            }, C.aZ = function(i, t) {
                return i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[4] = t[4], i[5] = t[5], i[6] = t[6], i[7] = t[7], i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i
            }, C.a_ = function(i, t, a) {
                return i[0] = t[0] * a[0], i[1] = t[1] * a[1], i[2] = t[2] * a[2], i[3] = t[3] * a[3], i
            }, C.aa = function(i) {
                const t = {};
                if (i.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (a, l, d, g) => {
                        const x = d || g;
                        return t[l] = !x || x.toLowerCase(), ""
                    }), t["max-age"]) {
                    const a = parseInt(t["max-age"], 10);
                    isNaN(a) ? delete t["max-age"] : t["max-age"] = a
                }
                return t
            }, C.ab = function(i, t) {
                const a = [];
                for (const l in i) l in t || a.push(l);
                return a
            }, C.ac = $e, C.ad = function(i, t, a) {
                var l = Math.sin(a),
                    d = Math.cos(a),
                    g = t[0],
                    x = t[1],
                    A = t[2],
                    M = t[3],
                    F = t[4],
                    D = t[5],
                    U = t[6],
                    N = t[7];
                return t !== i && (i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[0] = g * d + F * l, i[1] = x * d + D * l, i[2] = A * d + U * l, i[3] = M * d + N * l, i[4] = F * d - g * l, i[5] = D * d - x * l, i[6] = U * d - A * l, i[7] = N * d - M * l, i
            }, C.ae = function(i) {
                var t = new _o(16);
                return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], t
            }, C.af = uc, C.ag = function(i, t) {
                let a = 0,
                    l = 0;
                if (i.kind === "constant") l = i.layoutSize;
                else if (i.kind !== "source") {
                    const {
                        interpolationType: d,
                        minZoom: g,
                        maxZoom: x
                    } = i, A = d ? $e(Bi.interpolationFactor(d, t, g, x), 0, 1) : 0;
                    i.kind === "camera" ? l = en.number(i.minSize, i.maxSize, A) : a = A
                }
                return {
                    uSizeT: a,
                    uSize: l
                }
            }, C.ai = function(i, {
                uSize: t,
                uSizeT: a
            }, {
                lowerSize: l,
                upperSize: d
            }) {
                return i.kind === "source" ? l / Rs : i.kind === "composite" ? en.number(l / Rs, d / Rs, a) : t
            }, C.aj = hd, C.ak = function(i, t, a, l) {
                const d = t.y - i.y,
                    g = t.x - i.x,
                    x = l.y - a.y,
                    A = l.x - a.x,
                    M = x * g - A * d;
                if (M === 0) return null;
                const F = (A * (i.y - a.y) - x * (i.x - a.x)) / M;
                return new be(i.x + F * g, i.y + F * d)
            }, C.al = Ed, C.am = za, C.an = Js, C.ao = Xn, C.aq = Th, C.ar = function(i, t) {
                var a = t[0],
                    l = t[1],
                    d = t[2],
                    g = t[3],
                    x = t[4],
                    A = t[5],
                    M = t[6],
                    F = t[7],
                    D = t[8],
                    U = t[9],
                    N = t[10],
                    H = t[11],
                    X = t[12],
                    ne = t[13],
                    le = t[14],
                    ce = t[15],
                    Qe = a * A - l * x,
                    Se = a * M - d * x,
                    Re = a * F - g * x,
                    ot = l * M - d * A,
                    dt = l * F - g * A,
                    Ct = d * F - g * M,
                    Nt = D * ne - U * X,
                    qt = D * le - N * X,
                    Fe = D * ce - H * X,
                    Be = U * le - N * ne,
                    mt = U * ce - H * ne,
                    lt = N * ce - H * le,
                    Xe = Qe * lt - Se * mt + Re * Be + ot * Fe - dt * qt + Ct * Nt;
                return Xe ? (i[0] = (A * lt - M * mt + F * Be) * (Xe = 1 / Xe), i[1] = (d * mt - l * lt - g * Be) * Xe, i[2] = (ne * Ct - le * dt + ce * ot) * Xe, i[3] = (N * dt - U * Ct - H * ot) * Xe, i[4] = (M * Fe - x * lt - F * qt) * Xe, i[5] = (a * lt - d * Fe + g * qt) * Xe, i[6] = (le * Re - X * Ct - ce * Se) * Xe, i[7] = (D * Ct - N * Re + H * Se) * Xe, i[8] = (x * mt - A * Fe + F * Nt) * Xe, i[9] = (l * Fe - a * mt - g * Nt) * Xe, i[10] = (X * dt - ne * Re + ce * Qe) * Xe, i[11] = (U * Re - D * dt - H * Qe) * Xe, i[12] = (A * qt - x * Be - M * Nt) * Xe, i[13] = (a * Be - l * qt + d * Nt) * Xe, i[14] = (ne * Se - X * ot - le * Qe) * Xe, i[15] = (D * ot - U * Se + N * Qe) * Xe, i) : null
            }, C.as = Tu, C.at = Eo, C.au = Fd, C.av = function() {
                const i = {},
                    t = Le.$version;
                for (const a in Le.$root) {
                    const l = Le.$root[a];
                    if (l.required) {
                        let d = null;
                        d = a === "version" ? t : l.type === "array" ? [] : {}, d != null && (i[a] = d)
                    }
                }
                return i
            }, C.aw = Xl, C.ax = ve, C.ay = function(i) {
                i = i.slice();
                const t = Object.create(null);
                for (let a = 0; a < i.length; a++) t[i[a].id] = i[a];
                for (let a = 0; a < i.length; a++) "ref" in i[a] && (i[a] = ii(i[a], t[i[a].ref]));
                return i
            }, C.az = function(i) {
                if (i.type === "custom") return new Tc(i);
                switch (i.type) {
                    case "background":
                        return new yd(i);
                    case "circle":
                        return new Xh(i);
                    case "fill":
                        return new Br(i);
                    case "fill-extrusion":
                        return new au(i);
                    case "heatmap":
                        return new xp(i);
                    case "hillshade":
                        return new bp(i);
                    case "line":
                        return new gh(i);
                    case "raster":
                        return new np(i);
                    case "symbol":
                        return new Pl(i)
                }
            }, C.b = xe, C.b0 = vt, C.b1 = bd, C.b2 = _u, C.b3 = function(i, t, a, l, d) {
                var g, x = 1 / Math.tan(t / 2);
                return i[0] = x / a, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = x, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = -1, i[12] = 0, i[13] = 0, i[15] = 0, d != null && d !== 1 / 0 ? (i[10] = (d + l) * (g = 1 / (l - d)), i[14] = 2 * d * l * g) : (i[10] = -1, i[14] = -2 * l), i
            }, C.b4 = function(i, t, a) {
                var l = Math.sin(a),
                    d = Math.cos(a),
                    g = t[4],
                    x = t[5],
                    A = t[6],
                    M = t[7],
                    F = t[8],
                    D = t[9],
                    U = t[10],
                    N = t[11];
                return t !== i && (i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[4] = g * d + F * l, i[5] = x * d + D * l, i[6] = A * d + U * l, i[7] = M * d + N * l, i[8] = F * d - g * l, i[9] = D * d - x * l, i[10] = U * d - A * l, i[11] = N * d - M * l, i
            }, C.b5 = jt, C.b6 = di, C.b7 = function(i) {
                return i * Math.PI / 180
            }, C.b8 = function(i, t) {
                return i[0] = t[0], i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = t[1], i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = t[2], i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i
            }, C.b9 = class extends ic {}, C.ba = Mc, C.bb = k, C.bd = oe, C.be = function(i, t) {
                Dt.REGISTERED_PROTOCOLS[i] = t
            }, C.bf = function(i) {
                delete Dt.REGISTERED_PROTOCOLS[i]
            }, C.bg = function(i, t) {
                const a = {};
                for (let d = 0; d < i.length; d++) {
                    const g = t && t[i[d].id] || Qu(i[d]);
                    t && (t[i[d].id] = g);
                    let x = a[g];
                    x || (x = a[g] = []), x.push(i[d])
                }
                const l = [];
                for (const d in a) l.push(a[d]);
                return l
            }, C.bh = Ii, C.bi = wd, C.bj = Hr, C.bk = wh, C.bl = function(i) {
                i.bucket.createArrays(), i.bucket.tilePixelRatio = fr / (512 * i.bucket.overscaling), i.bucket.compareText = {}, i.bucket.iconsNeedLinear = !1;
                const t = i.bucket.layers[0],
                    a = t.layout,
                    l = t._unevaluatedLayout._values,
                    d = {
                        layoutIconSize: l["icon-size"].possiblyEvaluate(new cr(i.bucket.zoom + 1), i.canonical),
                        layoutTextSize: l["text-size"].possiblyEvaluate(new cr(i.bucket.zoom + 1), i.canonical),
                        textMaxSize: l["text-size"].possiblyEvaluate(new cr(18))
                    };
                if (i.bucket.textSizeData.kind === "composite") {
                    const {
                        minZoom: F,
                        maxZoom: D
                    } = i.bucket.textSizeData;
                    d.compositeTextSizes = [l["text-size"].possiblyEvaluate(new cr(F), i.canonical), l["text-size"].possiblyEvaluate(new cr(D), i.canonical)]
                }
                if (i.bucket.iconSizeData.kind === "composite") {
                    const {
                        minZoom: F,
                        maxZoom: D
                    } = i.bucket.iconSizeData;
                    d.compositeIconSizes = [l["icon-size"].possiblyEvaluate(new cr(F), i.canonical), l["icon-size"].possiblyEvaluate(new cr(D), i.canonical)]
                }
                const g = a.get("text-line-height") * Xn,
                    x = a.get("text-rotation-alignment") !== "viewport" && a.get("symbol-placement") !== "point",
                    A = a.get("text-keep-upright"),
                    M = a.get("text-size");
                for (const F of i.bucket.features) {
                    const D = a.get("text-font").evaluate(F, {}, i.canonical).join(","),
                        U = M.evaluate(F, {}, i.canonical),
                        N = d.layoutTextSize.evaluate(F, {}, i.canonical),
                        H = d.layoutIconSize.evaluate(F, {}, i.canonical),
                        X = {
                            horizontal: {},
                            vertical: void 0
                        },
                        ne = F.text;
                    let le, ce = [0, 0];
                    if (ne) {
                        const Re = ne.toString(),
                            ot = a.get("text-letter-spacing").evaluate(F, {}, i.canonical) * Xn,
                            dt = Ih(Re) ? ot : 0,
                            Ct = a.get("text-anchor").evaluate(F, {}, i.canonical),
                            Nt = up(t, F, i.canonical);
                        if (!Nt) {
                            const lt = a.get("text-radial-offset").evaluate(F, {}, i.canonical);
                            ce = lt ? hp(Ct, [lt * Xn, Au]) : a.get("text-offset").evaluate(F, {}, i.canonical).map(Xe => Xe * Xn)
                        }
                        let qt = x ? "center" : a.get("text-justify").evaluate(F, {}, i.canonical);
                        const Fe = a.get("symbol-placement"),
                            Be = Fe === "point" ? a.get("text-max-width").evaluate(F, {}, i.canonical) * Xn : 0,
                            mt = () => {
                                i.bucket.allowVerticalPlacement && jl(Re) && (X.vertical = Eh(ne, i.glyphMap, i.glyphPositions, i.imagePositions, D, Be, g, Ct, "left", dt, ce, C.ah.vertical, !0, Fe, N, U))
                            };
                        if (!x && Nt) {
                            const lt = new Set;
                            if (qt === "auto")
                                for (let Zt = 0; Zt < Nt.values.length; Zt += 2) lt.add(Tu(Nt.values[Zt]));
                            else lt.add(qt);
                            let Xe = !1;
                            for (const Zt of lt)
                                if (!X.horizontal[Zt])
                                    if (Xe) X.horizontal[Zt] = X.horizontal[0];
                                    else {
                                        const Ie = Eh(ne, i.glyphMap, i.glyphPositions, i.imagePositions, D, Be, g, "center", Zt, dt, ce, C.ah.horizontal, !1, Fe, N, U);
                                        Ie && (X.horizontal[Zt] = Ie, Xe = Ie.positionedLines.length === 1)
                                    } mt()
                        } else {
                            qt === "auto" && (qt = Tu(Ct));
                            const lt = Eh(ne, i.glyphMap, i.glyphPositions, i.imagePositions, D, Be, g, Ct, qt, dt, ce, C.ah.horizontal, !1, Fe, N, U);
                            lt && (X.horizontal[qt] = lt), mt(), jl(Re) && x && A && (X.vertical = Eh(ne, i.glyphMap, i.glyphPositions, i.imagePositions, D, Be, g, Ct, qt, dt, ce, C.ah.vertical, !1, Fe, N, U))
                        }
                    }
                    let Qe = !1;
                    if (F.icon && F.icon.name) {
                        const Re = i.imageMap[F.icon.name];
                        Re && (le = Tp(i.imagePositions[F.icon.name], a.get("icon-offset").evaluate(F, {}, i.canonical), a.get("icon-anchor").evaluate(F, {}, i.canonical)), Qe = !!Re.sdf, i.bucket.sdfIcons === void 0 ? i.bucket.sdfIcons = Qe : i.bucket.sdfIcons !== Qe && li("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Re.pixelRatio !== i.bucket.pixelRatio || a.get("icon-rotate").constantOr(1) !== 0) && (i.bucket.iconsNeedLinear = !0))
                    }
                    const Se = Bd(X.horizontal) || X.vertical;
                    i.bucket.iconsInText = !!Se && Se.iconsInText, (Se || le) && Mu(i.bucket, F, X, le, i.imageMap, d, N, H, ce, Qe, i.canonical)
                }
                i.showCollisionBoxes && i.bucket.generateCollisionDebugBuffers()
            }, C.bm = mh, C.bn = ch, C.bo = is, C.bp = Cs, C.bq = wc, C.br = class {
                constructor(i) {
                    this._marks = {
                        start: [i.url, "start"].join("#"),
                        end: [i.url, "end"].join("#"),
                        measure: i.url.toString()
                    }, performance.mark(this._marks.start)
                }
                finish() {
                    performance.mark(this._marks.end);
                    let i = performance.getEntriesByName(this._marks.measure);
                    return i.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), i = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), i
                }
            }, C.bs = function(i, t, a, l, d) {
                return p(this, void 0, void 0, function*() {
                    if (Ye()) try {
                        return yield st(i, t, a, l, d)
                    } catch (g) {}
                    return function(g, x, A, M, F) {
                        const D = g.width,
                            U = g.height;
                        De && gt || (De = new OffscreenCanvas(D, U), gt = De.getContext("2d", {
                            willReadFrequently: !0
                        })), De.width = D, De.height = U, gt.drawImage(g, 0, 0, D, U);
                        const N = gt.getImageData(x, A, M, F);
                        return gt.clearRect(0, 0, D, U), N.data
                    }(i, t, a, l, d)
                })
            }, C.bt = Bh, C.bu = se, C.bv = ie, C.bw = du, C.bx = dr, C.by = function(i) {
                return i.message === Qt
            }, C.bz = co, C.c = Ve, C.d = i => p(void 0, void 0, void 0, function*() {
                if (i.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
                const t = new Blob([new Uint8Array(i)], {
                    type: "image/png"
                });
                try {
                    return createImageBitmap(t)
                } catch (a) {
                    throw new Error(`Could not load image because of ${a.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`)
                }
            }), C.e = Kt, C.f = i => new Promise((t, a) => {
                const l = new Image;
                l.onload = () => {
                    t(l), URL.revokeObjectURL(l.src), l.onload = null, window.requestAnimationFrame(() => {
                        l.src = Ze
                    })
                }, l.onerror = () => a(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                const d = new Blob([new Uint8Array(i)], {
                    type: "image/png"
                });
                l.src = i.byteLength ? URL.createObjectURL(d) : Ze
            }), C.g = ei, C.h = (i, t) => Ne(Kt(i, {
                type: "json"
            }), t), C.i = ae, C.j = tt, C.k = ht, C.l = (i, t) => Ne(Kt(i, {
                type: "arrayBuffer"
            }), t), C.m = Ne, C.n = function(i) {
                return new wc(i).readFields(Ap, [])
            }, C.o = ih, C.p = od, C.q = ua, C.r = Oc, C.s = Ue, C.t = Uh, C.u = Ti, C.v = Le, C.w = li, C.x = gl, C.y = function([i, t, a]) {
                return t += 90, t *= Math.PI / 180, a *= Math.PI / 180, {
                    x: i * Math.cos(t) * Math.sin(a),
                    y: i * Math.sin(t) * Math.sin(a),
                    z: i * Math.cos(a)
                }
            }, C.z = en
        }), V("worker", ["./shared"], function(C) {
            class p {
                constructor(te) {
                    this.keyCache = {}, te && this.replace(te)
                }
                replace(te) {
                    this._layerConfigs = {}, this._layers = {}, this.update(te, [])
                }
                update(te, he) {
                    for (const Ae of te) {
                        this._layerConfigs[Ae.id] = Ae;
                        const qe = this._layers[Ae.id] = C.az(Ae);
                        qe._featureFilter = C.a6(qe.filter), this.keyCache[Ae.id] && delete this.keyCache[Ae.id]
                    }
                    for (const Ae of he) delete this.keyCache[Ae], delete this._layerConfigs[Ae], delete this._layers[Ae];
                    this.familiesBySource = {};
                    const fe = C.bg(Object.values(this._layerConfigs), this.keyCache);
                    for (const Ae of fe) {
                        const qe = Ae.map(zt => this._layers[zt.id]),
                            et = qe[0];
                        if (et.visibility === "none") continue;
                        const it = et.source || "";
                        let We = this.familiesBySource[it];
                        We || (We = this.familiesBySource[it] = {});
                        const ft = et.sourceLayer || "_geojsonTileLayer";
                        let Jt = We[ft];
                        Jt || (Jt = We[ft] = []), Jt.push(qe)
                    }
                }
            }
            class se {
                constructor(te) {
                    const he = {},
                        fe = [];
                    for (const it in te) {
                        const We = te[it],
                            ft = he[it] = {};
                        for (const Jt in We) {
                            const zt = We[+Jt];
                            if (!zt || zt.bitmap.width === 0 || zt.bitmap.height === 0) continue;
                            const It = {
                                x: 0,
                                y: 0,
                                w: zt.bitmap.width + 2,
                                h: zt.bitmap.height + 2
                            };
                            fe.push(It), ft[Jt] = {
                                rect: It,
                                metrics: zt.metrics
                            }
                        }
                    }
                    const {
                        w: Ae,
                        h: qe
                    } = C.p(fe), et = new C.o({
                        width: Ae || 1,
                        height: qe || 1
                    });
                    for (const it in te) {
                        const We = te[it];
                        for (const ft in We) {
                            const Jt = We[+ft];
                            if (!Jt || Jt.bitmap.width === 0 || Jt.bitmap.height === 0) continue;
                            const zt = he[it][ft].rect;
                            C.o.copy(Jt.bitmap, et, {
                                x: 0,
                                y: 0
                            }, {
                                x: zt.x + 1,
                                y: zt.y + 1
                            }, Jt.bitmap)
                        }
                    }
                    this.image = et, this.positions = he
                }
            }
            C.bh("GlyphAtlas", se);
            class ie {
                constructor(te) {
                    this.tileID = new C.Q(te.tileID.overscaledZ, te.tileID.wrap, te.tileID.canonical.z, te.tileID.canonical.x, te.tileID.canonical.y), this.uid = te.uid, this.zoom = te.zoom, this.pixelRatio = te.pixelRatio, this.tileSize = te.tileSize, this.source = te.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = te.showCollisionBoxes, this.collectResourceTiming = !!te.collectResourceTiming, this.returnDependencies = !!te.returnDependencies, this.promoteId = te.promoteId, this.inFlightDependencies = []
                }
                parse(te, he, fe, Ae) {
                    return C._(this, void 0, void 0, function*() {
                        this.status = "parsing", this.data = te, this.collisionBoxArray = new C.a4;
                        const qe = new C.bi(Object.keys(te.layers).sort()),
                            et = new C.bj(this.tileID, this.promoteId);
                        et.bucketLayerIDs = [];
                        const it = {},
                            We = {
                                featureIndex: et,
                                iconDependencies: {},
                                patternDependencies: {},
                                glyphDependencies: {},
                                availableImages: fe
                            },
                            ft = he.familiesBySource[this.source];
                        for (const hn in ft) {
                            const Vn = te.layers[hn];
                            if (!Vn) continue;
                            Vn.version === 1 && C.w(`Vector tile source "${this.source}" layer "${hn}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                            const Gn = qe.encode(hn),
                                zr = [];
                            for (let br = 0; br < Vn.length; br++) {
                                const ur = Vn.feature(br),
                                    wr = et.getId(ur, hn);
                                zr.push({
                                    feature: ur,
                                    id: wr,
                                    index: br,
                                    sourceLayerIndex: Gn
                                })
                            }
                            for (const br of ft[hn]) {
                                const ur = br[0];
                                ur.source !== this.source && C.w(`layer.source = ${ur.source} does not equal this.source = ${this.source}`), ur.minzoom && this.zoom < Math.floor(ur.minzoom) || ur.maxzoom && this.zoom >= ur.maxzoom || ur.visibility !== "none" && (He(br, this.zoom, fe), (it[ur.id] = ur.createBucket({
                                    index: et.bucketLayerIDs.length,
                                    layers: br,
                                    zoom: this.zoom,
                                    pixelRatio: this.pixelRatio,
                                    overscaling: this.overscaling,
                                    collisionBoxArray: this.collisionBoxArray,
                                    sourceLayerIndex: Gn,
                                    sourceID: this.source
                                })).populate(zr, We, this.tileID.canonical), et.bucketLayerIDs.push(br.map(wr => wr.id)))
                            }
                        }
                        const Jt = C.aE(We.glyphDependencies, hn => Object.keys(hn).map(Number));
                        this.inFlightDependencies.forEach(hn => hn == null ? void 0 : hn.abort()), this.inFlightDependencies = [];
                        let zt = Promise.resolve({});
                        if (Object.keys(Jt).length) {
                            const hn = new AbortController;
                            this.inFlightDependencies.push(hn), zt = Ae.sendAsync({
                                type: "getGlyphs",
                                data: {
                                    stacks: Jt,
                                    source: this.source,
                                    tileID: this.tileID,
                                    type: "glyphs"
                                }
                            }, hn)
                        }
                        const It = Object.keys(We.iconDependencies);
                        let zi = Promise.resolve({});
                        if (It.length) {
                            const hn = new AbortController;
                            this.inFlightDependencies.push(hn), zi = Ae.sendAsync({
                                type: "getImages",
                                data: {
                                    icons: It,
                                    source: this.source,
                                    tileID: this.tileID,
                                    type: "icons"
                                }
                            }, hn)
                        }
                        const Zi = Object.keys(We.patternDependencies);
                        let dn = Promise.resolve({});
                        if (Zi.length) {
                            const hn = new AbortController;
                            this.inFlightDependencies.push(hn), dn = Ae.sendAsync({
                                type: "getImages",
                                data: {
                                    icons: Zi,
                                    source: this.source,
                                    tileID: this.tileID,
                                    type: "patterns"
                                }
                            }, hn)
                        }
                        const [on, vn, Pn] = yield Promise.all([zt, zi, dn]), Fn = new se(on), kn = new C.bk(vn, Pn);
                        for (const hn in it) {
                            const Vn = it[hn];
                            Vn instanceof C.a5 ? (He(Vn.layers, this.zoom, fe), C.bl({
                                bucket: Vn,
                                glyphMap: on,
                                glyphPositions: Fn.positions,
                                imageMap: vn,
                                imagePositions: kn.iconPositions,
                                showCollisionBoxes: this.showCollisionBoxes,
                                canonical: this.tileID.canonical
                            })) : Vn.hasPattern && (Vn instanceof C.bm || Vn instanceof C.bn || Vn instanceof C.bo) && (He(Vn.layers, this.zoom, fe), Vn.addFeatures(We, this.tileID.canonical, kn.patternPositions))
                        }
                        return this.status = "done", {
                            buckets: Object.values(it).filter(hn => !hn.isEmpty()),
                            featureIndex: et,
                            collisionBoxArray: this.collisionBoxArray,
                            glyphAtlasImage: Fn.image,
                            imageAtlas: kn,
                            glyphMap: this.returnDependencies ? on : null,
                            iconMap: this.returnDependencies ? vn : null,
                            glyphPositions: this.returnDependencies ? Fn.positions : null
                        }
                    })
                }
            }

            function He(Te, te, he) {
                const fe = new C.a8(te);
                for (const Ae of Te) Ae.recalculate(fe, he)
            }
            class be {
                constructor(te, he, fe) {
                    this.actor = te, this.layerIndex = he, this.availableImages = fe, this.fetching = {}, this.loading = {}, this.loaded = {}
                }
                loadVectorTile(te, he) {
                    return C._(this, void 0, void 0, function*() {
                        const fe = yield C.l(te.request, he);
                        try {
                            return {
                                vectorTile: new C.bp.VectorTile(new C.bq(fe.data)),
                                rawData: fe.data,
                                cacheControl: fe.cacheControl,
                                expires: fe.expires
                            }
                        } catch (Ae) {
                            const qe = new Uint8Array(fe.data);
                            let et = `Unable to parse the tile at ${te.request.url}, `;
                            throw et += qe[0] === 31 && qe[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${Ae.messge}`, new Error(et)
                        }
                    })
                }
                loadTile(te) {
                    return C._(this, void 0, void 0, function*() {
                        const he = te.uid,
                            fe = !!(te && te.request && te.request.collectResourceTiming) && new C.br(te.request),
                            Ae = new ie(te);
                        this.loading[he] = Ae;
                        const qe = new AbortController;
                        Ae.abort = qe;
                        try {
                            const et = yield this.loadVectorTile(te, qe);
                            if (delete this.loading[he], !et) return null;
                            const it = et.rawData,
                                We = {};
                            et.expires && (We.expires = et.expires), et.cacheControl && (We.cacheControl = et.cacheControl);
                            const ft = {};
                            if (fe) {
                                const zt = fe.finish();
                                zt && (ft.resourceTiming = JSON.parse(JSON.stringify(zt)))
                            }
                            Ae.vectorTile = et.vectorTile;
                            const Jt = Ae.parse(et.vectorTile, this.layerIndex, this.availableImages, this.actor);
                            this.loaded[he] = Ae, this.fetching[he] = {
                                rawTileData: it,
                                cacheControl: We,
                                resourceTiming: ft
                            };
                            try {
                                const zt = yield Jt;
                                return C.e({
                                    rawTileData: it.slice(0)
                                }, zt, We, ft)
                            } finally {
                                delete this.fetching[he]
                            }
                        } catch (et) {
                            throw delete this.loading[he], Ae.status = "done", this.loaded[he] = Ae, et
                        }
                    })
                }
                reloadTile(te) {
                    return C._(this, void 0, void 0, function*() {
                        const he = te.uid;
                        if (!this.loaded || !this.loaded[he]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
                        const fe = this.loaded[he];
                        if (fe.showCollisionBoxes = te.showCollisionBoxes, fe.status === "parsing") {
                            const Ae = yield fe.parse(fe.vectorTile, this.layerIndex, this.availableImages, this.actor);
                            let qe;
                            if (this.fetching[he]) {
                                const {
                                    rawTileData: et,
                                    cacheControl: it,
                                    resourceTiming: We
                                } = this.fetching[he];
                                delete this.fetching[he], qe = C.e({
                                    rawTileData: et.slice(0)
                                }, Ae, it, We)
                            } else qe = Ae;
                            return qe
                        }
                        if (fe.status === "done" && fe.vectorTile) return fe.parse(fe.vectorTile, this.layerIndex, this.availableImages, this.actor)
                    })
                }
                abortTile(te) {
                    return C._(this, void 0, void 0, function*() {
                        const he = this.loading,
                            fe = te.uid;
                        he && he[fe] && he[fe].abort && (he[fe].abort.abort(), delete he[fe])
                    })
                }
                removeTile(te) {
                    return C._(this, void 0, void 0, function*() {
                        this.loaded && this.loaded[te.uid] && delete this.loaded[te.uid]
                    })
                }
            }
            class Ee {
                constructor() {
                    this.loaded = {}
                }
                loadTile(te) {
                    return C._(this, void 0, void 0, function*() {
                        const {
                            uid: he,
                            encoding: fe,
                            rawImageData: Ae,
                            redFactor: qe,
                            greenFactor: et,
                            blueFactor: it,
                            baseShift: We
                        } = te, ft = Ae.width + 2, Jt = Ae.height + 2, zt = C.b(Ae) ? new C.R({
                            width: ft,
                            height: Jt
                        }, yield C.bs(Ae, -1, -1, ft, Jt)) : Ae, It = new C.bt(he, zt, fe, qe, et, it, We);
                        return this.loaded = this.loaded || {}, this.loaded[he] = It, It
                    })
                }
                removeTile(te) {
                    const he = this.loaded,
                        fe = te.uid;
                    he && he[fe] && delete he[fe]
                }
            }

            function Lt(Te, te) {
                if (Te.length !== 0) {
                    Tt(Te[0], te);
                    for (var he = 1; he < Te.length; he++) Tt(Te[he], !te)
                }
            }

            function Tt(Te, te) {
                for (var he = 0, fe = 0, Ae = 0, qe = Te.length, et = qe - 1; Ae < qe; et = Ae++) {
                    var it = (Te[Ae][0] - Te[et][0]) * (Te[et][1] + Te[Ae][1]),
                        We = he + it;
                    fe += Math.abs(he) >= Math.abs(it) ? he - We + it : it - We + he, he = We
                }
                he + fe >= 0 != !!te && Te.reverse()
            }
            var Je = C.bu(function Te(te, he) {
                var fe, Ae = te && te.type;
                if (Ae === "FeatureCollection")
                    for (fe = 0; fe < te.features.length; fe++) Te(te.features[fe], he);
                else if (Ae === "GeometryCollection")
                    for (fe = 0; fe < te.geometries.length; fe++) Te(te.geometries[fe], he);
                else if (Ae === "Feature") Te(te.geometry, he);
                else if (Ae === "Polygon") Lt(te.coordinates, he);
                else if (Ae === "MultiPolygon")
                    for (fe = 0; fe < te.coordinates.length; fe++) Lt(te.coordinates[fe], he);
                return te
            });
            const wt = C.bp.VectorTileFeature.prototype.toGeoJSON;
            var Ke = {
                    exports: {}
                },
                Ye = C.bv,
                jt = C.bp.VectorTileFeature,
                di = $e;

            function $e(Te, te) {
                this.options = te || {}, this.features = Te, this.length = Te.length
            }

            function vt(Te, te) {
                this.id = typeof Te.id == "number" ? Te.id : void 0, this.type = Te.type, this.rawGeometry = Te.type === 1 ? [Te.geometry] : Te.geometry, this.properties = Te.tags, this.extent = te || 4096
            }
            $e.prototype.feature = function(Te) {
                return new vt(this.features[Te], this.options.extent)
            }, vt.prototype.loadGeometry = function() {
                var Te = this.rawGeometry;
                this.geometry = [];
                for (var te = 0; te < Te.length; te++) {
                    for (var he = Te[te], fe = [], Ae = 0; Ae < he.length; Ae++) fe.push(new Ye(he[Ae][0], he[Ae][1]));
                    this.geometry.push(fe)
                }
                return this.geometry
            }, vt.prototype.bbox = function() {
                this.geometry || this.loadGeometry();
                for (var Te = this.geometry, te = 1 / 0, he = -1 / 0, fe = 1 / 0, Ae = -1 / 0, qe = 0; qe < Te.length; qe++)
                    for (var et = Te[qe], it = 0; it < et.length; it++) {
                        var We = et[it];
                        te = Math.min(te, We.x), he = Math.max(he, We.x), fe = Math.min(fe, We.y), Ae = Math.max(Ae, We.y)
                    }
                return [te, fe, he, Ae]
            }, vt.prototype.toGeoJSON = jt.prototype.toGeoJSON;
            var Kt = C.bw,
                vi = di;

            function Li(Te) {
                var te = new Kt;
                return function(he, fe) {
                    for (var Ae in he.layers) fe.writeMessage(3, Ei, he.layers[Ae])
                }(Te, te), te.finish()
            }

            function Ei(Te, te) {
                var he;
                te.writeVarintField(15, Te.version || 1), te.writeStringField(1, Te.name || ""), te.writeVarintField(5, Te.extent || 4096);
                var fe = {
                    keys: [],
                    values: [],
                    keycache: {},
                    valuecache: {}
                };
                for (he = 0; he < Te.length; he++) fe.feature = Te.feature(he), te.writeMessage(2, ct, fe);
                var Ae = fe.keys;
                for (he = 0; he < Ae.length; he++) te.writeStringField(3, Ae[he]);
                var qe = fe.values;
                for (he = 0; he < qe.length; he++) te.writeMessage(4, ae, qe[he])
            }

            function ct(Te, te) {
                var he = Te.feature;
                he.id !== void 0 && te.writeVarintField(1, he.id), te.writeMessage(2, je, Te), te.writeVarintField(3, he.type), te.writeMessage(4, K, he)
            }

            function je(Te, te) {
                var he = Te.feature,
                    fe = Te.keys,
                    Ae = Te.values,
                    qe = Te.keycache,
                    et = Te.valuecache;
                for (var it in he.properties) {
                    var We = he.properties[it],
                        ft = qe[it];
                    if (We !== null) {
                        ft === void 0 && (fe.push(it), qe[it] = ft = fe.length - 1), te.writeVarint(ft);
                        var Jt = typeof We;
                        Jt !== "string" && Jt !== "boolean" && Jt !== "number" && (We = JSON.stringify(We));
                        var zt = Jt + ":" + We,
                            It = et[zt];
                        It === void 0 && (Ae.push(We), et[zt] = It = Ae.length - 1), te.writeVarint(It)
                    }
                }
            }

            function li(Te, te) {
                return (te << 3) + (7 & Te)
            }

            function O(Te) {
                return Te << 1 ^ Te >> 31
            }

            function K(Te, te) {
                for (var he = Te.loadGeometry(), fe = Te.type, Ae = 0, qe = 0, et = he.length, it = 0; it < et; it++) {
                    var We = he[it],
                        ft = 1;
                    fe === 1 && (ft = We.length), te.writeVarint(li(1, ft));
                    for (var Jt = fe === 3 ? We.length - 1 : We.length, zt = 0; zt < Jt; zt++) {
                        zt === 1 && fe !== 1 && te.writeVarint(li(2, Jt - 1));
                        var It = We[zt].x - Ae,
                            zi = We[zt].y - qe;
                        te.writeVarint(O(It)), te.writeVarint(O(zi)), Ae += It, qe += zi
                    }
                    fe === 3 && te.writeVarint(li(7, 1))
                }
            }

            function ae(Te, te) {
                var he = typeof Te;
                he === "string" ? te.writeStringField(1, Te) : he === "boolean" ? te.writeBooleanField(7, Te) : he === "number" && (Te % 1 != 0 ? te.writeDoubleField(3, Te) : Te < 0 ? te.writeSVarintField(6, Te) : te.writeVarintField(5, Te))
            }
            Ke.exports = Li, Ke.exports.fromVectorTileJs = Li, Ke.exports.fromGeojsonVt = function(Te, te) {
                te = te || {};
                var he = {};
                for (var fe in Te) he[fe] = new vi(Te[fe].features, te), he[fe].name = fe, he[fe].version = te.version, he[fe].extent = te.extent;
                return Li({
                    layers: he
                })
            }, Ke.exports.GeoJSONWrapper = vi;
            var _e = C.bu(Ke.exports);
            const xe = {
                    minZoom: 0,
                    maxZoom: 16,
                    minPoints: 2,
                    radius: 40,
                    extent: 512,
                    nodeSize: 64,
                    log: !1,
                    generateId: !1,
                    reduce: null,
                    map: Te => Te
                },
                Ze = Math.fround || (st = new Float32Array(1), Te => (st[0] = +Te, st[0]));
            var st;
            const De = 3,
                gt = 5,
                Qt = 6;
            class Ve {
                constructor(te) {
                    this.options = Object.assign(Object.create(xe), te), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = []
                }
                load(te) {
                    const {
                        log: he,
                        minZoom: fe,
                        maxZoom: Ae
                    } = this.options;
                    he && console.time("total time");
                    const qe = `prepare ${te.length} points`;
                    he && console.time(qe), this.points = te;
                    const et = [];
                    for (let We = 0; We < te.length; We++) {
                        const ft = te[We];
                        if (!ft.geometry) continue;
                        const [Jt, zt] = ft.geometry.coordinates, It = Ze(xi(Jt)), zi = Ze(oe(zt));
                        et.push(It, zi, 1 / 0, We, -1, 1), this.options.reduce && et.push(0)
                    }
                    let it = this.trees[Ae + 1] = this._createTree(et);
                    he && console.timeEnd(qe);
                    for (let We = Ae; We >= fe; We--) {
                        const ft = +Date.now();
                        it = this.trees[We] = this._createTree(this._cluster(it, We)), he && console.log("z%d: %d clusters in %dms", We, it.numItems, +Date.now() - ft)
                    }
                    return he && console.timeEnd("total time"), this
                }
                getClusters(te, he) {
                    let fe = ((te[0] + 180) % 360 + 360) % 360 - 180;
                    const Ae = Math.max(-90, Math.min(90, te[1]));
                    let qe = te[2] === 180 ? 180 : ((te[2] + 180) % 360 + 360) % 360 - 180;
                    const et = Math.max(-90, Math.min(90, te[3]));
                    if (te[2] - te[0] >= 360) fe = -180, qe = 180;
                    else if (fe > qe) {
                        const zt = this.getClusters([fe, Ae, 180, et], he),
                            It = this.getClusters([-180, Ae, qe, et], he);
                        return zt.concat(It)
                    }
                    const it = this.trees[this._limitZoom(he)],
                        We = it.range(xi(fe), oe(et), xi(qe), oe(Ae)),
                        ft = it.data,
                        Jt = [];
                    for (const zt of We) {
                        const It = this.stride * zt;
                        Jt.push(ft[It + gt] > 1 ? Dt(ft, It, this.clusterProps) : this.points[ft[It + De]])
                    }
                    return Jt
                }
                getChildren(te) {
                    const he = this._getOriginId(te),
                        fe = this._getOriginZoom(te),
                        Ae = "No cluster with the specified id.",
                        qe = this.trees[fe];
                    if (!qe) throw new Error(Ae);
                    const et = qe.data;
                    if (he * this.stride >= et.length) throw new Error(Ae);
                    const it = this.options.radius / (this.options.extent * Math.pow(2, fe - 1)),
                        We = qe.within(et[he * this.stride], et[he * this.stride + 1], it),
                        ft = [];
                    for (const Jt of We) {
                        const zt = Jt * this.stride;
                        et[zt + 4] === te && ft.push(et[zt + gt] > 1 ? Dt(et, zt, this.clusterProps) : this.points[et[zt + De]])
                    }
                    if (ft.length === 0) throw new Error(Ae);
                    return ft
                }
                getLeaves(te, he, fe) {
                    const Ae = [];
                    return this._appendLeaves(Ae, te, he = he || 10, fe = fe || 0, 0), Ae
                }
                getTile(te, he, fe) {
                    const Ae = this.trees[this._limitZoom(te)],
                        qe = Math.pow(2, te),
                        {
                            extent: et,
                            radius: it
                        } = this.options,
                        We = it / et,
                        ft = (fe - We) / qe,
                        Jt = (fe + 1 + We) / qe,
                        zt = {
                            features: []
                        };
                    return this._addTileFeatures(Ae.range((he - We) / qe, ft, (he + 1 + We) / qe, Jt), Ae.data, he, fe, qe, zt), he === 0 && this._addTileFeatures(Ae.range(1 - We / qe, ft, 1, Jt), Ae.data, qe, fe, qe, zt), he === qe - 1 && this._addTileFeatures(Ae.range(0, ft, We / qe, Jt), Ae.data, -1, fe, qe, zt), zt.features.length ? zt : null
                }
                getClusterExpansionZoom(te) {
                    let he = this._getOriginZoom(te) - 1;
                    for (; he <= this.options.maxZoom;) {
                        const fe = this.getChildren(te);
                        if (he++, fe.length !== 1) break;
                        te = fe[0].properties.cluster_id
                    }
                    return he
                }
                _appendLeaves(te, he, fe, Ae, qe) {
                    const et = this.getChildren(he);
                    for (const it of et) {
                        const We = it.properties;
                        if (We && We.cluster ? qe + We.point_count <= Ae ? qe += We.point_count : qe = this._appendLeaves(te, We.cluster_id, fe, Ae, qe) : qe < Ae ? qe++ : te.push(it), te.length === fe) break
                    }
                    return qe
                }
                _createTree(te) {
                    const he = new C.au(te.length / this.stride | 0, this.options.nodeSize, Float32Array);
                    for (let fe = 0; fe < te.length; fe += this.stride) he.add(te[fe], te[fe + 1]);
                    return he.finish(), he.data = te, he
                }
                _addTileFeatures(te, he, fe, Ae, qe, et) {
                    for (const it of te) {
                        const We = it * this.stride,
                            ft = he[We + gt] > 1;
                        let Jt, zt, It;
                        if (ft) Jt = ei(he, We, this.clusterProps), zt = he[We], It = he[We + 1];
                        else {
                            const dn = this.points[he[We + De]];
                            Jt = dn.properties;
                            const [on, vn] = dn.geometry.coordinates;
                            zt = xi(on), It = oe(vn)
                        }
                        const zi = {
                            type: 1,
                            geometry: [
                                [Math.round(this.options.extent * (zt * qe - fe)), Math.round(this.options.extent * (It * qe - Ae))]
                            ],
                            tags: Jt
                        };
                        let Zi;
                        Zi = ft || this.options.generateId ? he[We + De] : this.points[he[We + De]].id, Zi !== void 0 && (zi.id = Zi), et.features.push(zi)
                    }
                }
                _limitZoom(te) {
                    return Math.max(this.options.minZoom, Math.min(Math.floor(+te), this.options.maxZoom + 1))
                }
                _cluster(te, he) {
                    const {
                        radius: fe,
                        extent: Ae,
                        reduce: qe,
                        minPoints: et
                    } = this.options, it = fe / (Ae * Math.pow(2, he)), We = te.data, ft = [], Jt = this.stride;
                    for (let zt = 0; zt < We.length; zt += Jt) {
                        if (We[zt + 2] <= he) continue;
                        We[zt + 2] = he;
                        const It = We[zt],
                            zi = We[zt + 1],
                            Zi = te.within(We[zt], We[zt + 1], it),
                            dn = We[zt + gt];
                        let on = dn;
                        for (const vn of Zi) {
                            const Pn = vn * Jt;
                            We[Pn + 2] > he && (on += We[Pn + gt])
                        }
                        if (on > dn && on >= et) {
                            let vn, Pn = It * dn,
                                Fn = zi * dn,
                                kn = -1;
                            const hn = ((zt / Jt | 0) << 5) + (he + 1) + this.points.length;
                            for (const Vn of Zi) {
                                const Gn = Vn * Jt;
                                if (We[Gn + 2] <= he) continue;
                                We[Gn + 2] = he;
                                const zr = We[Gn + gt];
                                Pn += We[Gn] * zr, Fn += We[Gn + 1] * zr, We[Gn + 4] = hn, qe && (vn || (vn = this._map(We, zt, !0), kn = this.clusterProps.length, this.clusterProps.push(vn)), qe(vn, this._map(We, Gn)))
                            }
                            We[zt + 4] = hn, ft.push(Pn / on, Fn / on, 1 / 0, hn, -1, on), qe && ft.push(kn)
                        } else {
                            for (let vn = 0; vn < Jt; vn++) ft.push(We[zt + vn]);
                            if (on > 1)
                                for (const vn of Zi) {
                                    const Pn = vn * Jt;
                                    if (!(We[Pn + 2] <= he)) {
                                        We[Pn + 2] = he;
                                        for (let Fn = 0; Fn < Jt; Fn++) ft.push(We[Pn + Fn])
                                    }
                                }
                        }
                    }
                    return ft
                }
                _getOriginId(te) {
                    return te - this.points.length >> 5
                }
                _getOriginZoom(te) {
                    return (te - this.points.length) % 32
                }
                _map(te, he, fe) {
                    if (te[he + gt] > 1) {
                        const et = this.clusterProps[te[he + Qt]];
                        return fe ? Object.assign({}, et) : et
                    }
                    const Ae = this.points[te[he + De]].properties,
                        qe = this.options.map(Ae);
                    return fe && qe === Ae ? Object.assign({}, qe) : qe
                }
            }

            function Dt(Te, te, he) {
                return {
                    type: "Feature",
                    id: Te[te + De],
                    properties: ei(Te, te, he),
                    geometry: {
                        type: "Point",
                        coordinates: [(fe = Te[te], 360 * (fe - .5)), ve(Te[te + 1])]
                    }
                };
                var fe
            }

            function ei(Te, te, he) {
                const fe = Te[te + gt],
                    Ae = fe >= 1e4 ? `${Math.round(fe/1e3)}k` : fe >= 1e3 ? Math.round(fe / 100) / 10 + "k" : fe,
                    qe = Te[te + Qt],
                    et = qe === -1 ? {} : Object.assign({}, he[qe]);
                return Object.assign(et, {
                    cluster: !0,
                    cluster_id: Te[te + De],
                    point_count: fe,
                    point_count_abbreviated: Ae
                })
            }

            function xi(Te) {
                return Te / 360 + .5
            }

            function oe(Te) {
                const te = Math.sin(Te * Math.PI / 180),
                    he = .5 - .25 * Math.log((1 + te) / (1 - te)) / Math.PI;
                return he < 0 ? 0 : he > 1 ? 1 : he
            }

            function ve(Te) {
                const te = (180 - 360 * Te) * Math.PI / 180;
                return 360 * Math.atan(Math.exp(te)) / Math.PI - 90
            }

            function Ne(Te, te, he, fe) {
                for (var Ae, qe = fe, et = he - te >> 1, it = he - te, We = Te[te], ft = Te[te + 1], Jt = Te[he], zt = Te[he + 1], It = te + 3; It < he; It += 3) {
                    var zi = Ue(Te[It], Te[It + 1], We, ft, Jt, zt);
                    if (zi > qe) Ae = It, qe = zi;
                    else if (zi === qe) {
                        var Zi = Math.abs(It - et);
                        Zi < it && (Ae = It, it = Zi)
                    }
                }
                qe > fe && (Ae - te > 3 && Ne(Te, te, Ae, fe), Te[Ae + 2] = qe, he - Ae > 3 && Ne(Te, Ae, he, fe))
            }

            function Ue(Te, te, he, fe, Ae, qe) {
                var et = Ae - he,
                    it = qe - fe;
                if (et !== 0 || it !== 0) {
                    var We = ((Te - he) * et + (te - fe) * it) / (et * et + it * it);
                    We > 1 ? (he = Ae, fe = qe) : We > 0 && (he += et * We, fe += it * We)
                }
                return (et = Te - he) * et + (it = te - fe) * it
            }

            function Oe(Te, te, he, fe) {
                var Ae = {
                    id: Te === void 0 ? null : Te,
                    type: te,
                    geometry: he,
                    tags: fe,
                    minX: 1 / 0,
                    minY: 1 / 0,
                    maxX: -1 / 0,
                    maxY: -1 / 0
                };
                return function(qe) {
                    var et = qe.geometry,
                        it = qe.type;
                    if (it === "Point" || it === "MultiPoint" || it === "LineString") at(qe, et);
                    else if (it === "Polygon" || it === "MultiLineString")
                        for (var We = 0; We < et.length; We++) at(qe, et[We]);
                    else if (it === "MultiPolygon")
                        for (We = 0; We < et.length; We++)
                            for (var ft = 0; ft < et[We].length; ft++) at(qe, et[We][ft])
                }(Ae), Ae
            }

            function at(Te, te) {
                for (var he = 0; he < te.length; he += 3) Te.minX = Math.min(Te.minX, te[he]), Te.minY = Math.min(Te.minY, te[he + 1]), Te.maxX = Math.max(Te.maxX, te[he]), Te.maxY = Math.max(Te.maxY, te[he + 1])
            }

            function ht(Te, te, he, fe) {
                if (te.geometry) {
                    var Ae = te.geometry.coordinates,
                        qe = te.geometry.type,
                        et = Math.pow(he.tolerance / ((1 << he.maxZoom) * he.extent), 2),
                        it = [],
                        We = te.id;
                    if (he.promoteId ? We = te.properties[he.promoteId] : he.generateId && (We = fe || 0), qe === "Point") tt(Ae, it);
                    else if (qe === "MultiPoint")
                        for (var ft = 0; ft < Ae.length; ft++) tt(Ae[ft], it);
                    else if (qe === "LineString") Bt(Ae, it, et, !1);
                    else if (qe === "MultiLineString") {
                        if (he.lineMetrics) {
                            for (ft = 0; ft < Ae.length; ft++) Bt(Ae[ft], it = [], et, !1), Te.push(Oe(We, "LineString", it, te.properties));
                            return
                        }
                        Le(Ae, it, et, !1)
                    } else if (qe === "Polygon") Le(Ae, it, et, !0);
                    else {
                        if (qe !== "MultiPolygon") {
                            if (qe === "GeometryCollection") {
                                for (ft = 0; ft < te.geometry.geometries.length; ft++) ht(Te, {
                                    id: We,
                                    geometry: te.geometry.geometries[ft],
                                    properties: te.properties
                                }, he, fe);
                                return
                            }
                            throw new Error("Input data is not a valid GeoJSON object.")
                        }
                        for (ft = 0; ft < Ae.length; ft++) {
                            var Jt = [];
                            Le(Ae[ft], Jt, et, !0), it.push(Jt)
                        }
                    }
                    Te.push(Oe(We, qe, it, te.properties))
                }
            }

            function tt(Te, te) {
                te.push(Ot(Te[0])), te.push(ii(Te[1])), te.push(0)
            }

            function Bt(Te, te, he, fe) {
                for (var Ae, qe, et = 0, it = 0; it < Te.length; it++) {
                    var We = Ot(Te[it][0]),
                        ft = ii(Te[it][1]);
                    te.push(We), te.push(ft), te.push(0), it > 0 && (et += fe ? (Ae * ft - We * qe) / 2 : Math.sqrt(Math.pow(We - Ae, 2) + Math.pow(ft - qe, 2))), Ae = We, qe = ft
                }
                var Jt = te.length - 3;
                te[2] = 1, Ne(te, 0, Jt, he), te[Jt + 2] = 1, te.size = Math.abs(et), te.start = 0, te.end = te.size
            }

            function Le(Te, te, he, fe) {
                for (var Ae = 0; Ae < Te.length; Ae++) {
                    var qe = [];
                    Bt(Te[Ae], qe, he, fe), te.push(qe)
                }
            }

            function Ot(Te) {
                return Te / 360 + .5
            }

            function ii(Te) {
                var te = Math.sin(Te * Math.PI / 180),
                    he = .5 - .25 * Math.log((1 + te) / (1 - te)) / Math.PI;
                return he < 0 ? 0 : he > 1 ? 1 : he
            }

            function Wt(Te, te, he, fe, Ae, qe, et, it) {
                if (fe /= te, qe >= (he /= te) && et < fe) return Te;
                if (et < he || qe >= fe) return null;
                for (var We = [], ft = 0; ft < Te.length; ft++) {
                    var Jt = Te[ft],
                        zt = Jt.geometry,
                        It = Jt.type,
                        zi = Ae === 0 ? Jt.minX : Jt.minY,
                        Zi = Ae === 0 ? Jt.maxX : Jt.maxY;
                    if (zi >= he && Zi < fe) We.push(Jt);
                    else if (!(Zi < he || zi >= fe)) {
                        var dn = [];
                        if (It === "Point" || It === "MultiPoint") bi(zt, dn, he, fe, Ae);
                        else if (It === "LineString") Qi(zt, dn, he, fe, Ae, !1, it.lineMetrics);
                        else if (It === "MultiLineString") yn(zt, dn, he, fe, Ae, !1);
                        else if (It === "Polygon") yn(zt, dn, he, fe, Ae, !0);
                        else if (It === "MultiPolygon")
                            for (var on = 0; on < zt.length; on++) {
                                var vn = [];
                                yn(zt[on], vn, he, fe, Ae, !0), vn.length && dn.push(vn)
                            }
                        if (dn.length) {
                            if (it.lineMetrics && It === "LineString") {
                                for (on = 0; on < dn.length; on++) We.push(Oe(Jt.id, It, dn[on], Jt.tags));
                                continue
                            }
                            It !== "LineString" && It !== "MultiLineString" || (dn.length === 1 ? (It = "LineString", dn = dn[0]) : It = "MultiLineString"), It !== "Point" && It !== "MultiPoint" || (It = dn.length === 3 ? "Point" : "MultiPoint"), We.push(Oe(Jt.id, It, dn, Jt.tags))
                        }
                    }
                }
                return We.length ? We : null
            }

            function bi(Te, te, he, fe, Ae) {
                for (var qe = 0; qe < Te.length; qe += 3) {
                    var et = Te[qe + Ae];
                    et >= he && et <= fe && (te.push(Te[qe]), te.push(Te[qe + 1]), te.push(Te[qe + 2]))
                }
            }

            function Qi(Te, te, he, fe, Ae, qe, et) {
                for (var it, We, ft = sn(Te), Jt = Ae === 0 ? rn : Mi, zt = Te.start, It = 0; It < Te.length - 3; It += 3) {
                    var zi = Te[It],
                        Zi = Te[It + 1],
                        dn = Te[It + 2],
                        on = Te[It + 3],
                        vn = Te[It + 4],
                        Pn = Ae === 0 ? zi : Zi,
                        Fn = Ae === 0 ? on : vn,
                        kn = !1;
                    et && (it = Math.sqrt(Math.pow(zi - on, 2) + Math.pow(Zi - vn, 2))), Pn < he ? Fn > he && (We = Jt(ft, zi, Zi, on, vn, he), et && (ft.start = zt + it * We)) : Pn > fe ? Fn < fe && (We = Jt(ft, zi, Zi, on, vn, fe), et && (ft.start = zt + it * We)) : Yi(ft, zi, Zi, dn), Fn < he && Pn >= he && (We = Jt(ft, zi, Zi, on, vn, he), kn = !0), Fn > fe && Pn <= fe && (We = Jt(ft, zi, Zi, on, vn, fe), kn = !0), !qe && kn && (et && (ft.end = zt + it * We), te.push(ft), ft = sn(Te)), et && (zt += it)
                }
                var hn = Te.length - 3;
                zi = Te[hn], Zi = Te[hn + 1], dn = Te[hn + 2], (Pn = Ae === 0 ? zi : Zi) >= he && Pn <= fe && Yi(ft, zi, Zi, dn), hn = ft.length - 3, qe && hn >= 3 && (ft[hn] !== ft[0] || ft[hn + 1] !== ft[1]) && Yi(ft, ft[0], ft[1], ft[2]), ft.length && te.push(ft)
            }

            function sn(Te) {
                var te = [];
                return te.size = Te.size, te.start = Te.start, te.end = Te.end, te
            }

            function yn(Te, te, he, fe, Ae, qe) {
                for (var et = 0; et < Te.length; et++) Qi(Te[et], te, he, fe, Ae, qe, !1)
            }

            function Yi(Te, te, he, fe) {
                Te.push(te), Te.push(he), Te.push(fe)
            }

            function rn(Te, te, he, fe, Ae, qe) {
                var et = (qe - te) / (fe - te);
                return Te.push(qe), Te.push(he + (Ae - he) * et), Te.push(1), et
            }

            function Mi(Te, te, he, fe, Ae, qe) {
                var et = (qe - he) / (Ae - he);
                return Te.push(te + (fe - te) * et), Te.push(qe), Te.push(1), et
            }

            function Ht(Te, te) {
                for (var he = [], fe = 0; fe < Te.length; fe++) {
                    var Ae, qe = Te[fe],
                        et = qe.type;
                    if (et === "Point" || et === "MultiPoint" || et === "LineString") Ae = Pt(qe.geometry, te);
                    else if (et === "MultiLineString" || et === "Polygon") {
                        Ae = [];
                        for (var it = 0; it < qe.geometry.length; it++) Ae.push(Pt(qe.geometry[it], te))
                    } else if (et === "MultiPolygon")
                        for (Ae = [], it = 0; it < qe.geometry.length; it++) {
                            for (var We = [], ft = 0; ft < qe.geometry[it].length; ft++) We.push(Pt(qe.geometry[it][ft], te));
                            Ae.push(We)
                        }
                    he.push(Oe(qe.id, et, Ae, qe.tags))
                }
                return he
            }

            function Pt(Te, te) {
                var he = [];
                he.size = Te.size, Te.start !== void 0 && (he.start = Te.start, he.end = Te.end);
                for (var fe = 0; fe < Te.length; fe += 3) he.push(Te[fe] + te, Te[fe + 1], Te[fe + 2]);
                return he
            }

            function qn(Te, te) {
                if (Te.transformed) return Te;
                var he, fe, Ae, qe = 1 << Te.z,
                    et = Te.x,
                    it = Te.y;
                for (he = 0; he < Te.features.length; he++) {
                    var We = Te.features[he],
                        ft = We.geometry,
                        Jt = We.type;
                    if (We.geometry = [], Jt === 1)
                        for (fe = 0; fe < ft.length; fe += 2) We.geometry.push(ji(ft[fe], ft[fe + 1], te, qe, et, it));
                    else
                        for (fe = 0; fe < ft.length; fe++) {
                            var zt = [];
                            for (Ae = 0; Ae < ft[fe].length; Ae += 2) zt.push(ji(ft[fe][Ae], ft[fe][Ae + 1], te, qe, et, it));
                            We.geometry.push(zt)
                        }
                }
                return Te.transformed = !0, Te
            }

            function ji(Te, te, he, fe, Ae, qe) {
                return [Math.round(he * (Te * fe - Ae)), Math.round(he * (te * fe - qe))]
            }

            function na(Te, te, he, fe, Ae) {
                for (var qe = te === Ae.maxZoom ? 0 : Ae.tolerance / ((1 << te) * Ae.extent), et = {
                        features: [],
                        numPoints: 0,
                        numSimplified: 0,
                        numFeatures: 0,
                        source: null,
                        x: he,
                        y: fe,
                        z: te,
                        transformed: !1,
                        minX: 2,
                        minY: 1,
                        maxX: -1,
                        maxY: 0
                    }, it = 0; it < Te.length; it++) {
                    et.numFeatures++, cn(et, Te[it], qe, Ae);
                    var We = Te[it].minX,
                        ft = Te[it].minY,
                        Jt = Te[it].maxX,
                        zt = Te[it].maxY;
                    We < et.minX && (et.minX = We), ft < et.minY && (et.minY = ft), Jt > et.maxX && (et.maxX = Jt), zt > et.maxY && (et.maxY = zt)
                }
                return et
            }

            function cn(Te, te, he, fe) {
                var Ae = te.geometry,
                    qe = te.type,
                    et = [];
                if (qe === "Point" || qe === "MultiPoint")
                    for (var it = 0; it < Ae.length; it += 3) et.push(Ae[it]), et.push(Ae[it + 1]), Te.numPoints++, Te.numSimplified++;
                else if (qe === "LineString") yi(et, Ae, Te, he, !1, !1);
                else if (qe === "MultiLineString" || qe === "Polygon")
                    for (it = 0; it < Ae.length; it++) yi(et, Ae[it], Te, he, qe === "Polygon", it === 0);
                else if (qe === "MultiPolygon")
                    for (var We = 0; We < Ae.length; We++) {
                        var ft = Ae[We];
                        for (it = 0; it < ft.length; it++) yi(et, ft[it], Te, he, !0, it === 0)
                    }
                if (et.length) {
                    var Jt = te.tags || null;
                    if (qe === "LineString" && fe.lineMetrics) {
                        for (var zt in Jt = {}, te.tags) Jt[zt] = te.tags[zt];
                        Jt.mapbox_clip_start = Ae.start / Ae.size, Jt.mapbox_clip_end = Ae.end / Ae.size
                    }
                    var It = {
                        geometry: et,
                        type: qe === "Polygon" || qe === "MultiPolygon" ? 3 : qe === "LineString" || qe === "MultiLineString" ? 2 : 1,
                        tags: Jt
                    };
                    te.id !== null && (It.id = te.id), Te.features.push(It)
                }
            }

            function yi(Te, te, he, fe, Ae, qe) {
                var et = fe * fe;
                if (fe > 0 && te.size < (Ae ? et : fe)) he.numPoints += te.length / 3;
                else {
                    for (var it = [], We = 0; We < te.length; We += 3)(fe === 0 || te[We + 2] > et) && (he.numSimplified++, it.push(te[We]), it.push(te[We + 1])), he.numPoints++;
                    Ae && function(ft, Jt) {
                        for (var zt = 0, It = 0, zi = ft.length, Zi = zi - 2; It < zi; Zi = It, It += 2) zt += (ft[It] - ft[Zi]) * (ft[It + 1] + ft[Zi + 1]);
                        if (zt > 0 === Jt)
                            for (It = 0, zi = ft.length; It < zi / 2; It += 2) {
                                var dn = ft[It],
                                    on = ft[It + 1];
                                ft[It] = ft[zi - 2 - It], ft[It + 1] = ft[zi - 1 - It], ft[zi - 2 - It] = dn, ft[zi - 1 - It] = on
                            }
                    }(it, qe), Te.push(it)
                }
            }

            function Si(Te, te) {
                var he = (te = this.options = function(Ae, qe) {
                    for (var et in qe) Ae[et] = qe[et];
                    return Ae
                }(Object.create(this.options), te)).debug;
                if (he && console.time("preprocess data"), te.maxZoom < 0 || te.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
                if (te.promoteId && te.generateId) throw new Error("promoteId and generateId cannot be used together.");
                var fe = function(Ae, qe) {
                    var et = [];
                    if (Ae.type === "FeatureCollection")
                        for (var it = 0; it < Ae.features.length; it++) ht(et, Ae.features[it], qe, it);
                    else ht(et, Ae.type === "Feature" ? Ae : {
                        geometry: Ae
                    }, qe);
                    return et
                }(Te, te);
                this.tiles = {}, this.tileCoords = [], he && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", te.indexMaxZoom, te.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), fe = function(Ae, qe) {
                    var et = qe.buffer / qe.extent,
                        it = Ae,
                        We = Wt(Ae, 1, -1 - et, et, 0, -1, 2, qe),
                        ft = Wt(Ae, 1, 1 - et, 2 + et, 0, -1, 2, qe);
                    return (We || ft) && (it = Wt(Ae, 1, -et, 1 + et, 0, -1, 2, qe) || [], We && (it = Ht(We, 1).concat(it)), ft && (it = it.concat(Ht(ft, -1)))), it
                }(fe, te), fe.length && this.splitTile(fe, 0, 0, 0), he && (fe.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)))
            }

            function qi(Te, te, he) {
                return 32 * ((1 << Te) * he + te) + Te
            }

            function Nn(Te, te) {
                return te ? Te.properties[te] : Te.id
            }

            function Bn(Te, te) {
                if (Te == null) return !0;
                if (Te.type === "Feature") return Nn(Te, te) != null;
                if (Te.type === "FeatureCollection") {
                    const he = new Set;
                    for (const fe of Te.features) {
                        const Ae = Nn(fe, te);
                        if (Ae == null || he.has(Ae)) return !1;
                        he.add(Ae)
                    }
                    return !0
                }
                return !1
            }

            function ge(Te, te) {
                const he = new Map;
                if (Te != null)
                    if (Te.type === "Feature") he.set(Nn(Te, te), Te);
                    else
                        for (const fe of Te.features) he.set(Nn(fe, te), fe);
                return he
            }
            Si.prototype.options = {
                maxZoom: 14,
                indexMaxZoom: 5,
                indexMaxPoints: 1e5,
                tolerance: 3,
                extent: 4096,
                buffer: 64,
                lineMetrics: !1,
                promoteId: null,
                generateId: !1,
                debug: 0
            }, Si.prototype.splitTile = function(Te, te, he, fe, Ae, qe, et) {
                for (var it = [Te, te, he, fe], We = this.options, ft = We.debug; it.length;) {
                    fe = it.pop(), he = it.pop(), te = it.pop(), Te = it.pop();
                    var Jt = 1 << te,
                        zt = qi(te, he, fe),
                        It = this.tiles[zt];
                    if (!It && (ft > 1 && console.time("creation"), It = this.tiles[zt] = na(Te, te, he, fe, We), this.tileCoords.push({
                            z: te,
                            x: he,
                            y: fe
                        }), ft)) {
                        ft > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", te, he, fe, It.numFeatures, It.numPoints, It.numSimplified), console.timeEnd("creation"));
                        var zi = "z" + te;
                        this.stats[zi] = (this.stats[zi] || 0) + 1, this.total++
                    }
                    if (It.source = Te, Ae) {
                        if (te === We.maxZoom || te === Ae) continue;
                        var Zi = 1 << Ae - te;
                        if (he !== Math.floor(qe / Zi) || fe !== Math.floor(et / Zi)) continue
                    } else if (te === We.indexMaxZoom || It.numPoints <= We.indexMaxPoints) continue;
                    if (It.source = null, Te.length !== 0) {
                        ft > 1 && console.time("clipping");
                        var dn, on, vn, Pn, Fn, kn, hn = .5 * We.buffer / We.extent,
                            Vn = .5 - hn,
                            Gn = .5 + hn,
                            zr = 1 + hn;
                        dn = on = vn = Pn = null, Fn = Wt(Te, Jt, he - hn, he + Gn, 0, It.minX, It.maxX, We), kn = Wt(Te, Jt, he + Vn, he + zr, 0, It.minX, It.maxX, We), Te = null, Fn && (dn = Wt(Fn, Jt, fe - hn, fe + Gn, 1, It.minY, It.maxY, We), on = Wt(Fn, Jt, fe + Vn, fe + zr, 1, It.minY, It.maxY, We), Fn = null), kn && (vn = Wt(kn, Jt, fe - hn, fe + Gn, 1, It.minY, It.maxY, We), Pn = Wt(kn, Jt, fe + Vn, fe + zr, 1, It.minY, It.maxY, We), kn = null), ft > 1 && console.timeEnd("clipping"), it.push(dn || [], te + 1, 2 * he, 2 * fe), it.push(on || [], te + 1, 2 * he, 2 * fe + 1), it.push(vn || [], te + 1, 2 * he + 1, 2 * fe), it.push(Pn || [], te + 1, 2 * he + 1, 2 * fe + 1)
                    }
                }
            }, Si.prototype.getTile = function(Te, te, he) {
                var fe = this.options,
                    Ae = fe.extent,
                    qe = fe.debug;
                if (Te < 0 || Te > 24) return null;
                var et = 1 << Te,
                    it = qi(Te, te = (te % et + et) % et, he);
                if (this.tiles[it]) return qn(this.tiles[it], Ae);
                qe > 1 && console.log("drilling down to z%d-%d-%d", Te, te, he);
                for (var We, ft = Te, Jt = te, zt = he; !We && ft > 0;) ft--, Jt = Math.floor(Jt / 2), zt = Math.floor(zt / 2), We = this.tiles[qi(ft, Jt, zt)];
                return We && We.source ? (qe > 1 && console.log("found parent tile z%d-%d-%d", ft, Jt, zt), qe > 1 && console.time("drilling down"), this.splitTile(We.source, ft, Jt, zt, Te, te, he), qe > 1 && console.timeEnd("drilling down"), this.tiles[it] ? qn(this.tiles[it], Ae) : null) : null
            };
            class ga extends be {
                constructor() {
                    super(...arguments), this._dataUpdateable = new Map
                }
                loadVectorTile(te, he) {
                    return C._(this, void 0, void 0, function*() {
                        const fe = te.tileID.canonical;
                        if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
                        const Ae = this._geoJSONIndex.getTile(fe.z, fe.x, fe.y);
                        if (!Ae) return null;
                        const qe = new class {
                            constructor(it) {
                                this.layers = {
                                    _geojsonTileLayer: this
                                }, this.name = "_geojsonTileLayer", this.extent = C.W, this.length = it.length, this._features = it
                            }
                            feature(it) {
                                return new class {
                                    constructor(We) {
                                        this._feature = We, this.extent = C.W, this.type = We.type, this.properties = We.tags, "id" in We && !isNaN(We.id) && (this.id = parseInt(We.id, 10))
                                    }
                                    loadGeometry() {
                                        if (this._feature.type === 1) {
                                            const We = [];
                                            for (const ft of this._feature.geometry) We.push([new C.P(ft[0], ft[1])]);
                                            return We
                                        } {
                                            const We = [];
                                            for (const ft of this._feature.geometry) {
                                                const Jt = [];
                                                for (const zt of ft) Jt.push(new C.P(zt[0], zt[1]));
                                                We.push(Jt)
                                            }
                                            return We
                                        }
                                    }
                                    toGeoJSON(We, ft, Jt) {
                                        return wt.call(this, We, ft, Jt)
                                    }
                                }(this._features[it])
                            }
                        }(Ae.features);
                        let et = _e(qe);
                        return et.byteOffset === 0 && et.byteLength === et.buffer.byteLength || (et = new Uint8Array(et)), {
                            vectorTile: qe,
                            rawData: et.buffer
                        }
                    })
                }
                loadData(te) {
                    var he;
                    return C._(this, void 0, void 0, function*() {
                        (he = this._pendingRequest) === null || he === void 0 || he.abort();
                        const fe = !!(te && te.request && te.request.collectResourceTiming) && new C.br(te.request);
                        this._pendingRequest = new AbortController;
                        try {
                            let Ae = yield this.loadGeoJSON(te, this._pendingRequest);
                            if (delete this._pendingRequest, typeof Ae != "object") throw new Error(`Input data given to '${te.source}' is not a valid GeoJSON object.`);
                            if (Je(Ae, !0), te.filter) {
                                const et = C.bx(te.filter, {
                                    type: "boolean",
                                    "property-type": "data-driven",
                                    overridable: !1,
                                    transition: !1
                                });
                                if (et.result === "error") throw new Error(et.value.map(We => `${We.key}: ${We.message}`).join(", "));
                                Ae = {
                                    type: "FeatureCollection",
                                    features: Ae.features.filter(We => et.value.evaluate({
                                        zoom: 0
                                    }, We))
                                }
                            }
                            this._geoJSONIndex = te.cluster ? new Ve(function({
                                superclusterOptions: et,
                                clusterProperties: it
                            }) {
                                if (!it || !et) return et;
                                const We = {},
                                    ft = {},
                                    Jt = {
                                        accumulated: null,
                                        zoom: 0
                                    },
                                    zt = {
                                        properties: null
                                    },
                                    It = Object.keys(it);
                                for (const zi of It) {
                                    const [Zi, dn] = it[zi], on = C.bx(dn), vn = C.bx(typeof Zi == "string" ? [Zi, ["accumulated"],
                                        ["get", zi]
                                    ] : Zi);
                                    We[zi] = on.value, ft[zi] = vn.value
                                }
                                return et.map = zi => {
                                    zt.properties = zi;
                                    const Zi = {};
                                    for (const dn of It) Zi[dn] = We[dn].evaluate(Jt, zt);
                                    return Zi
                                }, et.reduce = (zi, Zi) => {
                                    zt.properties = Zi;
                                    for (const dn of It) Jt.accumulated = zi[dn], zi[dn] = ft[dn].evaluate(Jt, zt)
                                }, et
                            }(te)).load(Ae.features) : function(et, it) {
                                return new Si(et, it)
                            }(Ae, te.geojsonVtOptions), this.loaded = {};
                            const qe = {};
                            if (fe) {
                                const et = fe.finish();
                                et && (qe.resourceTiming = {}, qe.resourceTiming[te.source] = JSON.parse(JSON.stringify(et)))
                            }
                            return qe
                        } catch (Ae) {
                            if (delete this._pendingRequest, C.by(Ae)) return {
                                abandoned: !0
                            };
                            throw Ae
                        }
                    })
                }
                reloadTile(te) {
                    const he = this.loaded;
                    return he && he[te.uid] ? super.reloadTile(te) : this.loadTile(te)
                }
                loadGeoJSON(te, he) {
                    return C._(this, void 0, void 0, function*() {
                        const {
                            promoteId: fe
                        } = te;
                        if (te.request) {
                            const Ae = yield C.h(te.request, he);
                            return this._dataUpdateable = Bn(Ae.data, fe) ? ge(Ae.data, fe) : void 0, Ae.data
                        }
                        if (typeof te.data == "string") try {
                            const Ae = JSON.parse(te.data);
                            return this._dataUpdateable = Bn(Ae, fe) ? ge(Ae, fe) : void 0, Ae
                        } catch (Ae) {
                            throw new Error(`Input data given to '${te.source}' is not a valid GeoJSON object.`)
                        }
                        if (!te.dataDiff) throw new Error(`Input data given to '${te.source}' is not a valid GeoJSON object.`);
                        if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${te.source}`);
                        return function(Ae, qe, et) {
                            var it, We, ft, Jt;
                            if (qe.removeAll && Ae.clear(), qe.remove)
                                for (const zt of qe.remove) Ae.delete(zt);
                            if (qe.add)
                                for (const zt of qe.add) {
                                    const It = Nn(zt, et);
                                    It != null && Ae.set(It, zt)
                                }
                            if (qe.update)
                                for (const zt of qe.update) {
                                    let It = Ae.get(zt.id);
                                    if (It == null) continue;
                                    const zi = !zt.removeAllProperties && (((it = zt.removeProperties) === null || it === void 0 ? void 0 : it.length) > 0 || ((We = zt.addOrUpdateProperties) === null || We === void 0 ? void 0 : We.length) > 0);
                                    if ((zt.newGeometry || zt.removeAllProperties || zi) && (It = Object.assign({}, It), Ae.set(zt.id, It), zi && (It.properties = Object.assign({}, It.properties))), zt.newGeometry && (It.geometry = zt.newGeometry), zt.removeAllProperties) It.properties = {};
                                    else if (((ft = zt.removeProperties) === null || ft === void 0 ? void 0 : ft.length) > 0)
                                        for (const Zi of zt.removeProperties) Object.prototype.hasOwnProperty.call(It.properties, Zi) && delete It.properties[Zi];
                                    if (((Jt = zt.addOrUpdateProperties) === null || Jt === void 0 ? void 0 : Jt.length) > 0)
                                        for (const {
                                                key: Zi,
                                                value: dn
                                            }
                                            of zt.addOrUpdateProperties) It.properties[Zi] = dn
                                }
                        }(this._dataUpdateable, te.dataDiff, fe), {
                            type: "FeatureCollection",
                            features: Array.from(this._dataUpdateable.values())
                        }
                    })
                }
                removeSource(te) {
                    return C._(this, void 0, void 0, function*() {
                        this._pendingRequest && this._pendingRequest.abort()
                    })
                }
                getClusterExpansionZoom(te) {
                    return this._geoJSONIndex.getClusterExpansionZoom(te.clusterId)
                }
                getClusterChildren(te) {
                    return this._geoJSONIndex.getChildren(te.clusterId)
                }
                getClusterLeaves(te) {
                    return this._geoJSONIndex.getLeaves(te.clusterId, te.limit, te.offset)
                }
            }
            class On {
                constructor(te) {
                    this.self = te, this.actor = new C.C(te), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (he, fe) => {
                        if (this.externalWorkerSourceTypes[he]) throw new Error(`Worker source with name "${he}" already registered.`);
                        this.externalWorkerSourceTypes[he] = fe
                    }, this.self.addProtocol = C.be, this.self.removeProtocol = C.bf, this.self.registerRTLTextPlugin = he => {
                        if (C.bz.isParsed()) throw new Error("RTL text plugin already registered.");
                        C.bz.setMethods(he)
                    }, this.actor.registerMessageHandler("loadDEMTile", (he, fe) => this._getDEMWorkerSource(he, fe.source).loadTile(fe)), this.actor.registerMessageHandler("removeDEMTile", (he, fe) => C._(this, void 0, void 0, function*() {
                        this._getDEMWorkerSource(he, fe.source).removeTile(fe)
                    })), this.actor.registerMessageHandler("getClusterExpansionZoom", (he, fe) => C._(this, void 0, void 0, function*() {
                        return this._getWorkerSource(he, fe.type, fe.source).getClusterExpansionZoom(fe)
                    })), this.actor.registerMessageHandler("getClusterChildren", (he, fe) => C._(this, void 0, void 0, function*() {
                        return this._getWorkerSource(he, fe.type, fe.source).getClusterChildren(fe)
                    })), this.actor.registerMessageHandler("getClusterLeaves", (he, fe) => C._(this, void 0, void 0, function*() {
                        return this._getWorkerSource(he, fe.type, fe.source).getClusterLeaves(fe)
                    })), this.actor.registerMessageHandler("loadData", (he, fe) => this._getWorkerSource(he, fe.type, fe.source).loadData(fe)), this.actor.registerMessageHandler("loadTile", (he, fe) => this._getWorkerSource(he, fe.type, fe.source).loadTile(fe)), this.actor.registerMessageHandler("reloadTile", (he, fe) => this._getWorkerSource(he, fe.type, fe.source).reloadTile(fe)), this.actor.registerMessageHandler("abortTile", (he, fe) => this._getWorkerSource(he, fe.type, fe.source).abortTile(fe)), this.actor.registerMessageHandler("removeTile", (he, fe) => this._getWorkerSource(he, fe.type, fe.source).removeTile(fe)), this.actor.registerMessageHandler("removeSource", (he, fe) => C._(this, void 0, void 0, function*() {
                        if (!this.workerSources[he] || !this.workerSources[he][fe.type] || !this.workerSources[he][fe.type][fe.source]) return;
                        const Ae = this.workerSources[he][fe.type][fe.source];
                        delete this.workerSources[he][fe.type][fe.source], Ae.removeSource !== void 0 && Ae.removeSource(fe)
                    })), this.actor.registerMessageHandler("removeMap", he => C._(this, void 0, void 0, function*() {
                        delete this.layerIndexes[he], delete this.availableImages[he], delete this.workerSources[he], delete this.demWorkerSources[he]
                    })), this.actor.registerMessageHandler("setReferrer", (he, fe) => C._(this, void 0, void 0, function*() {
                        this.referrer = fe
                    })), this.actor.registerMessageHandler("syncRTLPluginState", (he, fe) => this._syncRTLPluginState(he, fe)), this.actor.registerMessageHandler("importScript", (he, fe) => C._(this, void 0, void 0, function*() {
                        this.self.importScripts(fe)
                    })), this.actor.registerMessageHandler("setImages", (he, fe) => this._setImages(he, fe)), this.actor.registerMessageHandler("updateLayers", (he, fe) => C._(this, void 0, void 0, function*() {
                        this._getLayerIndex(he).update(fe.layers, fe.removedIds)
                    })), this.actor.registerMessageHandler("setLayers", (he, fe) => C._(this, void 0, void 0, function*() {
                        this._getLayerIndex(he).replace(fe)
                    }))
                }
                _setImages(te, he) {
                    return C._(this, void 0, void 0, function*() {
                        this.availableImages[te] = he;
                        for (const fe in this.workerSources[te]) {
                            const Ae = this.workerSources[te][fe];
                            for (const qe in Ae) Ae[qe].availableImages = he
                        }
                    })
                }
                _syncRTLPluginState(te, he) {
                    return C._(this, void 0, void 0, function*() {
                        C.bz.setState(he);
                        const fe = C.bz.getPluginURL();
                        if (he.pluginStatus === "loaded" && !C.bz.isParsed() && fe != null) {
                            this.self.importScripts(fe);
                            const Ae = C.bz.isParsed();
                            if (Ae) return Ae;
                            throw new Error(`RTL Text Plugin failed to import scripts from ${fe}`)
                        }
                        return !1
                    })
                }
                _getAvailableImages(te) {
                    let he = this.availableImages[te];
                    return he || (he = []), he
                }
                _getLayerIndex(te) {
                    let he = this.layerIndexes[te];
                    return he || (he = this.layerIndexes[te] = new p), he
                }
                _getWorkerSource(te, he, fe) {
                    if (this.workerSources[te] || (this.workerSources[te] = {}), this.workerSources[te][he] || (this.workerSources[te][he] = {}), !this.workerSources[te][he][fe]) {
                        const Ae = {
                            sendAsync: (qe, et) => (qe.targetMapId = te, this.actor.sendAsync(qe, et))
                        };
                        switch (he) {
                            case "vector":
                                this.workerSources[te][he][fe] = new be(Ae, this._getLayerIndex(te), this._getAvailableImages(te));
                                break;
                            case "geojson":
                                this.workerSources[te][he][fe] = new ga(Ae, this._getLayerIndex(te), this._getAvailableImages(te));
                                break;
                            default:
                                this.workerSources[te][he][fe] = new this.externalWorkerSourceTypes[he](Ae, this._getLayerIndex(te), this._getAvailableImages(te))
                        }
                    }
                    return this.workerSources[te][he][fe]
                }
                _getDEMWorkerSource(te, he) {
                    return this.demWorkerSources[te] || (this.demWorkerSources[te] = {}), this.demWorkerSources[te][he] || (this.demWorkerSources[te][he] = new Ee), this.demWorkerSources[te][he]
                }
            }
            return C.i(self) && (self.worker = new On(self)), On
        }), V("index", ["exports", "./shared"], function(C, p) {
            var se = "4.1.0";
            let ie, He;
            const be = {
                now: typeof performance != "undefined" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date),
                frameAsync: b => new Promise((n, u) => {
                    const f = requestAnimationFrame(n);
                    b.signal.addEventListener("abort", () => {
                        cancelAnimationFrame(f), u(p.c())
                    })
                }),
                getImageData(b, n = 0) {
                    return this.getImageCanvasContext(b).getImageData(-n, -n, b.width + 2 * n, b.height + 2 * n)
                },
                getImageCanvasContext(b) {
                    const n = window.document.createElement("canvas"),
                        u = n.getContext("2d", {
                            willReadFrequently: !0
                        });
                    if (!u) throw new Error("failed to create canvas 2d context");
                    return n.width = b.width, n.height = b.height, u.drawImage(b, 0, 0, b.width, b.height), u
                },
                resolveURL: b => (ie || (ie = document.createElement("a")), ie.href = b, ie.href),
                hardwareConcurrency: typeof navigator != "undefined" && navigator.hardwareConcurrency || 4,
                get prefersReducedMotion() {
                    return !!matchMedia && (He == null && (He = matchMedia("(prefers-reduced-motion: reduce)")), He.matches)
                }
            };
            class Ee {
                static testProp(n) {
                    if (!Ee.docStyle) return n[0];
                    for (let u = 0; u < n.length; u++)
                        if (n[u] in Ee.docStyle) return n[u];
                    return n[0]
                }
                static create(n, u, f) {
                    const _ = window.document.createElement(n);
                    return u !== void 0 && (_.className = u), f && f.appendChild(_), _
                }
                static createNS(n, u) {
                    return window.document.createElementNS(n, u)
                }
                static disableDrag() {
                    Ee.docStyle && Ee.selectProp && (Ee.userSelect = Ee.docStyle[Ee.selectProp], Ee.docStyle[Ee.selectProp] = "none")
                }
                static enableDrag() {
                    Ee.docStyle && Ee.selectProp && (Ee.docStyle[Ee.selectProp] = Ee.userSelect)
                }
                static setTransform(n, u) {
                    n.style[Ee.transformProp] = u
                }
                static addEventListener(n, u, f, _ = {}) {
                    n.addEventListener(u, f, "passive" in _ ? _ : _.capture)
                }
                static removeEventListener(n, u, f, _ = {}) {
                    n.removeEventListener(u, f, "passive" in _ ? _ : _.capture)
                }
                static suppressClickInternal(n) {
                    n.preventDefault(), n.stopPropagation(), window.removeEventListener("click", Ee.suppressClickInternal, !0)
                }
                static suppressClick() {
                    window.addEventListener("click", Ee.suppressClickInternal, !0), window.setTimeout(() => {
                        window.removeEventListener("click", Ee.suppressClickInternal, !0)
                    }, 0)
                }
                static getScale(n) {
                    const u = n.getBoundingClientRect();
                    return {
                        x: u.width / n.offsetWidth || 1,
                        y: u.height / n.offsetHeight || 1,
                        boundingClientRect: u
                    }
                }
                static getPoint(n, u, f) {
                    const _ = u.boundingClientRect;
                    return new p.P((f.clientX - _.left) / u.x - n.clientLeft, (f.clientY - _.top) / u.y - n.clientTop)
                }
                static mousePos(n, u) {
                    const f = Ee.getScale(n);
                    return Ee.getPoint(n, f, u)
                }
                static touchPos(n, u) {
                    const f = [],
                        _ = Ee.getScale(n);
                    for (let S = 0; S < u.length; S++) f.push(Ee.getPoint(n, _, u[S]));
                    return f
                }
                static mouseButton(n) {
                    return n.button
                }
                static remove(n) {
                    n.parentNode && n.parentNode.removeChild(n)
                }
            }
            Ee.docStyle = typeof window != "undefined" && window.document && window.document.documentElement.style, Ee.selectProp = Ee.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), Ee.transformProp = Ee.testProp(["transform", "WebkitTransform"]);
            const Lt = {
                supported: !1,
                testSupport: function(b) {
                    !wt && Je && (Ke ? Ye(b) : Tt = b)
                }
            };
            let Tt, Je, wt = !1,
                Ke = !1;

            function Ye(b) {
                const n = b.createTexture();
                b.bindTexture(b.TEXTURE_2D, n);
                try {
                    if (b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, b.RGBA, b.UNSIGNED_BYTE, Je), b.isContextLost()) return;
                    Lt.supported = !0
                } catch (u) {}
                b.deleteTexture(n), wt = !0
            }
            var jt, di;
            typeof document != "undefined" && (Je = document.createElement("img"), Je.onload = function() {
                    Tt && Ye(Tt), Tt = null, Ke = !0
                }, Je.onerror = function() {
                    wt = !0, Tt = null
                }, Je.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="),
                function(b) {
                    let n, u, f, _;
                    b.resetRequestQueue = () => {
                        n = [], u = 0, f = 0, _ = {}
                    }, b.addThrottleControl = I => {
                        const G = f++;
                        return _[G] = I, G
                    }, b.removeThrottleControl = I => {
                        delete _[I], L()
                    }, b.getImage = (I, G, j = !0) => new Promise((ee, pe) => {
                        Lt.supported && (I.headers || (I.headers = {}), I.headers.accept = "image/webp,*/*"), p.e(I, {
                            type: "image"
                        }), n.push({
                            abortController: G,
                            requestParameters: I,
                            supportImageRefresh: j,
                            state: "queued",
                            onError: Ce => {
                                pe(Ce)
                            },
                            onSuccess: Ce => {
                                ee(Ce)
                            }
                        }), L()
                    });
                    const S = I => p._(this, void 0, void 0, function*() {
                            I.state = "running";
                            const {
                                requestParameters: G,
                                supportImageRefresh: j,
                                onError: ee,
                                onSuccess: pe,
                                abortController: Ce
                            } = I, Me = j === !1 && !p.i(self) && !p.g(G.url) && (!G.headers || Object.keys(G.headers).reduce((nt, bt) => nt && bt === "accept", !0));
                            u++;
                            const ke = Me ? P(G, Ce) : p.m(G, Ce);
                            try {
                                const nt = yield ke;
                                delete I.abortController, I.state = "completed", nt.data instanceof HTMLImageElement || p.b(nt.data) ? pe(nt) : nt.data && pe({
                                    data: yield(we = nt.data, typeof createImageBitmap == "function" ? p.d(we) : p.f(we)),
                                    cacheControl: nt.cacheControl,
                                    expires: nt.expires
                                })
                            } catch (nt) {
                                delete I.abortController, ee(nt)
                            } finally {
                                u--, L()
                            }
                            var we
                        }),
                        L = () => {
                            const I = (() => {
                                for (const G of Object.keys(_))
                                    if (_[G]()) return !0;
                                return !1
                            })() ? p.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : p.a.MAX_PARALLEL_IMAGE_REQUESTS;
                            for (let G = u; G < I && n.length > 0; G++) {
                                const j = n.shift();
                                j.abortController.signal.aborted ? G-- : S(j)
                            }
                        },
                        P = (I, G) => new Promise((j, ee) => {
                            const pe = new Image,
                                Ce = I.url,
                                Me = I.credentials;
                            Me && Me === "include" ? pe.crossOrigin = "use-credentials" : (Me && Me === "same-origin" || !p.s(Ce)) && (pe.crossOrigin = "anonymous"), G.signal.addEventListener("abort", () => {
                                pe.src = "", ee(p.c())
                            }), pe.fetchPriority = "high", pe.onload = () => {
                                pe.onerror = pe.onload = null, j({
                                    data: pe
                                })
                            }, pe.onerror = () => {
                                pe.onerror = pe.onload = null, G.signal.aborted || ee(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."))
                            }, pe.src = Ce
                        })
                }(jt || (jt = {})), jt.resetRequestQueue(),
                function(b) {
                    b.Glyphs = "Glyphs", b.Image = "Image", b.Source = "Source", b.SpriteImage = "SpriteImage", b.SpriteJSON = "SpriteJSON", b.Style = "Style", b.Tile = "Tile", b.Unknown = "Unknown"
                }(di || (di = {}));
            class $e {
                constructor(n) {
                    this._transformRequestFn = n
                }
                transformRequest(n, u) {
                    return this._transformRequestFn && this._transformRequestFn(n, u) || {
                        url: n
                    }
                }
                normalizeSpriteURL(n, u, f) {
                    const _ = function(S) {
                        const L = S.match(vt);
                        if (!L) throw new Error(`Unable to parse URL "${S}"`);
                        return {
                            protocol: L[1],
                            authority: L[2],
                            path: L[3] || "/",
                            params: L[4] ? L[4].split("&") : []
                        }
                    }(n);
                    return _.path += `${u}${f}`,
                        function(S) {
                            const L = S.params.length ? `?${S.params.join("&")}` : "";
                            return `${S.protocol}://${S.authority}${S.path}${L}`
                        }(_)
                }
                setTransformRequest(n) {
                    this._transformRequestFn = n
                }
            }
            const vt = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;

            function Kt(b) {
                var n = new p.A(3);
                return n[0] = b[0], n[1] = b[1], n[2] = b[2], n
            }
            var vi, Li = function(b, n, u) {
                return b[0] = n[0] - u[0], b[1] = n[1] - u[1], b[2] = n[2] - u[2], b
            };
            vi = new p.A(3), p.A != Float32Array && (vi[0] = 0, vi[1] = 0, vi[2] = 0);
            var Ei = function(b) {
                var n = b[0],
                    u = b[1];
                return n * n + u * u
            };

            function ct(b) {
                const n = [];
                if (typeof b == "string") n.push({
                    id: "default",
                    url: b
                });
                else if (b && b.length > 0) {
                    const u = [];
                    for (const {
                            id: f,
                            url: _
                        }
                        of b) {
                        const S = `${f}${_}`;
                        u.indexOf(S) === -1 && (u.push(S), n.push({
                            id: f,
                            url: _
                        }))
                    }
                }
                return n
            }(function() {
                var b = new p.A(2);
                p.A != Float32Array && (b[0] = 0, b[1] = 0)
            })();
            class je {
                constructor(n, u, f, _) {
                    this.context = n, this.format = f, this.texture = n.gl.createTexture(), this.update(u, _)
                }
                update(n, u, f) {
                    const {
                        width: _,
                        height: S
                    } = n, L = !(this.size && this.size[0] === _ && this.size[1] === S || f), {
                        context: P
                    } = this, {
                        gl: I
                    } = P;
                    if (this.useMipmap = !!(u && u.useMipmap), I.bindTexture(I.TEXTURE_2D, this.texture), P.pixelStoreUnpackFlipY.set(!1), P.pixelStoreUnpack.set(1), P.pixelStoreUnpackPremultiplyAlpha.set(this.format === I.RGBA && (!u || u.premultiply !== !1)), L) this.size = [_, S], n instanceof HTMLImageElement || n instanceof HTMLCanvasElement || n instanceof HTMLVideoElement || n instanceof ImageData || p.b(n) ? I.texImage2D(I.TEXTURE_2D, 0, this.format, this.format, I.UNSIGNED_BYTE, n) : I.texImage2D(I.TEXTURE_2D, 0, this.format, _, S, 0, this.format, I.UNSIGNED_BYTE, n.data);
                    else {
                        const {
                            x: G,
                            y: j
                        } = f || {
                            x: 0,
                            y: 0
                        };
                        n instanceof HTMLImageElement || n instanceof HTMLCanvasElement || n instanceof HTMLVideoElement || n instanceof ImageData || p.b(n) ? I.texSubImage2D(I.TEXTURE_2D, 0, G, j, I.RGBA, I.UNSIGNED_BYTE, n) : I.texSubImage2D(I.TEXTURE_2D, 0, G, j, _, S, I.RGBA, I.UNSIGNED_BYTE, n.data)
                    }
                    this.useMipmap && this.isSizePowerOfTwo() && I.generateMipmap(I.TEXTURE_2D)
                }
                bind(n, u, f) {
                    const {
                        context: _
                    } = this, {
                        gl: S
                    } = _;
                    S.bindTexture(S.TEXTURE_2D, this.texture), f !== S.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (f = S.LINEAR), n !== this.filter && (S.texParameteri(S.TEXTURE_2D, S.TEXTURE_MAG_FILTER, n), S.texParameteri(S.TEXTURE_2D, S.TEXTURE_MIN_FILTER, f || n), this.filter = n), u !== this.wrap && (S.texParameteri(S.TEXTURE_2D, S.TEXTURE_WRAP_S, u), S.texParameteri(S.TEXTURE_2D, S.TEXTURE_WRAP_T, u), this.wrap = u)
                }
                isSizePowerOfTwo() {
                    return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0
                }
                destroy() {
                    const {
                        gl: n
                    } = this.context;
                    n.deleteTexture(this.texture), this.texture = null
                }
            }

            function li(b) {
                const {
                    userImage: n
                } = b;
                return !!(n && n.render && n.render()) && (b.data.replace(new Uint8Array(n.data.buffer)), !0)
            }
            class O extends p.E {
                constructor() {
                    super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new p.R({
                        width: 1,
                        height: 1
                    }), this.dirty = !0
                }
                isLoaded() {
                    return this.loaded
                }
                setLoaded(n) {
                    if (this.loaded !== n && (this.loaded = n, n)) {
                        for (const {
                                ids: u,
                                promiseResolve: f
                            }
                            of this.requestors) f(this._getImagesForIds(u));
                        this.requestors = []
                    }
                }
                getImage(n) {
                    const u = this.images[n];
                    if (u && !u.data && u.spriteData) {
                        const f = u.spriteData;
                        u.data = new p.R({
                            width: f.width,
                            height: f.height
                        }, f.context.getImageData(f.x, f.y, f.width, f.height).data), u.spriteData = null
                    }
                    return u
                }
                addImage(n, u) {
                    if (this.images[n]) throw new Error(`Image id ${n} already exist, use updateImage instead`);
                    this._validate(n, u) && (this.images[n] = u)
                }
                _validate(n, u) {
                    let f = !0;
                    const _ = u.data || u.spriteData;
                    return this._validateStretch(u.stretchX, _ && _.width) || (this.fire(new p.j(new Error(`Image "${n}" has invalid "stretchX" value`))), f = !1), this._validateStretch(u.stretchY, _ && _.height) || (this.fire(new p.j(new Error(`Image "${n}" has invalid "stretchY" value`))), f = !1), this._validateContent(u.content, u) || (this.fire(new p.j(new Error(`Image "${n}" has invalid "content" value`))), f = !1), f
                }
                _validateStretch(n, u) {
                    if (!n) return !0;
                    let f = 0;
                    for (const _ of n) {
                        if (_[0] < f || _[1] < _[0] || u < _[1]) return !1;
                        f = _[1]
                    }
                    return !0
                }
                _validateContent(n, u) {
                    if (!n) return !0;
                    if (n.length !== 4) return !1;
                    const f = u.spriteData,
                        _ = f && f.width || u.data.width,
                        S = f && f.height || u.data.height;
                    return !(n[0] < 0 || _ < n[0] || n[1] < 0 || S < n[1] || n[2] < 0 || _ < n[2] || n[3] < 0 || S < n[3] || n[2] < n[0] || n[3] < n[1])
                }
                updateImage(n, u, f = !0) {
                    const _ = this.getImage(n);
                    if (f && (_.data.width !== u.data.width || _.data.height !== u.data.height)) throw new Error(`size mismatch between old image (${_.data.width}x${_.data.height}) and new image (${u.data.width}x${u.data.height}).`);
                    u.version = _.version + 1, this.images[n] = u, this.updatedImages[n] = !0
                }
                removeImage(n) {
                    const u = this.images[n];
                    delete this.images[n], delete this.patterns[n], u.userImage && u.userImage.onRemove && u.userImage.onRemove()
                }
                listImages() {
                    return Object.keys(this.images)
                }
                getImages(n) {
                    return new Promise((u, f) => {
                        let _ = !0;
                        if (!this.isLoaded())
                            for (const S of n) this.images[S] || (_ = !1);
                        this.isLoaded() || _ ? u(this._getImagesForIds(n)) : this.requestors.push({
                            ids: n,
                            promiseResolve: u
                        })
                    })
                }
                _getImagesForIds(n) {
                    const u = {};
                    for (const f of n) {
                        let _ = this.getImage(f);
                        _ || (this.fire(new p.k("styleimagemissing", {
                            id: f
                        })), _ = this.getImage(f)), _ ? u[f] = {
                            data: _.data.clone(),
                            pixelRatio: _.pixelRatio,
                            sdf: _.sdf,
                            version: _.version,
                            stretchX: _.stretchX,
                            stretchY: _.stretchY,
                            content: _.content,
                            hasRenderCallback: !!(_.userImage && _.userImage.render)
                        } : p.w(`Image "${f}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`)
                    }
                    return u
                }
                getPixelSize() {
                    const {
                        width: n,
                        height: u
                    } = this.atlasImage;
                    return {
                        width: n,
                        height: u
                    }
                }
                getPattern(n) {
                    const u = this.patterns[n],
                        f = this.getImage(n);
                    if (!f) return null;
                    if (u && u.position.version === f.version) return u.position;
                    if (u) u.position.version = f.version;
                    else {
                        const _ = {
                                w: f.data.width + 2,
                                h: f.data.height + 2,
                                x: 0,
                                y: 0
                            },
                            S = new p.I(_, f);
                        this.patterns[n] = {
                            bin: _,
                            position: S
                        }
                    }
                    return this._updatePatternAtlas(), this.patterns[n].position
                }
                bind(n) {
                    const u = n.gl;
                    this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new je(n, this.atlasImage, u.RGBA), this.atlasTexture.bind(u.LINEAR, u.CLAMP_TO_EDGE)
                }
                _updatePatternAtlas() {
                    const n = [];
                    for (const S in this.patterns) n.push(this.patterns[S].bin);
                    const {
                        w: u,
                        h: f
                    } = p.p(n), _ = this.atlasImage;
                    _.resize({
                        width: u || 1,
                        height: f || 1
                    });
                    for (const S in this.patterns) {
                        const {
                            bin: L
                        } = this.patterns[S], P = L.x + 1, I = L.y + 1, G = this.getImage(S).data, j = G.width, ee = G.height;
                        p.R.copy(G, _, {
                            x: 0,
                            y: 0
                        }, {
                            x: P,
                            y: I
                        }, {
                            width: j,
                            height: ee
                        }), p.R.copy(G, _, {
                            x: 0,
                            y: ee - 1
                        }, {
                            x: P,
                            y: I - 1
                        }, {
                            width: j,
                            height: 1
                        }), p.R.copy(G, _, {
                            x: 0,
                            y: 0
                        }, {
                            x: P,
                            y: I + ee
                        }, {
                            width: j,
                            height: 1
                        }), p.R.copy(G, _, {
                            x: j - 1,
                            y: 0
                        }, {
                            x: P - 1,
                            y: I
                        }, {
                            width: 1,
                            height: ee
                        }), p.R.copy(G, _, {
                            x: 0,
                            y: 0
                        }, {
                            x: P + j,
                            y: I
                        }, {
                            width: 1,
                            height: ee
                        })
                    }
                    this.dirty = !0
                }
                beginFrame() {
                    this.callbackDispatchedThisFrame = {}
                }
                dispatchRenderCallbacks(n) {
                    for (const u of n) {
                        if (this.callbackDispatchedThisFrame[u]) continue;
                        this.callbackDispatchedThisFrame[u] = !0;
                        const f = this.getImage(u);
                        f || p.w(`Image with ID: "${u}" was not found`), li(f) && this.updateImage(u, f)
                    }
                }
            }
            const K = 1e20;

            function ae(b, n, u, f, _, S, L, P, I) {
                for (let G = n; G < n + f; G++) _e(b, u * S + G, S, _, L, P, I);
                for (let G = u; G < u + _; G++) _e(b, G * S + n, 1, f, L, P, I)
            }

            function _e(b, n, u, f, _, S, L) {
                S[0] = 0, L[0] = -K, L[1] = K, _[0] = b[n];
                for (let P = 1, I = 0, G = 0; P < f; P++) {
                    _[P] = b[n + P * u];
                    const j = P * P;
                    do {
                        const ee = S[I];
                        G = (_[P] - _[ee] + j - ee * ee) / (P - ee) / 2
                    } while (G <= L[I] && --I > -1);
                    I++, S[I] = P, L[I] = G, L[I + 1] = K
                }
                for (let P = 0, I = 0; P < f; P++) {
                    for (; L[I + 1] < P;) I++;
                    const G = S[I],
                        j = P - G;
                    b[n + P * u] = _[G] + j * j
                }
            }
            class xe {
                constructor(n, u) {
                    this.requestManager = n, this.localIdeographFontFamily = u, this.entries = {}
                }
                setURL(n) {
                    this.url = n
                }
                getGlyphs(n) {
                    return p._(this, void 0, void 0, function*() {
                        const u = [];
                        for (const S in n)
                            for (const L of n[S]) u.push(this._getAndCacheGlyphsPromise(S, L));
                        const f = yield Promise.all(u), _ = {};
                        for (const {
                                stack: S,
                                id: L,
                                glyph: P
                            }
                            of f) _[S] || (_[S] = {}), _[S][L] = P && {
                            id: P.id,
                            bitmap: P.bitmap.clone(),
                            metrics: P.metrics
                        };
                        return _
                    })
                }
                _getAndCacheGlyphsPromise(n, u) {
                    return p._(this, void 0, void 0, function*() {
                        let f = this.entries[n];
                        f || (f = this.entries[n] = {
                            glyphs: {},
                            requests: {},
                            ranges: {}
                        });
                        let _ = f.glyphs[u];
                        if (_ !== void 0) return {
                            stack: n,
                            id: u,
                            glyph: _
                        };
                        if (_ = this._tinySDF(f, n, u), _) return f.glyphs[u] = _, {
                            stack: n,
                            id: u,
                            glyph: _
                        };
                        const S = Math.floor(u / 256);
                        if (256 * S > 65535) throw new Error("glyphs > 65535 not supported");
                        if (f.ranges[S]) return {
                            stack: n,
                            id: u,
                            glyph: _
                        };
                        if (!this.url) throw new Error("glyphsUrl is not set");
                        if (!f.requests[S]) {
                            const P = xe.loadGlyphRange(n, S, this.url, this.requestManager);
                            f.requests[S] = P
                        }
                        const L = yield f.requests[S];
                        for (const P in L) this._doesCharSupportLocalGlyph(+P) || (f.glyphs[+P] = L[+P]);
                        return f.ranges[S] = !0, {
                            stack: n,
                            id: u,
                            glyph: L[u] || null
                        }
                    })
                }
                _doesCharSupportLocalGlyph(n) {
                    return !!this.localIdeographFontFamily && (p.u["CJK Unified Ideographs"](n) || p.u["Hangul Syllables"](n) || p.u.Hiragana(n) || p.u.Katakana(n))
                }
                _tinySDF(n, u, f) {
                    const _ = this.localIdeographFontFamily;
                    if (!_ || !this._doesCharSupportLocalGlyph(f)) return;
                    let S = n.tinySDF;
                    if (!S) {
                        let P = "400";
                        /bold/i.test(u) ? P = "900" : /medium/i.test(u) ? P = "500" : /light/i.test(u) && (P = "200"), S = n.tinySDF = new xe.TinySDF({
                            fontSize: 48,
                            buffer: 6,
                            radius: 16,
                            cutoff: .25,
                            fontFamily: _,
                            fontWeight: P
                        })
                    }
                    const L = S.draw(String.fromCharCode(f));
                    return {
                        id: f,
                        bitmap: new p.o({
                            width: L.width || 60,
                            height: L.height || 60
                        }, L.data),
                        metrics: {
                            width: L.glyphWidth / 2 || 24,
                            height: L.glyphHeight / 2 || 24,
                            left: L.glyphLeft / 2 + .5 || 0,
                            top: L.glyphTop / 2 - 27.5 || -8,
                            advance: L.glyphAdvance / 2 || 24,
                            isDoubleResolution: !0
                        }
                    }
                }
            }
            xe.loadGlyphRange = function(b, n, u, f) {
                return p._(this, void 0, void 0, function*() {
                    const _ = 256 * n,
                        S = _ + 255,
                        L = f.transformRequest(u.replace("{fontstack}", b).replace("{range}", `${_}-${S}`), di.Glyphs),
                        P = yield p.l(L, new AbortController);
                    if (!P || !P.data) throw new Error(`Could not load glyph range. range: ${n}, ${_}-${S}`);
                    const I = {};
                    for (const G of p.n(P.data)) I[G.id] = G;
                    return I
                })
            }, xe.TinySDF = class {
                constructor({
                    fontSize: b = 24,
                    buffer: n = 3,
                    radius: u = 8,
                    cutoff: f = .25,
                    fontFamily: _ = "sans-serif",
                    fontWeight: S = "normal",
                    fontStyle: L = "normal"
                } = {}) {
                    this.buffer = n, this.cutoff = f, this.radius = u;
                    const P = this.size = b + 4 * n,
                        I = this._createCanvas(P),
                        G = this.ctx = I.getContext("2d", {
                            willReadFrequently: !0
                        });
                    G.font = `${L} ${S} ${b}px ${_}`, G.textBaseline = "alphabetic", G.textAlign = "left", G.fillStyle = "black", this.gridOuter = new Float64Array(P * P), this.gridInner = new Float64Array(P * P), this.f = new Float64Array(P), this.z = new Float64Array(P + 1), this.v = new Uint16Array(P)
                }
                _createCanvas(b) {
                    const n = document.createElement("canvas");
                    return n.width = n.height = b, n
                }
                draw(b) {
                    const {
                        width: n,
                        actualBoundingBoxAscent: u,
                        actualBoundingBoxDescent: f,
                        actualBoundingBoxLeft: _,
                        actualBoundingBoxRight: S
                    } = this.ctx.measureText(b), L = Math.ceil(u), P = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(S - _))), I = Math.min(this.size - this.buffer, L + Math.ceil(f)), G = P + 2 * this.buffer, j = I + 2 * this.buffer, ee = Math.max(G * j, 0), pe = new Uint8ClampedArray(ee), Ce = {
                        data: pe,
                        width: G,
                        height: j,
                        glyphWidth: P,
                        glyphHeight: I,
                        glyphTop: L,
                        glyphLeft: 0,
                        glyphAdvance: n
                    };
                    if (P === 0 || I === 0) return Ce;
                    const {
                        ctx: Me,
                        buffer: ke,
                        gridInner: we,
                        gridOuter: nt
                    } = this;
                    Me.clearRect(ke, ke, P, I), Me.fillText(b, ke, ke + L);
                    const bt = Me.getImageData(ke, ke, P, I);
                    nt.fill(K, 0, ee), we.fill(0, 0, ee);
                    for (let ze = 0; ze < I; ze++)
                        for (let ut = 0; ut < P; ut++) {
                            const St = bt.data[4 * (ze * P + ut) + 3] / 255;
                            if (St === 0) continue;
                            const yt = (ze + ke) * G + ut + ke;
                            if (St === 1) nt[yt] = 0, we[yt] = K;
                            else {
                                const Vt = .5 - St;
                                nt[yt] = Vt > 0 ? Vt * Vt : 0, we[yt] = Vt < 0 ? Vt * Vt : 0
                            }
                        }
                    ae(nt, 0, 0, G, j, G, this.f, this.v, this.z), ae(we, ke, ke, P, I, G, this.f, this.v, this.z);
                    for (let ze = 0; ze < ee; ze++) {
                        const ut = Math.sqrt(nt[ze]) - Math.sqrt(we[ze]);
                        pe[ze] = Math.round(255 - 255 * (ut / this.radius + this.cutoff))
                    }
                    return Ce
                }
            };
            class Ze {
                constructor() {
                    this.specification = p.v.light.position
                }
                possiblyEvaluate(n, u) {
                    return p.y(n.expression.evaluate(u))
                }
                interpolate(n, u, f) {
                    return {
                        x: p.z.number(n.x, u.x, f),
                        y: p.z.number(n.y, u.y, f),
                        z: p.z.number(n.z, u.z, f)
                    }
                }
            }
            let st;
            class De extends p.E {
                constructor(n) {
                    super(), st = st || new p.q({
                        anchor: new p.D(p.v.light.anchor),
                        position: new Ze,
                        color: new p.D(p.v.light.color),
                        intensity: new p.D(p.v.light.intensity)
                    }), this._transitionable = new p.T(st), this.setLight(n), this._transitioning = this._transitionable.untransitioned()
                }
                getLight() {
                    return this._transitionable.serialize()
                }
                setLight(n, u = {}) {
                    if (!this._validate(p.r, n, u))
                        for (const f in n) {
                            const _ = n[f];
                            f.endsWith("-transition") ? this._transitionable.setTransition(f.slice(0, -11), _) : this._transitionable.setValue(f, _)
                        }
                }
                updateTransitions(n) {
                    this._transitioning = this._transitionable.transitioned(n, this._transitioning)
                }
                hasTransition() {
                    return this._transitioning.hasTransition()
                }
                recalculate(n) {
                    this.properties = this._transitioning.possiblyEvaluate(n)
                }
                _validate(n, u, f) {
                    return (!f || f.validate !== !1) && p.t(this, n.call(p.x, {
                        value: u,
                        style: {
                            glyphs: !0,
                            sprite: !0
                        },
                        styleSpec: p.v
                    }))
                }
            }
            class gt {
                constructor(n, u) {
                    this.width = n, this.height = u, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {}
                }
                getDash(n, u) {
                    const f = n.join(",") + String(u);
                    return this.dashEntry[f] || (this.dashEntry[f] = this.addDash(n, u)), this.dashEntry[f]
                }
                getDashRanges(n, u, f) {
                    const _ = [];
                    let S = n.length % 2 == 1 ? -n[n.length - 1] * f : 0,
                        L = n[0] * f,
                        P = !0;
                    _.push({
                        left: S,
                        right: L,
                        isDash: P,
                        zeroLength: n[0] === 0
                    });
                    let I = n[0];
                    for (let G = 1; G < n.length; G++) {
                        P = !P;
                        const j = n[G];
                        S = I * f, I += j, L = I * f, _.push({
                            left: S,
                            right: L,
                            isDash: P,
                            zeroLength: j === 0
                        })
                    }
                    return _
                }
                addRoundDash(n, u, f) {
                    const _ = u / 2;
                    for (let S = -f; S <= f; S++) {
                        const L = this.width * (this.nextRow + f + S);
                        let P = 0,
                            I = n[P];
                        for (let G = 0; G < this.width; G++) {
                            G / I.right > 1 && (I = n[++P]);
                            const j = Math.abs(G - I.left),
                                ee = Math.abs(G - I.right),
                                pe = Math.min(j, ee);
                            let Ce;
                            const Me = S / f * (_ + 1);
                            if (I.isDash) {
                                const ke = _ - Math.abs(Me);
                                Ce = Math.sqrt(pe * pe + ke * ke)
                            } else Ce = _ - Math.sqrt(pe * pe + Me * Me);
                            this.data[L + G] = Math.max(0, Math.min(255, Ce + 128))
                        }
                    }
                }
                addRegularDash(n) {
                    for (let P = n.length - 1; P >= 0; --P) {
                        const I = n[P],
                            G = n[P + 1];
                        I.zeroLength ? n.splice(P, 1) : G && G.isDash === I.isDash && (G.left = I.left, n.splice(P, 1))
                    }
                    const u = n[0],
                        f = n[n.length - 1];
                    u.isDash === f.isDash && (u.left = f.left - this.width, f.right = u.right + this.width);
                    const _ = this.width * this.nextRow;
                    let S = 0,
                        L = n[S];
                    for (let P = 0; P < this.width; P++) {
                        P / L.right > 1 && (L = n[++S]);
                        const I = Math.abs(P - L.left),
                            G = Math.abs(P - L.right),
                            j = Math.min(I, G);
                        this.data[_ + P] = Math.max(0, Math.min(255, (L.isDash ? j : -j) + 128))
                    }
                }
                addDash(n, u) {
                    const f = u ? 7 : 0,
                        _ = 2 * f + 1;
                    if (this.nextRow + _ > this.height) return p.w("LineAtlas out of space"), null;
                    let S = 0;
                    for (let P = 0; P < n.length; P++) S += n[P];
                    if (S !== 0) {
                        const P = this.width / S,
                            I = this.getDashRanges(n, this.width, P);
                        u ? this.addRoundDash(I, P, f) : this.addRegularDash(I)
                    }
                    const L = {
                        y: (this.nextRow + f + .5) / this.height,
                        height: 2 * f / this.height,
                        width: S
                    };
                    return this.nextRow += _, this.dirty = !0, L
                }
                bind(n) {
                    const u = n.gl;
                    this.texture ? (u.bindTexture(u.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, u.texSubImage2D(u.TEXTURE_2D, 0, 0, 0, this.width, this.height, u.ALPHA, u.UNSIGNED_BYTE, this.data))) : (this.texture = u.createTexture(), u.bindTexture(u.TEXTURE_2D, this.texture), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, u.REPEAT), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, u.REPEAT), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, u.LINEAR), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, u.LINEAR), u.texImage2D(u.TEXTURE_2D, 0, u.ALPHA, this.width, this.height, 0, u.ALPHA, u.UNSIGNED_BYTE, this.data))
                }
            }
            const Qt = "maplibre_preloaded_worker_pool";
            class Ve {
                constructor() {
                    this.active = {}
                }
                acquire(n) {
                    if (!this.workers)
                        for (this.workers = []; this.workers.length < Ve.workerCount;) this.workers.push(new Worker(p.a.WORKER_URL));
                    return this.active[n] = !0, this.workers.slice()
                }
                release(n) {
                    delete this.active[n], this.numActive() === 0 && (this.workers.forEach(u => {
                        u.terminate()
                    }), this.workers = null)
                }
                isPreloaded() {
                    return !!this.active[Qt]
                }
                numActive() {
                    return Object.keys(this.active).length
                }
            }
            const Dt = Math.floor(be.hardwareConcurrency / 2);
            let ei, xi;

            function oe() {
                return ei || (ei = new Ve), ei
            }
            Ve.workerCount = p.B(globalThis) ? Math.max(Math.min(Dt, 3), 1) : 1;
            class ve {
                constructor(n, u) {
                    this.workerPool = n, this.actors = [], this.currentActor = 0, this.id = u;
                    const f = this.workerPool.acquire(u);
                    for (let _ = 0; _ < f.length; _++) {
                        const S = new p.C(f[_], u);
                        S.name = `Worker ${_}`, this.actors.push(S)
                    }
                    if (!this.actors.length) throw new Error("No actors found")
                }
                broadcast(n, u) {
                    const f = [];
                    for (const _ of this.actors) f.push(_.sendAsync({
                        type: n,
                        data: u
                    }));
                    return Promise.all(f)
                }
                getActor() {
                    return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor]
                }
                remove(n = !0) {
                    this.actors.forEach(u => {
                        u.remove()
                    }), this.actors = [], n && this.workerPool.release(this.id)
                }
                registerMessageHandler(n, u) {
                    for (const f of this.actors) f.registerMessageHandler(n, u)
                }
            }

            function Ne() {
                return xi || (xi = new ve(oe(), p.G), xi.registerMessageHandler("getResource", (b, n, u) => p.m(n, u))), xi
            }

            function Ue(b, n) {
                const u = p.F();
                return p.H(u, u, [1, 1, 0]), p.J(u, u, [.5 * b.width, .5 * b.height, 1]), p.K(u, u, b.calculatePosMatrix(n.toUnwrapped()))
            }

            function Oe(b, n, u, f, _, S) {
                const L = function(ee, pe, Ce) {
                        if (ee)
                            for (const Me of ee) {
                                const ke = pe[Me];
                                if (ke && ke.source === Ce && ke.type === "fill-extrusion") return !0
                            } else
                                for (const Me in pe) {
                                    const ke = pe[Me];
                                    if (ke.source === Ce && ke.type === "fill-extrusion") return !0
                                }
                        return !1
                    }(_ && _.layers, n, b.id),
                    P = S.maxPitchScaleFactor(),
                    I = b.tilesIn(f, P, L);
                I.sort(at);
                const G = [];
                for (const ee of I) G.push({
                    wrappedTileID: ee.tileID.wrapped().key,
                    queryResults: ee.tile.queryRenderedFeatures(n, u, b._state, ee.queryGeometry, ee.cameraQueryGeometry, ee.scale, _, S, P, Ue(b.transform, ee.tileID))
                });
                const j = function(ee) {
                    const pe = {},
                        Ce = {};
                    for (const Me of ee) {
                        const ke = Me.queryResults,
                            we = Me.wrappedTileID,
                            nt = Ce[we] = Ce[we] || {};
                        for (const bt in ke) {
                            const ze = ke[bt],
                                ut = nt[bt] = nt[bt] || {},
                                St = pe[bt] = pe[bt] || [];
                            for (const yt of ze) ut[yt.featureIndex] || (ut[yt.featureIndex] = !0, St.push(yt))
                        }
                    }
                    return pe
                }(G);
                for (const ee in j) j[ee].forEach(pe => {
                    const Ce = pe.feature,
                        Me = b.getFeatureState(Ce.layer["source-layer"], Ce.id);
                    Ce.source = Ce.layer.source, Ce.layer["source-layer"] && (Ce.sourceLayer = Ce.layer["source-layer"]), Ce.state = Me
                });
                return j
            }

            function at(b, n) {
                const u = b.tileID,
                    f = n.tileID;
                return u.overscaledZ - f.overscaledZ || u.canonical.y - f.canonical.y || u.wrap - f.wrap || u.canonical.x - f.canonical.x
            }

            function ht(b, n, u) {
                return p._(this, void 0, void 0, function*() {
                    let f = b;
                    if (b.url ? f = (yield p.h(n.transformRequest(b.url, di.Source), u)).data : yield be.frameAsync(u), !f) return null;
                    const _ = p.L(p.e(f, b), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
                    return "vector_layers" in f && f.vector_layers && (_.vectorLayerIds = f.vector_layers.map(S => S.id)), _
                })
            }
            class tt {
                constructor(n, u) {
                    n && (u ? this.setSouthWest(n).setNorthEast(u) : Array.isArray(n) && (n.length === 4 ? this.setSouthWest([n[0], n[1]]).setNorthEast([n[2], n[3]]) : this.setSouthWest(n[0]).setNorthEast(n[1])))
                }
                setNorthEast(n) {
                    return this._ne = n instanceof p.M ? new p.M(n.lng, n.lat) : p.M.convert(n), this
                }
                setSouthWest(n) {
                    return this._sw = n instanceof p.M ? new p.M(n.lng, n.lat) : p.M.convert(n), this
                }
                extend(n) {
                    const u = this._sw,
                        f = this._ne;
                    let _, S;
                    if (n instanceof p.M) _ = n, S = n;
                    else {
                        if (!(n instanceof tt)) return Array.isArray(n) ? n.length === 4 || n.every(Array.isArray) ? this.extend(tt.convert(n)) : this.extend(p.M.convert(n)) : n && ("lng" in n || "lon" in n) && "lat" in n ? this.extend(p.M.convert(n)) : this;
                        if (_ = n._sw, S = n._ne, !_ || !S) return this
                    }
                    return u || f ? (u.lng = Math.min(_.lng, u.lng), u.lat = Math.min(_.lat, u.lat), f.lng = Math.max(S.lng, f.lng), f.lat = Math.max(S.lat, f.lat)) : (this._sw = new p.M(_.lng, _.lat), this._ne = new p.M(S.lng, S.lat)), this
                }
                getCenter() {
                    return new p.M((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2)
                }
                getSouthWest() {
                    return this._sw
                }
                getNorthEast() {
                    return this._ne
                }
                getNorthWest() {
                    return new p.M(this.getWest(), this.getNorth())
                }
                getSouthEast() {
                    return new p.M(this.getEast(), this.getSouth())
                }
                getWest() {
                    return this._sw.lng
                }
                getSouth() {
                    return this._sw.lat
                }
                getEast() {
                    return this._ne.lng
                }
                getNorth() {
                    return this._ne.lat
                }
                toArray() {
                    return [this._sw.toArray(), this._ne.toArray()]
                }
                toString() {
                    return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`
                }
                isEmpty() {
                    return !(this._sw && this._ne)
                }
                contains(n) {
                    const {
                        lng: u,
                        lat: f
                    } = p.M.convert(n);
                    let _ = this._sw.lng <= u && u <= this._ne.lng;
                    return this._sw.lng > this._ne.lng && (_ = this._sw.lng >= u && u >= this._ne.lng), this._sw.lat <= f && f <= this._ne.lat && _
                }
                static convert(n) {
                    return n instanceof tt ? n : n && new tt(n)
                }
                static fromLngLat(n, u = 0) {
                    const f = 360 * u / 40075017,
                        _ = f / Math.cos(Math.PI / 180 * n.lat);
                    return new tt(new p.M(n.lng - _, n.lat - f), new p.M(n.lng + _, n.lat + f))
                }
            }
            class Bt {
                constructor(n, u, f) {
                    this.bounds = tt.convert(this.validateBounds(n)), this.minzoom = u || 0, this.maxzoom = f || 24
                }
                validateBounds(n) {
                    return Array.isArray(n) && n.length === 4 ? [Math.max(-180, n[0]), Math.max(-90, n[1]), Math.min(180, n[2]), Math.min(90, n[3])] : [-180, -90, 180, 90]
                }
                contains(n) {
                    const u = Math.pow(2, n.z),
                        f = Math.floor(p.N(this.bounds.getWest()) * u),
                        _ = Math.floor(p.O(this.bounds.getNorth()) * u),
                        S = Math.ceil(p.N(this.bounds.getEast()) * u),
                        L = Math.ceil(p.O(this.bounds.getSouth()) * u);
                    return n.x >= f && n.x < S && n.y >= _ && n.y < L
                }
            }
            class Le extends p.E {
                constructor(n, u, f, _) {
                    if (super(), this.id = n, this.dispatcher = f, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, p.e(this, p.L(u, ["url", "scheme", "tileSize", "promoteId"])), this._options = p.e({
                            type: "vector"
                        }, u), this._collectResourceTiming = u.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
                    this.setEventedParent(_)
                }
                load() {
                    return p._(this, void 0, void 0, function*() {
                        this._loaded = !1, this.fire(new p.k("dataloading", {
                            dataType: "source"
                        })), this._tileJSONRequest = new AbortController;
                        try {
                            const n = yield ht(this._options, this.map._requestManager, this._tileJSONRequest);
                            this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), n && (p.e(this, n), n.bounds && (this.tileBounds = new Bt(n.bounds, this.minzoom, this.maxzoom)), this.fire(new p.k("data", {
                                dataType: "source",
                                sourceDataType: "metadata"
                            })), this.fire(new p.k("data", {
                                dataType: "source",
                                sourceDataType: "content"
                            })))
                        } catch (n) {
                            this._tileJSONRequest = null, this.fire(new p.j(n))
                        }
                    })
                }
                loaded() {
                    return this._loaded
                }
                hasTile(n) {
                    return !this.tileBounds || this.tileBounds.contains(n.canonical)
                }
                onAdd(n) {
                    this.map = n, this.load()
                }
                setSourceProperty(n) {
                    this._tileJSONRequest && this._tileJSONRequest.abort(), n(), this.load()
                }
                setTiles(n) {
                    return this.setSourceProperty(() => {
                        this._options.tiles = n
                    }), this
                }
                setUrl(n) {
                    return this.setSourceProperty(() => {
                        this.url = n, this._options.url = n
                    }), this
                }
                onRemove() {
                    this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null)
                }
                serialize() {
                    return p.e({}, this._options)
                }
                loadTile(n) {
                    return p._(this, void 0, void 0, function*() {
                        const u = n.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
                            f = {
                                request: this.map._requestManager.transformRequest(u, di.Tile),
                                uid: n.uid,
                                tileID: n.tileID,
                                zoom: n.tileID.overscaledZ,
                                tileSize: this.tileSize * n.tileID.overscaleFactor(),
                                type: this.type,
                                source: this.id,
                                pixelRatio: this.map.getPixelRatio(),
                                showCollisionBoxes: this.map.showCollisionBoxes,
                                promoteId: this.promoteId
                            };
                        f.request.collectResourceTiming = this._collectResourceTiming;
                        let _ = "reloadTile";
                        if (n.actor && n.state !== "expired") {
                            if (n.state === "loading") return new Promise((S, L) => {
                                n.reloadPromise = {
                                    resolve: S,
                                    reject: L
                                }
                            })
                        } else n.actor = this.dispatcher.getActor(), _ = "loadTile";
                        n.abortController = new AbortController;
                        try {
                            const S = yield n.actor.sendAsync({
                                type: _,
                                data: f
                            }, n.abortController);
                            if (delete n.abortController, n.aborted) return;
                            this._afterTileLoadWorkerResponse(n, S)
                        } catch (S) {
                            if (delete n.abortController, n.aborted) return;
                            if (S && S.status !== 404) throw S;
                            this._afterTileLoadWorkerResponse(n, null)
                        }
                    })
                }
                _afterTileLoadWorkerResponse(n, u) {
                    if (u && u.resourceTiming && (n.resourceTiming = u.resourceTiming), u && this.map._refreshExpiredTiles && n.setExpiryData(u), n.loadVectorData(u, this.map.painter), n.reloadPromise) {
                        const f = n.reloadPromise;
                        n.reloadPromise = null, this.loadTile(n).then(f.resolve).catch(f.reject)
                    }
                }
                abortTile(n) {
                    return p._(this, void 0, void 0, function*() {
                        n.abortController && (n.abortController.abort(), delete n.abortController), n.actor && (yield n.actor.sendAsync({
                            type: "abortTile",
                            data: {
                                uid: n.uid,
                                type: this.type,
                                source: this.id
                            }
                        }))
                    })
                }
                unloadTile(n) {
                    return p._(this, void 0, void 0, function*() {
                        n.unloadVectorData(), n.actor && (yield n.actor.sendAsync({
                            type: "removeTile",
                            data: {
                                uid: n.uid,
                                type: this.type,
                                source: this.id
                            }
                        }))
                    })
                }
                hasTransition() {
                    return !1
                }
            }
            class Ot extends p.E {
                constructor(n, u, f, _) {
                    super(), this.id = n, this.dispatcher = f, this.setEventedParent(_), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = p.e({
                        type: "raster"
                    }, u), p.e(this, p.L(u, ["url", "scheme", "tileSize"]))
                }
                load() {
                    return p._(this, void 0, void 0, function*() {
                        this._loaded = !1, this.fire(new p.k("dataloading", {
                            dataType: "source"
                        })), this._tileJSONRequest = new AbortController;
                        try {
                            const n = yield ht(this._options, this.map._requestManager, this._tileJSONRequest);
                            this._tileJSONRequest = null, this._loaded = !0, n && (p.e(this, n), n.bounds && (this.tileBounds = new Bt(n.bounds, this.minzoom, this.maxzoom)), this.fire(new p.k("data", {
                                dataType: "source",
                                sourceDataType: "metadata"
                            })), this.fire(new p.k("data", {
                                dataType: "source",
                                sourceDataType: "content"
                            })))
                        } catch (n) {
                            this._tileJSONRequest = null, this.fire(new p.j(n))
                        }
                    })
                }
                loaded() {
                    return this._loaded
                }
                onAdd(n) {
                    this.map = n, this.load()
                }
                onRemove() {
                    this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null)
                }
                setSourceProperty(n) {
                    this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), n(), this.load()
                }
                setTiles(n) {
                    return this.setSourceProperty(() => {
                        this._options.tiles = n
                    }), this
                }
                setUrl(n) {
                    return this.setSourceProperty(() => {
                        this.url = n, this._options.url = n
                    }), this
                }
                serialize() {
                    return p.e({}, this._options)
                }
                hasTile(n) {
                    return !this.tileBounds || this.tileBounds.contains(n.canonical)
                }
                loadTile(n) {
                    return p._(this, void 0, void 0, function*() {
                        const u = n.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
                        n.abortController = new AbortController;
                        try {
                            const f = yield jt.getImage(this.map._requestManager.transformRequest(u, di.Tile), n.abortController, this.map._refreshExpiredTiles);
                            if (delete n.abortController, n.aborted) return void(n.state = "unloaded");
                            if (f && f.data) {
                                this.map._refreshExpiredTiles && f.cacheControl && f.expires && n.setExpiryData({
                                    cacheControl: f.cacheControl,
                                    expires: f.expires
                                });
                                const _ = this.map.painter.context,
                                    S = _.gl,
                                    L = f.data;
                                n.texture = this.map.painter.getTileTexture(L.width), n.texture ? n.texture.update(L, {
                                    useMipmap: !0
                                }) : (n.texture = new je(_, L, S.RGBA, {
                                    useMipmap: !0
                                }), n.texture.bind(S.LINEAR, S.CLAMP_TO_EDGE, S.LINEAR_MIPMAP_NEAREST), _.extTextureFilterAnisotropic && S.texParameterf(S.TEXTURE_2D, _.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, _.extTextureFilterAnisotropicMax)), n.state = "loaded"
                            }
                        } catch (f) {
                            if (delete n.abortController, n.aborted) n.state = "unloaded";
                            else if (f) throw n.state = "errored", f
                        }
                    })
                }
                abortTile(n) {
                    return p._(this, void 0, void 0, function*() {
                        n.abortController && (n.abortController.abort(), delete n.abortController)
                    })
                }
                unloadTile(n) {
                    return p._(this, void 0, void 0, function*() {
                        n.texture && this.map.painter.saveTileTexture(n.texture)
                    })
                }
                hasTransition() {
                    return !1
                }
            }
            class ii extends Ot {
                constructor(n, u, f, _) {
                    super(n, u, f, _), this.type = "raster-dem", this.maxzoom = 22, this._options = p.e({
                        type: "raster-dem"
                    }, u), this.encoding = u.encoding || "mapbox", this.redFactor = u.redFactor, this.greenFactor = u.greenFactor, this.blueFactor = u.blueFactor, this.baseShift = u.baseShift
                }
                loadTile(n) {
                    return p._(this, void 0, void 0, function*() {
                        const u = n.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
                            f = this.map._requestManager.transformRequest(u, di.Tile);
                        n.neighboringTiles = this._getNeighboringTiles(n.tileID), n.abortController = new AbortController;
                        try {
                            const _ = yield jt.getImage(f, n.abortController, this.map._refreshExpiredTiles);
                            if (delete n.abortController, n.aborted) return void(n.state = "unloaded");
                            if (_ && _.data) {
                                const S = _.data;
                                this.map._refreshExpiredTiles && _.cacheControl && _.expires && n.setExpiryData({
                                    cacheControl: _.cacheControl,
                                    expires: _.expires
                                });
                                const L = p.b(S) && p.S() ? S : yield this.readImageNow(S), P = {
                                    type: this.type,
                                    uid: n.uid,
                                    source: this.id,
                                    rawImageData: L,
                                    encoding: this.encoding,
                                    redFactor: this.redFactor,
                                    greenFactor: this.greenFactor,
                                    blueFactor: this.blueFactor,
                                    baseShift: this.baseShift
                                };
                                if (!n.actor || n.state === "expired") {
                                    n.actor = this.dispatcher.getActor();
                                    const I = yield n.actor.sendAsync({
                                        type: "loadDEMTile",
                                        data: P
                                    });
                                    n.dem = I, n.needsHillshadePrepare = !0, n.needsTerrainPrepare = !0, n.state = "loaded"
                                }
                            }
                        } catch (_) {
                            if (delete n.abortController, n.aborted) n.state = "unloaded";
                            else if (_) throw n.state = "errored", _
                        }
                    })
                }
                readImageNow(n) {
                    return p._(this, void 0, void 0, function*() {
                        if (typeof VideoFrame != "undefined" && p.U()) {
                            const u = n.width + 2,
                                f = n.height + 2;
                            try {
                                return new p.R({
                                    width: u,
                                    height: f
                                }, yield p.V(n, -1, -1, u, f))
                            } catch (_) {}
                        }
                        return be.getImageData(n, 1)
                    })
                }
                _getNeighboringTiles(n) {
                    const u = n.canonical,
                        f = Math.pow(2, u.z),
                        _ = (u.x - 1 + f) % f,
                        S = u.x === 0 ? n.wrap - 1 : n.wrap,
                        L = (u.x + 1 + f) % f,
                        P = u.x + 1 === f ? n.wrap + 1 : n.wrap,
                        I = {};
                    return I[new p.Q(n.overscaledZ, S, u.z, _, u.y).key] = {
                        backfilled: !1
                    }, I[new p.Q(n.overscaledZ, P, u.z, L, u.y).key] = {
                        backfilled: !1
                    }, u.y > 0 && (I[new p.Q(n.overscaledZ, S, u.z, _, u.y - 1).key] = {
                        backfilled: !1
                    }, I[new p.Q(n.overscaledZ, n.wrap, u.z, u.x, u.y - 1).key] = {
                        backfilled: !1
                    }, I[new p.Q(n.overscaledZ, P, u.z, L, u.y - 1).key] = {
                        backfilled: !1
                    }), u.y + 1 < f && (I[new p.Q(n.overscaledZ, S, u.z, _, u.y + 1).key] = {
                        backfilled: !1
                    }, I[new p.Q(n.overscaledZ, n.wrap, u.z, u.x, u.y + 1).key] = {
                        backfilled: !1
                    }, I[new p.Q(n.overscaledZ, P, u.z, L, u.y + 1).key] = {
                        backfilled: !1
                    }), I
                }
                unloadTile(n) {
                    return p._(this, void 0, void 0, function*() {
                        n.demTexture && this.map.painter.saveTileTexture(n.demTexture), n.fbo && (n.fbo.destroy(), delete n.fbo), n.dem && delete n.dem, delete n.neighboringTiles, n.state = "unloaded", n.actor && (yield n.actor.sendAsync({
                            type: "removeDEMTile",
                            data: {
                                type: this.type,
                                uid: n.uid,
                                source: this.id
                            }
                        }))
                    })
                }
            }
            class Wt extends p.E {
                constructor(n, u, f, _) {
                    super(), this.id = n, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._pendingLoads = 0, this.actor = f.getActor(), this.setEventedParent(_), this._data = u.data, this._options = p.e({}, u), this._collectResourceTiming = u.collectResourceTiming, u.maxzoom !== void 0 && (this.maxzoom = u.maxzoom), u.type && (this.type = u.type), u.attribution && (this.attribution = u.attribution), this.promoteId = u.promoteId;
                    const S = p.W / this.tileSize;
                    this.workerOptions = p.e({
                        source: this.id,
                        cluster: u.cluster || !1,
                        geojsonVtOptions: {
                            buffer: (u.buffer !== void 0 ? u.buffer : 128) * S,
                            tolerance: (u.tolerance !== void 0 ? u.tolerance : .375) * S,
                            extent: p.W,
                            maxZoom: this.maxzoom,
                            lineMetrics: u.lineMetrics || !1,
                            generateId: u.generateId || !1
                        },
                        superclusterOptions: {
                            maxZoom: u.clusterMaxZoom !== void 0 ? u.clusterMaxZoom : this.maxzoom - 1,
                            minPoints: Math.max(2, u.clusterMinPoints || 2),
                            extent: p.W,
                            radius: (u.clusterRadius || 50) * S,
                            log: !1,
                            generateId: u.generateId || !1
                        },
                        clusterProperties: u.clusterProperties,
                        filter: u.filter
                    }, u.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId)
                }
                load() {
                    return p._(this, void 0, void 0, function*() {
                        yield this._updateWorkerData()
                    })
                }
                onAdd(n) {
                    this.map = n, this.load()
                }
                setData(n) {
                    return this._data = n, this._updateWorkerData(), this
                }
                updateData(n) {
                    return this._updateWorkerData(n), this
                }
                setClusterOptions(n) {
                    return this.workerOptions.cluster = n.cluster, n && (n.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = n.clusterRadius), n.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = n.clusterMaxZoom)), this._updateWorkerData(), this
                }
                getClusterExpansionZoom(n) {
                    return this.actor.sendAsync({
                        type: "getClusterExpansionZoom",
                        data: {
                            type: this.type,
                            clusterId: n,
                            source: this.id
                        }
                    })
                }
                getClusterChildren(n) {
                    return this.actor.sendAsync({
                        type: "getClusterChildren",
                        data: {
                            type: this.type,
                            clusterId: n,
                            source: this.id
                        }
                    })
                }
                getClusterLeaves(n, u, f) {
                    return this.actor.sendAsync({
                        type: "getClusterLeaves",
                        data: {
                            type: this.type,
                            source: this.id,
                            clusterId: n,
                            limit: u,
                            offset: f
                        }
                    })
                }
                _updateWorkerData(n) {
                    return p._(this, void 0, void 0, function*() {
                        const u = p.e({
                            type: this.type
                        }, this.workerOptions);
                        n ? u.dataDiff = n : typeof this._data == "string" ? (u.request = this.map._requestManager.transformRequest(be.resolveURL(this._data), di.Source), u.request.collectResourceTiming = this._collectResourceTiming) : u.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new p.k("dataloading", {
                            dataType: "source"
                        }));
                        try {
                            const f = yield this.actor.sendAsync({
                                type: "loadData",
                                data: u
                            });
                            if (this._pendingLoads--, this._removed || f.abandoned) return void this.fire(new p.k("dataabort", {
                                dataType: "source"
                            }));
                            let _ = null;
                            f.resourceTiming && f.resourceTiming[this.id] && (_ = f.resourceTiming[this.id].slice(0));
                            const S = {
                                dataType: "source"
                            };
                            this._collectResourceTiming && _ && _.length > 0 && p.e(S, {
                                resourceTiming: _
                            }), this.fire(new p.k("data", Object.assign(Object.assign({}, S), {
                                sourceDataType: "metadata"
                            }))), this.fire(new p.k("data", Object.assign(Object.assign({}, S), {
                                sourceDataType: "content"
                            })))
                        } catch (f) {
                            if (this._pendingLoads--, this._removed) return void this.fire(new p.k("dataabort", {
                                dataType: "source"
                            }));
                            this.fire(new p.j(f))
                        }
                    })
                }
                loaded() {
                    return this._pendingLoads === 0
                }
                loadTile(n) {
                    return p._(this, void 0, void 0, function*() {
                        const u = n.actor ? "reloadTile" : "loadTile";
                        n.actor = this.actor;
                        const f = {
                            type: this.type,
                            uid: n.uid,
                            tileID: n.tileID,
                            zoom: n.tileID.overscaledZ,
                            maxZoom: this.maxzoom,
                            tileSize: this.tileSize,
                            source: this.id,
                            pixelRatio: this.map.getPixelRatio(),
                            showCollisionBoxes: this.map.showCollisionBoxes,
                            promoteId: this.promoteId
                        };
                        n.abortController = new AbortController;
                        const _ = yield this.actor.sendAsync({
                            type: u,
                            data: f
                        }, n.abortController);
                        delete n.abortController, n.unloadVectorData(), n.aborted || n.loadVectorData(_, this.map.painter, u === "reloadTile")
                    })
                }
                abortTile(n) {
                    return p._(this, void 0, void 0, function*() {
                        n.abortController && (n.abortController.abort(), delete n.abortController), n.aborted = !0
                    })
                }
                unloadTile(n) {
                    return p._(this, void 0, void 0, function*() {
                        n.unloadVectorData(), yield this.actor.sendAsync({
                            type: "removeTile",
                            data: {
                                uid: n.uid,
                                type: this.type,
                                source: this.id
                            }
                        })
                    })
                }
                onRemove() {
                    this._removed = !0, this.actor.sendAsync({
                        type: "removeSource",
                        data: {
                            type: this.type,
                            source: this.id
                        }
                    })
                }
                serialize() {
                    return p.e({}, this._options, {
                        type: this.type,
                        data: this._data
                    })
                }
                hasTransition() {
                    return !1
                }
            }
            var bi = p.X([{
                name: "a_pos",
                type: "Int16",
                components: 2
            }, {
                name: "a_texture_pos",
                type: "Int16",
                components: 2
            }]);
            class Qi extends p.E {
                constructor(n, u, f, _) {
                    super(), this.id = n, this.dispatcher = f, this.coordinates = u.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(_), this.options = u
                }
                load(n) {
                    return p._(this, void 0, void 0, function*() {
                        this._loaded = !1, this.fire(new p.k("dataloading", {
                            dataType: "source"
                        })), this.url = this.options.url, this._request = new AbortController;
                        try {
                            const u = yield jt.getImage(this.map._requestManager.transformRequest(this.url, di.Image), this._request);
                            this._request = null, this._loaded = !0, u && u.data && (this.image = u.data, n && (this.coordinates = n), this._finishLoading())
                        } catch (u) {
                            this._request = null, this.fire(new p.j(u))
                        }
                    })
                }
                loaded() {
                    return this._loaded
                }
                updateImage(n) {
                    return n.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = n.url, this.load(n.coordinates).finally(() => {
                        this.texture = null
                    }), this) : this
                }
                _finishLoading() {
                    this.map && (this.setCoordinates(this.coordinates), this.fire(new p.k("data", {
                        dataType: "source",
                        sourceDataType: "metadata"
                    })))
                }
                onAdd(n) {
                    this.map = n, this.load()
                }
                onRemove() {
                    this._request && (this._request.abort(), this._request = null)
                }
                setCoordinates(n) {
                    this.coordinates = n;
                    const u = n.map(p.Y.fromLngLat);
                    this.tileID = function(_) {
                        let S = 1 / 0,
                            L = 1 / 0,
                            P = -1 / 0,
                            I = -1 / 0;
                        for (const pe of _) S = Math.min(S, pe.x), L = Math.min(L, pe.y), P = Math.max(P, pe.x), I = Math.max(I, pe.y);
                        const G = Math.max(P - S, I - L),
                            j = Math.max(0, Math.floor(-Math.log(G) / Math.LN2)),
                            ee = Math.pow(2, j);
                        return new p.a0(j, Math.floor((S + P) / 2 * ee), Math.floor((L + I) / 2 * ee))
                    }(u), this.minzoom = this.maxzoom = this.tileID.z;
                    const f = u.map(_ => this.tileID.getTilePoint(_)._round());
                    return this._boundsArray = new p.Z, this._boundsArray.emplaceBack(f[0].x, f[0].y, 0, 0), this._boundsArray.emplaceBack(f[1].x, f[1].y, p.W, 0), this._boundsArray.emplaceBack(f[3].x, f[3].y, 0, p.W), this._boundsArray.emplaceBack(f[2].x, f[2].y, p.W, p.W), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new p.k("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    })), this
                }
                prepare() {
                    if (Object.keys(this.tiles).length === 0 || !this.image) return;
                    const n = this.map.painter.context,
                        u = n.gl;
                    this.boundsBuffer || (this.boundsBuffer = n.createVertexBuffer(this._boundsArray, bi.members)), this.boundsSegments || (this.boundsSegments = p.$.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new je(n, this.image, u.RGBA), this.texture.bind(u.LINEAR, u.CLAMP_TO_EDGE));
                    let f = !1;
                    for (const _ in this.tiles) {
                        const S = this.tiles[_];
                        S.state !== "loaded" && (S.state = "loaded", S.texture = this.texture, f = !0)
                    }
                    f && this.fire(new p.k("data", {
                        dataType: "source",
                        sourceDataType: "idle",
                        sourceId: this.id
                    }))
                }
                loadTile(n) {
                    return p._(this, void 0, void 0, function*() {
                        this.tileID && this.tileID.equals(n.tileID.canonical) ? (this.tiles[String(n.tileID.wrap)] = n, n.buckets = {}) : n.state = "errored"
                    })
                }
                serialize() {
                    return {
                        type: "image",
                        url: this.options.url,
                        coordinates: this.coordinates
                    }
                }
                hasTransition() {
                    return !1
                }
            }
            class sn extends Qi {
                constructor(n, u, f, _) {
                    super(n, u, f, _), this.roundZoom = !0, this.type = "video", this.options = u
                }
                load() {
                    return p._(this, void 0, void 0, function*() {
                        this._loaded = !1;
                        const n = this.options;
                        this.urls = [];
                        for (const u of n.urls) this.urls.push(this.map._requestManager.transformRequest(u, di.Source).url);
                        try {
                            const u = yield p.a2(this.urls);
                            if (this._loaded = !0, !u) return;
                            this.video = u, this.video.loop = !0, this.video.addEventListener("playing", () => {
                                this.map.triggerRepaint()
                            }), this.map && this.video.play(), this._finishLoading()
                        } catch (u) {
                            this.fire(new p.j(u))
                        }
                    })
                }
                pause() {
                    this.video && this.video.pause()
                }
                play() {
                    this.video && this.video.play()
                }
                seek(n) {
                    if (this.video) {
                        const u = this.video.seekable;
                        n < u.start(0) || n > u.end(0) ? this.fire(new p.j(new p.a1(`sources.${this.id}`, null, `Playback for this video can be set only between the ${u.start(0)} and ${u.end(0)}-second mark.`))) : this.video.currentTime = n
                    }
                }
                getVideo() {
                    return this.video
                }
                onAdd(n) {
                    this.map || (this.map = n, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)))
                }
                prepare() {
                    if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
                    const n = this.map.painter.context,
                        u = n.gl;
                    this.boundsBuffer || (this.boundsBuffer = n.createVertexBuffer(this._boundsArray, bi.members)), this.boundsSegments || (this.boundsSegments = p.$.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(u.LINEAR, u.CLAMP_TO_EDGE), u.texSubImage2D(u.TEXTURE_2D, 0, 0, 0, u.RGBA, u.UNSIGNED_BYTE, this.video)) : (this.texture = new je(n, this.video, u.RGBA), this.texture.bind(u.LINEAR, u.CLAMP_TO_EDGE));
                    let f = !1;
                    for (const _ in this.tiles) {
                        const S = this.tiles[_];
                        S.state !== "loaded" && (S.state = "loaded", S.texture = this.texture, f = !0)
                    }
                    f && this.fire(new p.k("data", {
                        dataType: "source",
                        sourceDataType: "idle",
                        sourceId: this.id
                    }))
                }
                serialize() {
                    return {
                        type: "video",
                        urls: this.urls,
                        coordinates: this.coordinates
                    }
                }
                hasTransition() {
                    return this.video && !this.video.paused
                }
            }
            class yn extends Qi {
                constructor(n, u, f, _) {
                    super(n, u, f, _), u.coordinates ? Array.isArray(u.coordinates) && u.coordinates.length === 4 && !u.coordinates.some(S => !Array.isArray(S) || S.length !== 2 || S.some(L => typeof L != "number")) || this.fire(new p.j(new p.a1(`sources.${n}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new p.j(new p.a1(`sources.${n}`, null, 'missing required property "coordinates"'))), u.animate && typeof u.animate != "boolean" && this.fire(new p.j(new p.a1(`sources.${n}`, null, 'optional "animate" property must be a boolean value'))), u.canvas ? typeof u.canvas == "string" || u.canvas instanceof HTMLCanvasElement || this.fire(new p.j(new p.a1(`sources.${n}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new p.j(new p.a1(`sources.${n}`, null, 'missing required property "canvas"'))), this.options = u, this.animate = u.animate === void 0 || u.animate
                }
                load() {
                    return p._(this, void 0, void 0, function*() {
                        this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new p.j(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                            this._playing = !0, this.map.triggerRepaint()
                        }, this.pause = function() {
                            this._playing && (this.prepare(), this._playing = !1)
                        }, this._finishLoading())
                    })
                }
                getCanvas() {
                    return this.canvas
                }
                onAdd(n) {
                    this.map = n, this.load(), this.canvas && this.animate && this.play()
                }
                onRemove() {
                    this.pause()
                }
                prepare() {
                    let n = !1;
                    if (this.canvas.width !== this.width && (this.width = this.canvas.width, n = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, n = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
                    const u = this.map.painter.context,
                        f = u.gl;
                    this.boundsBuffer || (this.boundsBuffer = u.createVertexBuffer(this._boundsArray, bi.members)), this.boundsSegments || (this.boundsSegments = p.$.simpleSegment(0, 0, 4, 2)), this.texture ? (n || this._playing) && this.texture.update(this.canvas, {
                        premultiply: !0
                    }) : this.texture = new je(u, this.canvas, f.RGBA, {
                        premultiply: !0
                    });
                    let _ = !1;
                    for (const S in this.tiles) {
                        const L = this.tiles[S];
                        L.state !== "loaded" && (L.state = "loaded", L.texture = this.texture, _ = !0)
                    }
                    _ && this.fire(new p.k("data", {
                        dataType: "source",
                        sourceDataType: "idle",
                        sourceId: this.id
                    }))
                }
                serialize() {
                    return {
                        type: "canvas",
                        coordinates: this.coordinates
                    }
                }
                hasTransition() {
                    return this._playing
                }
                _hasInvalidDimensions() {
                    for (const n of [this.canvas.width, this.canvas.height])
                        if (isNaN(n) || n <= 0) return !0;
                    return !1
                }
            }
            const Yi = {},
                rn = b => {
                    switch (b) {
                        case "geojson":
                            return Wt;
                        case "image":
                            return Qi;
                        case "raster":
                            return Ot;
                        case "raster-dem":
                            return ii;
                        case "vector":
                            return Le;
                        case "video":
                            return sn;
                        case "canvas":
                            return yn
                    }
                    return Yi[b]
                };
            class Mi extends p.E {
                constructor() {
                    super(...arguments), this.pluginStatus = "unavailable", this.pluginURL = null, this.dispatcher = Ne(), this.queue = []
                }
                _sendPluginStateToWorker() {
                    return p._(this, void 0, void 0, function*() {
                        yield this.dispatcher.broadcast("syncRTLPluginState", {
                            pluginStatus: this.pluginStatus,
                            pluginURL: this.pluginURL
                        }), this.fire(new p.k("pluginStateChange", {
                            pluginStatus: this.pluginStatus,
                            pluginURL: this.pluginURL
                        }))
                    })
                }
                getRTLTextPluginStatus() {
                    return this.pluginStatus
                }
                clearRTLTextPlugin() {
                    this.pluginStatus = "unavailable", this.pluginURL = null
                }
                setRTLTextPlugin(n, u = !1) {
                    return p._(this, void 0, void 0, function*() {
                        if (this.pluginStatus === "deferred" || this.pluginStatus === "loading" || this.pluginStatus === "loaded") throw new Error("setRTLTextPlugin cannot be called multiple times.");
                        this.pluginURL = be.resolveURL(n), this.pluginStatus = "deferred", yield this._sendPluginStateToWorker(), u || (yield this._downloadRTLTextPlugin())
                    })
                }
                _downloadRTLTextPlugin() {
                    return p._(this, void 0, void 0, function*() {
                        if (this.pluginStatus !== "deferred" || !this.pluginURL) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
                        try {
                            this.pluginStatus = "loading", yield this._sendPluginStateToWorker(), yield p.l({
                                url: this.pluginURL
                            }, new AbortController), this.pluginStatus = "loaded"
                        } catch (n) {
                            this.pluginStatus = "error"
                        }
                        yield this._sendPluginStateToWorker()
                    })
                }
                lazyLoadRTLTextPlugin() {
                    return p._(this, void 0, void 0, function*() {
                        this.pluginStatus === "deferred" && (yield this._downloadRTLTextPlugin())
                    })
                }
            }
            let Ht = null;

            function Pt() {
                return Ht || (Ht = new Mi), Ht
            }
            class qn {
                constructor(n, u) {
                    this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = n, this.uid = p.a3(), this.uses = 0, this.tileSize = u, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading"
                }
                registerFadeDuration(n) {
                    const u = n + this.timeAdded;
                    u < this.fadeEndTime || (this.fadeEndTime = u)
                }
                wasRequested() {
                    return this.state === "errored" || this.state === "loaded" || this.state === "reloading"
                }
                clearTextures(n) {
                    this.demTexture && n.saveTileTexture(this.demTexture), this.demTexture = null
                }
                loadVectorData(n, u, f) {
                    if (this.hasData() && this.unloadVectorData(), this.state = "loaded", n) {
                        n.featureIndex && (this.latestFeatureIndex = n.featureIndex, n.rawTileData ? (this.latestRawTileData = n.rawTileData, this.latestFeatureIndex.rawTileData = n.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = n.collisionBoxArray, this.buckets = function(_, S) {
                            const L = {};
                            if (!S) return L;
                            for (const P of _) {
                                const I = P.layerIds.map(G => S.getLayer(G)).filter(Boolean);
                                if (I.length !== 0) {
                                    P.layers = I, P.stateDependentLayerIds && (P.stateDependentLayers = P.stateDependentLayerIds.map(G => I.filter(j => j.id === G)[0]));
                                    for (const G of I) L[G.id] = P
                                }
                            }
                            return L
                        }(n.buckets, u.style), this.hasSymbolBuckets = !1;
                        for (const _ in this.buckets) {
                            const S = this.buckets[_];
                            if (S instanceof p.a5) {
                                if (this.hasSymbolBuckets = !0, !f) break;
                                S.justReloaded = !0
                            }
                        }
                        if (this.hasRTLText = !1, this.hasSymbolBuckets)
                            for (const _ in this.buckets) {
                                const S = this.buckets[_];
                                if (S instanceof p.a5 && S.hasRTLText) {
                                    this.hasRTLText = !0, Pt().lazyLoadRTLTextPlugin();
                                    break
                                }
                            }
                        this.queryPadding = 0;
                        for (const _ in this.buckets) {
                            const S = this.buckets[_];
                            this.queryPadding = Math.max(this.queryPadding, u.style.getLayer(_).queryRadius(S))
                        }
                        n.imageAtlas && (this.imageAtlas = n.imageAtlas), n.glyphAtlasImage && (this.glyphAtlasImage = n.glyphAtlasImage)
                    } else this.collisionBoxArray = new p.a4
                }
                unloadVectorData() {
                    for (const n in this.buckets) this.buckets[n].destroy();
                    this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded"
                }
                getBucket(n) {
                    return this.buckets[n.id]
                }
                upload(n) {
                    for (const f in this.buckets) {
                        const _ = this.buckets[f];
                        _.uploadPending() && _.upload(n)
                    }
                    const u = n.gl;
                    this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new je(n, this.imageAtlas.image, u.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new je(n, this.glyphAtlasImage, u.ALPHA), this.glyphAtlasImage = null)
                }
                prepare(n) {
                    this.imageAtlas && this.imageAtlas.patchUpdatedImages(n, this.imageAtlasTexture)
                }
                queryRenderedFeatures(n, u, f, _, S, L, P, I, G, j) {
                    return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
                        queryGeometry: _,
                        cameraQueryGeometry: S,
                        scale: L,
                        tileSize: this.tileSize,
                        pixelPosMatrix: j,
                        transform: I,
                        params: P,
                        queryPadding: this.queryPadding * G
                    }, n, u, f) : {}
                }
                querySourceFeatures(n, u) {
                    const f = this.latestFeatureIndex;
                    if (!f || !f.rawTileData) return;
                    const _ = f.loadVTLayers(),
                        S = u && u.sourceLayer ? u.sourceLayer : "",
                        L = _._geojsonTileLayer || _[S];
                    if (!L) return;
                    const P = p.a6(u && u.filter),
                        {
                            z: I,
                            x: G,
                            y: j
                        } = this.tileID.canonical,
                        ee = {
                            z: I,
                            x: G,
                            y: j
                        };
                    for (let pe = 0; pe < L.length; pe++) {
                        const Ce = L.feature(pe);
                        if (P.needGeometry) {
                            const we = p.a7(Ce, !0);
                            if (!P.filter(new p.a8(this.tileID.overscaledZ), we, this.tileID.canonical)) continue
                        } else if (!P.filter(new p.a8(this.tileID.overscaledZ), Ce)) continue;
                        const Me = f.getId(Ce, S),
                            ke = new p.a9(Ce, I, G, j, Me);
                        ke.tile = ee, n.push(ke)
                    }
                }
                hasData() {
                    return this.state === "loaded" || this.state === "reloading" || this.state === "expired"
                }
                patternsLoaded() {
                    return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length
                }
                setExpiryData(n) {
                    const u = this.expirationTime;
                    if (n.cacheControl) {
                        const f = p.aa(n.cacheControl);
                        f["max-age"] && (this.expirationTime = Date.now() + 1e3 * f["max-age"])
                    } else n.expires && (this.expirationTime = new Date(n.expires).getTime());
                    if (this.expirationTime) {
                        const f = Date.now();
                        let _ = !1;
                        if (this.expirationTime > f) _ = !1;
                        else if (u)
                            if (this.expirationTime < u) _ = !0;
                            else {
                                const S = this.expirationTime - u;
                                S ? this.expirationTime = f + Math.max(S, 3e4) : _ = !0
                            }
                        else _ = !0;
                        _ ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0
                    }
                }
                getExpiryTimeout() {
                    if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1)
                }
                setFeatureState(n, u) {
                    if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(n).length === 0) return;
                    const f = this.latestFeatureIndex.loadVTLayers();
                    for (const _ in this.buckets) {
                        if (!u.style.hasLayer(_)) continue;
                        const S = this.buckets[_],
                            L = S.layers[0].sourceLayer || "_geojsonTileLayer",
                            P = f[L],
                            I = n[L];
                        if (!P || !I || Object.keys(I).length === 0) continue;
                        S.update(I, P, this.imageAtlas && this.imageAtlas.patternPositions || {});
                        const G = u && u.style && u.style.getLayer(_);
                        G && (this.queryPadding = Math.max(this.queryPadding, G.queryRadius(S)))
                    }
                }
                holdingForFade() {
                    return this.symbolFadeHoldUntil !== void 0
                }
                symbolFadeFinished() {
                    return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < be.now()
                }
                clearFadeHold() {
                    this.symbolFadeHoldUntil = void 0
                }
                setHoldDuration(n) {
                    this.symbolFadeHoldUntil = be.now() + n
                }
                setDependencies(n, u) {
                    const f = {};
                    for (const _ of u) f[_] = !0;
                    this.dependencies[n] = f
                }
                hasDependency(n, u) {
                    for (const f of n) {
                        const _ = this.dependencies[f];
                        if (_) {
                            for (const S of u)
                                if (_[S]) return !0
                        }
                    }
                    return !1
                }
            }
            class ji {
                constructor(n, u) {
                    this.max = n, this.onRemove = u, this.reset()
                }
                reset() {
                    for (const n in this.data)
                        for (const u of this.data[n]) u.timeout && clearTimeout(u.timeout), this.onRemove(u.value);
                    return this.data = {}, this.order = [], this
                }
                add(n, u, f) {
                    const _ = n.wrapped().key;
                    this.data[_] === void 0 && (this.data[_] = []);
                    const S = {
                        value: u,
                        timeout: void 0
                    };
                    if (f !== void 0 && (S.timeout = setTimeout(() => {
                            this.remove(n, S)
                        }, f)), this.data[_].push(S), this.order.push(_), this.order.length > this.max) {
                        const L = this._getAndRemoveByKey(this.order[0]);
                        L && this.onRemove(L)
                    }
                    return this
                }
                has(n) {
                    return n.wrapped().key in this.data
                }
                getAndRemove(n) {
                    return this.has(n) ? this._getAndRemoveByKey(n.wrapped().key) : null
                }
                _getAndRemoveByKey(n) {
                    const u = this.data[n].shift();
                    return u.timeout && clearTimeout(u.timeout), this.data[n].length === 0 && delete this.data[n], this.order.splice(this.order.indexOf(n), 1), u.value
                }
                getByKey(n) {
                    const u = this.data[n];
                    return u ? u[0].value : null
                }
                get(n) {
                    return this.has(n) ? this.data[n.wrapped().key][0].value : null
                }
                remove(n, u) {
                    if (!this.has(n)) return this;
                    const f = n.wrapped().key,
                        _ = u === void 0 ? 0 : this.data[f].indexOf(u),
                        S = this.data[f][_];
                    return this.data[f].splice(_, 1), S.timeout && clearTimeout(S.timeout), this.data[f].length === 0 && delete this.data[f], this.onRemove(S.value), this.order.splice(this.order.indexOf(f), 1), this
                }
                setMaxSize(n) {
                    for (this.max = n; this.order.length > this.max;) {
                        const u = this._getAndRemoveByKey(this.order[0]);
                        u && this.onRemove(u)
                    }
                    return this
                }
                filter(n) {
                    const u = [];
                    for (const f in this.data)
                        for (const _ of this.data[f]) n(_.value) || u.push(_);
                    for (const f of u) this.remove(f.value.tileID, f)
                }
            }
            class na {
                constructor() {
                    this.state = {}, this.stateChanges = {}, this.deletedStates = {}
                }
                updateState(n, u, f) {
                    const _ = String(u);
                    if (this.stateChanges[n] = this.stateChanges[n] || {}, this.stateChanges[n][_] = this.stateChanges[n][_] || {}, p.e(this.stateChanges[n][_], f), this.deletedStates[n] === null) {
                        this.deletedStates[n] = {};
                        for (const S in this.state[n]) S !== _ && (this.deletedStates[n][S] = null)
                    } else if (this.deletedStates[n] && this.deletedStates[n][_] === null) {
                        this.deletedStates[n][_] = {};
                        for (const S in this.state[n][_]) f[S] || (this.deletedStates[n][_][S] = null)
                    } else
                        for (const S in f) this.deletedStates[n] && this.deletedStates[n][_] && this.deletedStates[n][_][S] === null && delete this.deletedStates[n][_][S]
                }
                removeFeatureState(n, u, f) {
                    if (this.deletedStates[n] === null) return;
                    const _ = String(u);
                    if (this.deletedStates[n] = this.deletedStates[n] || {}, f && u !== void 0) this.deletedStates[n][_] !== null && (this.deletedStates[n][_] = this.deletedStates[n][_] || {}, this.deletedStates[n][_][f] = null);
                    else if (u !== void 0)
                        if (this.stateChanges[n] && this.stateChanges[n][_])
                            for (f in this.deletedStates[n][_] = {}, this.stateChanges[n][_]) this.deletedStates[n][_][f] = null;
                        else this.deletedStates[n][_] = null;
                    else this.deletedStates[n] = null
                }
                getState(n, u) {
                    const f = String(u),
                        _ = p.e({}, (this.state[n] || {})[f], (this.stateChanges[n] || {})[f]);
                    if (this.deletedStates[n] === null) return {};
                    if (this.deletedStates[n]) {
                        const S = this.deletedStates[n][u];
                        if (S === null) return {};
                        for (const L in S) delete _[L]
                    }
                    return _
                }
                initializeTileState(n, u) {
                    n.setFeatureState(this.state, u)
                }
                coalesceChanges(n, u) {
                    const f = {};
                    for (const _ in this.stateChanges) {
                        this.state[_] = this.state[_] || {};
                        const S = {};
                        for (const L in this.stateChanges[_]) this.state[_][L] || (this.state[_][L] = {}), p.e(this.state[_][L], this.stateChanges[_][L]), S[L] = this.state[_][L];
                        f[_] = S
                    }
                    for (const _ in this.deletedStates) {
                        this.state[_] = this.state[_] || {};
                        const S = {};
                        if (this.deletedStates[_] === null)
                            for (const L in this.state[_]) S[L] = {}, this.state[_][L] = {};
                        else
                            for (const L in this.deletedStates[_]) {
                                if (this.deletedStates[_][L] === null) this.state[_][L] = {};
                                else
                                    for (const P of Object.keys(this.deletedStates[_][L])) delete this.state[_][L][P];
                                S[L] = this.state[_][L]
                            }
                        f[_] = f[_] || {}, p.e(f[_], S)
                    }
                    if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(f).length !== 0)
                        for (const _ in n) n[_].setFeatureState(f, u)
                }
            }
            class cn extends p.E {
                constructor(n, u, f) {
                    super(), this.id = n, this.dispatcher = f, this.on("data", _ => {
                        _.dataType === "source" && _.sourceDataType === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && _.dataType === "source" && _.sourceDataType === "content" && (this.reload(), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0)
                    }), this.on("dataloading", () => {
                        this._sourceErrored = !1
                    }), this.on("error", () => {
                        this._sourceErrored = this._source.loaded()
                    }), this._source = ((_, S, L, P) => {
                        const I = new(rn(S.type))(_, S, L, P);
                        if (I.id !== _) throw new Error(`Expected Source id to be ${_} instead of ${I.id}`);
                        return I
                    })(n, u, f, this), this._tiles = {}, this._cache = new ji(0, _ => this._unloadTile(_)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new na, this._didEmitContent = !1, this._updated = !1
                }
                onAdd(n) {
                    this.map = n, this._maxTileCacheSize = n ? n._maxTileCacheSize : null, this._maxTileCacheZoomLevels = n ? n._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(n)
                }
                onRemove(n) {
                    this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(n)
                }
                loaded() {
                    if (this._sourceErrored) return !0;
                    if (!this._sourceLoaded || !this._source.loaded()) return !1;
                    if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
                    if (!this._updated) return !1;
                    for (const n in this._tiles) {
                        const u = this._tiles[n];
                        if (u.state !== "loaded" && u.state !== "errored") return !1
                    }
                    return !0
                }
                getSource() {
                    return this._source
                }
                pause() {
                    this._paused = !0
                }
                resume() {
                    if (!this._paused) return;
                    const n = this._shouldReloadOnResume;
                    this._paused = !1, this._shouldReloadOnResume = !1, n && this.reload(), this.transform && this.update(this.transform, this.terrain)
                }
                _loadTile(n, u, f) {
                    return p._(this, void 0, void 0, function*() {
                        try {
                            yield this._source.loadTile(n), this._tileLoaded(n, u, f)
                        } catch (_) {
                            n.state = "errored", _.status !== 404 ? this._source.fire(new p.j(_, {
                                tile: n
                            })) : this.update(this.transform, this.terrain)
                        }
                    })
                }
                _unloadTile(n) {
                    this._source.unloadTile && this._source.unloadTile(n)
                }
                _abortTile(n) {
                    this._source.abortTile && this._source.abortTile(n), this._source.fire(new p.k("dataabort", {
                        tile: n,
                        coord: n.tileID,
                        dataType: "source"
                    }))
                }
                serialize() {
                    return this._source.serialize()
                }
                prepare(n) {
                    this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
                    for (const u in this._tiles) {
                        const f = this._tiles[u];
                        f.upload(n), f.prepare(this.map.style.imageManager)
                    }
                }
                getIds() {
                    return Object.values(this._tiles).map(n => n.tileID).sort(yi).map(n => n.key)
                }
                getRenderableIds(n) {
                    const u = [];
                    for (const f in this._tiles) this._isIdRenderable(f, n) && u.push(this._tiles[f]);
                    return n ? u.sort((f, _) => {
                        const S = f.tileID,
                            L = _.tileID,
                            P = new p.P(S.canonical.x, S.canonical.y)._rotate(this.transform.angle),
                            I = new p.P(L.canonical.x, L.canonical.y)._rotate(this.transform.angle);
                        return S.overscaledZ - L.overscaledZ || I.y - P.y || I.x - P.x
                    }).map(f => f.tileID.key) : u.map(f => f.tileID).sort(yi).map(f => f.key)
                }
                hasRenderableParent(n) {
                    const u = this.findLoadedParent(n, 0);
                    return !!u && this._isIdRenderable(u.tileID.key)
                }
                _isIdRenderable(n, u) {
                    return this._tiles[n] && this._tiles[n].hasData() && !this._coveredTiles[n] && (u || !this._tiles[n].holdingForFade())
                }
                reload() {
                    if (this._paused) this._shouldReloadOnResume = !0;
                    else {
                        this._cache.reset();
                        for (const n in this._tiles) this._tiles[n].state !== "errored" && this._reloadTile(n, "reloading")
                    }
                }
                _reloadTile(n, u) {
                    return p._(this, void 0, void 0, function*() {
                        const f = this._tiles[n];
                        f && (f.state !== "loading" && (f.state = u), yield this._loadTile(f, n, u))
                    })
                }
                _tileLoaded(n, u, f) {
                    n.timeAdded = be.now(), f === "expired" && (n.refreshedUponExpiration = !0), this._setTileReloadTimer(u, n), this.getSource().type === "raster-dem" && n.dem && this._backfillDEM(n), this._state.initializeTileState(n, this.map ? this.map.painter : null), n.aborted || this._source.fire(new p.k("data", {
                        dataType: "source",
                        tile: n,
                        coord: n.tileID
                    }))
                }
                _backfillDEM(n) {
                    const u = this.getRenderableIds();
                    for (let _ = 0; _ < u.length; _++) {
                        const S = u[_];
                        if (n.neighboringTiles && n.neighboringTiles[S]) {
                            const L = this.getTileByID(S);
                            f(n, L), f(L, n)
                        }
                    }

                    function f(_, S) {
                        _.needsHillshadePrepare = !0, _.needsTerrainPrepare = !0;
                        let L = S.tileID.canonical.x - _.tileID.canonical.x;
                        const P = S.tileID.canonical.y - _.tileID.canonical.y,
                            I = Math.pow(2, _.tileID.canonical.z),
                            G = S.tileID.key;
                        L === 0 && P === 0 || Math.abs(P) > 1 || (Math.abs(L) > 1 && (Math.abs(L + I) === 1 ? L += I : Math.abs(L - I) === 1 && (L -= I)), S.dem && _.dem && (_.dem.backfillBorder(S.dem, L, P), _.neighboringTiles && _.neighboringTiles[G] && (_.neighboringTiles[G].backfilled = !0)))
                    }
                }
                getTile(n) {
                    return this.getTileByID(n.key)
                }
                getTileByID(n) {
                    return this._tiles[n]
                }
                _retainLoadedChildren(n, u, f, _) {
                    for (const S in this._tiles) {
                        let L = this._tiles[S];
                        if (_[S] || !L.hasData() || L.tileID.overscaledZ <= u || L.tileID.overscaledZ > f) continue;
                        let P = L.tileID;
                        for (; L && L.tileID.overscaledZ > u + 1;) {
                            const G = L.tileID.scaledTo(L.tileID.overscaledZ - 1);
                            L = this._tiles[G.key], L && L.hasData() && (P = G)
                        }
                        let I = P;
                        for (; I.overscaledZ > u;)
                            if (I = I.scaledTo(I.overscaledZ - 1), n[I.key]) {
                                _[P.key] = P;
                                break
                            }
                    }
                }
                findLoadedParent(n, u) {
                    if (n.key in this._loadedParentTiles) {
                        const f = this._loadedParentTiles[n.key];
                        return f && f.tileID.overscaledZ >= u ? f : null
                    }
                    for (let f = n.overscaledZ - 1; f >= u; f--) {
                        const _ = n.scaledTo(f),
                            S = this._getLoadedTile(_);
                        if (S) return S
                    }
                }
                _getLoadedTile(n) {
                    const u = this._tiles[n.key];
                    return u && u.hasData() ? u : this._cache.getByKey(n.wrapped().key)
                }
                updateCacheSize(n) {
                    const u = Math.ceil(n.width / this._source.tileSize) + 1,
                        f = Math.ceil(n.height / this._source.tileSize) + 1,
                        _ = Math.floor(u * f * (this._maxTileCacheZoomLevels === null ? p.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)),
                        S = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, _) : _;
                    this._cache.setMaxSize(S)
                }
                handleWrapJump(n) {
                    const u = Math.round((n - (this._prevLng === void 0 ? n : this._prevLng)) / 360);
                    if (this._prevLng = n, u) {
                        const f = {};
                        for (const _ in this._tiles) {
                            const S = this._tiles[_];
                            S.tileID = S.tileID.unwrapTo(S.tileID.wrap + u), f[S.tileID.key] = S
                        }
                        this._tiles = f;
                        for (const _ in this._timers) clearTimeout(this._timers[_]), delete this._timers[_];
                        for (const _ in this._tiles) this._setTileReloadTimer(_, this._tiles[_])
                    }
                }
                update(n, u) {
                    if (this.transform = n, this.terrain = u, !this._sourceLoaded || this._paused) return;
                    let f;
                    this.updateCacheSize(n), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? f = n.getVisibleUnwrappedCoordinates(this._source.tileID).map(j => new p.Q(j.canonical.z, j.wrap, j.canonical.z, j.canonical.x, j.canonical.y)) : (f = n.coveringTiles({
                        tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize,
                        minzoom: this._source.minzoom,
                        maxzoom: this._source.maxzoom,
                        roundZoom: !this.usedForTerrain && this._source.roundZoom,
                        reparseOverscaled: this._source.reparseOverscaled,
                        terrain: u
                    }), this._source.hasTile && (f = f.filter(j => this._source.hasTile(j)))) : f = [];
                    const _ = n.coveringZoomLevel(this._source),
                        S = Math.max(_ - cn.maxOverzooming, this._source.minzoom),
                        L = Math.max(_ + cn.maxUnderzooming, this._source.minzoom);
                    if (this.usedForTerrain) {
                        const j = {};
                        for (const ee of f)
                            if (ee.canonical.z > this._source.minzoom) {
                                const pe = ee.scaledTo(ee.canonical.z - 1);
                                j[pe.key] = pe;
                                const Ce = ee.scaledTo(Math.max(this._source.minzoom, Math.min(ee.canonical.z, 5)));
                                j[Ce.key] = Ce
                            } f = f.concat(Object.values(j))
                    }
                    const P = f.length === 0 && !this._updated && this._didEmitContent;
                    this._updated = !0, P && this.fire(new p.k("data", {
                        sourceDataType: "idle",
                        dataType: "source",
                        sourceId: this.id
                    }));
                    const I = this._updateRetainedTiles(f, _);
                    if (Si(this._source.type)) {
                        const j = {},
                            ee = {},
                            pe = Object.keys(I),
                            Ce = be.now();
                        for (const Me of pe) {
                            const ke = I[Me],
                                we = this._tiles[Me];
                            if (!we || we.fadeEndTime !== 0 && we.fadeEndTime <= Ce) continue;
                            const nt = this.findLoadedParent(ke, S);
                            nt && (this._addTile(nt.tileID), j[nt.tileID.key] = nt.tileID), ee[Me] = ke
                        }
                        this._retainLoadedChildren(ee, _, L, I);
                        for (const Me in j) I[Me] || (this._coveredTiles[Me] = !0, I[Me] = j[Me]);
                        if (u) {
                            const Me = {},
                                ke = {};
                            for (const we of f) this._tiles[we.key].hasData() ? Me[we.key] = we : ke[we.key] = we;
                            for (const we in ke) {
                                const nt = ke[we].children(this._source.maxzoom);
                                this._tiles[nt[0].key] && this._tiles[nt[1].key] && this._tiles[nt[2].key] && this._tiles[nt[3].key] && (Me[nt[0].key] = I[nt[0].key] = nt[0], Me[nt[1].key] = I[nt[1].key] = nt[1], Me[nt[2].key] = I[nt[2].key] = nt[2], Me[nt[3].key] = I[nt[3].key] = nt[3], delete ke[we])
                            }
                            for (const we in ke) {
                                const nt = this.findLoadedParent(ke[we], this._source.minzoom);
                                if (nt) {
                                    Me[nt.tileID.key] = I[nt.tileID.key] = nt.tileID;
                                    for (const bt in Me) Me[bt].isChildOf(nt.tileID) && delete Me[bt]
                                }
                            }
                            for (const we in this._tiles) Me[we] || (this._coveredTiles[we] = !0)
                        }
                    }
                    for (const j in I) this._tiles[j].clearFadeHold();
                    const G = p.ab(this._tiles, I);
                    for (const j of G) {
                        const ee = this._tiles[j];
                        ee.hasSymbolBuckets && !ee.holdingForFade() ? ee.setHoldDuration(this.map._fadeDuration) : ee.hasSymbolBuckets && !ee.symbolFadeFinished() || this._removeTile(j)
                    }
                    this._updateLoadedParentTileCache()
                }
                releaseSymbolFadeTiles() {
                    for (const n in this._tiles) this._tiles[n].holdingForFade() && this._removeTile(n)
                }
                _updateRetainedTiles(n, u) {
                    const f = {},
                        _ = {},
                        S = Math.max(u - cn.maxOverzooming, this._source.minzoom),
                        L = Math.max(u + cn.maxUnderzooming, this._source.minzoom),
                        P = {};
                    for (const I of n) {
                        const G = this._addTile(I);
                        f[I.key] = I, G.hasData() || u < this._source.maxzoom && (P[I.key] = I)
                    }
                    this._retainLoadedChildren(P, u, L, f);
                    for (const I of n) {
                        let G = this._tiles[I.key];
                        if (G.hasData()) continue;
                        if (u + 1 > this._source.maxzoom) {
                            const ee = I.children(this._source.maxzoom)[0],
                                pe = this.getTile(ee);
                            if (pe && pe.hasData()) {
                                f[ee.key] = ee;
                                continue
                            }
                        } else {
                            const ee = I.children(this._source.maxzoom);
                            if (f[ee[0].key] && f[ee[1].key] && f[ee[2].key] && f[ee[3].key]) continue
                        }
                        let j = G.wasRequested();
                        for (let ee = I.overscaledZ - 1; ee >= S; --ee) {
                            const pe = I.scaledTo(ee);
                            if (_[pe.key]) break;
                            if (_[pe.key] = !0, G = this.getTile(pe), !G && j && (G = this._addTile(pe)), G) {
                                const Ce = G.hasData();
                                if ((j || Ce) && (f[pe.key] = pe), j = G.wasRequested(), Ce) break
                            }
                        }
                    }
                    return f
                }
                _updateLoadedParentTileCache() {
                    this._loadedParentTiles = {};
                    for (const n in this._tiles) {
                        const u = [];
                        let f, _ = this._tiles[n].tileID;
                        for (; _.overscaledZ > 0;) {
                            if (_.key in this._loadedParentTiles) {
                                f = this._loadedParentTiles[_.key];
                                break
                            }
                            u.push(_.key);
                            const S = _.scaledTo(_.overscaledZ - 1);
                            if (f = this._getLoadedTile(S), f) break;
                            _ = S
                        }
                        for (const S of u) this._loadedParentTiles[S] = f
                    }
                }
                _addTile(n) {
                    let u = this._tiles[n.key];
                    if (u) return u;
                    u = this._cache.getAndRemove(n), u && (this._setTileReloadTimer(n.key, u), u.tileID = n, this._state.initializeTileState(u, this.map ? this.map.painter : null), this._cacheTimers[n.key] && (clearTimeout(this._cacheTimers[n.key]), delete this._cacheTimers[n.key], this._setTileReloadTimer(n.key, u)));
                    const f = u;
                    return u || (u = new qn(n, this._source.tileSize * n.overscaleFactor()), this._loadTile(u, n.key, u.state)), u.uses++, this._tiles[n.key] = u, f || this._source.fire(new p.k("dataloading", {
                        tile: u,
                        coord: u.tileID,
                        dataType: "source"
                    })), u
                }
                _setTileReloadTimer(n, u) {
                    n in this._timers && (clearTimeout(this._timers[n]), delete this._timers[n]);
                    const f = u.getExpiryTimeout();
                    f && (this._timers[n] = setTimeout(() => {
                        this._reloadTile(n, "expired"), delete this._timers[n]
                    }, f))
                }
                _removeTile(n) {
                    const u = this._tiles[n];
                    u && (u.uses--, delete this._tiles[n], this._timers[n] && (clearTimeout(this._timers[n]), delete this._timers[n]), u.uses > 0 || (u.hasData() && u.state !== "reloading" ? this._cache.add(u.tileID, u, u.getExpiryTimeout()) : (u.aborted = !0, this._abortTile(u), this._unloadTile(u))))
                }
                clearTiles() {
                    this._shouldReloadOnResume = !1, this._paused = !1;
                    for (const n in this._tiles) this._removeTile(n);
                    this._cache.reset()
                }
                tilesIn(n, u, f) {
                    const _ = [],
                        S = this.transform;
                    if (!S) return _;
                    const L = f ? S.getCameraQueryGeometry(n) : n,
                        P = n.map(Me => S.pointCoordinate(Me, this.terrain)),
                        I = L.map(Me => S.pointCoordinate(Me, this.terrain)),
                        G = this.getIds();
                    let j = 1 / 0,
                        ee = 1 / 0,
                        pe = -1 / 0,
                        Ce = -1 / 0;
                    for (const Me of I) j = Math.min(j, Me.x), ee = Math.min(ee, Me.y), pe = Math.max(pe, Me.x), Ce = Math.max(Ce, Me.y);
                    for (let Me = 0; Me < G.length; Me++) {
                        const ke = this._tiles[G[Me]];
                        if (ke.holdingForFade()) continue;
                        const we = ke.tileID,
                            nt = Math.pow(2, S.zoom - ke.tileID.overscaledZ),
                            bt = u * ke.queryPadding * p.W / ke.tileSize / nt,
                            ze = [we.getTilePoint(new p.Y(j, ee)), we.getTilePoint(new p.Y(pe, Ce))];
                        if (ze[0].x - bt < p.W && ze[0].y - bt < p.W && ze[1].x + bt >= 0 && ze[1].y + bt >= 0) {
                            const ut = P.map(yt => we.getTilePoint(yt)),
                                St = I.map(yt => we.getTilePoint(yt));
                            _.push({
                                tile: ke,
                                tileID: we,
                                queryGeometry: ut,
                                cameraQueryGeometry: St,
                                scale: nt
                            })
                        }
                    }
                    return _
                }
                getVisibleCoordinates(n) {
                    const u = this.getRenderableIds(n).map(f => this._tiles[f].tileID);
                    for (const f of u) f.posMatrix = this.transform.calculatePosMatrix(f.toUnwrapped());
                    return u
                }
                hasTransition() {
                    if (this._source.hasTransition()) return !0;
                    if (Si(this._source.type)) {
                        const n = be.now();
                        for (const u in this._tiles)
                            if (this._tiles[u].fadeEndTime >= n) return !0
                    }
                    return !1
                }
                setFeatureState(n, u, f) {
                    this._state.updateState(n = n || "_geojsonTileLayer", u, f)
                }
                removeFeatureState(n, u, f) {
                    this._state.removeFeatureState(n = n || "_geojsonTileLayer", u, f)
                }
                getFeatureState(n, u) {
                    return this._state.getState(n = n || "_geojsonTileLayer", u)
                }
                setDependencies(n, u, f) {
                    const _ = this._tiles[n];
                    _ && _.setDependencies(u, f)
                }
                reloadTilesForDependencies(n, u) {
                    for (const f in this._tiles) this._tiles[f].hasDependency(n, u) && this._reloadTile(f, "reloading");
                    this._cache.filter(f => !f.hasDependency(n, u))
                }
            }

            function yi(b, n) {
                const u = Math.abs(2 * b.wrap) - +(b.wrap < 0),
                    f = Math.abs(2 * n.wrap) - +(n.wrap < 0);
                return b.overscaledZ - n.overscaledZ || f - u || n.canonical.y - b.canonical.y || n.canonical.x - b.canonical.x
            }

            function Si(b) {
                return b === "raster" || b === "image" || b === "video"
            }
            cn.maxOverzooming = 10, cn.maxUnderzooming = 3;
            class qi {
                constructor(n, u) {
                    this.reset(n, u)
                }
                reset(n, u) {
                    this.points = n || [], this._distances = [0];
                    for (let f = 1; f < this.points.length; f++) this._distances[f] = this._distances[f - 1] + this.points[f].dist(this.points[f - 1]);
                    this.length = this._distances[this._distances.length - 1], this.padding = Math.min(u || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding
                }
                lerp(n) {
                    if (this.points.length === 1) return this.points[0];
                    n = p.ac(n, 0, 1);
                    let u = 1,
                        f = this._distances[u];
                    const _ = n * this.paddedLength + this.padding;
                    for (; f < _ && u < this._distances.length;) f = this._distances[++u];
                    const S = u - 1,
                        L = this._distances[S],
                        P = f - L,
                        I = P > 0 ? (_ - L) / P : 0;
                    return this.points[S].mult(1 - I).add(this.points[u].mult(I))
                }
            }

            function Nn(b, n) {
                let u = !0;
                return b === "always" || b !== "never" && n !== "never" || (u = !1), u
            }
            class Bn {
                constructor(n, u, f) {
                    const _ = this.boxCells = [],
                        S = this.circleCells = [];
                    this.xCellCount = Math.ceil(n / f), this.yCellCount = Math.ceil(u / f);
                    for (let L = 0; L < this.xCellCount * this.yCellCount; L++) _.push([]), S.push([]);
                    this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = n, this.height = u, this.xScale = this.xCellCount / n, this.yScale = this.yCellCount / u, this.boxUid = 0, this.circleUid = 0
                }
                keysLength() {
                    return this.boxKeys.length + this.circleKeys.length
                }
                insert(n, u, f, _, S) {
                    this._forEachCell(u, f, _, S, this._insertBoxCell, this.boxUid++), this.boxKeys.push(n), this.bboxes.push(u), this.bboxes.push(f), this.bboxes.push(_), this.bboxes.push(S)
                }
                insertCircle(n, u, f, _) {
                    this._forEachCell(u - _, f - _, u + _, f + _, this._insertCircleCell, this.circleUid++), this.circleKeys.push(n), this.circles.push(u), this.circles.push(f), this.circles.push(_)
                }
                _insertBoxCell(n, u, f, _, S, L) {
                    this.boxCells[S].push(L)
                }
                _insertCircleCell(n, u, f, _, S, L) {
                    this.circleCells[S].push(L)
                }
                _query(n, u, f, _, S, L, P) {
                    if (f < 0 || n > this.width || _ < 0 || u > this.height) return [];
                    const I = [];
                    if (n <= 0 && u <= 0 && this.width <= f && this.height <= _) {
                        if (S) return [{
                            key: null,
                            x1: n,
                            y1: u,
                            x2: f,
                            y2: _
                        }];
                        for (let G = 0; G < this.boxKeys.length; G++) I.push({
                            key: this.boxKeys[G],
                            x1: this.bboxes[4 * G],
                            y1: this.bboxes[4 * G + 1],
                            x2: this.bboxes[4 * G + 2],
                            y2: this.bboxes[4 * G + 3]
                        });
                        for (let G = 0; G < this.circleKeys.length; G++) {
                            const j = this.circles[3 * G],
                                ee = this.circles[3 * G + 1],
                                pe = this.circles[3 * G + 2];
                            I.push({
                                key: this.circleKeys[G],
                                x1: j - pe,
                                y1: ee - pe,
                                x2: j + pe,
                                y2: ee + pe
                            })
                        }
                    } else this._forEachCell(n, u, f, _, this._queryCell, I, {
                        hitTest: S,
                        overlapMode: L,
                        seenUids: {
                            box: {},
                            circle: {}
                        }
                    }, P);
                    return I
                }
                query(n, u, f, _) {
                    return this._query(n, u, f, _, !1, null)
                }
                hitTest(n, u, f, _, S, L) {
                    return this._query(n, u, f, _, !0, S, L).length > 0
                }
                hitTestCircle(n, u, f, _, S) {
                    const L = n - f,
                        P = n + f,
                        I = u - f,
                        G = u + f;
                    if (P < 0 || L > this.width || G < 0 || I > this.height) return !1;
                    const j = [];
                    return this._forEachCell(L, I, P, G, this._queryCellCircle, j, {
                        hitTest: !0,
                        overlapMode: _,
                        circle: {
                            x: n,
                            y: u,
                            radius: f
                        },
                        seenUids: {
                            box: {},
                            circle: {}
                        }
                    }, S), j.length > 0
                }
                _queryCell(n, u, f, _, S, L, P, I) {
                    const {
                        seenUids: G,
                        hitTest: j,
                        overlapMode: ee
                    } = P, pe = this.boxCells[S];
                    if (pe !== null) {
                        const Me = this.bboxes;
                        for (const ke of pe)
                            if (!G.box[ke]) {
                                G.box[ke] = !0;
                                const we = 4 * ke,
                                    nt = this.boxKeys[ke];
                                if (n <= Me[we + 2] && u <= Me[we + 3] && f >= Me[we + 0] && _ >= Me[we + 1] && (!I || I(nt)) && (!j || !Nn(ee, nt.overlapMode)) && (L.push({
                                        key: nt,
                                        x1: Me[we],
                                        y1: Me[we + 1],
                                        x2: Me[we + 2],
                                        y2: Me[we + 3]
                                    }), j)) return !0
                            }
                    }
                    const Ce = this.circleCells[S];
                    if (Ce !== null) {
                        const Me = this.circles;
                        for (const ke of Ce)
                            if (!G.circle[ke]) {
                                G.circle[ke] = !0;
                                const we = 3 * ke,
                                    nt = this.circleKeys[ke];
                                if (this._circleAndRectCollide(Me[we], Me[we + 1], Me[we + 2], n, u, f, _) && (!I || I(nt)) && (!j || !Nn(ee, nt.overlapMode))) {
                                    const bt = Me[we],
                                        ze = Me[we + 1],
                                        ut = Me[we + 2];
                                    if (L.push({
                                            key: nt,
                                            x1: bt - ut,
                                            y1: ze - ut,
                                            x2: bt + ut,
                                            y2: ze + ut
                                        }), j) return !0
                                }
                            }
                    }
                    return !1
                }
                _queryCellCircle(n, u, f, _, S, L, P, I) {
                    const {
                        circle: G,
                        seenUids: j,
                        overlapMode: ee
                    } = P, pe = this.boxCells[S];
                    if (pe !== null) {
                        const Me = this.bboxes;
                        for (const ke of pe)
                            if (!j.box[ke]) {
                                j.box[ke] = !0;
                                const we = 4 * ke,
                                    nt = this.boxKeys[ke];
                                if (this._circleAndRectCollide(G.x, G.y, G.radius, Me[we + 0], Me[we + 1], Me[we + 2], Me[we + 3]) && (!I || I(nt)) && !Nn(ee, nt.overlapMode)) return L.push(!0), !0
                            }
                    }
                    const Ce = this.circleCells[S];
                    if (Ce !== null) {
                        const Me = this.circles;
                        for (const ke of Ce)
                            if (!j.circle[ke]) {
                                j.circle[ke] = !0;
                                const we = 3 * ke,
                                    nt = this.circleKeys[ke];
                                if (this._circlesCollide(Me[we], Me[we + 1], Me[we + 2], G.x, G.y, G.radius) && (!I || I(nt)) && !Nn(ee, nt.overlapMode)) return L.push(!0), !0
                            }
                    }
                }
                _forEachCell(n, u, f, _, S, L, P, I) {
                    const G = this._convertToXCellCoord(n),
                        j = this._convertToYCellCoord(u),
                        ee = this._convertToXCellCoord(f),
                        pe = this._convertToYCellCoord(_);
                    for (let Ce = G; Ce <= ee; Ce++)
                        for (let Me = j; Me <= pe; Me++)
                            if (S.call(this, n, u, f, _, this.xCellCount * Me + Ce, L, P, I)) return
                }
                _convertToXCellCoord(n) {
                    return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(n * this.xScale)))
                }
                _convertToYCellCoord(n) {
                    return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(n * this.yScale)))
                }
                _circlesCollide(n, u, f, _, S, L) {
                    const P = _ - n,
                        I = S - u,
                        G = f + L;
                    return G * G > P * P + I * I
                }
                _circleAndRectCollide(n, u, f, _, S, L, P) {
                    const I = (L - _) / 2,
                        G = Math.abs(n - (_ + I));
                    if (G > I + f) return !1;
                    const j = (P - S) / 2,
                        ee = Math.abs(u - (S + j));
                    if (ee > j + f) return !1;
                    if (G <= I || ee <= j) return !0;
                    const pe = G - I,
                        Ce = ee - j;
                    return pe * pe + Ce * Ce <= f * f
                }
            }

            function ge(b, n, u, f, _) {
                const S = p.F();
                return n ? (p.J(S, S, [1 / _, 1 / _, 1]), u || p.ad(S, S, f.angle)) : p.K(S, f.labelPlaneMatrix, b), S
            }

            function ga(b, n, u, f, _) {
                if (n) {
                    const S = p.ae(b);
                    return p.J(S, S, [_, _, 1]), u || p.ad(S, S, -f.angle), S
                }
                return f.glCoordMatrix
            }

            function On(b, n, u) {
                let f;
                u ? (f = [b.x, b.y, u(b.x, b.y), 1], p.af(f, f, n)) : (f = [b.x, b.y, 0, 1], zi(f, f, n));
                const _ = f[3];
                return {
                    point: new p.P(f[0] / _, f[1] / _),
                    signedDistanceFromCamera: _
                }
            }

            function Te(b, n) {
                return .5 + b / n * .5
            }

            function te(b, n) {
                const u = b[0] / b[3],
                    f = b[1] / b[3];
                return u >= -n[0] && u <= n[0] && f >= -n[1] && f <= n[1]
            }

            function he(b, n, u, f, _, S, L, P, I, G) {
                const j = f ? b.textSizeData : b.iconSizeData,
                    ee = p.ag(j, u.transform.zoom),
                    pe = [256 / u.width * 2 + 1, 256 / u.height * 2 + 1],
                    Ce = f ? b.text.dynamicLayoutVertexArray : b.icon.dynamicLayoutVertexArray;
                Ce.clear();
                const Me = b.lineVertexArray,
                    ke = f ? b.text.placedSymbolArray : b.icon.placedSymbolArray,
                    we = u.transform.width / u.transform.height;
                let nt = !1;
                for (let bt = 0; bt < ke.length; bt++) {
                    const ze = ke.get(bt);
                    if (ze.hidden || ze.writingMode === p.ah.vertical && !nt) {
                        It(ze.numGlyphs, Ce);
                        continue
                    }
                    let ut;
                    if (nt = !1, G ? (ut = [ze.anchorX, ze.anchorY, G(ze.anchorX, ze.anchorY), 1], p.af(ut, ut, n)) : (ut = [ze.anchorX, ze.anchorY, 0, 1], zi(ut, ut, n)), !te(ut, pe)) {
                        It(ze.numGlyphs, Ce);
                        continue
                    }
                    const St = Te(u.transform.cameraToCenterDistance, ut[3]),
                        yt = p.ai(j, ee, ze),
                        Vt = L ? yt / St : yt * St,
                        ci = new p.P(ze.anchorX, ze.anchorY),
                        $t = On(ci, _, G).point,
                        gi = {
                            projections: {},
                            offsets: {}
                        },
                        Ri = qe(ze, Vt, !1, P, n, _, S, b.glyphOffsetArray, Me, Ce, $t, ci, gi, we, I, G);
                    nt = Ri.useVertical, (Ri.notEnoughRoom || nt || Ri.needsFlipping && qe(ze, Vt, !0, P, n, _, S, b.glyphOffsetArray, Me, Ce, $t, ci, gi, we, I, G).notEnoughRoom) && It(ze.numGlyphs, Ce)
                }
                f ? b.text.dynamicLayoutVertexBuffer.updateData(Ce) : b.icon.dynamicLayoutVertexBuffer.updateData(Ce)
            }

            function fe(b, n, u, f, _, S, L, P, I, G, j, ee, pe) {
                const Ce = P.glyphStartIndex + P.numGlyphs,
                    Me = P.lineStartIndex,
                    ke = P.lineStartIndex + P.lineLength,
                    we = n.getoffsetX(P.glyphStartIndex),
                    nt = n.getoffsetX(Ce - 1),
                    bt = Jt(b * we, u, f, _, S, L, P.segment, Me, ke, I, G, j, ee, pe);
                if (!bt) return null;
                const ze = Jt(b * nt, u, f, _, S, L, P.segment, Me, ke, I, G, j, ee, pe);
                return ze ? {
                    first: bt,
                    last: ze
                } : null
            }

            function Ae(b, n, u, f) {
                return b === p.ah.horizontal && Math.abs(u.y - n.y) > Math.abs(u.x - n.x) * f ? {
                    useVertical: !0
                } : (b === p.ah.vertical ? n.y < u.y : n.x > u.x) ? {
                    needsFlipping: !0
                } : null
            }

            function qe(b, n, u, f, _, S, L, P, I, G, j, ee, pe, Ce, Me, ke) {
                const we = n / 24,
                    nt = b.lineOffsetX * we,
                    bt = b.lineOffsetY * we;
                let ze;
                if (b.numGlyphs > 1) {
                    const ut = b.glyphStartIndex + b.numGlyphs,
                        St = b.lineStartIndex,
                        yt = b.lineStartIndex + b.lineLength,
                        Vt = fe(we, P, nt, bt, u, j, ee, b, I, S, pe, Me, ke);
                    if (!Vt) return {
                        notEnoughRoom: !0
                    };
                    const ci = On(Vt.first.point, L, ke).point,
                        $t = On(Vt.last.point, L, ke).point;
                    if (f && !u) {
                        const gi = Ae(b.writingMode, ci, $t, Ce);
                        if (gi) return gi
                    }
                    ze = [Vt.first];
                    for (let gi = b.glyphStartIndex + 1; gi < ut - 1; gi++) ze.push(Jt(we * P.getoffsetX(gi), nt, bt, u, j, ee, b.segment, St, yt, I, S, pe, Me, ke));
                    ze.push(Vt.last)
                } else {
                    if (f && !u) {
                        const St = On(ee, _, ke).point,
                            yt = b.lineStartIndex + b.segment + 1,
                            Vt = new p.P(I.getx(yt), I.gety(yt)),
                            ci = On(Vt, _, ke),
                            $t = ci.signedDistanceFromCamera > 0 ? ci.point : et(ee, Vt, St, 1, _, ke),
                            gi = Ae(b.writingMode, St, $t, Ce);
                        if (gi) return gi
                    }
                    const ut = Jt(we * P.getoffsetX(b.glyphStartIndex), nt, bt, u, j, ee, b.segment, b.lineStartIndex, b.lineStartIndex + b.lineLength, I, S, pe, Me, ke);
                    if (!ut) return {
                        notEnoughRoom: !0
                    };
                    ze = [ut]
                }
                for (const ut of ze) p.aj(G, ut.point, ut.angle);
                return {}
            }

            function et(b, n, u, f, _, S) {
                const L = On(b.add(b.sub(n)._unit()), _, S).point,
                    P = u.sub(L);
                return u.add(P._mult(f / P.mag()))
            }

            function it(b, n) {
                const {
                    projectionCache: u,
                    lineVertexArray: f,
                    labelPlaneMatrix: _,
                    tileAnchorPoint: S,
                    distanceFromAnchor: L,
                    getElevation: P,
                    previousVertex: I,
                    direction: G,
                    absOffsetX: j
                } = n;
                if (u.projections[b]) return u.projections[b];
                const ee = new p.P(f.getx(b), f.gety(b)),
                    pe = On(ee, _, P);
                if (pe.signedDistanceFromCamera > 0) return u.projections[b] = pe.point, pe.point;
                const Ce = b - G;
                return et(L === 0 ? S : new p.P(f.getx(Ce), f.gety(Ce)), ee, I, j - L + 1, _, P)
            }

            function We(b, n, u) {
                return b._unit()._perp()._mult(n * u)
            }

            function ft(b, n, u, f, _, S, L, P) {
                const {
                    projectionCache: I,
                    direction: G
                } = P;
                if (I.offsets[b]) return I.offsets[b];
                const j = u.add(n);
                if (b + G < f || b + G >= _) return I.offsets[b] = j, j;
                const ee = it(b + G, P),
                    pe = We(ee.sub(u), L, G),
                    Ce = u.add(pe),
                    Me = ee.add(pe);
                return I.offsets[b] = p.ak(S, j, Ce, Me) || j, I.offsets[b]
            }

            function Jt(b, n, u, f, _, S, L, P, I, G, j, ee, pe, Ce) {
                const Me = f ? b - n : b + n;
                let ke = Me > 0 ? 1 : -1,
                    we = 0;
                f && (ke *= -1, we = Math.PI), ke < 0 && (we += Math.PI);
                let nt, bt, ze = ke > 0 ? P + L : P + L + 1,
                    ut = _,
                    St = _,
                    yt = 0,
                    Vt = 0;
                const ci = Math.abs(Me),
                    $t = [];
                let gi;
                for (; yt + Vt <= ci;) {
                    if (ze += ke, ze < P || ze >= I) return null;
                    yt += Vt, St = ut, bt = nt;
                    const wi = {
                        projectionCache: ee,
                        lineVertexArray: G,
                        labelPlaneMatrix: j,
                        tileAnchorPoint: S,
                        distanceFromAnchor: yt,
                        getElevation: Ce,
                        previousVertex: St,
                        direction: ke,
                        absOffsetX: ci
                    };
                    if (ut = it(ze, wi), u === 0) $t.push(St), gi = ut.sub(St);
                    else {
                        let $i;
                        const Vi = ut.sub(St);
                        $i = Vi.mag() === 0 ? We(it(ze + ke, wi).sub(ut), u, ke) : We(Vi, u, ke), bt || (bt = St.add($i)), nt = ft(ze, $i, ut, P, I, bt, u, wi), $t.push(bt), gi = nt.sub(bt)
                    }
                    Vt = gi.mag()
                }
                const Ri = gi._mult((ci - yt) / Vt)._add(bt || St),
                    Ki = we + Math.atan2(ut.y - St.y, ut.x - St.x);
                return $t.push(Ri), {
                    point: Ri,
                    angle: pe ? Ki : 0,
                    path: $t
                }
            }
            const zt = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);

            function It(b, n) {
                for (let u = 0; u < b; u++) {
                    const f = n.length;
                    n.resize(f + 4), n.float32.set(zt, 3 * f)
                }
            }

            function zi(b, n, u) {
                const f = n[0],
                    _ = n[1];
                return b[0] = u[0] * f + u[4] * _ + u[12], b[1] = u[1] * f + u[5] * _ + u[13], b[3] = u[3] * f + u[7] * _ + u[15], b
            }
            const Zi = 100;
            class dn {
                constructor(n, u = new Bn(n.width + 200, n.height + 200, 25), f = new Bn(n.width + 200, n.height + 200, 25)) {
                    this.transform = n, this.grid = u, this.ignoredGrid = f, this.pitchfactor = Math.cos(n._pitch) * n.cameraToCenterDistance, this.screenRightBoundary = n.width + Zi, this.screenBottomBoundary = n.height + Zi, this.gridRightBoundary = n.width + 200, this.gridBottomBoundary = n.height + 200, this.perspectiveRatioCutoff = .6
                }
                placeCollisionBox(n, u, f, _, S, L) {
                    const P = this.projectAndGetPerspectiveRatio(_, n.anchorPointX, n.anchorPointY, L),
                        I = f * P.perspectiveRatio,
                        G = n.x1 * I + P.point.x,
                        j = n.y1 * I + P.point.y,
                        ee = n.x2 * I + P.point.x,
                        pe = n.y2 * I + P.point.y;
                    return !this.isInsideGrid(G, j, ee, pe) || u !== "always" && this.grid.hitTest(G, j, ee, pe, u, S) || P.perspectiveRatio < this.perspectiveRatioCutoff ? {
                        box: [],
                        offscreen: !1
                    } : {
                        box: [G, j, ee, pe],
                        offscreen: this.isOffscreen(G, j, ee, pe)
                    }
                }
                placeCollisionCircles(n, u, f, _, S, L, P, I, G, j, ee, pe, Ce, Me) {
                    const ke = [],
                        we = new p.P(u.anchorX, u.anchorY),
                        nt = On(we, L, Me),
                        bt = Te(this.transform.cameraToCenterDistance, nt.signedDistanceFromCamera),
                        ze = (j ? S / bt : S * bt) / p.ao,
                        ut = On(we, P, Me).point,
                        St = fe(ze, _, u.lineOffsetX * ze, u.lineOffsetY * ze, !1, ut, we, u, f, P, {
                            projections: {},
                            offsets: {}
                        }, !1, Me);
                    let yt = !1,
                        Vt = !1,
                        ci = !0;
                    if (St) {
                        const $t = .5 * pe * bt + Ce,
                            gi = new p.P(-100, -100),
                            Ri = new p.P(this.screenRightBoundary, this.screenBottomBoundary),
                            Ki = new qi,
                            wi = St.first,
                            $i = St.last;
                        let Vi = [];
                        for (let mn = wi.path.length - 1; mn >= 1; mn--) Vi.push(wi.path[mn]);
                        for (let mn = 1; mn < $i.path.length; mn++) Vi.push($i.path[mn]);
                        const Jn = 2.5 * $t;
                        if (I) {
                            const mn = Vi.map(wn => On(wn, I, Me));
                            Vi = mn.some(wn => wn.signedDistanceFromCamera <= 0) ? [] : mn.map(wn => wn.point)
                        }
                        let xn = [];
                        if (Vi.length > 0) {
                            const mn = Vi[0].clone(),
                                wn = Vi[0].clone();
                            for (let Tr = 1; Tr < Vi.length; Tr++) mn.x = Math.min(mn.x, Vi[Tr].x), mn.y = Math.min(mn.y, Vi[Tr].y), wn.x = Math.max(wn.x, Vi[Tr].x), wn.y = Math.max(wn.y, Vi[Tr].y);
                            xn = mn.x >= gi.x && wn.x <= Ri.x && mn.y >= gi.y && wn.y <= Ri.y ? [Vi] : wn.x < gi.x || mn.x > Ri.x || wn.y < gi.y || mn.y > Ri.y ? [] : p.al([Vi], gi.x, gi.y, Ri.x, Ri.y)
                        }
                        for (const mn of xn) {
                            Ki.reset(mn, .25 * $t);
                            let wn = 0;
                            wn = Ki.length <= .5 * $t ? 1 : Math.ceil(Ki.paddedLength / Jn) + 1;
                            for (let Tr = 0; Tr < wn; Tr++) {
                                const Hn = Tr / Math.max(wn - 1, 1),
                                    sa = Ki.lerp(Hn),
                                    Gr = sa.x + Zi,
                                    hr = sa.y + Zi;
                                ke.push(Gr, hr, $t, 0);
                                const da = Gr - $t,
                                    pa = hr - $t,
                                    Ia = Gr + $t,
                                    Ts = hr + $t;
                                if (ci = ci && this.isOffscreen(da, pa, Ia, Ts), Vt = Vt || this.isInsideGrid(da, pa, Ia, Ts), n !== "always" && this.grid.hitTestCircle(Gr, hr, $t, n, ee) && (yt = !0, !G)) return {
                                    circles: [],
                                    offscreen: !1,
                                    collisionDetected: yt
                                }
                            }
                        }
                    }
                    return {
                        circles: !G && yt || !Vt || bt < this.perspectiveRatioCutoff ? [] : ke,
                        offscreen: ci,
                        collisionDetected: yt
                    }
                }
                queryRenderedSymbols(n) {
                    if (n.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
                    const u = [];
                    let f = 1 / 0,
                        _ = 1 / 0,
                        S = -1 / 0,
                        L = -1 / 0;
                    for (const j of n) {
                        const ee = new p.P(j.x + Zi, j.y + Zi);
                        f = Math.min(f, ee.x), _ = Math.min(_, ee.y), S = Math.max(S, ee.x), L = Math.max(L, ee.y), u.push(ee)
                    }
                    const P = this.grid.query(f, _, S, L).concat(this.ignoredGrid.query(f, _, S, L)),
                        I = {},
                        G = {};
                    for (const j of P) {
                        const ee = j.key;
                        if (I[ee.bucketInstanceId] === void 0 && (I[ee.bucketInstanceId] = {}), I[ee.bucketInstanceId][ee.featureIndex]) continue;
                        const pe = [new p.P(j.x1, j.y1), new p.P(j.x2, j.y1), new p.P(j.x2, j.y2), new p.P(j.x1, j.y2)];
                        p.am(u, pe) && (I[ee.bucketInstanceId][ee.featureIndex] = !0, G[ee.bucketInstanceId] === void 0 && (G[ee.bucketInstanceId] = []), G[ee.bucketInstanceId].push(ee.featureIndex))
                    }
                    return G
                }
                insertCollisionBox(n, u, f, _, S, L) {
                    (f ? this.ignoredGrid : this.grid).insert({
                        bucketInstanceId: _,
                        featureIndex: S,
                        collisionGroupID: L,
                        overlapMode: u
                    }, n[0], n[1], n[2], n[3])
                }
                insertCollisionCircles(n, u, f, _, S, L) {
                    const P = f ? this.ignoredGrid : this.grid,
                        I = {
                            bucketInstanceId: _,
                            featureIndex: S,
                            collisionGroupID: L,
                            overlapMode: u
                        };
                    for (let G = 0; G < n.length; G += 4) P.insertCircle(I, n[G], n[G + 1], n[G + 2])
                }
                projectAndGetPerspectiveRatio(n, u, f, _) {
                    let S;
                    return _ ? (S = [u, f, _(u, f), 1], p.af(S, S, n)) : (S = [u, f, 0, 1], zi(S, S, n)), {
                        point: new p.P((S[0] / S[3] + 1) / 2 * this.transform.width + Zi, (-S[1] / S[3] + 1) / 2 * this.transform.height + Zi),
                        perspectiveRatio: .5 + this.transform.cameraToCenterDistance / S[3] * .5
                    }
                }
                isOffscreen(n, u, f, _) {
                    return f < Zi || n >= this.screenRightBoundary || _ < Zi || u > this.screenBottomBoundary
                }
                isInsideGrid(n, u, f, _) {
                    return f >= 0 && n < this.gridRightBoundary && _ >= 0 && u < this.gridBottomBoundary
                }
                getViewportMatrix() {
                    const n = p.an([]);
                    return p.H(n, n, [-100, -100, 0]), n
                }
            }

            function on(b, n, u) {
                return n * (p.W / (b.tileSize * Math.pow(2, u - b.tileID.overscaledZ)))
            }
            class vn {
                constructor(n, u, f, _) {
                    this.opacity = n ? Math.max(0, Math.min(1, n.opacity + (n.placed ? u : -u))) : _ && f ? 1 : 0, this.placed = f
                }
                isHidden() {
                    return this.opacity === 0 && !this.placed
                }
            }
            class Pn {
                constructor(n, u, f, _, S) {
                    this.text = new vn(n ? n.text : null, u, f, S), this.icon = new vn(n ? n.icon : null, u, _, S)
                }
                isHidden() {
                    return this.text.isHidden() && this.icon.isHidden()
                }
            }
            class Fn {
                constructor(n, u, f) {
                    this.text = n, this.icon = u, this.skipFade = f
                }
            }
            class kn {
                constructor() {
                    this.invProjMatrix = p.F(), this.viewportMatrix = p.F(), this.circles = []
                }
            }
            class hn {
                constructor(n, u, f, _, S) {
                    this.bucketInstanceId = n, this.featureIndex = u, this.sourceLayerIndex = f, this.bucketIndex = _, this.tileID = S
                }
            }
            class Vn {
                constructor(n) {
                    this.crossSourceCollisions = n, this.maxGroupID = 0, this.collisionGroups = {}
                }
                get(n) {
                    if (this.crossSourceCollisions) return {
                        ID: 0,
                        predicate: null
                    };
                    if (!this.collisionGroups[n]) {
                        const u = ++this.maxGroupID;
                        this.collisionGroups[n] = {
                            ID: u,
                            predicate: f => f.collisionGroupID === u
                        }
                    }
                    return this.collisionGroups[n]
                }
            }

            function Gn(b, n, u, f, _) {
                const {
                    horizontalAlign: S,
                    verticalAlign: L
                } = p.at(b);
                return new p.P(-(S - .5) * n + f[0] * _, -(L - .5) * u + f[1] * _)
            }

            function zr(b, n, u, f, _, S) {
                const {
                    x1: L,
                    x2: P,
                    y1: I,
                    y2: G,
                    anchorPointX: j,
                    anchorPointY: ee
                } = b, pe = new p.P(n, u);
                return f && pe._rotate(_ ? S : -S), {
                    x1: L + pe.x,
                    y1: I + pe.y,
                    x2: P + pe.x,
                    y2: G + pe.y,
                    anchorPointX: j,
                    anchorPointY: ee
                }
            }
            class br {
                constructor(n, u, f, _, S) {
                    this.transform = n.clone(), this.terrain = u, this.collisionIndex = new dn(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = f, this.retainedQueryData = {}, this.collisionGroups = new Vn(_), this.collisionCircleArrays = {}, this.prevPlacement = S, S && (S.prevPlacement = void 0), this.placedOrientations = {}
                }
                getBucketParts(n, u, f, _) {
                    const S = f.getBucket(u),
                        L = f.latestFeatureIndex;
                    if (!S || !L || u.id !== S.layerIds[0]) return;
                    const P = f.collisionBoxArray,
                        I = S.layers[0].layout,
                        G = Math.pow(2, this.transform.zoom - f.tileID.overscaledZ),
                        j = f.tileSize / p.W,
                        ee = this.transform.calculatePosMatrix(f.tileID.toUnwrapped()),
                        pe = I.get("text-pitch-alignment") === "map",
                        Ce = I.get("text-rotation-alignment") === "map",
                        Me = on(f, 1, this.transform.zoom),
                        ke = ge(ee, pe, Ce, this.transform, Me);
                    let we = null;
                    if (pe) {
                        const bt = ga(ee, pe, Ce, this.transform, Me);
                        we = p.K([], this.transform.labelPlaneMatrix, bt)
                    }
                    this.retainedQueryData[S.bucketInstanceId] = new hn(S.bucketInstanceId, L, S.sourceLayerIndex, S.index, f.tileID);
                    const nt = {
                        bucket: S,
                        layout: I,
                        posMatrix: ee,
                        textLabelPlaneMatrix: ke,
                        labelToScreenMatrix: we,
                        scale: G,
                        textPixelRatio: j,
                        holdingForFade: f.holdingForFade(),
                        collisionBoxArray: P,
                        partiallyEvaluatedTextSize: p.ag(S.textSizeData, this.transform.zoom),
                        collisionGroup: this.collisionGroups.get(S.sourceID)
                    };
                    if (_)
                        for (const bt of S.sortKeyRanges) {
                            const {
                                sortKey: ze,
                                symbolInstanceStart: ut,
                                symbolInstanceEnd: St
                            } = bt;
                            n.push({
                                sortKey: ze,
                                symbolInstanceStart: ut,
                                symbolInstanceEnd: St,
                                parameters: nt
                            })
                        } else n.push({
                            symbolInstanceStart: 0,
                            symbolInstanceEnd: S.symbolInstances.length,
                            parameters: nt
                        })
                }
                attemptAnchorPlacement(n, u, f, _, S, L, P, I, G, j, ee, pe, Ce, Me, ke, we) {
                    const nt = p.ap[n.textAnchor],
                        bt = [n.textOffset0, n.textOffset1],
                        ze = Gn(nt, f, _, bt, S),
                        ut = this.collisionIndex.placeCollisionBox(zr(u, ze.x, ze.y, L, P, this.transform.angle), ee, I, G, j.predicate, we);
                    if ((!ke || this.collisionIndex.placeCollisionBox(zr(ke, ze.x, ze.y, L, P, this.transform.angle), ee, I, G, j.predicate, we).box.length !== 0) && ut.box.length > 0) {
                        let St;
                        if (this.prevPlacement && this.prevPlacement.variableOffsets[pe.crossTileID] && this.prevPlacement.placements[pe.crossTileID] && this.prevPlacement.placements[pe.crossTileID].text && (St = this.prevPlacement.variableOffsets[pe.crossTileID].anchor), pe.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
                        return this.variableOffsets[pe.crossTileID] = {
                            textOffset: bt,
                            width: f,
                            height: _,
                            anchor: nt,
                            textBoxScale: S,
                            prevAnchor: St
                        }, this.markUsedJustification(Ce, nt, pe, Me), Ce.allowVerticalPlacement && (this.markUsedOrientation(Ce, Me, pe), this.placedOrientations[pe.crossTileID] = Me), {
                            shift: ze,
                            placedGlyphBoxes: ut
                        }
                    }
                }
                placeLayerBucketPart(n, u, f) {
                    const {
                        bucket: _,
                        layout: S,
                        posMatrix: L,
                        textLabelPlaneMatrix: P,
                        labelToScreenMatrix: I,
                        textPixelRatio: G,
                        holdingForFade: j,
                        collisionBoxArray: ee,
                        partiallyEvaluatedTextSize: pe,
                        collisionGroup: Ce
                    } = n.parameters, Me = S.get("text-optional"), ke = S.get("icon-optional"), we = p.aq(S, "text-overlap", "text-allow-overlap"), nt = we === "always", bt = p.aq(S, "icon-overlap", "icon-allow-overlap"), ze = bt === "always", ut = S.get("text-rotation-alignment") === "map", St = S.get("text-pitch-alignment") === "map", yt = S.get("icon-text-fit") !== "none", Vt = S.get("symbol-z-order") === "viewport-y", ci = nt && (ze || !_.hasIconData() || ke), $t = ze && (nt || !_.hasTextData() || Me);
                    !_.collisionArrays && ee && _.deserializeCollisionBoxes(ee);
                    const gi = this.retainedQueryData[_.bucketInstanceId].tileID,
                        Ri = this.terrain ? (wi, $i) => this.terrain.getElevation(gi, wi, $i) : null,
                        Ki = (wi, $i) => {
                            var Vi, Jn;
                            if (u[wi.crossTileID]) return;
                            if (j) return void(this.placements[wi.crossTileID] = new Fn(!1, !1, !1));
                            let xn = !1,
                                mn = !1,
                                wn = !0,
                                Tr = null,
                                Hn = {
                                    box: null,
                                    offscreen: null
                                },
                                sa = {
                                    box: null,
                                    offscreen: null
                                },
                                Gr = null,
                                hr = null,
                                da = null,
                                pa = 0,
                                Ia = 0,
                                Ts = 0;
                            $i.textFeatureIndex ? pa = $i.textFeatureIndex : wi.useRuntimeCollisionCircles && (pa = wi.featureIndex), $i.verticalTextFeatureIndex && (Ia = $i.verticalTextFeatureIndex);
                            const mo = $i.textBox;
                            if (mo) {
                                const Mr = Zn => {
                                        let Zr = p.ah.horizontal;
                                        if (_.allowVerticalPlacement && !Zn && this.prevPlacement) {
                                            const ea = this.prevPlacement.placedOrientations[wi.crossTileID];
                                            ea && (this.placedOrientations[wi.crossTileID] = ea, Zr = ea, this.markUsedOrientation(_, Zr, wi))
                                        }
                                        return Zr
                                    },
                                    pr = (Zn, Zr) => {
                                        if (_.allowVerticalPlacement && wi.numVerticalGlyphVertices > 0 && $i.verticalTextBox) {
                                            for (const ea of _.writingModes)
                                                if (ea === p.ah.vertical ? (Hn = Zr(), sa = Hn) : Hn = Zn(), Hn && Hn.box && Hn.box.length) break
                                        } else Hn = Zn()
                                    },
                                    yr = wi.textAnchorOffsetStartIndex,
                                    Ta = wi.textAnchorOffsetEndIndex;
                                if (Ta === yr) {
                                    const Zn = (Zr, ea) => {
                                        const Dr = this.collisionIndex.placeCollisionBox(Zr, we, G, L, Ce.predicate, Ri);
                                        return Dr && Dr.box && Dr.box.length && (this.markUsedOrientation(_, ea, wi), this.placedOrientations[wi.crossTileID] = ea), Dr
                                    };
                                    pr(() => Zn(mo, p.ah.horizontal), () => {
                                        const Zr = $i.verticalTextBox;
                                        return _.allowVerticalPlacement && wi.numVerticalGlyphVertices > 0 && Zr ? Zn(Zr, p.ah.vertical) : {
                                            box: null,
                                            offscreen: null
                                        }
                                    }), Mr(Hn && Hn.box && Hn.box.length)
                                } else {
                                    let Zn = p.ap[(Jn = (Vi = this.prevPlacement) === null || Vi === void 0 ? void 0 : Vi.variableOffsets[wi.crossTileID]) === null || Jn === void 0 ? void 0 : Jn.anchor];
                                    const Zr = (Dr, Oo, fr) => {
                                        const Xr = Dr.x2 - Dr.x1,
                                            qc = Dr.y2 - Dr.y1,
                                            Hs = wi.textBoxScale,
                                            Ws = yt && bt === "never" ? Oo : null;
                                        let Ka = {
                                                box: [],
                                                offscreen: !1
                                            },
                                            go = we === "never" ? 1 : 2,
                                            za = "never";
                                        Zn && go++;
                                        for (let $c = 0; $c < go; $c++) {
                                            for (let Tl = yr; Tl < Ta; Tl++) {
                                                const xa = _.textAnchorOffsets.get(Tl);
                                                if (Zn && xa.textAnchor !== Zn) continue;
                                                const yo = this.attemptAnchorPlacement(xa, Dr, Xr, qc, Hs, ut, St, G, L, Ce, za, wi, _, fr, Ws, Ri);
                                                if (yo && (Ka = yo.placedGlyphBoxes, Ka && Ka.box && Ka.box.length)) return xn = !0, Tr = yo.shift, Ka
                                            }
                                            Zn ? Zn = null : za = we
                                        }
                                        return Ka
                                    };
                                    pr(() => Zr(mo, $i.iconBox, p.ah.horizontal), () => {
                                        const Dr = $i.verticalTextBox;
                                        return _.allowVerticalPlacement && !(Hn && Hn.box && Hn.box.length) && wi.numVerticalGlyphVertices > 0 && Dr ? Zr(Dr, $i.verticalIconBox, p.ah.vertical) : {
                                            box: null,
                                            offscreen: null
                                        }
                                    }), Hn && (xn = Hn.box, wn = Hn.offscreen);
                                    const ea = Mr(Hn && Hn.box);
                                    if (!xn && this.prevPlacement) {
                                        const Dr = this.prevPlacement.variableOffsets[wi.crossTileID];
                                        Dr && (this.variableOffsets[wi.crossTileID] = Dr, this.markUsedJustification(_, Dr.anchor, wi, ea))
                                    }
                                }
                            }
                            if (Gr = Hn, xn = Gr && Gr.box && Gr.box.length > 0, wn = Gr && Gr.offscreen, wi.useRuntimeCollisionCircles) {
                                const Mr = _.text.placedSymbolArray.get(wi.centerJustifiedTextSymbolIndex),
                                    pr = p.ai(_.textSizeData, pe, Mr),
                                    yr = S.get("text-padding");
                                hr = this.collisionIndex.placeCollisionCircles(we, Mr, _.lineVertexArray, _.glyphOffsetArray, pr, L, P, I, f, St, Ce.predicate, wi.collisionCircleDiameter, yr, Ri), hr.circles.length && hr.collisionDetected && !f && p.w("Collisions detected, but collision boxes are not shown"), xn = nt || hr.circles.length > 0 && !hr.collisionDetected, wn = wn && hr.offscreen
                            }
                            if ($i.iconFeatureIndex && (Ts = $i.iconFeatureIndex), $i.iconBox) {
                                const Mr = pr => {
                                    const yr = yt && Tr ? zr(pr, Tr.x, Tr.y, ut, St, this.transform.angle) : pr;
                                    return this.collisionIndex.placeCollisionBox(yr, bt, G, L, Ce.predicate, Ri)
                                };
                                sa && sa.box && sa.box.length && $i.verticalIconBox ? (da = Mr($i.verticalIconBox), mn = da.box.length > 0) : (da = Mr($i.iconBox), mn = da.box.length > 0), wn = wn && da.offscreen
                            }
                            const No = Me || wi.numHorizontalGlyphVertices === 0 && wi.numVerticalGlyphVertices === 0,
                                Ms = ke || wi.numIconVertices === 0;
                            if (No || Ms ? Ms ? No || (mn = mn && xn) : xn = mn && xn : mn = xn = mn && xn, xn && Gr && Gr.box && this.collisionIndex.insertCollisionBox(Gr.box, we, S.get("text-ignore-placement"), _.bucketInstanceId, sa && sa.box && Ia ? Ia : pa, Ce.ID), mn && da && this.collisionIndex.insertCollisionBox(da.box, bt, S.get("icon-ignore-placement"), _.bucketInstanceId, Ts, Ce.ID), hr && (xn && this.collisionIndex.insertCollisionCircles(hr.circles, we, S.get("text-ignore-placement"), _.bucketInstanceId, pa, Ce.ID), f)) {
                                const Mr = _.bucketInstanceId;
                                let pr = this.collisionCircleArrays[Mr];
                                pr === void 0 && (pr = this.collisionCircleArrays[Mr] = new kn);
                                for (let yr = 0; yr < hr.circles.length; yr += 4) pr.circles.push(hr.circles[yr + 0]), pr.circles.push(hr.circles[yr + 1]), pr.circles.push(hr.circles[yr + 2]), pr.circles.push(hr.collisionDetected ? 1 : 0)
                            }
                            if (wi.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
                            if (_.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
                            this.placements[wi.crossTileID] = new Fn(xn || ci, mn || $t, wn || _.justReloaded), u[wi.crossTileID] = !0
                        };
                    if (Vt) {
                        if (n.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
                        const wi = _.getSortedSymbolIndexes(this.transform.angle);
                        for (let $i = wi.length - 1; $i >= 0; --$i) {
                            const Vi = wi[$i];
                            Ki(_.symbolInstances.get(Vi), _.collisionArrays[Vi])
                        }
                    } else
                        for (let wi = n.symbolInstanceStart; wi < n.symbolInstanceEnd; wi++) Ki(_.symbolInstances.get(wi), _.collisionArrays[wi]);
                    if (f && _.bucketInstanceId in this.collisionCircleArrays) {
                        const wi = this.collisionCircleArrays[_.bucketInstanceId];
                        p.ar(wi.invProjMatrix, L), wi.viewportMatrix = this.collisionIndex.getViewportMatrix()
                    }
                    _.justReloaded = !1
                }
                markUsedJustification(n, u, f, _) {
                    let S;
                    S = _ === p.ah.vertical ? f.verticalPlacedTextSymbolIndex : {
                        left: f.leftJustifiedTextSymbolIndex,
                        center: f.centerJustifiedTextSymbolIndex,
                        right: f.rightJustifiedTextSymbolIndex
                    } [p.as(u)];
                    const L = [f.leftJustifiedTextSymbolIndex, f.centerJustifiedTextSymbolIndex, f.rightJustifiedTextSymbolIndex, f.verticalPlacedTextSymbolIndex];
                    for (const P of L) P >= 0 && (n.text.placedSymbolArray.get(P).crossTileID = S >= 0 && P !== S ? 0 : f.crossTileID)
                }
                markUsedOrientation(n, u, f) {
                    const _ = u === p.ah.horizontal || u === p.ah.horizontalOnly ? u : 0,
                        S = u === p.ah.vertical ? u : 0,
                        L = [f.leftJustifiedTextSymbolIndex, f.centerJustifiedTextSymbolIndex, f.rightJustifiedTextSymbolIndex];
                    for (const P of L) n.text.placedSymbolArray.get(P).placedOrientation = _;
                    f.verticalPlacedTextSymbolIndex && (n.text.placedSymbolArray.get(f.verticalPlacedTextSymbolIndex).placedOrientation = S)
                }
                commit(n) {
                    this.commitTime = n, this.zoomAtLastRecencyCheck = this.transform.zoom;
                    const u = this.prevPlacement;
                    let f = !1;
                    this.prevZoomAdjustment = u ? u.zoomAdjustment(this.transform.zoom) : 0;
                    const _ = u ? u.symbolFadeChange(n) : 1,
                        S = u ? u.opacities : {},
                        L = u ? u.variableOffsets : {},
                        P = u ? u.placedOrientations : {};
                    for (const I in this.placements) {
                        const G = this.placements[I],
                            j = S[I];
                        j ? (this.opacities[I] = new Pn(j, _, G.text, G.icon), f = f || G.text !== j.text.placed || G.icon !== j.icon.placed) : (this.opacities[I] = new Pn(null, _, G.text, G.icon, G.skipFade), f = f || G.text || G.icon)
                    }
                    for (const I in S) {
                        const G = S[I];
                        if (!this.opacities[I]) {
                            const j = new Pn(G, _, !1, !1);
                            j.isHidden() || (this.opacities[I] = j, f = f || G.text.placed || G.icon.placed)
                        }
                    }
                    for (const I in L) this.variableOffsets[I] || !this.opacities[I] || this.opacities[I].isHidden() || (this.variableOffsets[I] = L[I]);
                    for (const I in P) this.placedOrientations[I] || !this.opacities[I] || this.opacities[I].isHidden() || (this.placedOrientations[I] = P[I]);
                    if (u && u.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
                    f ? this.lastPlacementChangeTime = n : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = u ? u.lastPlacementChangeTime : n)
                }
                updateLayerOpacities(n, u) {
                    const f = {};
                    for (const _ of u) {
                        const S = _.getBucket(n);
                        S && _.latestFeatureIndex && n.id === S.layerIds[0] && this.updateBucketOpacities(S, f, _.collisionBoxArray)
                    }
                }
                updateBucketOpacities(n, u, f) {
                    n.hasTextData() && (n.text.opacityVertexArray.clear(), n.text.hasVisibleVertices = !1), n.hasIconData() && (n.icon.opacityVertexArray.clear(), n.icon.hasVisibleVertices = !1), n.hasIconCollisionBoxData() && n.iconCollisionBox.collisionVertexArray.clear(), n.hasTextCollisionBoxData() && n.textCollisionBox.collisionVertexArray.clear();
                    const _ = n.layers[0],
                        S = _.layout,
                        L = new Pn(null, 0, !1, !1, !0),
                        P = S.get("text-allow-overlap"),
                        I = S.get("icon-allow-overlap"),
                        G = _._unevaluatedLayout.hasValue("text-variable-anchor") || _._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
                        j = S.get("text-rotation-alignment") === "map",
                        ee = S.get("text-pitch-alignment") === "map",
                        pe = S.get("icon-text-fit") !== "none",
                        Ce = new Pn(null, 0, P && (I || !n.hasIconData() || S.get("icon-optional")), I && (P || !n.hasTextData() || S.get("text-optional")), !0);
                    !n.collisionArrays && f && (n.hasIconCollisionBoxData() || n.hasTextCollisionBoxData()) && n.deserializeCollisionBoxes(f);
                    const Me = (ke, we, nt) => {
                        for (let bt = 0; bt < we / 4; bt++) ke.opacityVertexArray.emplaceBack(nt);
                        ke.hasVisibleVertices = ke.hasVisibleVertices || nt !== Lr
                    };
                    for (let ke = 0; ke < n.symbolInstances.length; ke++) {
                        const we = n.symbolInstances.get(ke),
                            {
                                numHorizontalGlyphVertices: nt,
                                numVerticalGlyphVertices: bt,
                                crossTileID: ze
                            } = we;
                        let ut = this.opacities[ze];
                        u[ze] ? ut = L : ut || (ut = Ce, this.opacities[ze] = ut), u[ze] = !0;
                        const St = we.numIconVertices > 0,
                            yt = this.placedOrientations[we.crossTileID],
                            Vt = yt === p.ah.vertical,
                            ci = yt === p.ah.horizontal || yt === p.ah.horizontalOnly;
                        if (nt > 0 || bt > 0) {
                            const $t = Fr(ut.text);
                            Me(n.text, nt, Vt ? Lr : $t), Me(n.text, bt, ci ? Lr : $t);
                            const gi = ut.text.isHidden();
                            [we.rightJustifiedTextSymbolIndex, we.centerJustifiedTextSymbolIndex, we.leftJustifiedTextSymbolIndex].forEach(wi => {
                                wi >= 0 && (n.text.placedSymbolArray.get(wi).hidden = gi || Vt ? 1 : 0)
                            }), we.verticalPlacedTextSymbolIndex >= 0 && (n.text.placedSymbolArray.get(we.verticalPlacedTextSymbolIndex).hidden = gi || ci ? 1 : 0);
                            const Ri = this.variableOffsets[we.crossTileID];
                            Ri && this.markUsedJustification(n, Ri.anchor, we, yt);
                            const Ki = this.placedOrientations[we.crossTileID];
                            Ki && (this.markUsedJustification(n, "left", we, Ki), this.markUsedOrientation(n, Ki, we))
                        }
                        if (St) {
                            const $t = Fr(ut.icon),
                                gi = !(pe && we.verticalPlacedIconSymbolIndex && Vt);
                            we.placedIconSymbolIndex >= 0 && (Me(n.icon, we.numIconVertices, gi ? $t : Lr), n.icon.placedSymbolArray.get(we.placedIconSymbolIndex).hidden = ut.icon.isHidden()), we.verticalPlacedIconSymbolIndex >= 0 && (Me(n.icon, we.numVerticalIconVertices, gi ? Lr : $t), n.icon.placedSymbolArray.get(we.verticalPlacedIconSymbolIndex).hidden = ut.icon.isHidden())
                        }
                        if (n.hasIconCollisionBoxData() || n.hasTextCollisionBoxData()) {
                            const $t = n.collisionArrays[ke];
                            if ($t) {
                                let gi = new p.P(0, 0);
                                if ($t.textBox || $t.verticalTextBox) {
                                    let Ki = !0;
                                    if (G) {
                                        const wi = this.variableOffsets[ze];
                                        wi ? (gi = Gn(wi.anchor, wi.width, wi.height, wi.textOffset, wi.textBoxScale), j && gi._rotate(ee ? this.transform.angle : -this.transform.angle)) : Ki = !1
                                    }
                                    $t.textBox && ur(n.textCollisionBox.collisionVertexArray, ut.text.placed, !Ki || Vt, gi.x, gi.y), $t.verticalTextBox && ur(n.textCollisionBox.collisionVertexArray, ut.text.placed, !Ki || ci, gi.x, gi.y)
                                }
                                const Ri = !!(!ci && $t.verticalIconBox);
                                $t.iconBox && ur(n.iconCollisionBox.collisionVertexArray, ut.icon.placed, Ri, pe ? gi.x : 0, pe ? gi.y : 0), $t.verticalIconBox && ur(n.iconCollisionBox.collisionVertexArray, ut.icon.placed, !Ri, pe ? gi.x : 0, pe ? gi.y : 0)
                            }
                        }
                    }
                    if (n.sortFeatures(this.transform.angle), this.retainedQueryData[n.bucketInstanceId] && (this.retainedQueryData[n.bucketInstanceId].featureSortOrder = n.featureSortOrder), n.hasTextData() && n.text.opacityVertexBuffer && n.text.opacityVertexBuffer.updateData(n.text.opacityVertexArray), n.hasIconData() && n.icon.opacityVertexBuffer && n.icon.opacityVertexBuffer.updateData(n.icon.opacityVertexArray), n.hasIconCollisionBoxData() && n.iconCollisionBox.collisionVertexBuffer && n.iconCollisionBox.collisionVertexBuffer.updateData(n.iconCollisionBox.collisionVertexArray), n.hasTextCollisionBoxData() && n.textCollisionBox.collisionVertexBuffer && n.textCollisionBox.collisionVertexBuffer.updateData(n.textCollisionBox.collisionVertexArray), n.text.opacityVertexArray.length !== n.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${n.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${n.text.layoutVertexArray.length}) / 4`);
                    if (n.icon.opacityVertexArray.length !== n.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${n.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${n.icon.layoutVertexArray.length}) / 4`);
                    if (n.bucketInstanceId in this.collisionCircleArrays) {
                        const ke = this.collisionCircleArrays[n.bucketInstanceId];
                        n.placementInvProjMatrix = ke.invProjMatrix, n.placementViewportMatrix = ke.viewportMatrix, n.collisionCircleArray = ke.circles, delete this.collisionCircleArrays[n.bucketInstanceId]
                    }
                }
                symbolFadeChange(n) {
                    return this.fadeDuration === 0 ? 1 : (n - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment
                }
                zoomAdjustment(n) {
                    return Math.max(0, (this.transform.zoom - n) / 1.5)
                }
                hasTransitions(n) {
                    return this.stale || n - this.lastPlacementChangeTime < this.fadeDuration
                }
                stillRecent(n, u) {
                    const f = this.zoomAtLastRecencyCheck === u ? 1 - this.zoomAdjustment(u) : 1;
                    return this.zoomAtLastRecencyCheck = u, this.commitTime + this.fadeDuration * f > n
                }
                setStale() {
                    this.stale = !0
                }
            }

            function ur(b, n, u, f, _) {
                b.emplaceBack(n ? 1 : 0, u ? 1 : 0, f || 0, _ || 0), b.emplaceBack(n ? 1 : 0, u ? 1 : 0, f || 0, _ || 0), b.emplaceBack(n ? 1 : 0, u ? 1 : 0, f || 0, _ || 0), b.emplaceBack(n ? 1 : 0, u ? 1 : 0, f || 0, _ || 0)
            }
            const wr = Math.pow(2, 25),
                Ui = Math.pow(2, 24),
                ya = Math.pow(2, 17),
                _n = Math.pow(2, 16),
                Qs = Math.pow(2, 9),
                Ra = Math.pow(2, 8),
                rr = Math.pow(2, 1);

            function Fr(b) {
                if (b.opacity === 0 && !b.placed) return 0;
                if (b.opacity === 1 && b.placed) return 4294967295;
                const n = b.placed ? 1 : 0,
                    u = Math.floor(127 * b.opacity);
                return u * wr + n * Ui + u * ya + n * _n + u * Qs + n * Ra + u * rr + n
            }
            const Lr = 0;
            class ra {
                constructor(n) {
                    this._sortAcrossTiles = n.layout.get("symbol-z-order") !== "viewport-y" && !n.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = []
                }
                continuePlacement(n, u, f, _, S) {
                    const L = this._bucketParts;
                    for (; this._currentTileIndex < n.length;)
                        if (u.getBucketParts(L, _, n[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, S()) return !0;
                    for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, L.sort((P, I) => P.sortKey - I.sortKey)); this._currentPartIndex < L.length;)
                        if (u.placeLayerBucketPart(L[this._currentPartIndex], this._seenCrossTileIDs, f), this._currentPartIndex++, S()) return !0;
                    return !1
                }
            }
            class $r {
                constructor(n, u, f, _, S, L, P, I) {
                    this.placement = new br(n, u, L, P, I), this._currentPlacementIndex = f.length - 1, this._forceFullPlacement = _, this._showCollisionBoxes = S, this._done = !1
                }
                isDone() {
                    return this._done
                }
                continuePlacement(n, u, f) {
                    const _ = be.now(),
                        S = () => !this._forceFullPlacement && be.now() - _ > 2;
                    for (; this._currentPlacementIndex >= 0;) {
                        const L = u[n[this._currentPlacementIndex]],
                            P = this.placement.collisionIndex.transform.zoom;
                        if (L.type === "symbol" && (!L.minzoom || L.minzoom <= P) && (!L.maxzoom || L.maxzoom > P)) {
                            if (this._inProgressLayer || (this._inProgressLayer = new ra(L)), this._inProgressLayer.continuePlacement(f[L.source], this.placement, this._showCollisionBoxes, L, S)) return;
                            delete this._inProgressLayer
                        }
                        this._currentPlacementIndex--
                    }
                    this._done = !0
                }
                commit(n) {
                    return this.placement.commit(n), this.placement
                }
            }
            const gr = 512 / p.W / 2;
            class Jr {
                constructor(n, u, f) {
                    this.tileID = n, this.bucketInstanceId = f, this._symbolsByKey = {};
                    const _ = new Map;
                    for (let S = 0; S < u.length; S++) {
                        const L = u.get(S),
                            P = L.key,
                            I = _.get(P);
                        I ? I.push(L) : _.set(P, [L])
                    }
                    for (const [S, L] of _) {
                        const P = {
                            positions: L.map(I => ({
                                x: Math.floor(I.anchorX * gr),
                                y: Math.floor(I.anchorY * gr)
                            })),
                            crossTileIDs: L.map(I => I.crossTileID)
                        };
                        if (P.positions.length > 128) {
                            const I = new p.au(P.positions.length, 16, Uint16Array);
                            for (const {
                                    x: G,
                                    y: j
                                }
                                of P.positions) I.add(G, j);
                            I.finish(), delete P.positions, P.index = I
                        }
                        this._symbolsByKey[S] = P
                    }
                }
                getScaledCoordinates(n, u) {
                    const {
                        x: f,
                        y: _,
                        z: S
                    } = this.tileID.canonical, {
                        x: L,
                        y: P,
                        z: I
                    } = u.canonical, G = gr / Math.pow(2, I - S), j = (P * p.W + n.anchorY) * G, ee = _ * p.W * gr;
                    return {
                        x: Math.floor((L * p.W + n.anchorX) * G - f * p.W * gr),
                        y: Math.floor(j - ee)
                    }
                }
                findMatches(n, u, f) {
                    const _ = this.tileID.canonical.z < u.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - u.canonical.z);
                    for (let S = 0; S < n.length; S++) {
                        const L = n.get(S);
                        if (L.crossTileID) continue;
                        const P = this._symbolsByKey[L.key];
                        if (!P) continue;
                        const I = this.getScaledCoordinates(L, u);
                        if (P.index) {
                            const G = P.index.range(I.x - _, I.y - _, I.x + _, I.y + _).sort();
                            for (const j of G) {
                                const ee = P.crossTileIDs[j];
                                if (!f[ee]) {
                                    f[ee] = !0, L.crossTileID = ee;
                                    break
                                }
                            }
                        } else if (P.positions)
                            for (let G = 0; G < P.positions.length; G++) {
                                const j = P.positions[G],
                                    ee = P.crossTileIDs[G];
                                if (Math.abs(j.x - I.x) <= _ && Math.abs(j.y - I.y) <= _ && !f[ee]) {
                                    f[ee] = !0, L.crossTileID = ee;
                                    break
                                }
                            }
                    }
                }
                getCrossTileIDsLists() {
                    return Object.values(this._symbolsByKey).map(({
                        crossTileIDs: n
                    }) => n)
                }
            }
            class or {
                constructor() {
                    this.maxCrossTileID = 0
                }
                generate() {
                    return ++this.maxCrossTileID
                }
            }
            class wa {
                constructor() {
                    this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0
                }
                handleWrapJump(n) {
                    const u = Math.round((n - this.lng) / 360);
                    if (u !== 0)
                        for (const f in this.indexes) {
                            const _ = this.indexes[f],
                                S = {};
                            for (const L in _) {
                                const P = _[L];
                                P.tileID = P.tileID.unwrapTo(P.tileID.wrap + u), S[P.tileID.key] = P
                            }
                            this.indexes[f] = S
                        }
                    this.lng = n
                }
                addBucket(n, u, f) {
                    if (this.indexes[n.overscaledZ] && this.indexes[n.overscaledZ][n.key]) {
                        if (this.indexes[n.overscaledZ][n.key].bucketInstanceId === u.bucketInstanceId) return !1;
                        this.removeBucketCrossTileIDs(n.overscaledZ, this.indexes[n.overscaledZ][n.key])
                    }
                    for (let S = 0; S < u.symbolInstances.length; S++) u.symbolInstances.get(S).crossTileID = 0;
                    this.usedCrossTileIDs[n.overscaledZ] || (this.usedCrossTileIDs[n.overscaledZ] = {});
                    const _ = this.usedCrossTileIDs[n.overscaledZ];
                    for (const S in this.indexes) {
                        const L = this.indexes[S];
                        if (Number(S) > n.overscaledZ)
                            for (const P in L) {
                                const I = L[P];
                                I.tileID.isChildOf(n) && I.findMatches(u.symbolInstances, n, _)
                            } else {
                                const P = L[n.scaledTo(Number(S)).key];
                                P && P.findMatches(u.symbolInstances, n, _)
                            }
                    }
                    for (let S = 0; S < u.symbolInstances.length; S++) {
                        const L = u.symbolInstances.get(S);
                        L.crossTileID || (L.crossTileID = f.generate(), _[L.crossTileID] = !0)
                    }
                    return this.indexes[n.overscaledZ] === void 0 && (this.indexes[n.overscaledZ] = {}), this.indexes[n.overscaledZ][n.key] = new Jr(n, u.symbolInstances, u.bucketInstanceId), !0
                }
                removeBucketCrossTileIDs(n, u) {
                    for (const f of u.getCrossTileIDsLists())
                        for (const _ of f) delete this.usedCrossTileIDs[n][_]
                }
                removeStaleBuckets(n) {
                    let u = !1;
                    for (const f in this.indexes) {
                        const _ = this.indexes[f];
                        for (const S in _) n[_[S].bucketInstanceId] || (this.removeBucketCrossTileIDs(f, _[S]), delete _[S], u = !0)
                    }
                    return u
                }
            }
            class la {
                constructor() {
                    this.layerIndexes = {}, this.crossTileIDs = new or, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {}
                }
                addLayer(n, u, f) {
                    let _ = this.layerIndexes[n.id];
                    _ === void 0 && (_ = this.layerIndexes[n.id] = new wa);
                    let S = !1;
                    const L = {};
                    _.handleWrapJump(f);
                    for (const P of u) {
                        const I = P.getBucket(n);
                        I && n.id === I.layerIds[0] && (I.bucketInstanceId || (I.bucketInstanceId = ++this.maxBucketInstanceId), _.addBucket(P.tileID, I, this.crossTileIDs) && (S = !0), L[I.bucketInstanceId] = !0)
                    }
                    return _.removeStaleBuckets(L) && (S = !0), S
                }
                pruneUnusedLayers(n) {
                    const u = {};
                    n.forEach(f => {
                        u[f] = !0
                    });
                    for (const f in this.layerIndexes) u[f] || delete this.layerIndexes[f]
                }
            }
            const Ln = (b, n) => p.t(b, n && n.filter(u => u.identifier !== "source.canvas")),
                ja = p.av();
            class Nr extends p.E {
                constructor(n, u = {}) {
                    super(), this._rtlTextPluginStateChange = () => {
                        for (const f in this.sourceCaches) {
                            const _ = this.sourceCaches[f].getSource().type;
                            _ !== "vector" && _ !== "geojson" || this.sourceCaches[f].reload()
                        }
                    }, this.map = n, this.dispatcher = new ve(oe(), n._getMapId()), this.dispatcher.registerMessageHandler("getGlyphs", (f, _) => this.getGlyphs(f, _)), this.dispatcher.registerMessageHandler("getImages", (f, _) => this.getImages(f, _)), this.imageManager = new O, this.imageManager.setEventedParent(this), this.glyphManager = new xe(n._requestManager, u.localIdeographFontFamily), this.lineAtlas = new gt(256, 512), this.crossTileSymbolIndex = new la, this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new p.aw, this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", p.ax()), Pt().on("pluginStateChange", this._rtlTextPluginStateChange), this.on("data", f => {
                        if (f.dataType !== "source" || f.sourceDataType !== "metadata") return;
                        const _ = this.sourceCaches[f.sourceId];
                        if (!_) return;
                        const S = _.getSource();
                        if (S && S.vectorLayerIds)
                            for (const L in this._layers) {
                                const P = this._layers[L];
                                P.source === S.id && this._validateLayer(P)
                            }
                    })
                }
                loadURL(n, u = {}, f) {
                    this.fire(new p.k("dataloading", {
                        dataType: "style"
                    })), u.validate = typeof u.validate != "boolean" || u.validate;
                    const _ = this.map._requestManager.transformRequest(n, di.Style);
                    this._loadStyleRequest = new AbortController, p.h(_, this._loadStyleRequest).then(S => {
                        this._loadStyleRequest = null, this._load(S.data, u, f)
                    }).catch(S => {
                        this._loadStyleRequest = null, S && this.fire(new p.j(S))
                    })
                }
                loadJSON(n, u = {}, f) {
                    this.fire(new p.k("dataloading", {
                        dataType: "style"
                    })), this._frameRequest = new AbortController, be.frameAsync(this._frameRequest).then(() => {
                        this._frameRequest = null, u.validate = u.validate !== !1, this._load(n, u, f)
                    }).catch(() => {})
                }
                loadEmpty() {
                    this.fire(new p.k("dataloading", {
                        dataType: "style"
                    })), this._load(ja, {
                        validate: !1
                    })
                }
                _load(n, u, f) {
                    var _;
                    const S = u.transformStyle ? u.transformStyle(f, n) : n;
                    if (!u.validate || !Ln(this, p.x(S))) {
                        this._loaded = !0, this.stylesheet = S;
                        for (const L in S.sources) this.addSource(L, S.sources[L], {
                            validate: !1
                        });
                        S.sprite ? this._loadSprite(S.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(S.glyphs), this._createLayers(), this.light = new De(this.stylesheet.light), this.map.setTerrain((_ = this.stylesheet.terrain) !== null && _ !== void 0 ? _ : null), this.fire(new p.k("data", {
                            dataType: "style"
                        })), this.fire(new p.k("style.load"))
                    }
                }
                _createLayers() {
                    const n = p.ay(this.stylesheet.layers);
                    this.dispatcher.broadcast("setLayers", n), this._order = n.map(u => u.id), this._layers = {}, this._serializedLayers = null;
                    for (const u of n) {
                        const f = p.az(u);
                        f.setEventedParent(this, {
                            layer: {
                                id: u.id
                            }
                        }), this._layers[u.id] = f
                    }
                }
                _loadSprite(n, u = !1, f = void 0) {
                    let _;
                    this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController,
                        function(S, L, P, I) {
                            return p._(this, void 0, void 0, function*() {
                                const G = ct(S),
                                    j = P > 1 ? "@2x" : "",
                                    ee = {},
                                    pe = {};
                                for (const {
                                        id: Ce,
                                        url: Me
                                    }
                                    of G) {
                                    const ke = L.transformRequest(L.normalizeSpriteURL(Me, j, ".json"), di.SpriteJSON);
                                    ee[Ce] = p.h(ke, I);
                                    const we = L.transformRequest(L.normalizeSpriteURL(Me, j, ".png"), di.SpriteImage);
                                    pe[Ce] = jt.getImage(we, I)
                                }
                                return yield Promise.all([...Object.values(ee), ...Object.values(pe)]),
                                    function(Ce, Me) {
                                        return p._(this, void 0, void 0, function*() {
                                            const ke = {};
                                            for (const we in Ce) {
                                                ke[we] = {};
                                                const nt = be.getImageCanvasContext((yield Me[we]).data),
                                                    bt = (yield Ce[we]).data;
                                                for (const ze in bt) {
                                                    const {
                                                        width: ut,
                                                        height: St,
                                                        x: yt,
                                                        y: Vt,
                                                        sdf: ci,
                                                        pixelRatio: $t,
                                                        stretchX: gi,
                                                        stretchY: Ri,
                                                        content: Ki
                                                    } = bt[ze];
                                                    ke[we][ze] = {
                                                        data: null,
                                                        pixelRatio: $t,
                                                        sdf: ci,
                                                        stretchX: gi,
                                                        stretchY: Ri,
                                                        content: Ki,
                                                        spriteData: {
                                                            width: ut,
                                                            height: St,
                                                            x: yt,
                                                            y: Vt,
                                                            context: nt
                                                        }
                                                    }
                                                }
                                            }
                                            return ke
                                        })
                                    }(ee, pe)
                            })
                        }(n, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then(S => {
                            if (this._spriteRequest = null, S)
                                for (const L in S) {
                                    this._spritesImagesIds[L] = [];
                                    const P = this._spritesImagesIds[L] ? this._spritesImagesIds[L].filter(I => !(I in S)) : [];
                                    for (const I of P) this.imageManager.removeImage(I), this._changedImages[I] = !0;
                                    for (const I in S[L]) {
                                        const G = L === "default" ? I : `${L}:${I}`;
                                        this._spritesImagesIds[L].push(G), G in this.imageManager.images ? this.imageManager.updateImage(G, S[L][I], !1) : this.imageManager.addImage(G, S[L][I]), u && (this._changedImages[G] = !0)
                                    }
                                }
                        }).catch(S => {
                            this._spriteRequest = null, _ = S, this.fire(new p.j(_))
                        }).finally(() => {
                            this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), u && (this._changed = !0), this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new p.k("data", {
                                dataType: "style"
                            })), f && f(_)
                        })
                }
                _unloadSprite() {
                    for (const n of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(n), this._changedImages[n] = !0;
                    this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new p.k("data", {
                        dataType: "style"
                    }))
                }
                _validateLayer(n) {
                    const u = this.sourceCaches[n.source];
                    if (!u) return;
                    const f = n.sourceLayer;
                    if (!f) return;
                    const _ = u.getSource();
                    (_.type === "geojson" || _.vectorLayerIds && _.vectorLayerIds.indexOf(f) === -1) && this.fire(new p.j(new Error(`Source layer "${f}" does not exist on source "${_.id}" as specified by style layer "${n.id}".`)))
                }
                loaded() {
                    if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
                    for (const n in this.sourceCaches)
                        if (!this.sourceCaches[n].loaded()) return !1;
                    return !!this.imageManager.isLoaded()
                }
                _serializeByIds(n) {
                    const u = this._serializedAllLayers();
                    if (!n || n.length === 0) return Object.values(u);
                    const f = [];
                    for (const _ of n) u[_] && f.push(u[_]);
                    return f
                }
                _serializedAllLayers() {
                    let n = this._serializedLayers;
                    if (n) return n;
                    n = this._serializedLayers = {};
                    const u = Object.keys(this._layers);
                    for (const f of u) {
                        const _ = this._layers[f];
                        _.type !== "custom" && (n[f] = _.serialize())
                    }
                    return n
                }
                hasTransitions() {
                    if (this.light && this.light.hasTransition()) return !0;
                    for (const n in this.sourceCaches)
                        if (this.sourceCaches[n].hasTransition()) return !0;
                    for (const n in this._layers)
                        if (this._layers[n].hasTransition()) return !0;
                    return !1
                }
                _checkLoaded() {
                    if (!this._loaded) throw new Error("Style is not done loading.")
                }
                update(n) {
                    if (!this._loaded) return;
                    const u = this._changed;
                    if (this._changed) {
                        const _ = Object.keys(this._updatedLayers),
                            S = Object.keys(this._removedLayers);
                        (_.length || S.length) && this._updateWorkerLayers(_, S);
                        for (const L in this._updatedSources) {
                            const P = this._updatedSources[L];
                            if (P === "reload") this._reloadSource(L);
                            else {
                                if (P !== "clear") throw new Error(`Invalid action ${P}`);
                                this._clearSource(L)
                            }
                        }
                        this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
                        for (const L in this._updatedPaintProps) this._layers[L].updateTransitions(n);
                        this.light.updateTransitions(n), this._resetUpdates()
                    }
                    const f = {};
                    for (const _ in this.sourceCaches) {
                        const S = this.sourceCaches[_];
                        f[_] = S.used, S.used = !1
                    }
                    for (const _ of this._order) {
                        const S = this._layers[_];
                        S.recalculate(n, this._availableImages), !S.isHidden(n.zoom) && S.source && (this.sourceCaches[S.source].used = !0)
                    }
                    for (const _ in f) {
                        const S = this.sourceCaches[_];
                        f[_] !== S.used && S.fire(new p.k("data", {
                            sourceDataType: "visibility",
                            dataType: "source",
                            sourceId: _
                        }))
                    }
                    this.light.recalculate(n), this.z = n.zoom, u && this.fire(new p.k("data", {
                        dataType: "style"
                    }))
                }
                _updateTilesForChangedImages() {
                    const n = Object.keys(this._changedImages);
                    if (n.length) {
                        for (const u in this.sourceCaches) this.sourceCaches[u].reloadTilesForDependencies(["icons", "patterns"], n);
                        this._changedImages = {}
                    }
                }
                _updateTilesForChangedGlyphs() {
                    if (this._glyphsDidChange) {
                        for (const n in this.sourceCaches) this.sourceCaches[n].reloadTilesForDependencies(["glyphs"], [""]);
                        this._glyphsDidChange = !1
                    }
                }
                _updateWorkerLayers(n, u) {
                    this.dispatcher.broadcast("updateLayers", {
                        layers: this._serializeByIds(n),
                        removedIds: u
                    })
                }
                _resetUpdates() {
                    this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1
                }
                setState(n, u = {}) {
                    var f;
                    this._checkLoaded();
                    const _ = this.serialize();
                    if (n = u.transformStyle ? u.transformStyle(_, n) : n, ((f = u.validate) === null || f === void 0 || f) && Ln(this, p.x(n))) return !1;
                    (n = p.aA(n)).layers = p.ay(n.layers);
                    const S = p.aB(_, n),
                        L = this._getOperationsToPerform(S);
                    if (L.unimplemented.length > 0) throw new Error(`Unimplemented: ${L.unimplemented.join(", ")}.`);
                    if (L.operations.length === 0) return !1;
                    for (const P of L.operations) P();
                    return this.stylesheet = n, this._serializedLayers = null, !0
                }
                _getOperationsToPerform(n) {
                    const u = [],
                        f = [];
                    for (const _ of n) switch (_.command) {
                        case "setCenter":
                        case "setZoom":
                        case "setBearing":
                        case "setPitch":
                            continue;
                        case "addLayer":
                            u.push(() => this.addLayer.apply(this, _.args));
                            break;
                        case "removeLayer":
                            u.push(() => this.removeLayer.apply(this, _.args));
                            break;
                        case "setPaintProperty":
                            u.push(() => this.setPaintProperty.apply(this, _.args));
                            break;
                        case "setLayoutProperty":
                            u.push(() => this.setLayoutProperty.apply(this, _.args));
                            break;
                        case "setFilter":
                            u.push(() => this.setFilter.apply(this, _.args));
                            break;
                        case "addSource":
                            u.push(() => this.addSource.apply(this, _.args));
                            break;
                        case "removeSource":
                            u.push(() => this.removeSource.apply(this, _.args));
                            break;
                        case "setLayerZoomRange":
                            u.push(() => this.setLayerZoomRange.apply(this, _.args));
                            break;
                        case "setLight":
                            u.push(() => this.setLight.apply(this, _.args));
                            break;
                        case "setGeoJSONSourceData":
                            u.push(() => this.setGeoJSONSourceData.apply(this, _.args));
                            break;
                        case "setGlyphs":
                            u.push(() => this.setGlyphs.apply(this, _.args));
                            break;
                        case "setSprite":
                            u.push(() => this.setSprite.apply(this, _.args));
                            break;
                        case "setTerrain":
                            u.push(() => this.map.setTerrain.apply(this, _.args));
                            break;
                        case "setTransition":
                            u.push(() => {});
                            break;
                        default:
                            f.push(_.command)
                    }
                    return {
                        operations: u,
                        unimplemented: f
                    }
                }
                addImage(n, u) {
                    if (this.getImage(n)) return this.fire(new p.j(new Error(`An image named "${n}" already exists.`)));
                    this.imageManager.addImage(n, u), this._afterImageUpdated(n)
                }
                updateImage(n, u) {
                    this.imageManager.updateImage(n, u)
                }
                getImage(n) {
                    return this.imageManager.getImage(n)
                }
                removeImage(n) {
                    if (!this.getImage(n)) return this.fire(new p.j(new Error(`An image named "${n}" does not exist.`)));
                    this.imageManager.removeImage(n), this._afterImageUpdated(n)
                }
                _afterImageUpdated(n) {
                    this._availableImages = this.imageManager.listImages(), this._changedImages[n] = !0, this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new p.k("data", {
                        dataType: "style"
                    }))
                }
                listImages() {
                    return this._checkLoaded(), this.imageManager.listImages()
                }
                addSource(n, u, f = {}) {
                    if (this._checkLoaded(), this.sourceCaches[n] !== void 0) throw new Error(`Source "${n}" already exists.`);
                    if (!u.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(u).join(", ")}.`);
                    if (["vector", "raster", "geojson", "video", "image"].indexOf(u.type) >= 0 && this._validate(p.x.source, `sources.${n}`, u, null, f)) return;
                    this.map && this.map._collectResourceTiming && (u.collectResourceTiming = !0);
                    const _ = this.sourceCaches[n] = new cn(n, u, this.dispatcher);
                    _.style = this, _.setEventedParent(this, () => ({
                        isSourceLoaded: _.loaded(),
                        source: _.serialize(),
                        sourceId: n
                    })), _.onAdd(this.map), this._changed = !0
                }
                removeSource(n) {
                    if (this._checkLoaded(), this.sourceCaches[n] === void 0) throw new Error("There is no source with this ID");
                    for (const f in this._layers)
                        if (this._layers[f].source === n) return this.fire(new p.j(new Error(`Source "${n}" cannot be removed while layer "${f}" is using it.`)));
                    const u = this.sourceCaches[n];
                    delete this.sourceCaches[n], delete this._updatedSources[n], u.fire(new p.k("data", {
                        sourceDataType: "metadata",
                        dataType: "source",
                        sourceId: n
                    })), u.setEventedParent(null), u.onRemove(this.map), this._changed = !0
                }
                setGeoJSONSourceData(n, u) {
                    if (this._checkLoaded(), this.sourceCaches[n] === void 0) throw new Error(`There is no source with this ID=${n}`);
                    const f = this.sourceCaches[n].getSource();
                    if (f.type !== "geojson") throw new Error(`geojsonSource.type is ${f.type}, which is !== 'geojson`);
                    f.setData(u), this._changed = !0
                }
                getSource(n) {
                    return this.sourceCaches[n] && this.sourceCaches[n].getSource()
                }
                addLayer(n, u, f = {}) {
                    this._checkLoaded();
                    const _ = n.id;
                    if (this.getLayer(_)) return void this.fire(new p.j(new Error(`Layer "${_}" already exists on this map.`)));
                    let S;
                    if (n.type === "custom") {
                        if (Ln(this, p.aC(n))) return;
                        S = p.az(n)
                    } else {
                        if ("source" in n && typeof n.source == "object" && (this.addSource(_, n.source), n = p.aA(n), n = p.e(n, {
                                source: _
                            })), this._validate(p.x.layer, `layers.${_}`, n, {
                                arrayIndex: -1
                            }, f)) return;
                        S = p.az(n), this._validateLayer(S), S.setEventedParent(this, {
                            layer: {
                                id: _
                            }
                        })
                    }
                    const L = u ? this._order.indexOf(u) : this._order.length;
                    if (u && L === -1) this.fire(new p.j(new Error(`Cannot add layer "${_}" before non-existing layer "${u}".`)));
                    else {
                        if (this._order.splice(L, 0, _), this._layerOrderChanged = !0, this._layers[_] = S, this._removedLayers[_] && S.source && S.type !== "custom") {
                            const P = this._removedLayers[_];
                            delete this._removedLayers[_], P.type !== S.type ? this._updatedSources[S.source] = "clear" : (this._updatedSources[S.source] = "reload", this.sourceCaches[S.source].pause())
                        }
                        this._updateLayer(S), S.onAdd && S.onAdd(this.map)
                    }
                }
                moveLayer(n, u) {
                    if (this._checkLoaded(), this._changed = !0, !this._layers[n]) return void this.fire(new p.j(new Error(`The layer '${n}' does not exist in the map's style and cannot be moved.`)));
                    if (n === u) return;
                    const f = this._order.indexOf(n);
                    this._order.splice(f, 1);
                    const _ = u ? this._order.indexOf(u) : this._order.length;
                    u && _ === -1 ? this.fire(new p.j(new Error(`Cannot move layer "${n}" before non-existing layer "${u}".`))) : (this._order.splice(_, 0, n), this._layerOrderChanged = !0)
                }
                removeLayer(n) {
                    this._checkLoaded();
                    const u = this._layers[n];
                    if (!u) return void this.fire(new p.j(new Error(`Cannot remove non-existing layer "${n}".`)));
                    u.setEventedParent(null);
                    const f = this._order.indexOf(n);
                    this._order.splice(f, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[n] = u, delete this._layers[n], this._serializedLayers && delete this._serializedLayers[n], delete this._updatedLayers[n], delete this._updatedPaintProps[n], u.onRemove && u.onRemove(this.map)
                }
                getLayer(n) {
                    return this._layers[n]
                }
                getLayersOrder() {
                    return [...this._order]
                }
                hasLayer(n) {
                    return n in this._layers
                }
                setLayerZoomRange(n, u, f) {
                    this._checkLoaded();
                    const _ = this.getLayer(n);
                    _ ? _.minzoom === u && _.maxzoom === f || (u != null && (_.minzoom = u), f != null && (_.maxzoom = f), this._updateLayer(_)) : this.fire(new p.j(new Error(`Cannot set the zoom range of non-existing layer "${n}".`)))
                }
                setFilter(n, u, f = {}) {
                    this._checkLoaded();
                    const _ = this.getLayer(n);
                    if (_) {
                        if (!p.aD(_.filter, u)) return u == null ? (_.filter = void 0, void this._updateLayer(_)) : void(this._validate(p.x.filter, `layers.${_.id}.filter`, u, null, f) || (_.filter = p.aA(u), this._updateLayer(_)))
                    } else this.fire(new p.j(new Error(`Cannot filter non-existing layer "${n}".`)))
                }
                getFilter(n) {
                    return p.aA(this.getLayer(n).filter)
                }
                setLayoutProperty(n, u, f, _ = {}) {
                    this._checkLoaded();
                    const S = this.getLayer(n);
                    S ? p.aD(S.getLayoutProperty(u), f) || (S.setLayoutProperty(u, f, _), this._updateLayer(S)) : this.fire(new p.j(new Error(`Cannot style non-existing layer "${n}".`)))
                }
                getLayoutProperty(n, u) {
                    const f = this.getLayer(n);
                    if (f) return f.getLayoutProperty(u);
                    this.fire(new p.j(new Error(`Cannot get style of non-existing layer "${n}".`)))
                }
                setPaintProperty(n, u, f, _ = {}) {
                    this._checkLoaded();
                    const S = this.getLayer(n);
                    S ? p.aD(S.getPaintProperty(u), f) || (S.setPaintProperty(u, f, _) && this._updateLayer(S), this._changed = !0, this._updatedPaintProps[n] = !0) : this.fire(new p.j(new Error(`Cannot style non-existing layer "${n}".`)))
                }
                getPaintProperty(n, u) {
                    return this.getLayer(n).getPaintProperty(u)
                }
                setFeatureState(n, u) {
                    this._checkLoaded();
                    const f = n.source,
                        _ = n.sourceLayer,
                        S = this.sourceCaches[f];
                    if (S === void 0) return void this.fire(new p.j(new Error(`The source '${f}' does not exist in the map's style.`)));
                    const L = S.getSource().type;
                    L === "geojson" && _ ? this.fire(new p.j(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : L !== "vector" || _ ? (n.id === void 0 && this.fire(new p.j(new Error("The feature id parameter must be provided."))), S.setFeatureState(_, n.id, u)) : this.fire(new p.j(new Error("The sourceLayer parameter must be provided for vector source types.")))
                }
                removeFeatureState(n, u) {
                    this._checkLoaded();
                    const f = n.source,
                        _ = this.sourceCaches[f];
                    if (_ === void 0) return void this.fire(new p.j(new Error(`The source '${f}' does not exist in the map's style.`)));
                    const S = _.getSource().type,
                        L = S === "vector" ? n.sourceLayer : void 0;
                    S !== "vector" || L ? u && typeof n.id != "string" && typeof n.id != "number" ? this.fire(new p.j(new Error("A feature id is required to remove its specific state property."))) : _.removeFeatureState(L, n.id, u) : this.fire(new p.j(new Error("The sourceLayer parameter must be provided for vector source types.")))
                }
                getFeatureState(n) {
                    this._checkLoaded();
                    const u = n.source,
                        f = n.sourceLayer,
                        _ = this.sourceCaches[u];
                    if (_ !== void 0) return _.getSource().type !== "vector" || f ? (n.id === void 0 && this.fire(new p.j(new Error("The feature id parameter must be provided."))), _.getFeatureState(f, n.id)) : void this.fire(new p.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
                    this.fire(new p.j(new Error(`The source '${u}' does not exist in the map's style.`)))
                }
                getTransition() {
                    return p.e({
                        duration: 300,
                        delay: 0
                    }, this.stylesheet && this.stylesheet.transition)
                }
                serialize() {
                    if (!this._loaded) return;
                    const n = p.aE(this.sourceCaches, S => S.serialize()),
                        u = this._serializeByIds(this._order),
                        f = this.map.getTerrain() || void 0,
                        _ = this.stylesheet;
                    return p.aF({
                        version: _.version,
                        name: _.name,
                        metadata: _.metadata,
                        light: _.light,
                        center: _.center,
                        zoom: _.zoom,
                        bearing: _.bearing,
                        pitch: _.pitch,
                        sprite: _.sprite,
                        glyphs: _.glyphs,
                        transition: _.transition,
                        sources: n,
                        layers: u,
                        terrain: f
                    }, S => S !== void 0)
                }
                _updateLayer(n) {
                    this._updatedLayers[n.id] = !0, n.source && !this._updatedSources[n.source] && this.sourceCaches[n.source].getSource().type !== "raster" && (this._updatedSources[n.source] = "reload", this.sourceCaches[n.source].pause()), this._serializedLayers = null, this._changed = !0
                }
                _flattenAndSortRenderedFeatures(n) {
                    const u = L => this._layers[L].type === "fill-extrusion",
                        f = {},
                        _ = [];
                    for (let L = this._order.length - 1; L >= 0; L--) {
                        const P = this._order[L];
                        if (u(P)) {
                            f[P] = L;
                            for (const I of n) {
                                const G = I[P];
                                if (G)
                                    for (const j of G) _.push(j)
                            }
                        }
                    }
                    _.sort((L, P) => P.intersectionZ - L.intersectionZ);
                    const S = [];
                    for (let L = this._order.length - 1; L >= 0; L--) {
                        const P = this._order[L];
                        if (u(P))
                            for (let I = _.length - 1; I >= 0; I--) {
                                const G = _[I].feature;
                                if (f[G.layer.id] < L) break;
                                S.push(G), _.pop()
                            } else
                                for (const I of n) {
                                    const G = I[P];
                                    if (G)
                                        for (const j of G) S.push(j.feature)
                                }
                    }
                    return S
                }
                queryRenderedFeatures(n, u, f) {
                    u && u.filter && this._validate(p.x.filter, "queryRenderedFeatures.filter", u.filter, null, u);
                    const _ = {};
                    if (u && u.layers) {
                        if (!Array.isArray(u.layers)) return this.fire(new p.j(new Error("parameters.layers must be an Array."))), [];
                        for (const P of u.layers) {
                            const I = this._layers[P];
                            if (!I) return this.fire(new p.j(new Error(`The layer '${P}' does not exist in the map's style and cannot be queried for features.`))), [];
                            _[I.source] = !0
                        }
                    }
                    const S = [];
                    u.availableImages = this._availableImages;
                    const L = this._serializedAllLayers();
                    for (const P in this.sourceCaches) u.layers && !_[P] || S.push(Oe(this.sourceCaches[P], this._layers, L, n, u, f));
                    return this.placement && S.push(function(P, I, G, j, ee, pe, Ce) {
                        const Me = {},
                            ke = pe.queryRenderedSymbols(j),
                            we = [];
                        for (const nt of Object.keys(ke).map(Number)) we.push(Ce[nt]);
                        we.sort(at);
                        for (const nt of we) {
                            const bt = nt.featureIndex.lookupSymbolFeatures(ke[nt.bucketInstanceId], I, nt.bucketIndex, nt.sourceLayerIndex, ee.filter, ee.layers, ee.availableImages, P);
                            for (const ze in bt) {
                                const ut = Me[ze] = Me[ze] || [],
                                    St = bt[ze];
                                St.sort((yt, Vt) => {
                                    const ci = nt.featureSortOrder;
                                    if (ci) {
                                        const $t = ci.indexOf(yt.featureIndex);
                                        return ci.indexOf(Vt.featureIndex) - $t
                                    }
                                    return Vt.featureIndex - yt.featureIndex
                                });
                                for (const yt of St) ut.push(yt)
                            }
                        }
                        for (const nt in Me) Me[nt].forEach(bt => {
                            const ze = bt.feature,
                                ut = G[P[nt].source].getFeatureState(ze.layer["source-layer"], ze.id);
                            ze.source = ze.layer.source, ze.layer["source-layer"] && (ze.sourceLayer = ze.layer["source-layer"]), ze.state = ut
                        });
                        return Me
                    }(this._layers, L, this.sourceCaches, n, u, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(S)
                }
                querySourceFeatures(n, u) {
                    u && u.filter && this._validate(p.x.filter, "querySourceFeatures.filter", u.filter, null, u);
                    const f = this.sourceCaches[n];
                    return f ? function(_, S) {
                        const L = _.getRenderableIds().map(G => _.getTileByID(G)),
                            P = [],
                            I = {};
                        for (let G = 0; G < L.length; G++) {
                            const j = L[G],
                                ee = j.tileID.canonical.key;
                            I[ee] || (I[ee] = !0, j.querySourceFeatures(P, S))
                        }
                        return P
                    }(f, u) : []
                }
                getLight() {
                    return this.light.getLight()
                }
                setLight(n, u = {}) {
                    this._checkLoaded();
                    const f = this.light.getLight();
                    let _ = !1;
                    for (const L in n)
                        if (!p.aD(n[L], f[L])) {
                            _ = !0;
                            break
                        } if (!_) return;
                    const S = {
                        now: be.now(),
                        transition: p.e({
                            duration: 300,
                            delay: 0
                        }, this.stylesheet.transition)
                    };
                    this.light.setLight(n, u), this.light.updateTransitions(S)
                }
                _validate(n, u, f, _, S = {}) {
                    return (!S || S.validate !== !1) && Ln(this, n.call(p.x, p.e({
                        key: u,
                        style: this.serialize(),
                        value: f,
                        styleSpec: p.v
                    }, _)))
                }
                _remove(n = !0) {
                    this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), Pt().off("pluginStateChange", this._rtlTextPluginStateChange);
                    for (const u in this._layers) this._layers[u].setEventedParent(null);
                    for (const u in this.sourceCaches) {
                        const f = this.sourceCaches[u];
                        f.setEventedParent(null), f.onRemove(this.map)
                    }
                    this.imageManager.setEventedParent(null), this.setEventedParent(null), n && this.dispatcher.broadcast("removeMap", void 0), this.dispatcher.remove(n)
                }
                _clearSource(n) {
                    this.sourceCaches[n].clearTiles()
                }
                _reloadSource(n) {
                    this.sourceCaches[n].resume(), this.sourceCaches[n].reload()
                }
                _updateSources(n) {
                    for (const u in this.sourceCaches) this.sourceCaches[u].update(n, this.map.terrain)
                }
                _generateCollisionBoxes() {
                    for (const n in this.sourceCaches) this._reloadSource(n)
                }
                _updatePlacement(n, u, f, _, S = !1) {
                    let L = !1,
                        P = !1;
                    const I = {};
                    for (const G of this._order) {
                        const j = this._layers[G];
                        if (j.type !== "symbol") continue;
                        if (!I[j.source]) {
                            const pe = this.sourceCaches[j.source];
                            I[j.source] = pe.getRenderableIds(!0).map(Ce => pe.getTileByID(Ce)).sort((Ce, Me) => Me.tileID.overscaledZ - Ce.tileID.overscaledZ || (Ce.tileID.isLessThan(Me.tileID) ? -1 : 1))
                        }
                        const ee = this.crossTileSymbolIndex.addLayer(j, I[j.source], n.center.lng);
                        L = L || ee
                    }
                    if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((S = S || this._layerOrderChanged || f === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(be.now(), n.zoom)) && (this.pauseablePlacement = new $r(n, this.map.terrain, this._order, S, u, f, _, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, I), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(be.now()), P = !0), L && this.pauseablePlacement.placement.setStale()), P || L)
                        for (const G of this._order) {
                            const j = this._layers[G];
                            j.type === "symbol" && this.placement.updateLayerOpacities(j, I[j.source])
                        }
                    return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(be.now())
                }
                _releaseSymbolFadeTiles() {
                    for (const n in this.sourceCaches) this.sourceCaches[n].releaseSymbolFadeTiles()
                }
                getImages(n, u) {
                    return p._(this, void 0, void 0, function*() {
                        const f = yield this.imageManager.getImages(u.icons);
                        this._updateTilesForChangedImages();
                        const _ = this.sourceCaches[u.source];
                        return _ && _.setDependencies(u.tileID.key, u.type, u.icons), f
                    })
                }
                getGlyphs(n, u) {
                    return p._(this, void 0, void 0, function*() {
                        const f = yield this.glyphManager.getGlyphs(u.stacks), _ = this.sourceCaches[u.source];
                        return _ && _.setDependencies(u.tileID.key, u.type, [""]), f
                    })
                }
                getGlyphsUrl() {
                    return this.stylesheet.glyphs || null
                }
                setGlyphs(n, u = {}) {
                    this._checkLoaded(), n && this._validate(p.x.glyphs, "glyphs", n, null, u) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = n, this.glyphManager.entries = {}, this.glyphManager.setURL(n))
                }
                addSprite(n, u, f = {}, _) {
                    this._checkLoaded();
                    const S = [{
                            id: n,
                            url: u
                        }],
                        L = [...ct(this.stylesheet.sprite), ...S];
                    this._validate(p.x.sprite, "sprite", L, null, f) || (this.stylesheet.sprite = L, this._loadSprite(S, !0, _))
                }
                removeSprite(n) {
                    this._checkLoaded();
                    const u = ct(this.stylesheet.sprite);
                    if (u.find(f => f.id === n)) {
                        if (this._spritesImagesIds[n])
                            for (const f of this._spritesImagesIds[n]) this.imageManager.removeImage(f), this._changedImages[f] = !0;
                        u.splice(u.findIndex(f => f.id === n), 1), this.stylesheet.sprite = u.length > 0 ? u : void 0, delete this._spritesImagesIds[n], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new p.k("data", {
                            dataType: "style"
                        }))
                    } else this.fire(new p.j(new Error(`Sprite "${n}" doesn't exists on this map.`)))
                }
                getSprite() {
                    return ct(this.stylesheet.sprite)
                }
                setSprite(n, u = {}, f) {
                    this._checkLoaded(), n && this._validate(p.x.sprite, "sprite", n, null, u) || (this.stylesheet.sprite = n, n ? this._loadSprite(n, !0, f) : (this._unloadSprite(), f && f(null)))
                }
            }
            var Ps = p.X([{
                    name: "a_pos",
                    type: "Int16",
                    components: 2
                }]),
                va = "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;varying float v_depth;void main() {float extent=8192.0;float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/extent;gl_Position=u_matrix*vec4(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta,1.0);v_depth=gl_Position.z/gl_Position.w;}";
            const $n = {
                prelude: Qn(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}`),
                background: Qn(`uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),
                backgroundPattern: Qn(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),
                circle: Qn(`varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`),
                clippingMask: Qn("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),
                heatmap: Qn(`uniform highp float u_intensity;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}`),
                heatmapTexture: Qn(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),
                collisionBox: Qn("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,get_elevation(a_pos),1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
                collisionCircle: Qn("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
                debug: Qn("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"),
                fill: Qn(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_FragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);}`),
                fillOutline: Qn(`varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`),
                fillOutlinePattern: Qn(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`),
                fillPattern: Qn(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`),
                fillExtrusion: Qn(`varying vec4 v_color;void main() {gl_FragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`),
                fillExtrusionPattern: Qn(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`),
                hillshadePrepare: Qn(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
                hillshade: Qn(`uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"),
                line: Qn(`uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
                lineGradient: Qn(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
                linePattern: Qn(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`),
                lineSDF: Qn(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`),
                raster: Qn(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"),
                symbolIcon: Qn(`uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),z,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`),
                symbolSDF: Qn(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`),
                symbolTextAndIcon: Qn(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`),
                terrain: Qn("uniform sampler2D u_texture;varying vec2 v_texture_pos;void main() {gl_FragColor=texture2D(u_texture,v_texture_pos);}", va),
                terrainDepth: Qn("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", va),
                terrainCoords: Qn("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", va)
            };

            function Qn(b, n) {
                const u = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,
                    f = n.match(/attribute ([\w]+) ([\w]+)/g),
                    _ = b.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
                    S = n.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
                    L = S ? S.concat(_) : _,
                    P = {};
                return {
                    fragmentSource: b = b.replace(u, (I, G, j, ee, pe) => (P[pe] = !0, G === "define" ? `
#ifndef HAS_UNIFORM_u_${pe}
varying ${j} ${ee} ${pe};
#else
uniform ${j} ${ee} u_${pe};
#endif
` : `
#ifdef HAS_UNIFORM_u_${pe}
    ${j} ${ee} ${pe} = u_${pe};
#endif
`)),
                    vertexSource: n = n.replace(u, (I, G, j, ee, pe) => {
                        const Ce = ee === "float" ? "vec2" : "vec4",
                            Me = pe.match(/color/) ? "color" : Ce;
                        return P[pe] ? G === "define" ? `
#ifndef HAS_UNIFORM_u_${pe}
uniform lowp float u_${pe}_t;
attribute ${j} ${Ce} a_${pe};
varying ${j} ${ee} ${pe};
#else
uniform ${j} ${ee} u_${pe};
#endif
` : Me === "vec4" ? `
#ifndef HAS_UNIFORM_u_${pe}
    ${pe} = a_${pe};
#else
    ${j} ${ee} ${pe} = u_${pe};
#endif
` : `
#ifndef HAS_UNIFORM_u_${pe}
    ${pe} = unpack_mix_${Me}(a_${pe}, u_${pe}_t);
#else
    ${j} ${ee} ${pe} = u_${pe};
#endif
` : G === "define" ? `
#ifndef HAS_UNIFORM_u_${pe}
uniform lowp float u_${pe}_t;
attribute ${j} ${Ce} a_${pe};
#else
uniform ${j} ${ee} u_${pe};
#endif
` : Me === "vec4" ? `
#ifndef HAS_UNIFORM_u_${pe}
    ${j} ${ee} ${pe} = a_${pe};
#else
    ${j} ${ee} ${pe} = u_${pe};
#endif
` : `
#ifndef HAS_UNIFORM_u_${pe}
    ${j} ${ee} ${pe} = unpack_mix_${Me}(a_${pe}, u_${pe}_t);
#else
    ${j} ${ee} ${pe} = u_${pe};
#endif
`
                    }),
                    staticAttributes: f,
                    staticUniforms: L
                }
            }
            class os {
                constructor() {
                    this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null
                }
                bind(n, u, f, _, S, L, P, I, G) {
                    this.context = n;
                    let j = this.boundPaintVertexBuffers.length !== _.length;
                    for (let ee = 0; !j && ee < _.length; ee++) this.boundPaintVertexBuffers[ee] !== _[ee] && (j = !0);
                    !this.vao || this.boundProgram !== u || this.boundLayoutVertexBuffer !== f || j || this.boundIndexBuffer !== S || this.boundVertexOffset !== L || this.boundDynamicVertexBuffer !== P || this.boundDynamicVertexBuffer2 !== I || this.boundDynamicVertexBuffer3 !== G ? this.freshBind(u, f, _, S, L, P, I, G) : (n.bindVertexArray.set(this.vao), P && P.bind(), S && S.dynamicDraw && S.bind(), I && I.bind(), G && G.bind())
                }
                freshBind(n, u, f, _, S, L, P, I) {
                    const G = n.numAttributes,
                        j = this.context,
                        ee = j.gl;
                    this.vao && this.destroy(), this.vao = j.createVertexArray(), j.bindVertexArray.set(this.vao), this.boundProgram = n, this.boundLayoutVertexBuffer = u, this.boundPaintVertexBuffers = f, this.boundIndexBuffer = _, this.boundVertexOffset = S, this.boundDynamicVertexBuffer = L, this.boundDynamicVertexBuffer2 = P, this.boundDynamicVertexBuffer3 = I, u.enableAttributes(ee, n);
                    for (const pe of f) pe.enableAttributes(ee, n);
                    L && L.enableAttributes(ee, n), P && P.enableAttributes(ee, n), I && I.enableAttributes(ee, n), u.bind(), u.setVertexAttribPointers(ee, n, S);
                    for (const pe of f) pe.bind(), pe.setVertexAttribPointers(ee, n, S);
                    L && (L.bind(), L.setVertexAttribPointers(ee, n, S)), _ && _.bind(), P && (P.bind(), P.setVertexAttribPointers(ee, n, S)), I && (I.bind(), I.setVertexAttribPointers(ee, n, S)), j.currentNumAttributes = G
                }
                destroy() {
                    this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null)
                }
            }

            function Va(b) {
                const n = [];
                for (let u = 0; u < b.length; u++) {
                    if (b[u] === null) continue;
                    const f = b[u].split(" ");
                    n.push(f.pop())
                }
                return n
            }
            class Da {
                constructor(n, u, f, _, S, L) {
                    const P = n.gl;
                    this.program = P.createProgram();
                    const I = Va(u.staticAttributes),
                        G = f ? f.getBinderAttributes() : [],
                        j = I.concat(G),
                        ee = $n.prelude.staticUniforms ? Va($n.prelude.staticUniforms) : [],
                        pe = u.staticUniforms ? Va(u.staticUniforms) : [],
                        Ce = f ? f.getBinderUniforms() : [],
                        Me = ee.concat(pe).concat(Ce),
                        ke = [];
                    for (const yt of Me) ke.indexOf(yt) < 0 && ke.push(yt);
                    const we = f ? f.defines() : [];
                    S && we.push("#define OVERDRAW_INSPECTOR;"), L && we.push("#define TERRAIN3D;");
                    const nt = we.concat($n.prelude.fragmentSource, u.fragmentSource).join(`
`),
                        bt = we.concat($n.prelude.vertexSource, u.vertexSource).join(`
`),
                        ze = P.createShader(P.FRAGMENT_SHADER);
                    if (P.isContextLost()) return void(this.failedToCreate = !0);
                    if (P.shaderSource(ze, nt), P.compileShader(ze), !P.getShaderParameter(ze, P.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${P.getShaderInfoLog(ze)}`);
                    P.attachShader(this.program, ze);
                    const ut = P.createShader(P.VERTEX_SHADER);
                    if (P.isContextLost()) return void(this.failedToCreate = !0);
                    if (P.shaderSource(ut, bt), P.compileShader(ut), !P.getShaderParameter(ut, P.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${P.getShaderInfoLog(ut)}`);
                    P.attachShader(this.program, ut), this.attributes = {};
                    const St = {};
                    this.numAttributes = j.length;
                    for (let yt = 0; yt < this.numAttributes; yt++) j[yt] && (P.bindAttribLocation(this.program, yt, j[yt]), this.attributes[j[yt]] = yt);
                    if (P.linkProgram(this.program), !P.getProgramParameter(this.program, P.LINK_STATUS)) throw new Error(`Program failed to link: ${P.getProgramInfoLog(this.program)}`);
                    P.deleteShader(ut), P.deleteShader(ze);
                    for (let yt = 0; yt < ke.length; yt++) {
                        const Vt = ke[yt];
                        if (Vt && !St[Vt]) {
                            const ci = P.getUniformLocation(this.program, Vt);
                            ci && (St[Vt] = ci)
                        }
                    }
                    this.fixedUniforms = _(n, St), this.terrainUniforms = ((yt, Vt) => ({
                        u_depth: new p.aG(yt, Vt.u_depth),
                        u_terrain: new p.aG(yt, Vt.u_terrain),
                        u_terrain_dim: new p.aH(yt, Vt.u_terrain_dim),
                        u_terrain_matrix: new p.aI(yt, Vt.u_terrain_matrix),
                        u_terrain_unpack: new p.aJ(yt, Vt.u_terrain_unpack),
                        u_terrain_exaggeration: new p.aH(yt, Vt.u_terrain_exaggeration)
                    }))(n, St), this.binderUniforms = f ? f.getUniforms(n, St) : []
                }
                draw(n, u, f, _, S, L, P, I, G, j, ee, pe, Ce, Me, ke, we, nt, bt) {
                    const ze = n.gl;
                    if (this.failedToCreate) return;
                    if (n.program.set(this.program), n.setDepthMode(f), n.setStencilMode(_), n.setColorMode(S), n.setCullFace(L), I) {
                        n.activeTexture.set(ze.TEXTURE2), ze.bindTexture(ze.TEXTURE_2D, I.depthTexture), n.activeTexture.set(ze.TEXTURE3), ze.bindTexture(ze.TEXTURE_2D, I.texture);
                        for (const St in this.terrainUniforms) this.terrainUniforms[St].set(I[St])
                    }
                    for (const St in this.fixedUniforms) this.fixedUniforms[St].set(P[St]);
                    ke && ke.setUniforms(n, this.binderUniforms, Ce, {
                        zoom: Me
                    });
                    let ut = 0;
                    switch (u) {
                        case ze.LINES:
                            ut = 2;
                            break;
                        case ze.TRIANGLES:
                            ut = 3;
                            break;
                        case ze.LINE_STRIP:
                            ut = 1
                    }
                    for (const St of pe.get()) {
                        const yt = St.vaos || (St.vaos = {});
                        (yt[G] || (yt[G] = new os)).bind(n, this, j, ke ? ke.getPaintVertexBuffers() : [], ee, St.vertexOffset, we, nt, bt), ze.drawElements(u, St.primitiveLength * ut, ze.UNSIGNED_SHORT, St.primitiveOffset * ut * 2)
                    }
                }
            }

            function Z(b, n, u) {
                const f = 1 / on(u, 1, n.transform.tileZoom),
                    _ = Math.pow(2, u.tileID.overscaledZ),
                    S = u.tileSize * Math.pow(2, n.transform.tileZoom) / _,
                    L = S * (u.tileID.canonical.x + u.tileID.wrap * _),
                    P = S * u.tileID.canonical.y;
                return {
                    u_image: 0,
                    u_texsize: u.imageAtlasTexture.size,
                    u_scale: [f, b.fromScale, b.toScale],
                    u_fade: b.t,
                    u_pixel_coord_upper: [L >> 16, P >> 16],
                    u_pixel_coord_lower: [65535 & L, 65535 & P]
                }
            }
            const q = (b, n, u, f) => {
                    const _ = n.style.light,
                        S = _.properties.get("position"),
                        L = [S.x, S.y, S.z],
                        P = function() {
                            var G = new p.A(9);
                            return p.A != Float32Array && (G[1] = 0, G[2] = 0, G[3] = 0, G[5] = 0, G[6] = 0, G[7] = 0), G[0] = 1, G[4] = 1, G[8] = 1, G
                        }();
                    _.properties.get("anchor") === "viewport" && function(G, j) {
                            var ee = Math.sin(j),
                                pe = Math.cos(j);
                            G[0] = pe, G[1] = ee, G[2] = 0, G[3] = -ee, G[4] = pe, G[5] = 0, G[6] = 0, G[7] = 0, G[8] = 1
                        }(P, -n.transform.angle),
                        function(G, j, ee) {
                            var pe = j[0],
                                Ce = j[1],
                                Me = j[2];
                            G[0] = pe * ee[0] + Ce * ee[3] + Me * ee[6], G[1] = pe * ee[1] + Ce * ee[4] + Me * ee[7], G[2] = pe * ee[2] + Ce * ee[5] + Me * ee[8]
                        }(L, L, P);
                    const I = _.properties.get("color");
                    return {
                        u_matrix: b,
                        u_lightpos: L,
                        u_lightintensity: _.properties.get("intensity"),
                        u_lightcolor: [I.r, I.g, I.b],
                        u_vertical_gradient: +u,
                        u_opacity: f
                    }
                },
                de = (b, n, u, f, _, S, L) => p.e(q(b, n, u, f), Z(S, n, L), {
                    u_height_factor: -Math.pow(2, _.overscaledZ) / L.tileSize / 8
                }),
                Pe = b => ({
                    u_matrix: b
                }),
                Et = (b, n, u, f) => p.e(Pe(b), Z(u, n, f)),
                Ft = (b, n) => ({
                    u_matrix: b,
                    u_world: n
                }),
                _t = (b, n, u, f, _) => p.e(Et(b, n, u, f), {
                    u_world: _
                }),
                Yt = (b, n, u, f) => {
                    const _ = b.transform;
                    let S, L;
                    if (f.paint.get("circle-pitch-alignment") === "map") {
                        const P = on(u, 1, _.zoom);
                        S = !0, L = [P, P]
                    } else S = !1, L = _.pixelsToGLUnits;
                    return {
                        u_camera_to_center_distance: _.cameraToCenterDistance,
                        u_scale_with_map: +(f.paint.get("circle-pitch-scale") === "map"),
                        u_matrix: b.translatePosMatrix(n.posMatrix, u, f.paint.get("circle-translate"), f.paint.get("circle-translate-anchor")),
                        u_pitch_with_map: +S,
                        u_device_pixel_ratio: b.pixelRatio,
                        u_extrude_scale: L
                    }
                },
                J = (b, n, u) => {
                    const f = on(u, 1, n.zoom),
                        _ = Math.pow(2, n.zoom - u.tileID.overscaledZ),
                        S = u.tileID.overscaleFactor();
                    return {
                        u_matrix: b,
                        u_camera_to_center_distance: n.cameraToCenterDistance,
                        u_pixels_to_tile_units: f,
                        u_extrude_scale: [n.pixelsToGLUnits[0] / (f * _), n.pixelsToGLUnits[1] / (f * _)],
                        u_overscale_factor: S
                    }
                },
                W = (b, n, u = 1) => ({
                    u_matrix: b,
                    u_color: n,
                    u_overlay: 0,
                    u_overlay_scale: u
                }),
                re = b => ({
                    u_matrix: b
                }),
                ye = (b, n, u, f) => ({
                    u_matrix: b,
                    u_extrude_scale: on(n, 1, u),
                    u_intensity: f
                });

            function me(b, n) {
                const u = Math.pow(2, n.canonical.z),
                    f = n.canonical.y;
                return [new p.Y(0, f / u).toLngLat().lat, new p.Y(0, (f + 1) / u).toLngLat().lat]
            }
            const rt = (b, n, u, f) => {
                    const _ = b.transform;
                    return {
                        u_matrix: ni(b, n, u, f),
                        u_ratio: 1 / on(n, 1, _.zoom),
                        u_device_pixel_ratio: b.pixelRatio,
                        u_units_to_pixels: [1 / _.pixelsToGLUnits[0], 1 / _.pixelsToGLUnits[1]]
                    }
                },
                At = (b, n, u, f, _) => p.e(rt(b, n, u, _), {
                    u_image: 0,
                    u_image_height: f
                }),
                Mt = (b, n, u, f, _) => {
                    const S = b.transform,
                        L = ti(n, S);
                    return {
                        u_matrix: ni(b, n, u, _),
                        u_texsize: n.imageAtlasTexture.size,
                        u_ratio: 1 / on(n, 1, S.zoom),
                        u_device_pixel_ratio: b.pixelRatio,
                        u_image: 0,
                        u_scale: [L, f.fromScale, f.toScale],
                        u_fade: f.t,
                        u_units_to_pixels: [1 / S.pixelsToGLUnits[0], 1 / S.pixelsToGLUnits[1]]
                    }
                },
                si = (b, n, u, f, _, S) => {
                    const L = b.lineAtlas,
                        P = ti(n, b.transform),
                        I = u.layout.get("line-cap") === "round",
                        G = L.getDash(f.from, I),
                        j = L.getDash(f.to, I),
                        ee = G.width * _.fromScale,
                        pe = j.width * _.toScale;
                    return p.e(rt(b, n, u, S), {
                        u_patternscale_a: [P / ee, -G.height / 2],
                        u_patternscale_b: [P / pe, -j.height / 2],
                        u_sdfgamma: L.width / (256 * Math.min(ee, pe) * b.pixelRatio) / 2,
                        u_image: 0,
                        u_tex_y_a: G.y,
                        u_tex_y_b: j.y,
                        u_mix: _.t
                    })
                };

            function ti(b, n) {
                return 1 / on(b, 1, n.tileZoom)
            }

            function ni(b, n, u, f) {
                return b.translatePosMatrix(f ? f.posMatrix : n.tileID.posMatrix, n, u.paint.get("line-translate"), u.paint.get("line-translate-anchor"))
            }
            const ri = (b, n, u, f, _) => {
                return {
                    u_matrix: b,
                    u_tl_parent: n,
                    u_scale_parent: u,
                    u_buffer_scale: 1,
                    u_fade_t: f.mix,
                    u_opacity: f.opacity * _.paint.get("raster-opacity"),
                    u_image0: 0,
                    u_image1: 1,
                    u_brightness_low: _.paint.get("raster-brightness-min"),
                    u_brightness_high: _.paint.get("raster-brightness-max"),
                    u_saturation_factor: (L = _.paint.get("raster-saturation"), L > 0 ? 1 - 1 / (1.001 - L) : -L),
                    u_contrast_factor: (S = _.paint.get("raster-contrast"), S > 0 ? 1 / (1 - S) : 1 + S),
                    u_spin_weights: Wi(_.paint.get("raster-hue-rotate"))
                };
                var S, L
            };

            function Wi(b) {
                b *= Math.PI / 180;
                const n = Math.sin(b),
                    u = Math.cos(b);
                return [(2 * u + 1) / 3, (-Math.sqrt(3) * n - u + 1) / 3, (Math.sqrt(3) * n - u + 1) / 3]
            }
            const Ci = (b, n, u, f, _, S, L, P, I, G) => {
                    const j = _.transform;
                    return {
                        u_is_size_zoom_constant: +(b === "constant" || b === "source"),
                        u_is_size_feature_constant: +(b === "constant" || b === "camera"),
                        u_size_t: n ? n.uSizeT : 0,
                        u_size: n ? n.uSize : 0,
                        u_camera_to_center_distance: j.cameraToCenterDistance,
                        u_pitch: j.pitch / 360 * 2 * Math.PI,
                        u_rotate_symbol: +u,
                        u_aspect_ratio: j.width / j.height,
                        u_fade_change: _.options.fadeDuration ? _.symbolFadeChange : 1,
                        u_matrix: S,
                        u_label_plane_matrix: L,
                        u_coord_matrix: P,
                        u_is_text: +I,
                        u_pitch_with_map: +f,
                        u_texsize: G,
                        u_texture: 0
                    }
                },
                Pi = (b, n, u, f, _, S, L, P, I, G, j) => {
                    const ee = _.transform;
                    return p.e(Ci(b, n, u, f, _, S, L, P, I, G), {
                        u_gamma_scale: f ? Math.cos(ee._pitch) * ee.cameraToCenterDistance : 1,
                        u_device_pixel_ratio: _.pixelRatio,
                        u_is_halo: +j
                    })
                },
                ai = (b, n, u, f, _, S, L, P, I, G) => p.e(Pi(b, n, u, f, _, S, L, P, !0, I, !0), {
                    u_texsize_icon: G,
                    u_texture_icon: 1
                }),
                Rt = (b, n, u) => ({
                    u_matrix: b,
                    u_opacity: n,
                    u_color: u
                }),
                Gi = (b, n, u, f, _, S) => p.e(function(L, P, I, G) {
                    const j = I.imageManager.getPattern(L.from.toString()),
                        ee = I.imageManager.getPattern(L.to.toString()),
                        {
                            width: pe,
                            height: Ce
                        } = I.imageManager.getPixelSize(),
                        Me = Math.pow(2, G.tileID.overscaledZ),
                        ke = G.tileSize * Math.pow(2, I.transform.tileZoom) / Me,
                        we = ke * (G.tileID.canonical.x + G.tileID.wrap * Me),
                        nt = ke * G.tileID.canonical.y;
                    return {
                        u_image: 0,
                        u_pattern_tl_a: j.tl,
                        u_pattern_br_a: j.br,
                        u_pattern_tl_b: ee.tl,
                        u_pattern_br_b: ee.br,
                        u_texsize: [pe, Ce],
                        u_mix: P.t,
                        u_pattern_size_a: j.displaySize,
                        u_pattern_size_b: ee.displaySize,
                        u_scale_a: P.fromScale,
                        u_scale_b: P.toScale,
                        u_tile_units_to_pixels: 1 / on(G, 1, I.transform.tileZoom),
                        u_pixel_coord_upper: [we >> 16, nt >> 16],
                        u_pixel_coord_lower: [65535 & we, 65535 & nt]
                    }
                }(f, S, u, _), {
                    u_matrix: b,
                    u_opacity: n
                }),
                ki = {
                    fillExtrusion: (b, n) => ({
                        u_matrix: new p.aI(b, n.u_matrix),
                        u_lightpos: new p.aK(b, n.u_lightpos),
                        u_lightintensity: new p.aH(b, n.u_lightintensity),
                        u_lightcolor: new p.aK(b, n.u_lightcolor),
                        u_vertical_gradient: new p.aH(b, n.u_vertical_gradient),
                        u_opacity: new p.aH(b, n.u_opacity)
                    }),
                    fillExtrusionPattern: (b, n) => ({
                        u_matrix: new p.aI(b, n.u_matrix),
                        u_lightpos: new p.aK(b, n.u_lightpos),
                        u_lightintensity: new p.aH(b, n.u_lightintensity),
                        u_lightcolor: new p.aK(b, n.u_lightcolor),
                        u_vertical_gradient: new p.aH(b, n.u_vertical_gradient),
                        u_height_factor: new p.aH(b, n.u_height_factor),
                        u_image: new p.aG(b, n.u_image),
                        u_texsize: new p.aL(b, n.u_texsize),
                        u_pixel_coord_upper: new p.aL(b, n.u_pixel_coord_upper),
                        u_pixel_coord_lower: new p.aL(b, n.u_pixel_coord_lower),
                        u_scale: new p.aK(b, n.u_scale),
                        u_fade: new p.aH(b, n.u_fade),
                        u_opacity: new p.aH(b, n.u_opacity)
                    }),
                    fill: (b, n) => ({
                        u_matrix: new p.aI(b, n.u_matrix)
                    }),
                    fillPattern: (b, n) => ({
                        u_matrix: new p.aI(b, n.u_matrix),
                        u_image: new p.aG(b, n.u_image),
                        u_texsize: new p.aL(b, n.u_texsize),
                        u_pixel_coord_upper: new p.aL(b, n.u_pixel_coord_upper),
                        u_pixel_coord_lower: new p.aL(b, n.u_pixel_coord_lower),
                        u_scale: new p.aK(b, n.u_scale),
                        u_fade: new p.aH(b, n.u_fade)
                    }),
                    fillOutline: (b, n) => ({
                        u_matrix: new p.aI(b, n.u_matrix),
                        u_world: new p.aL(b, n.u_world)
                    }),
                    fillOutlinePattern: (b, n) => ({
                        u_matrix: new p.aI(b, n.u_matrix),
                        u_world: new p.aL(b, n.u_world),
                        u_image: new p.aG(b, n.u_image),
                        u_texsize: new p.aL(b, n.u_texsize),
                        u_pixel_coord_upper: new p.aL(b, n.u_pixel_coord_upper),
                        u_pixel_coord_lower: new p.aL(b, n.u_pixel_coord_lower),
                        u_scale: new p.aK(b, n.u_scale),
                        u_fade: new p.aH(b, n.u_fade)
                    }),
                    circle: (b, n) => ({
                        u_camera_to_center_distance: new p.aH(b, n.u_camera_to_center_distance),
                        u_scale_with_map: new p.aG(b, n.u_scale_with_map),
                        u_pitch_with_map: new p.aG(b, n.u_pitch_with_map),
                        u_extrude_scale: new p.aL(b, n.u_extrude_scale),
                        u_device_pixel_ratio: new p.aH(b, n.u_device_pixel_ratio),
                        u_matrix: new p.aI(b, n.u_matrix)
                    }),
                    collisionBox: (b, n) => ({
                        u_matrix: new p.aI(b, n.u_matrix),
                        u_camera_to_center_distance: new p.aH(b, n.u_camera_to_center_distance),
                        u_pixels_to_tile_units: new p.aH(b, n.u_pixels_to_tile_units),
                        u_extrude_scale: new p.aL(b, n.u_extrude_scale),
                        u_overscale_factor: new p.aH(b, n.u_overscale_factor)
                    }),
                    collisionCircle: (b, n) => ({
                        u_matrix: new p.aI(b, n.u_matrix),
                        u_inv_matrix: new p.aI(b, n.u_inv_matrix),
                        u_camera_to_center_distance: new p.aH(b, n.u_camera_to_center_distance),
                        u_viewport_size: new p.aL(b, n.u_viewport_size)
                    }),
                    debug: (b, n) => ({
                        u_color: new p.aM(b, n.u_color),
                        u_matrix: new p.aI(b, n.u_matrix),
                        u_overlay: new p.aG(b, n.u_overlay),
                        u_overlay_scale: new p.aH(b, n.u_overlay_scale)
                    }),
                    clippingMask: (b, n) => ({
                        u_matrix: new p.aI(b, n.u_matrix)
                    }),
                    heatmap: (b, n) => ({
                        u_extrude_scale: new p.aH(b, n.u_extrude_scale),
                        u_intensity: new p.aH(b, n.u_intensity),
                        u_matrix: new p.aI(b, n.u_matrix)
                    }),
                    heatmapTexture: (b, n) => ({
                        u_matrix: new p.aI(b, n.u_matrix),
                        u_world: new p.aL(b, n.u_world),
                        u_image: new p.aG(b, n.u_image),
                        u_color_ramp: new p.aG(b, n.u_color_ramp),
                        u_opacity: new p.aH(b, n.u_opacity)
                    }),
                    hillshade: (b, n) => ({
                        u_matrix: new p.aI(b, n.u_matrix),
                        u_image: new p.aG(b, n.u_image),
                        u_latrange: new p.aL(b, n.u_latrange),
                        u_light: new p.aL(b, n.u_light),
                        u_shadow: new p.aM(b, n.u_shadow),
                        u_highlight: new p.aM(b, n.u_highlight),
                        u_accent: new p.aM(b, n.u_accent)
                    }),
                    hillshadePrepare: (b, n) => ({
                        u_matrix: new p.aI(b, n.u_matrix),
                        u_image: new p.aG(b, n.u_image),
                        u_dimension: new p.aL(b, n.u_dimension),
                        u_zoom: new p.aH(b, n.u_zoom),
                        u_unpack: new p.aJ(b, n.u_unpack)
                    }),
                    line: (b, n) => ({
                        u_matrix: new p.aI(b, n.u_matrix),
                        u_ratio: new p.aH(b, n.u_ratio),
                        u_device_pixel_ratio: new p.aH(b, n.u_device_pixel_ratio),
                        u_units_to_pixels: new p.aL(b, n.u_units_to_pixels)
                    }),
                    lineGradient: (b, n) => ({
                        u_matrix: new p.aI(b, n.u_matrix),
                        u_ratio: new p.aH(b, n.u_ratio),
                        u_device_pixel_ratio: new p.aH(b, n.u_device_pixel_ratio),
                        u_units_to_pixels: new p.aL(b, n.u_units_to_pixels),
                        u_image: new p.aG(b, n.u_image),
                        u_image_height: new p.aH(b, n.u_image_height)
                    }),
                    linePattern: (b, n) => ({
                        u_matrix: new p.aI(b, n.u_matrix),
                        u_texsize: new p.aL(b, n.u_texsize),
                        u_ratio: new p.aH(b, n.u_ratio),
                        u_device_pixel_ratio: new p.aH(b, n.u_device_pixel_ratio),
                        u_image: new p.aG(b, n.u_image),
                        u_units_to_pixels: new p.aL(b, n.u_units_to_pixels),
                        u_scale: new p.aK(b, n.u_scale),
                        u_fade: new p.aH(b, n.u_fade)
                    }),
                    lineSDF: (b, n) => ({
                        u_matrix: new p.aI(b, n.u_matrix),
                        u_ratio: new p.aH(b, n.u_ratio),
                        u_device_pixel_ratio: new p.aH(b, n.u_device_pixel_ratio),
                        u_units_to_pixels: new p.aL(b, n.u_units_to_pixels),
                        u_patternscale_a: new p.aL(b, n.u_patternscale_a),
                        u_patternscale_b: new p.aL(b, n.u_patternscale_b),
                        u_sdfgamma: new p.aH(b, n.u_sdfgamma),
                        u_image: new p.aG(b, n.u_image),
                        u_tex_y_a: new p.aH(b, n.u_tex_y_a),
                        u_tex_y_b: new p.aH(b, n.u_tex_y_b),
                        u_mix: new p.aH(b, n.u_mix)
                    }),
                    raster: (b, n) => ({
                        u_matrix: new p.aI(b, n.u_matrix),
                        u_tl_parent: new p.aL(b, n.u_tl_parent),
                        u_scale_parent: new p.aH(b, n.u_scale_parent),
                        u_buffer_scale: new p.aH(b, n.u_buffer_scale),
                        u_fade_t: new p.aH(b, n.u_fade_t),
                        u_opacity: new p.aH(b, n.u_opacity),
                        u_image0: new p.aG(b, n.u_image0),
                        u_image1: new p.aG(b, n.u_image1),
                        u_brightness_low: new p.aH(b, n.u_brightness_low),
                        u_brightness_high: new p.aH(b, n.u_brightness_high),
                        u_saturation_factor: new p.aH(b, n.u_saturation_factor),
                        u_contrast_factor: new p.aH(b, n.u_contrast_factor),
                        u_spin_weights: new p.aK(b, n.u_spin_weights)
                    }),
                    symbolIcon: (b, n) => ({
                        u_is_size_zoom_constant: new p.aG(b, n.u_is_size_zoom_constant),
                        u_is_size_feature_constant: new p.aG(b, n.u_is_size_feature_constant),
                        u_size_t: new p.aH(b, n.u_size_t),
                        u_size: new p.aH(b, n.u_size),
                        u_camera_to_center_distance: new p.aH(b, n.u_camera_to_center_distance),
                        u_pitch: new p.aH(b, n.u_pitch),
                        u_rotate_symbol: new p.aG(b, n.u_rotate_symbol),
                        u_aspect_ratio: new p.aH(b, n.u_aspect_ratio),
                        u_fade_change: new p.aH(b, n.u_fade_change),
                        u_matrix: new p.aI(b, n.u_matrix),
                        u_label_plane_matrix: new p.aI(b, n.u_label_plane_matrix),
                        u_coord_matrix: new p.aI(b, n.u_coord_matrix),
                        u_is_text: new p.aG(b, n.u_is_text),
                        u_pitch_with_map: new p.aG(b, n.u_pitch_with_map),
                        u_texsize: new p.aL(b, n.u_texsize),
                        u_texture: new p.aG(b, n.u_texture)
                    }),
                    symbolSDF: (b, n) => ({
                        u_is_size_zoom_constant: new p.aG(b, n.u_is_size_zoom_constant),
                        u_is_size_feature_constant: new p.aG(b, n.u_is_size_feature_constant),
                        u_size_t: new p.aH(b, n.u_size_t),
                        u_size: new p.aH(b, n.u_size),
                        u_camera_to_center_distance: new p.aH(b, n.u_camera_to_center_distance),
                        u_pitch: new p.aH(b, n.u_pitch),
                        u_rotate_symbol: new p.aG(b, n.u_rotate_symbol),
                        u_aspect_ratio: new p.aH(b, n.u_aspect_ratio),
                        u_fade_change: new p.aH(b, n.u_fade_change),
                        u_matrix: new p.aI(b, n.u_matrix),
                        u_label_plane_matrix: new p.aI(b, n.u_label_plane_matrix),
                        u_coord_matrix: new p.aI(b, n.u_coord_matrix),
                        u_is_text: new p.aG(b, n.u_is_text),
                        u_pitch_with_map: new p.aG(b, n.u_pitch_with_map),
                        u_texsize: new p.aL(b, n.u_texsize),
                        u_texture: new p.aG(b, n.u_texture),
                        u_gamma_scale: new p.aH(b, n.u_gamma_scale),
                        u_device_pixel_ratio: new p.aH(b, n.u_device_pixel_ratio),
                        u_is_halo: new p.aG(b, n.u_is_halo)
                    }),
                    symbolTextAndIcon: (b, n) => ({
                        u_is_size_zoom_constant: new p.aG(b, n.u_is_size_zoom_constant),
                        u_is_size_feature_constant: new p.aG(b, n.u_is_size_feature_constant),
                        u_size_t: new p.aH(b, n.u_size_t),
                        u_size: new p.aH(b, n.u_size),
                        u_camera_to_center_distance: new p.aH(b, n.u_camera_to_center_distance),
                        u_pitch: new p.aH(b, n.u_pitch),
                        u_rotate_symbol: new p.aG(b, n.u_rotate_symbol),
                        u_aspect_ratio: new p.aH(b, n.u_aspect_ratio),
                        u_fade_change: new p.aH(b, n.u_fade_change),
                        u_matrix: new p.aI(b, n.u_matrix),
                        u_label_plane_matrix: new p.aI(b, n.u_label_plane_matrix),
                        u_coord_matrix: new p.aI(b, n.u_coord_matrix),
                        u_is_text: new p.aG(b, n.u_is_text),
                        u_pitch_with_map: new p.aG(b, n.u_pitch_with_map),
                        u_texsize: new p.aL(b, n.u_texsize),
                        u_texsize_icon: new p.aL(b, n.u_texsize_icon),
                        u_texture: new p.aG(b, n.u_texture),
                        u_texture_icon: new p.aG(b, n.u_texture_icon),
                        u_gamma_scale: new p.aH(b, n.u_gamma_scale),
                        u_device_pixel_ratio: new p.aH(b, n.u_device_pixel_ratio),
                        u_is_halo: new p.aG(b, n.u_is_halo)
                    }),
                    background: (b, n) => ({
                        u_matrix: new p.aI(b, n.u_matrix),
                        u_opacity: new p.aH(b, n.u_opacity),
                        u_color: new p.aM(b, n.u_color)
                    }),
                    backgroundPattern: (b, n) => ({
                        u_matrix: new p.aI(b, n.u_matrix),
                        u_opacity: new p.aH(b, n.u_opacity),
                        u_image: new p.aG(b, n.u_image),
                        u_pattern_tl_a: new p.aL(b, n.u_pattern_tl_a),
                        u_pattern_br_a: new p.aL(b, n.u_pattern_br_a),
                        u_pattern_tl_b: new p.aL(b, n.u_pattern_tl_b),
                        u_pattern_br_b: new p.aL(b, n.u_pattern_br_b),
                        u_texsize: new p.aL(b, n.u_texsize),
                        u_mix: new p.aH(b, n.u_mix),
                        u_pattern_size_a: new p.aL(b, n.u_pattern_size_a),
                        u_pattern_size_b: new p.aL(b, n.u_pattern_size_b),
                        u_scale_a: new p.aH(b, n.u_scale_a),
                        u_scale_b: new p.aH(b, n.u_scale_b),
                        u_pixel_coord_upper: new p.aL(b, n.u_pixel_coord_upper),
                        u_pixel_coord_lower: new p.aL(b, n.u_pixel_coord_lower),
                        u_tile_units_to_pixels: new p.aH(b, n.u_tile_units_to_pixels)
                    }),
                    terrain: (b, n) => ({
                        u_matrix: new p.aI(b, n.u_matrix),
                        u_texture: new p.aG(b, n.u_texture),
                        u_ele_delta: new p.aH(b, n.u_ele_delta)
                    }),
                    terrainDepth: (b, n) => ({
                        u_matrix: new p.aI(b, n.u_matrix),
                        u_ele_delta: new p.aH(b, n.u_ele_delta)
                    }),
                    terrainCoords: (b, n) => ({
                        u_matrix: new p.aI(b, n.u_matrix),
                        u_texture: new p.aG(b, n.u_texture),
                        u_terrain_coords_id: new p.aH(b, n.u_terrain_coords_id),
                        u_ele_delta: new p.aH(b, n.u_ele_delta)
                    })
                };
            class pn {
                constructor(n, u, f) {
                    this.context = n;
                    const _ = n.gl;
                    this.buffer = _.createBuffer(), this.dynamicDraw = !!f, this.context.unbindVAO(), n.bindElementBuffer.set(this.buffer), _.bufferData(_.ELEMENT_ARRAY_BUFFER, u.arrayBuffer, this.dynamicDraw ? _.DYNAMIC_DRAW : _.STATIC_DRAW), this.dynamicDraw || delete u.arrayBuffer
                }
                bind() {
                    this.context.bindElementBuffer.set(this.buffer)
                }
                updateData(n) {
                    const u = this.context.gl;
                    if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
                    this.context.unbindVAO(), this.bind(), u.bufferSubData(u.ELEMENT_ARRAY_BUFFER, 0, n.arrayBuffer)
                }
                destroy() {
                    this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
                }
            }
            const pi = {
                Int8: "BYTE",
                Uint8: "UNSIGNED_BYTE",
                Int16: "SHORT",
                Uint16: "UNSIGNED_SHORT",
                Int32: "INT",
                Uint32: "UNSIGNED_INT",
                Float32: "FLOAT"
            };
            class Hi {
                constructor(n, u, f, _) {
                    this.length = u.length, this.attributes = f, this.itemSize = u.bytesPerElement, this.dynamicDraw = _, this.context = n;
                    const S = n.gl;
                    this.buffer = S.createBuffer(), n.bindVertexBuffer.set(this.buffer), S.bufferData(S.ARRAY_BUFFER, u.arrayBuffer, this.dynamicDraw ? S.DYNAMIC_DRAW : S.STATIC_DRAW), this.dynamicDraw || delete u.arrayBuffer
                }
                bind() {
                    this.context.bindVertexBuffer.set(this.buffer)
                }
                updateData(n) {
                    if (n.length !== this.length) throw new Error(`Length of new data is ${n.length}, which doesn't match current length of ${this.length}`);
                    const u = this.context.gl;
                    this.bind(), u.bufferSubData(u.ARRAY_BUFFER, 0, n.arrayBuffer)
                }
                enableAttributes(n, u) {
                    for (let f = 0; f < this.attributes.length; f++) {
                        const _ = u.attributes[this.attributes[f].name];
                        _ !== void 0 && n.enableVertexAttribArray(_)
                    }
                }
                setVertexAttribPointers(n, u, f) {
                    for (let _ = 0; _ < this.attributes.length; _++) {
                        const S = this.attributes[_],
                            L = u.attributes[S.name];
                        L !== void 0 && n.vertexAttribPointer(L, S.components, n[pi[S.type]], !1, this.itemSize, S.offset + this.itemSize * (f || 0))
                    }
                }
                destroy() {
                    this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
                }
            }
            const en = new WeakMap;

            function Bi(b) {
                var n;
                if (en.has(b)) return en.get(b);
                {
                    const u = (n = b.getParameter(b.VERSION)) === null || n === void 0 ? void 0 : n.startsWith("WebGL 2.0");
                    return en.set(b, u), u
                }
            }
            class Xi {
                constructor(n) {
                    this.gl = n.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1
                }
                get() {
                    return this.current
                }
                set(n) {}
                getDefault() {
                    return this.default
                }
                setDefault() {
                    this.set(this.default)
                }
            }
            class Un extends Xi {
                getDefault() {
                    return p.aO.transparent
                }
                set(n) {
                    const u = this.current;
                    (n.r !== u.r || n.g !== u.g || n.b !== u.b || n.a !== u.a || this.dirty) && (this.gl.clearColor(n.r, n.g, n.b, n.a), this.current = n, this.dirty = !1)
                }
            }
            class lr extends Xi {
                getDefault() {
                    return 1
                }
                set(n) {
                    (n !== this.current || this.dirty) && (this.gl.clearDepth(n), this.current = n, this.dirty = !1)
                }
            }
            class Qr extends Xi {
                getDefault() {
                    return 0
                }
                set(n) {
                    (n !== this.current || this.dirty) && (this.gl.clearStencil(n), this.current = n, this.dirty = !1)
                }
            }
            class aa extends Xi {
                getDefault() {
                    return [!0, !0, !0, !0]
                }
                set(n) {
                    const u = this.current;
                    (n[0] !== u[0] || n[1] !== u[1] || n[2] !== u[2] || n[3] !== u[3] || this.dirty) && (this.gl.colorMask(n[0], n[1], n[2], n[3]), this.current = n, this.dirty = !1)
                }
            }
            class Ai extends Xi {
                getDefault() {
                    return !0
                }
                set(n) {
                    (n !== this.current || this.dirty) && (this.gl.depthMask(n), this.current = n, this.dirty = !1)
                }
            }
            class ca extends Xi {
                getDefault() {
                    return 255
                }
                set(n) {
                    (n !== this.current || this.dirty) && (this.gl.stencilMask(n), this.current = n, this.dirty = !1)
                }
            }
            class Ea extends Xi {
                getDefault() {
                    return {
                        func: this.gl.ALWAYS,
                        ref: 0,
                        mask: 255
                    }
                }
                set(n) {
                    const u = this.current;
                    (n.func !== u.func || n.ref !== u.ref || n.mask !== u.mask || this.dirty) && (this.gl.stencilFunc(n.func, n.ref, n.mask), this.current = n, this.dirty = !1)
                }
            }
            class Kr extends Xi {
                getDefault() {
                    const n = this.gl;
                    return [n.KEEP, n.KEEP, n.KEEP]
                }
                set(n) {
                    const u = this.current;
                    (n[0] !== u[0] || n[1] !== u[1] || n[2] !== u[2] || this.dirty) && (this.gl.stencilOp(n[0], n[1], n[2]), this.current = n, this.dirty = !1)
                }
            }
            class Er extends Xi {
                getDefault() {
                    return !1
                }
                set(n) {
                    if (n === this.current && !this.dirty) return;
                    const u = this.gl;
                    n ? u.enable(u.STENCIL_TEST) : u.disable(u.STENCIL_TEST), this.current = n, this.dirty = !1
                }
            }
            class ro extends Xi {
                getDefault() {
                    return [0, 1]
                }
                set(n) {
                    const u = this.current;
                    (n[0] !== u[0] || n[1] !== u[1] || this.dirty) && (this.gl.depthRange(n[0], n[1]), this.current = n, this.dirty = !1)
                }
            }
            class Or extends Xi {
                getDefault() {
                    return !1
                }
                set(n) {
                    if (n === this.current && !this.dirty) return;
                    const u = this.gl;
                    n ? u.enable(u.DEPTH_TEST) : u.disable(u.DEPTH_TEST), this.current = n, this.dirty = !1
                }
            }
            class ls extends Xi {
                getDefault() {
                    return this.gl.LESS
                }
                set(n) {
                    (n !== this.current || this.dirty) && (this.gl.depthFunc(n), this.current = n, this.dirty = !1)
                }
            }
            class ms extends Xi {
                getDefault() {
                    return !1
                }
                set(n) {
                    if (n === this.current && !this.dirty) return;
                    const u = this.gl;
                    n ? u.enable(u.BLEND) : u.disable(u.BLEND), this.current = n, this.dirty = !1
                }
            }
            class _a extends Xi {
                getDefault() {
                    const n = this.gl;
                    return [n.ONE, n.ZERO]
                }
                set(n) {
                    const u = this.current;
                    (n[0] !== u[0] || n[1] !== u[1] || this.dirty) && (this.gl.blendFunc(n[0], n[1]), this.current = n, this.dirty = !1)
                }
            }
            class ks extends Xi {
                getDefault() {
                    return p.aO.transparent
                }
                set(n) {
                    const u = this.current;
                    (n.r !== u.r || n.g !== u.g || n.b !== u.b || n.a !== u.a || this.dirty) && (this.gl.blendColor(n.r, n.g, n.b, n.a), this.current = n, this.dirty = !1)
                }
            }
            class Pr extends Xi {
                getDefault() {
                    return this.gl.FUNC_ADD
                }
                set(n) {
                    (n !== this.current || this.dirty) && (this.gl.blendEquation(n), this.current = n, this.dirty = !1)
                }
            }
            class an extends Xi {
                getDefault() {
                    return !1
                }
                set(n) {
                    if (n === this.current && !this.dirty) return;
                    const u = this.gl;
                    n ? u.enable(u.CULL_FACE) : u.disable(u.CULL_FACE), this.current = n, this.dirty = !1
                }
            }
            class Nl extends Xi {
                getDefault() {
                    return this.gl.BACK
                }
                set(n) {
                    (n !== this.current || this.dirty) && (this.gl.cullFace(n), this.current = n, this.dirty = !1)
                }
            }
            class gs extends Xi {
                getDefault() {
                    return this.gl.CCW
                }
                set(n) {
                    (n !== this.current || this.dirty) && (this.gl.frontFace(n), this.current = n, this.dirty = !1)
                }
            }
            class cl extends Xi {
                getDefault() {
                    return null
                }
                set(n) {
                    (n !== this.current || this.dirty) && (this.gl.useProgram(n), this.current = n, this.dirty = !1)
                }
            }
            class cs extends Xi {
                getDefault() {
                    return this.gl.TEXTURE0
                }
                set(n) {
                    (n !== this.current || this.dirty) && (this.gl.activeTexture(n), this.current = n, this.dirty = !1)
                }
            }
            class Ua extends Xi {
                getDefault() {
                    const n = this.gl;
                    return [0, 0, n.drawingBufferWidth, n.drawingBufferHeight]
                }
                set(n) {
                    const u = this.current;
                    (n[0] !== u[0] || n[1] !== u[1] || n[2] !== u[2] || n[3] !== u[3] || this.dirty) && (this.gl.viewport(n[0], n[1], n[2], n[3]), this.current = n, this.dirty = !1)
                }
            }
            class ys extends Xi {
                getDefault() {
                    return null
                }
                set(n) {
                    if (n === this.current && !this.dirty) return;
                    const u = this.gl;
                    u.bindFramebuffer(u.FRAMEBUFFER, n), this.current = n, this.dirty = !1
                }
            }
            class Ol extends Xi {
                getDefault() {
                    return null
                }
                set(n) {
                    if (n === this.current && !this.dirty) return;
                    const u = this.gl;
                    u.bindRenderbuffer(u.RENDERBUFFER, n), this.current = n, this.dirty = !1
                }
            }
            class hl extends Xi {
                getDefault() {
                    return null
                }
                set(n) {
                    if (n === this.current && !this.dirty) return;
                    const u = this.gl;
                    u.bindTexture(u.TEXTURE_2D, n), this.current = n, this.dirty = !1
                }
            }
            class vs extends Xi {
                getDefault() {
                    return null
                }
                set(n) {
                    if (n === this.current && !this.dirty) return;
                    const u = this.gl;
                    u.bindBuffer(u.ARRAY_BUFFER, n), this.current = n, this.dirty = !1
                }
            }
            class ul extends Xi {
                getDefault() {
                    return null
                }
                set(n) {
                    const u = this.gl;
                    u.bindBuffer(u.ELEMENT_ARRAY_BUFFER, n), this.current = n, this.dirty = !1
                }
            }
            class _s extends Xi {
                getDefault() {
                    return null
                }
                set(n) {
                    var u;
                    if (n === this.current && !this.dirty) return;
                    const f = this.gl;
                    Bi(f) ? f.bindVertexArray(n) : (u = f.getExtension("OES_vertex_array_object")) === null || u === void 0 || u.bindVertexArrayOES(n), this.current = n, this.dirty = !1
                }
            }
            class xs extends Xi {
                getDefault() {
                    return 4
                }
                set(n) {
                    if (n === this.current && !this.dirty) return;
                    const u = this.gl;
                    u.pixelStorei(u.UNPACK_ALIGNMENT, n), this.current = n, this.dirty = !1
                }
            }
            class dl extends Xi {
                getDefault() {
                    return !1
                }
                set(n) {
                    if (n === this.current && !this.dirty) return;
                    const u = this.gl;
                    u.pixelStorei(u.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n), this.current = n, this.dirty = !1
                }
            }
            class Bo extends Xi {
                getDefault() {
                    return !1
                }
                set(n) {
                    if (n === this.current && !this.dirty) return;
                    const u = this.gl;
                    u.pixelStorei(u.UNPACK_FLIP_Y_WEBGL, n), this.current = n, this.dirty = !1
                }
            }
            class Mn extends Xi {
                constructor(n, u) {
                    super(n), this.context = n, this.parent = u
                }
                getDefault() {
                    return null
                }
            }
            class Ro extends Mn {
                setDirty() {
                    this.dirty = !0
                }
                set(n) {
                    if (n === this.current && !this.dirty) return;
                    this.context.bindFramebuffer.set(this.parent);
                    const u = this.gl;
                    u.framebufferTexture2D(u.FRAMEBUFFER, u.COLOR_ATTACHMENT0, u.TEXTURE_2D, n, 0), this.current = n, this.dirty = !1
                }
            }
            class Vl extends Mn {
                set(n) {
                    if (n === this.current && !this.dirty) return;
                    this.context.bindFramebuffer.set(this.parent);
                    const u = this.gl;
                    u.framebufferRenderbuffer(u.FRAMEBUFFER, u.DEPTH_ATTACHMENT, u.RENDERBUFFER, n), this.current = n, this.dirty = !1
                }
            }
            class ar extends Mn {
                set(n) {
                    if (n === this.current && !this.dirty) return;
                    this.context.bindFramebuffer.set(this.parent);
                    const u = this.gl;
                    u.framebufferRenderbuffer(u.FRAMEBUFFER, u.DEPTH_STENCIL_ATTACHMENT, u.RENDERBUFFER, n), this.current = n, this.dirty = !1
                }
            }
            class Ds {
                constructor(n, u, f, _, S) {
                    this.context = n, this.width = u, this.height = f;
                    const L = n.gl,
                        P = this.framebuffer = L.createFramebuffer();
                    if (this.colorAttachment = new Ro(n, P), _) this.depthAttachment = S ? new ar(n, P) : new Vl(n, P);
                    else if (S) throw new Error("Stencil cannot be set without depth");
                    if (L.checkFramebufferStatus(L.FRAMEBUFFER) !== L.FRAMEBUFFER_COMPLETE) throw new Error("Framebuffer is not complete")
                }
                destroy() {
                    const n = this.context.gl,
                        u = this.colorAttachment.get();
                    if (u && n.deleteTexture(u), this.depthAttachment) {
                        const f = this.depthAttachment.get();
                        f && n.deleteRenderbuffer(f)
                    }
                    n.deleteFramebuffer(this.framebuffer)
                }
            }
            class sr {
                constructor(n, u, f) {
                    this.blendFunction = n, this.blendColor = u, this.mask = f
                }
            }
            sr.Replace = [1, 0], sr.disabled = new sr(sr.Replace, p.aO.transparent, [!1, !1, !1, !1]), sr.unblended = new sr(sr.Replace, p.aO.transparent, [!0, !0, !0, !0]), sr.alphaBlended = new sr([1, 771], p.aO.transparent, [!0, !0, !0, !0]);
            class Fo {
                constructor(n) {
                    var u, f;
                    if (this.gl = n, this.clearColor = new Un(this), this.clearDepth = new lr(this), this.clearStencil = new Qr(this), this.colorMask = new aa(this), this.depthMask = new Ai(this), this.stencilMask = new ca(this), this.stencilFunc = new Ea(this), this.stencilOp = new Kr(this), this.stencilTest = new Er(this), this.depthRange = new ro(this), this.depthTest = new Or(this), this.depthFunc = new ls(this), this.blend = new ms(this), this.blendFunc = new _a(this), this.blendColor = new ks(this), this.blendEquation = new Pr(this), this.cullFace = new an(this), this.cullFaceSide = new Nl(this), this.frontFace = new gs(this), this.program = new cl(this), this.activeTexture = new cs(this), this.viewport = new Ua(this), this.bindFramebuffer = new ys(this), this.bindRenderbuffer = new Ol(this), this.bindTexture = new hl(this), this.bindVertexBuffer = new vs(this), this.bindElementBuffer = new ul(this), this.bindVertexArray = new _s(this), this.pixelStoreUnpack = new xs(this), this.pixelStoreUnpackPremultiplyAlpha = new dl(this), this.pixelStoreUnpackFlipY = new Bo(this), this.extTextureFilterAnisotropic = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = n.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = n.getParameter(n.MAX_TEXTURE_SIZE), Bi(n)) {
                        this.HALF_FLOAT = n.HALF_FLOAT;
                        const _ = n.getExtension("EXT_color_buffer_half_float");
                        this.RGBA16F = (u = n.RGBA16F) !== null && u !== void 0 ? u : _ == null ? void 0 : _.RGBA16F_EXT, this.RGB16F = (f = n.RGB16F) !== null && f !== void 0 ? f : _ == null ? void 0 : _.RGB16F_EXT, n.getExtension("EXT_color_buffer_float")
                    } else {
                        n.getExtension("EXT_color_buffer_half_float"), n.getExtension("OES_texture_half_float_linear");
                        const _ = n.getExtension("OES_texture_half_float");
                        this.HALF_FLOAT = _ == null ? void 0 : _.HALF_FLOAT_OES
                    }
                }
                setDefault() {
                    this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault()
                }
                setDirty() {
                    this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0
                }
                createIndexBuffer(n, u) {
                    return new pn(this, n, u)
                }
                createVertexBuffer(n, u, f) {
                    return new Hi(this, n, u, f)
                }
                createRenderbuffer(n, u, f) {
                    const _ = this.gl,
                        S = _.createRenderbuffer();
                    return this.bindRenderbuffer.set(S), _.renderbufferStorage(_.RENDERBUFFER, n, u, f), this.bindRenderbuffer.set(null), S
                }
                createFramebuffer(n, u, f, _) {
                    return new Ds(this, n, u, f, _)
                }
                clear({
                    color: n,
                    depth: u,
                    stencil: f
                }) {
                    const _ = this.gl;
                    let S = 0;
                    n && (S |= _.COLOR_BUFFER_BIT, this.clearColor.set(n), this.colorMask.set([!0, !0, !0, !0])), u !== void 0 && (S |= _.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(u), this.depthMask.set(!0)), f !== void 0 && (S |= _.STENCIL_BUFFER_BIT, this.clearStencil.set(f), this.stencilMask.set(255)), _.clear(S)
                }
                setCullFace(n) {
                    n.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(n.mode), this.frontFace.set(n.frontFace))
                }
                setDepthMode(n) {
                    n.func !== this.gl.ALWAYS || n.mask ? (this.depthTest.set(!0), this.depthFunc.set(n.func), this.depthMask.set(n.mask), this.depthRange.set(n.range)) : this.depthTest.set(!1)
                }
                setStencilMode(n) {
                    n.test.func !== this.gl.ALWAYS || n.mask ? (this.stencilTest.set(!0), this.stencilMask.set(n.mask), this.stencilOp.set([n.fail, n.depthFail, n.pass]), this.stencilFunc.set({
                        func: n.test.func,
                        ref: n.ref,
                        mask: n.test.mask
                    })) : this.stencilTest.set(!1)
                }
                setColorMode(n) {
                    p.aD(n.blendFunction, sr.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(n.blendFunction), this.blendColor.set(n.blendColor)), this.colorMask.set(n.mask)
                }
                createVertexArray() {
                    var n;
                    return Bi(this.gl) ? this.gl.createVertexArray() : (n = this.gl.getExtension("OES_vertex_array_object")) === null || n === void 0 ? void 0 : n.createVertexArrayOES()
                }
                deleteVertexArray(n) {
                    var u;
                    return Bi(this.gl) ? this.gl.deleteVertexArray(n) : (u = this.gl.getExtension("OES_vertex_array_object")) === null || u === void 0 ? void 0 : u.deleteVertexArrayOES(n)
                }
                unbindVAO() {
                    this.bindVertexArray.set(null)
                }
            }
            class un {
                constructor(n, u, f) {
                    this.func = n, this.mask = u, this.range = f
                }
            }
            un.ReadOnly = !1, un.ReadWrite = !0, un.disabled = new un(519, un.ReadOnly, [0, 1]);
            const Gl = 7680;
            class Cn {
                constructor(n, u, f, _, S, L) {
                    this.test = n, this.ref = u, this.mask = f, this.fail = _, this.depthFail = S, this.pass = L
                }
            }
            Cn.disabled = new Cn({
                func: 519,
                mask: 0
            }, 0, 0, Gl, Gl, Gl);
            class Dn {
                constructor(n, u, f) {
                    this.enable = n, this.mode = u, this.frontFace = f
                }
            }
            let dr;

            function bs(b, n, u, f, _, S, L) {
                const P = b.context,
                    I = P.gl,
                    G = b.useProgram("collisionBox"),
                    j = [];
                let ee = 0,
                    pe = 0;
                for (let ze = 0; ze < f.length; ze++) {
                    const ut = f[ze],
                        St = n.getTile(ut),
                        yt = St.getBucket(u);
                    if (!yt) continue;
                    let Vt = ut.posMatrix;
                    _[0] === 0 && _[1] === 0 || (Vt = b.translatePosMatrix(ut.posMatrix, St, _, S));
                    const ci = L ? yt.textCollisionBox : yt.iconCollisionBox,
                        $t = yt.collisionCircleArray;
                    if ($t.length > 0) {
                        const gi = p.F(),
                            Ri = Vt;
                        p.aP(gi, yt.placementInvProjMatrix, b.transform.glCoordMatrix), p.aP(gi, gi, yt.placementViewportMatrix), j.push({
                            circleArray: $t,
                            circleOffset: pe,
                            transform: Ri,
                            invTransform: gi,
                            coord: ut
                        }), ee += $t.length / 4, pe = ee
                    }
                    ci && G.draw(P, I.LINES, un.disabled, Cn.disabled, b.colorModeForRenderPass(), Dn.disabled, J(Vt, b.transform, St), b.style.map.terrain && b.style.map.terrain.getTerrainData(ut), u.id, ci.layoutVertexBuffer, ci.indexBuffer, ci.segments, null, b.transform.zoom, null, null, ci.collisionVertexBuffer)
                }
                if (!L || !j.length) return;
                const Ce = b.useProgram("collisionCircle"),
                    Me = new p.aQ;
                Me.resize(4 * ee), Me._trim();
                let ke = 0;
                for (const ze of j)
                    for (let ut = 0; ut < ze.circleArray.length / 4; ut++) {
                        const St = 4 * ut,
                            yt = ze.circleArray[St + 0],
                            Vt = ze.circleArray[St + 1],
                            ci = ze.circleArray[St + 2],
                            $t = ze.circleArray[St + 3];
                        Me.emplace(ke++, yt, Vt, ci, $t, 0), Me.emplace(ke++, yt, Vt, ci, $t, 1), Me.emplace(ke++, yt, Vt, ci, $t, 2), Me.emplace(ke++, yt, Vt, ci, $t, 3)
                    }(!dr || dr.length < 2 * ee) && (dr = function(ze) {
                        const ut = 2 * ze,
                            St = new p.aS;
                        St.resize(ut), St._trim();
                        for (let yt = 0; yt < ut; yt++) {
                            const Vt = 6 * yt;
                            St.uint16[Vt + 0] = 4 * yt + 0, St.uint16[Vt + 1] = 4 * yt + 1, St.uint16[Vt + 2] = 4 * yt + 2, St.uint16[Vt + 3] = 4 * yt + 2, St.uint16[Vt + 4] = 4 * yt + 3, St.uint16[Vt + 5] = 4 * yt + 0
                        }
                        return St
                    }(ee));
                const we = P.createIndexBuffer(dr, !0),
                    nt = P.createVertexBuffer(Me, p.aR.members, !0);
                for (const ze of j) {
                    const ut = {
                        u_matrix: ze.transform,
                        u_inv_matrix: ze.invTransform,
                        u_camera_to_center_distance: (bt = b.transform).cameraToCenterDistance,
                        u_viewport_size: [bt.width, bt.height]
                    };
                    Ce.draw(P, I.TRIANGLES, un.disabled, Cn.disabled, b.colorModeForRenderPass(), Dn.disabled, ut, b.style.map.terrain && b.style.map.terrain.getTerrainData(ze.coord), u.id, nt, we, p.$.simpleSegment(0, 2 * ze.circleOffset, ze.circleArray.length, ze.circleArray.length / 2), null, b.transform.zoom, null, null, null)
                }
                var bt;
                nt.destroy(), we.destroy()
            }
            Dn.disabled = new Dn(!1, 1029, 2305), Dn.backCCW = new Dn(!0, 1029, 2305);
            const Lo = p.an(new Float32Array(16));

            function ao(b, n, u, f, _, S) {
                const {
                    horizontalAlign: L,
                    verticalAlign: P
                } = p.at(b);
                return new p.P((-(L - .5) * n / _ + f[0]) * S, (-(P - .5) * u / _ + f[1]) * S)
            }

            function so(b, n, u, f, _, S, L, P, I, G, j) {
                const ee = b.text.placedSymbolArray,
                    pe = b.text.dynamicLayoutVertexArray,
                    Ce = b.icon.dynamicLayoutVertexArray,
                    Me = {};
                pe.clear();
                for (let ke = 0; ke < ee.length; ke++) {
                    const we = ee.get(ke),
                        nt = we.hidden || !we.crossTileID || b.allowVerticalPlacement && !we.placedOrientation ? null : f[we.crossTileID];
                    if (nt) {
                        const bt = new p.P(we.anchorX, we.anchorY),
                            ze = On(bt, u ? L : S, j),
                            ut = Te(_.cameraToCenterDistance, ze.signedDistanceFromCamera);
                        let St = p.ai(b.textSizeData, I, we) * ut / p.ao;
                        u && (St *= b.tilePixelRatio / P);
                        const {
                            width: yt,
                            height: Vt,
                            anchor: ci,
                            textOffset: $t,
                            textBoxScale: gi
                        } = nt, Ri = ao(ci, yt, Vt, $t, gi, St), Ki = u ? On(bt.add(Ri), S, j).point : ze.point.add(n ? Ri.rotate(-_.angle) : Ri), wi = b.allowVerticalPlacement && we.placedOrientation === p.ah.vertical ? Math.PI / 2 : 0;
                        for (let $i = 0; $i < we.numGlyphs; $i++) p.aj(pe, Ki, wi);
                        G && we.associatedIconIndex >= 0 && (Me[we.associatedIconIndex] = {
                            shiftedAnchor: Ki,
                            angle: wi
                        })
                    } else It(we.numGlyphs, pe)
                }
                if (G) {
                    Ce.clear();
                    const ke = b.icon.placedSymbolArray;
                    for (let we = 0; we < ke.length; we++) {
                        const nt = ke.get(we);
                        if (nt.hidden) It(nt.numGlyphs, Ce);
                        else {
                            const bt = Me[we];
                            if (bt)
                                for (let ze = 0; ze < nt.numGlyphs; ze++) p.aj(Ce, bt.shiftedAnchor, bt.angle);
                            else It(nt.numGlyphs, Ce)
                        }
                    }
                    b.icon.dynamicLayoutVertexBuffer.updateData(Ce)
                }
                b.text.dynamicLayoutVertexBuffer.updateData(pe)
            }

            function ws(b, n, u) {
                return u.iconsInText && n ? "symbolTextAndIcon" : b ? "symbolSDF" : "symbolIcon"
            }

            function Es(b, n, u, f, _, S, L, P, I, G, j, ee) {
                const pe = b.context,
                    Ce = pe.gl,
                    Me = b.transform,
                    ke = P === "map",
                    we = I === "map",
                    nt = P !== "viewport" && u.layout.get("symbol-placement") !== "point",
                    bt = ke && !we && !nt,
                    ze = !u.layout.get("symbol-sort-key").isConstant();
                let ut = !1;
                const St = b.depthModeForSublayer(0, un.ReadOnly),
                    yt = u._unevaluatedLayout.hasValue("text-variable-anchor") || u._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
                    Vt = [];
                for (const ci of f) {
                    const $t = n.getTile(ci),
                        gi = $t.getBucket(u);
                    if (!gi) continue;
                    const Ri = _ ? gi.text : gi.icon;
                    if (!Ri || !Ri.segments.get().length || !Ri.hasVisibleVertices) continue;
                    const Ki = Ri.programConfigurations.get(u.id),
                        wi = _ || gi.sdfIcons,
                        $i = _ ? gi.textSizeData : gi.iconSizeData,
                        Vi = we || Me.pitch !== 0,
                        Jn = b.useProgram(ws(wi, _, gi), Ki),
                        xn = p.ag($i, Me.zoom),
                        mn = b.style.map.terrain && b.style.map.terrain.getTerrainData(ci);
                    let wn, Tr, Hn, sa, Gr = [0, 0],
                        hr = null;
                    if (_) Tr = $t.glyphAtlasTexture, Hn = Ce.LINEAR, wn = $t.glyphAtlasTexture.size, gi.iconsInText && (Gr = $t.imageAtlasTexture.size, hr = $t.imageAtlasTexture, sa = Vi || b.options.rotating || b.options.zooming || $i.kind === "composite" || $i.kind === "camera" ? Ce.LINEAR : Ce.NEAREST);
                    else {
                        const Zn = u.layout.get("icon-size").constantOr(0) !== 1 || gi.iconsNeedLinear;
                        Tr = $t.imageAtlasTexture, Hn = wi || b.options.rotating || b.options.zooming || Zn || Vi ? Ce.LINEAR : Ce.NEAREST, wn = $t.imageAtlasTexture.size
                    }
                    const da = on($t, 1, b.transform.zoom),
                        pa = ge(ci.posMatrix, we, ke, b.transform, da),
                        Ia = ga(ci.posMatrix, we, ke, b.transform, da),
                        Ts = yt && gi.hasTextData(),
                        mo = u.layout.get("icon-text-fit") !== "none" && Ts && gi.hasIconData();
                    if (nt) {
                        const Zn = b.style.map.terrain ? (ea, Dr) => b.style.map.terrain.getElevation(ci, ea, Dr) : null,
                            Zr = u.layout.get("text-rotation-alignment") === "map";
                        he(gi, ci.posMatrix, b, _, pa, Ia, we, G, Zr, Zn)
                    }
                    const No = b.translatePosMatrix(ci.posMatrix, $t, S, L),
                        Ms = nt || _ && yt || mo ? Lo : pa,
                        Mr = b.translatePosMatrix(Ia, $t, S, L, !0),
                        pr = wi && u.paint.get(_ ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
                    let yr;
                    yr = wi ? gi.iconsInText ? ai($i.kind, xn, bt, we, b, No, Ms, Mr, wn, Gr) : Pi($i.kind, xn, bt, we, b, No, Ms, Mr, _, wn, !0) : Ci($i.kind, xn, bt, we, b, No, Ms, Mr, _, wn);
                    const Ta = {
                        program: Jn,
                        buffers: Ri,
                        uniformValues: yr,
                        atlasTexture: Tr,
                        atlasTextureIcon: hr,
                        atlasInterpolation: Hn,
                        atlasInterpolationIcon: sa,
                        isSDF: wi,
                        hasHalo: pr
                    };
                    if (ze && gi.canOverlap) {
                        ut = !0;
                        const Zn = Ri.segments.get();
                        for (const Zr of Zn) Vt.push({
                            segments: new p.$([Zr]),
                            sortKey: Zr.sortKey,
                            state: Ta,
                            terrainData: mn
                        })
                    } else Vt.push({
                        segments: Ri.segments,
                        sortKey: 0,
                        state: Ta,
                        terrainData: mn
                    })
                }
                ut && Vt.sort((ci, $t) => ci.sortKey - $t.sortKey);
                for (const ci of Vt) {
                    const $t = ci.state;
                    if (pe.activeTexture.set(Ce.TEXTURE0), $t.atlasTexture.bind($t.atlasInterpolation, Ce.CLAMP_TO_EDGE), $t.atlasTextureIcon && (pe.activeTexture.set(Ce.TEXTURE1), $t.atlasTextureIcon && $t.atlasTextureIcon.bind($t.atlasInterpolationIcon, Ce.CLAMP_TO_EDGE)), $t.isSDF) {
                        const gi = $t.uniformValues;
                        $t.hasHalo && (gi.u_is_halo = 1, pl($t.buffers, ci.segments, u, b, $t.program, St, j, ee, gi, ci.terrainData)), gi.u_is_halo = 0
                    }
                    pl($t.buffers, ci.segments, u, b, $t.program, St, j, ee, $t.uniformValues, ci.terrainData)
                }
            }

            function pl(b, n, u, f, _, S, L, P, I, G) {
                const j = f.context;
                _.draw(j, j.gl.TRIANGLES, S, L, P, Dn.disabled, I, G, u.id, b.layoutVertexBuffer, b.indexBuffer, n, u.paint, f.transform.zoom, b.programConfigurations.get(u.id), b.dynamicLayoutVertexBuffer, b.opacityVertexBuffer)
            }

            function Us(b, n, u, f, _) {
                if (!u || !f || !f.imageAtlas) return;
                const S = f.imageAtlas.patternPositions;
                let L = S[u.to.toString()],
                    P = S[u.from.toString()];
                if (!L && P && (L = P), !P && L && (P = L), !L || !P) {
                    const I = _.getPaintProperty(n);
                    L = S[I], P = S[I]
                }
                L && P && b.setConstantPatternPositions(L, P)
            }

            function Pc(b, n, u, f, _, S, L) {
                const P = b.context.gl,
                    I = "fill-pattern",
                    G = u.paint.get(I),
                    j = G && G.constantOr(1),
                    ee = u.getCrossfadeParameters();
                let pe, Ce, Me, ke, we;
                L ? (Ce = j && !u.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", pe = P.LINES) : (Ce = j ? "fillPattern" : "fill", pe = P.TRIANGLES);
                const nt = G.constantOr(null);
                for (const bt of f) {
                    const ze = n.getTile(bt);
                    if (j && !ze.patternsLoaded()) continue;
                    const ut = ze.getBucket(u);
                    if (!ut) continue;
                    const St = ut.programConfigurations.get(u.id),
                        yt = b.useProgram(Ce, St),
                        Vt = b.style.map.terrain && b.style.map.terrain.getTerrainData(bt);
                    j && (b.context.activeTexture.set(P.TEXTURE0), ze.imageAtlasTexture.bind(P.LINEAR, P.CLAMP_TO_EDGE), St.updatePaintBuffers(ee)), Us(St, I, nt, ze, u);
                    const ci = Vt ? bt : null,
                        $t = b.translatePosMatrix(ci ? ci.posMatrix : bt.posMatrix, ze, u.paint.get("fill-translate"), u.paint.get("fill-translate-anchor"));
                    if (L) {
                        ke = ut.indexBuffer2, we = ut.segments2;
                        const gi = [P.drawingBufferWidth, P.drawingBufferHeight];
                        Me = Ce === "fillOutlinePattern" && j ? _t($t, b, ee, ze, gi) : Ft($t, gi)
                    } else ke = ut.indexBuffer, we = ut.segments, Me = j ? Et($t, b, ee, ze) : Pe($t);
                    yt.draw(b.context, pe, _, b.stencilModeForClipping(bt), S, Dn.disabled, Me, Vt, u.id, ut.layoutVertexBuffer, ke, we, u.paint, b.transform.zoom, St)
                }
            }

            function Hl(b, n, u, f, _, S, L) {
                const P = b.context,
                    I = P.gl,
                    G = "fill-extrusion-pattern",
                    j = u.paint.get(G),
                    ee = j.constantOr(1),
                    pe = u.getCrossfadeParameters(),
                    Ce = u.paint.get("fill-extrusion-opacity"),
                    Me = j.constantOr(null);
                for (const ke of f) {
                    const we = n.getTile(ke),
                        nt = we.getBucket(u);
                    if (!nt) continue;
                    const bt = b.style.map.terrain && b.style.map.terrain.getTerrainData(ke),
                        ze = nt.programConfigurations.get(u.id),
                        ut = b.useProgram(ee ? "fillExtrusionPattern" : "fillExtrusion", ze);
                    ee && (b.context.activeTexture.set(I.TEXTURE0), we.imageAtlasTexture.bind(I.LINEAR, I.CLAMP_TO_EDGE), ze.updatePaintBuffers(pe)), Us(ze, G, Me, we, u);
                    const St = b.translatePosMatrix(ke.posMatrix, we, u.paint.get("fill-extrusion-translate"), u.paint.get("fill-extrusion-translate-anchor")),
                        yt = u.paint.get("fill-extrusion-vertical-gradient"),
                        Vt = ee ? de(St, b, yt, Ce, ke, pe, we) : q(St, b, yt, Ce);
                    ut.draw(P, P.gl.TRIANGLES, _, S, L, Dn.backCCW, Vt, bt, u.id, nt.layoutVertexBuffer, nt.indexBuffer, nt.segments, u.paint, b.transform.zoom, ze, b.style.map.terrain && nt.centroidVertexBuffer)
                }
            }

            function Is(b, n, u, f, _, S, L) {
                const P = b.context,
                    I = P.gl,
                    G = u.fbo;
                if (!G) return;
                const j = b.useProgram("hillshade"),
                    ee = b.style.map.terrain && b.style.map.terrain.getTerrainData(n);
                P.activeTexture.set(I.TEXTURE0), I.bindTexture(I.TEXTURE_2D, G.colorAttachment.get()), j.draw(P, I.TRIANGLES, _, S, L, Dn.disabled, ((pe, Ce, Me, ke) => {
                    const we = Me.paint.get("hillshade-shadow-color"),
                        nt = Me.paint.get("hillshade-highlight-color"),
                        bt = Me.paint.get("hillshade-accent-color");
                    let ze = Me.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
                    Me.paint.get("hillshade-illumination-anchor") === "viewport" && (ze -= pe.transform.angle);
                    const ut = !pe.options.moving;
                    return {
                        u_matrix: ke ? ke.posMatrix : pe.transform.calculatePosMatrix(Ce.tileID.toUnwrapped(), ut),
                        u_image: 0,
                        u_latrange: me(0, Ce.tileID),
                        u_light: [Me.paint.get("hillshade-exaggeration"), ze],
                        u_shadow: we,
                        u_highlight: nt,
                        u_accent: bt
                    }
                })(b, u, f, ee ? n : null), ee, f.id, b.rasterBoundsBuffer, b.quadTriangleIndexBuffer, b.rasterBoundsSegments)
            }

            function An(b, n, u, f, _, S) {
                const L = b.context,
                    P = L.gl,
                    I = n.dem;
                if (I && I.data) {
                    const G = I.dim,
                        j = I.stride,
                        ee = I.getPixels();
                    if (L.activeTexture.set(P.TEXTURE1), L.pixelStoreUnpackPremultiplyAlpha.set(!1), n.demTexture = n.demTexture || b.getTileTexture(j), n.demTexture) {
                        const Ce = n.demTexture;
                        Ce.update(ee, {
                            premultiply: !1
                        }), Ce.bind(P.NEAREST, P.CLAMP_TO_EDGE)
                    } else n.demTexture = new je(L, ee, P.RGBA, {
                        premultiply: !1
                    }), n.demTexture.bind(P.NEAREST, P.CLAMP_TO_EDGE);
                    L.activeTexture.set(P.TEXTURE0);
                    let pe = n.fbo;
                    if (!pe) {
                        const Ce = new je(L, {
                            width: G,
                            height: G,
                            data: null
                        }, P.RGBA);
                        Ce.bind(P.LINEAR, P.CLAMP_TO_EDGE), pe = n.fbo = L.createFramebuffer(G, G, !0, !1), pe.colorAttachment.set(Ce.texture)
                    }
                    L.bindFramebuffer.set(pe.framebuffer), L.viewport.set([0, 0, G, G]), b.useProgram("hillshadePrepare").draw(L, P.TRIANGLES, f, _, S, Dn.disabled, ((Ce, Me) => {
                        const ke = Me.stride,
                            we = p.F();
                        return p.aN(we, 0, p.W, -p.W, 0, 0, 1), p.H(we, we, [0, -p.W, 0]), {
                            u_matrix: we,
                            u_image: 1,
                            u_dimension: [ke, ke],
                            u_zoom: Ce.overscaledZ,
                            u_unpack: Me.getUnpackVector()
                        }
                    })(n.tileID, I), null, u.id, b.rasterBoundsBuffer, b.quadTriangleIndexBuffer, b.rasterBoundsSegments), n.needsHillshadePrepare = !1
                }
            }

            function Oi(b, n, u, f, _, S) {
                const L = f.paint.get("raster-fade-duration");
                if (!S && L > 0) {
                    const P = be.now(),
                        I = (P - b.timeAdded) / L,
                        G = n ? (P - n.timeAdded) / L : -1,
                        j = u.getSource(),
                        ee = _.coveringZoomLevel({
                            tileSize: j.tileSize,
                            roundZoom: j.roundZoom
                        }),
                        pe = !n || Math.abs(n.tileID.overscaledZ - ee) > Math.abs(b.tileID.overscaledZ - ee),
                        Ce = pe && b.refreshedUponExpiration ? 1 : p.ac(pe ? I : 1 - G, 0, 1);
                    return b.refreshedUponExpiration && I >= 1 && (b.refreshedUponExpiration = !1), n ? {
                        opacity: 1,
                        mix: 1 - Ce
                    } : {
                        opacity: Ce,
                        mix: 0
                    }
                }
                return {
                    opacity: 1,
                    mix: 0
                }
            }
            const Ga = new p.aO(1, 0, 0, 1),
                Wl = new p.aO(0, 1, 0, 1),
                kc = new p.aO(0, 0, 1, 1),
                Qu = new p.aO(1, 0, 1, 1),
                Ph = new p.aO(0, 1, 1, 1);

            function Sr(b, n, u, f) {
                Sa(b, 0, n + u / 2, b.transform.width, u, f)
            }

            function zs(b, n, u, f) {
                Sa(b, n - u / 2, 0, u, b.transform.height, f)
            }

            function Sa(b, n, u, f, _, S) {
                const L = b.context,
                    P = L.gl;
                P.enable(P.SCISSOR_TEST), P.scissor(n * b.pixelRatio, u * b.pixelRatio, f * b.pixelRatio, _ * b.pixelRatio), L.clear({
                    color: S
                }), P.disable(P.SCISSOR_TEST)
            }

            function Dc(b, n, u) {
                const f = b.context,
                    _ = f.gl,
                    S = u.posMatrix,
                    L = b.useProgram("debug"),
                    P = un.disabled,
                    I = Cn.disabled,
                    G = b.colorModeForRenderPass(),
                    j = "$debug",
                    ee = b.style.map.terrain && b.style.map.terrain.getTerrainData(u);
                f.activeTexture.set(_.TEXTURE0);
                const pe = n.getTileByID(u.key).latestRawTileData,
                    Ce = Math.floor((pe && pe.byteLength || 0) / 1024),
                    Me = n.getTile(u).tileSize,
                    ke = 512 / Math.min(Me, 512) * (u.overscaledZ / b.transform.zoom) * .5;
                let we = u.canonical.toString();
                u.overscaledZ !== u.canonical.z && (we += ` => ${u.overscaledZ}`),
                    function(nt, bt) {
                        nt.initDebugOverlayCanvas();
                        const ze = nt.debugOverlayCanvas,
                            ut = nt.context.gl,
                            St = nt.debugOverlayCanvas.getContext("2d");
                        St.clearRect(0, 0, ze.width, ze.height), St.shadowColor = "white", St.shadowBlur = 2, St.lineWidth = 1.5, St.strokeStyle = "white", St.textBaseline = "top", St.font = "bold 36px Open Sans, sans-serif", St.fillText(bt, 5, 5), St.strokeText(bt, 5, 5), nt.debugOverlayTexture.update(ze), nt.debugOverlayTexture.bind(ut.LINEAR, ut.CLAMP_TO_EDGE)
                    }(b, `${we} ${Ce}kB`), L.draw(f, _.TRIANGLES, P, I, sr.alphaBlended, Dn.disabled, W(S, p.aO.transparent, ke), null, j, b.debugBuffer, b.quadTriangleIndexBuffer, b.debugSegments), L.draw(f, _.LINE_STRIP, P, I, G, Dn.disabled, W(S, p.aO.red), ee, j, b.debugBuffer, b.tileBorderIndexBuffer, b.debugSegments)
            }

            function Jl(b, n, u) {
                const f = b.context,
                    _ = f.gl,
                    S = b.colorModeForRenderPass(),
                    L = new un(_.LEQUAL, un.ReadWrite, b.depthRangeFor3D),
                    P = b.useProgram("terrain"),
                    I = n.getTerrainMesh();
                f.bindFramebuffer.set(null), f.viewport.set([0, 0, b.width, b.height]);
                for (const G of u) {
                    const j = b.renderToTexture.getTexture(G),
                        ee = n.getTerrainData(G.tileID);
                    f.activeTexture.set(_.TEXTURE0), _.bindTexture(_.TEXTURE_2D, j.texture);
                    const pe = {
                        u_matrix: b.transform.calculatePosMatrix(G.tileID.toUnwrapped()),
                        u_texture: 0,
                        u_ele_delta: n.getMeshFrameDelta(b.transform.zoom)
                    };
                    P.draw(f, _.TRIANGLES, L, Cn.disabled, S, Dn.backCCW, pe, ee, "terrain", I.vertexBuffer, I.indexBuffer, I.segments)
                }
            }
            class kh {
                constructor(n, u) {
                    this.context = new Fo(n), this.transform = u, this._tileTextures = {}, this.terrainFacilitator = {
                        dirty: !0,
                        matrix: p.F(),
                        renderTime: 0
                    }, this.setup(), this.numSublayers = cn.maxUnderzooming + cn.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new la
                }
                resize(n, u, f) {
                    if (this.width = Math.floor(n * f), this.height = Math.floor(u * f), this.pixelRatio = f, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
                        for (const _ of this.style._order) this.style._layers[_].resize()
                }
                setup() {
                    const n = this.context,
                        u = new p.aV;
                    u.emplaceBack(0, 0), u.emplaceBack(p.W, 0), u.emplaceBack(0, p.W), u.emplaceBack(p.W, p.W), this.tileExtentBuffer = n.createVertexBuffer(u, Ps.members), this.tileExtentSegments = p.$.simpleSegment(0, 0, 4, 2);
                    const f = new p.aV;
                    f.emplaceBack(0, 0), f.emplaceBack(p.W, 0), f.emplaceBack(0, p.W), f.emplaceBack(p.W, p.W), this.debugBuffer = n.createVertexBuffer(f, Ps.members), this.debugSegments = p.$.simpleSegment(0, 0, 4, 5);
                    const _ = new p.Z;
                    _.emplaceBack(0, 0, 0, 0), _.emplaceBack(p.W, 0, p.W, 0), _.emplaceBack(0, p.W, 0, p.W), _.emplaceBack(p.W, p.W, p.W, p.W), this.rasterBoundsBuffer = n.createVertexBuffer(_, bi.members), this.rasterBoundsSegments = p.$.simpleSegment(0, 0, 4, 2);
                    const S = new p.aV;
                    S.emplaceBack(0, 0), S.emplaceBack(1, 0), S.emplaceBack(0, 1), S.emplaceBack(1, 1), this.viewportBuffer = n.createVertexBuffer(S, Ps.members), this.viewportSegments = p.$.simpleSegment(0, 0, 4, 2);
                    const L = new p.aW;
                    L.emplaceBack(0), L.emplaceBack(1), L.emplaceBack(3), L.emplaceBack(2), L.emplaceBack(0), this.tileBorderIndexBuffer = n.createIndexBuffer(L);
                    const P = new p.aX;
                    P.emplaceBack(0, 1, 2), P.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = n.createIndexBuffer(P);
                    const I = this.context.gl;
                    this.stencilClearMode = new Cn({
                        func: I.ALWAYS,
                        mask: 0
                    }, 0, 255, I.ZERO, I.ZERO, I.ZERO)
                }
                clearStencil() {
                    const n = this.context,
                        u = n.gl;
                    this.nextStencilID = 1, this.currentStencilSource = void 0;
                    const f = p.F();
                    p.aN(f, 0, this.width, this.height, 0, 0, 1), p.J(f, f, [u.drawingBufferWidth, u.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(n, u.TRIANGLES, un.disabled, this.stencilClearMode, sr.disabled, Dn.disabled, re(f), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments)
                }
                _renderTileClippingMasks(n, u) {
                    if (this.currentStencilSource === n.source || !n.isTileClipped() || !u || !u.length) return;
                    this.currentStencilSource = n.source;
                    const f = this.context,
                        _ = f.gl;
                    this.nextStencilID + u.length > 256 && this.clearStencil(), f.setColorMode(sr.disabled), f.setDepthMode(un.disabled);
                    const S = this.useProgram("clippingMask");
                    this._tileClippingMaskIDs = {};
                    for (const L of u) {
                        const P = this._tileClippingMaskIDs[L.key] = this.nextStencilID++,
                            I = this.style.map.terrain && this.style.map.terrain.getTerrainData(L);
                        S.draw(f, _.TRIANGLES, un.disabled, new Cn({
                            func: _.ALWAYS,
                            mask: 0
                        }, P, 255, _.KEEP, _.KEEP, _.REPLACE), sr.disabled, Dn.disabled, re(L.posMatrix), I, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments)
                    }
                }
                stencilModeFor3D() {
                    this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
                    const n = this.nextStencilID++,
                        u = this.context.gl;
                    return new Cn({
                        func: u.NOTEQUAL,
                        mask: 255
                    }, n, 255, u.KEEP, u.KEEP, u.REPLACE)
                }
                stencilModeForClipping(n) {
                    const u = this.context.gl;
                    return new Cn({
                        func: u.EQUAL,
                        mask: 255
                    }, this._tileClippingMaskIDs[n.key], 0, u.KEEP, u.KEEP, u.REPLACE)
                }
                stencilConfigForOverlap(n) {
                    const u = this.context.gl,
                        f = n.sort((L, P) => P.overscaledZ - L.overscaledZ),
                        _ = f[f.length - 1].overscaledZ,
                        S = f[0].overscaledZ - _ + 1;
                    if (S > 1) {
                        this.currentStencilSource = void 0, this.nextStencilID + S > 256 && this.clearStencil();
                        const L = {};
                        for (let P = 0; P < S; P++) L[P + _] = new Cn({
                            func: u.GEQUAL,
                            mask: 255
                        }, P + this.nextStencilID, 255, u.KEEP, u.KEEP, u.REPLACE);
                        return this.nextStencilID += S, [L, f]
                    }
                    return [{
                        [_]: Cn.disabled
                    }, f]
                }
                colorModeForRenderPass() {
                    const n = this.context.gl;
                    return this._showOverdrawInspector ? new sr([n.CONSTANT_COLOR, n.ONE], new p.aO(.125, .125, .125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? sr.unblended : sr.alphaBlended
                }
                depthModeForSublayer(n, u, f) {
                    if (!this.opaquePassEnabledForLayer()) return un.disabled;
                    const _ = 1 - ((1 + this.currentLayer) * this.numSublayers + n) * this.depthEpsilon;
                    return new un(f || this.context.gl.LEQUAL, u, [_, _])
                }
                opaquePassEnabledForLayer() {
                    return this.currentLayer < this.opaquePassCutoff
                }
                render(n, u) {
                    this.style = n, this.options = u, this.lineAtlas = n.lineAtlas, this.imageManager = n.imageManager, this.glyphManager = n.glyphManager, this.symbolFadeChange = n.placement.symbolFadeChange(be.now()), this.imageManager.beginFrame();
                    const f = this.style._order,
                        _ = this.style.sourceCaches,
                        S = {},
                        L = {},
                        P = {};
                    for (const I in _) {
                        const G = _[I];
                        G.used && G.prepare(this.context), S[I] = G.getVisibleCoordinates(), L[I] = S[I].slice().reverse(), P[I] = G.getVisibleCoordinates(!0).reverse()
                    }
                    this.opaquePassCutoff = 1 / 0;
                    for (let I = 0; I < f.length; I++)
                        if (this.style._layers[f[I]].is3D()) {
                            this.opaquePassCutoff = I;
                            break
                        } if (this.renderToTexture) {
                        this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0;
                        const I = this.style.map.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime);
                        (this.terrainFacilitator.dirty || !p.aY(this.terrainFacilitator.matrix, this.transform.projMatrix) || I.length) && (p.aZ(this.terrainFacilitator.matrix, this.transform.projMatrix), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function(G, j) {
                            const ee = G.context,
                                pe = ee.gl,
                                Ce = sr.unblended,
                                Me = new un(pe.LEQUAL, un.ReadWrite, [0, 1]),
                                ke = j.getTerrainMesh(),
                                we = j.sourceCache.getRenderableTiles(),
                                nt = G.useProgram("terrainDepth");
                            ee.bindFramebuffer.set(j.getFramebuffer("depth").framebuffer), ee.viewport.set([0, 0, G.width / devicePixelRatio, G.height / devicePixelRatio]), ee.clear({
                                color: p.aO.transparent,
                                depth: 1
                            });
                            for (const bt of we) {
                                const ze = j.getTerrainData(bt.tileID),
                                    ut = {
                                        u_matrix: G.transform.calculatePosMatrix(bt.tileID.toUnwrapped()),
                                        u_ele_delta: j.getMeshFrameDelta(G.transform.zoom)
                                    };
                                nt.draw(ee, pe.TRIANGLES, Me, Cn.disabled, Ce, Dn.backCCW, ut, ze, "terrain", ke.vertexBuffer, ke.indexBuffer, ke.segments)
                            }
                            ee.bindFramebuffer.set(null), ee.viewport.set([0, 0, G.width, G.height])
                        }(this, this.style.map.terrain), function(G, j) {
                            const ee = G.context,
                                pe = ee.gl,
                                Ce = sr.unblended,
                                Me = new un(pe.LEQUAL, un.ReadWrite, [0, 1]),
                                ke = j.getTerrainMesh(),
                                we = j.getCoordsTexture(),
                                nt = j.sourceCache.getRenderableTiles(),
                                bt = G.useProgram("terrainCoords");
                            ee.bindFramebuffer.set(j.getFramebuffer("coords").framebuffer), ee.viewport.set([0, 0, G.width / devicePixelRatio, G.height / devicePixelRatio]), ee.clear({
                                color: p.aO.transparent,
                                depth: 1
                            }), j.coordsIndex = [];
                            for (const ze of nt) {
                                const ut = j.getTerrainData(ze.tileID);
                                ee.activeTexture.set(pe.TEXTURE0), pe.bindTexture(pe.TEXTURE_2D, we.texture);
                                const St = {
                                    u_matrix: G.transform.calculatePosMatrix(ze.tileID.toUnwrapped()),
                                    u_terrain_coords_id: (255 - j.coordsIndex.length) / 255,
                                    u_texture: 0,
                                    u_ele_delta: j.getMeshFrameDelta(G.transform.zoom)
                                };
                                bt.draw(ee, pe.TRIANGLES, Me, Cn.disabled, Ce, Dn.backCCW, St, ut, "terrain", ke.vertexBuffer, ke.indexBuffer, ke.segments), j.coordsIndex.push(ze.tileID.key)
                            }
                            ee.bindFramebuffer.set(null), ee.viewport.set([0, 0, G.width, G.height])
                        }(this, this.style.map.terrain))
                    }
                    this.renderPass = "offscreen";
                    for (const I of f) {
                        const G = this.style._layers[I];
                        if (!G.hasOffscreenPass() || G.isHidden(this.transform.zoom)) continue;
                        const j = L[G.source];
                        (G.type === "custom" || j.length) && this.renderLayer(this, _[G.source], G, j)
                    }
                    if (this.context.bindFramebuffer.set(null), this.context.clear({
                            color: u.showOverdrawInspector ? p.aO.black : p.aO.transparent,
                            depth: 1
                        }), this.clearStencil(), this._showOverdrawInspector = u.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (n._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture)
                        for (this.renderPass = "opaque", this.currentLayer = f.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                            const I = this.style._layers[f[this.currentLayer]],
                                G = _[I.source],
                                j = S[I.source];
                            this._renderTileClippingMasks(I, j), this.renderLayer(this, G, I, j)
                        }
                    for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < f.length; this.currentLayer++) {
                        const I = this.style._layers[f[this.currentLayer]],
                            G = _[I.source];
                        if (this.renderToTexture && this.renderToTexture.renderLayer(I)) continue;
                        const j = (I.type === "symbol" ? P : L)[I.source];
                        this._renderTileClippingMasks(I, S[I.source]), this.renderLayer(this, G, I, j)
                    }
                    if (this.options.showTileBoundaries) {
                        const I = function(G, j) {
                            let ee = null;
                            const pe = Object.values(G._layers).flatMap(we => we.source && !we.isHidden(j) ? [G.sourceCaches[we.source]] : []),
                                Ce = pe.filter(we => we.getSource().type === "vector"),
                                Me = pe.filter(we => we.getSource().type !== "vector"),
                                ke = we => {
                                    (!ee || ee.getSource().maxzoom < we.getSource().maxzoom) && (ee = we)
                                };
                            return Ce.forEach(we => ke(we)), ee || Me.forEach(we => ke(we)), ee
                        }(this.style, this.transform.zoom);
                        I && function(G, j, ee) {
                            for (let pe = 0; pe < ee.length; pe++) Dc(G, j, ee[pe])
                        }(this, I, I.getVisibleCoordinates())
                    }
                    this.options.showPadding && function(I) {
                        const G = I.transform.padding;
                        Sr(I, I.transform.height - (G.top || 0), 3, Ga), Sr(I, G.bottom || 0, 3, Wl), zs(I, G.left || 0, 3, kc), zs(I, I.transform.width - (G.right || 0), 3, Qu);
                        const j = I.transform.centerPoint;
                        (function(ee, pe, Ce, Me) {
                            Sa(ee, pe - 1, Ce - 10, 2, 20, Me), Sa(ee, pe - 10, Ce - 1, 20, 2, Me)
                        })(I, j.x, I.transform.height - j.y, Ph)
                    }(this), this.context.setDefault()
                }
                renderLayer(n, u, f, _) {
                    if (!f.isHidden(this.transform.zoom) && (f.type === "background" || f.type === "custom" || (_ || []).length)) switch (this.id = f.id, f.type) {
                        case "symbol":
                            (function(S, L, P, I, G) {
                                if (S.renderPass !== "translucent") return;
                                const j = Cn.disabled,
                                    ee = S.colorModeForRenderPass();
                                (P._unevaluatedLayout.hasValue("text-variable-anchor") || P._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(pe, Ce, Me, ke, we, nt, bt) {
                                    const ze = Ce.transform,
                                        ut = we === "map",
                                        St = nt === "map";
                                    for (const yt of pe) {
                                        const Vt = ke.getTile(yt),
                                            ci = Vt.getBucket(Me);
                                        if (!ci || !ci.text || !ci.text.segments.get().length) continue;
                                        const $t = p.ag(ci.textSizeData, ze.zoom),
                                            gi = on(Vt, 1, Ce.transform.zoom),
                                            Ri = ge(yt.posMatrix, St, ut, Ce.transform, gi),
                                            Ki = Me.layout.get("icon-text-fit") !== "none" && ci.hasIconData();
                                        if ($t) {
                                            const wi = Math.pow(2, ze.zoom - Vt.tileID.overscaledZ);
                                            so(ci, ut, St, bt, ze, Ri, yt.posMatrix, wi, $t, Ki, Ce.style.map.terrain ? ($i, Vi) => Ce.style.map.terrain.getElevation(yt, $i, Vi) : null)
                                        }
                                    }
                                }(I, S, P, L, P.layout.get("text-rotation-alignment"), P.layout.get("text-pitch-alignment"), G), P.paint.get("icon-opacity").constantOr(1) !== 0 && Es(S, L, P, I, !1, P.paint.get("icon-translate"), P.paint.get("icon-translate-anchor"), P.layout.get("icon-rotation-alignment"), P.layout.get("icon-pitch-alignment"), P.layout.get("icon-keep-upright"), j, ee), P.paint.get("text-opacity").constantOr(1) !== 0 && Es(S, L, P, I, !0, P.paint.get("text-translate"), P.paint.get("text-translate-anchor"), P.layout.get("text-rotation-alignment"), P.layout.get("text-pitch-alignment"), P.layout.get("text-keep-upright"), j, ee), L.map.showCollisionBoxes && (bs(S, L, P, I, P.paint.get("text-translate"), P.paint.get("text-translate-anchor"), !0), bs(S, L, P, I, P.paint.get("icon-translate"), P.paint.get("icon-translate-anchor"), !1))
                            })(n, u, f, _, this.style.placement.variableOffsets);
                            break;
                        case "circle":
                            (function(S, L, P, I) {
                                if (S.renderPass !== "translucent") return;
                                const G = P.paint.get("circle-opacity"),
                                    j = P.paint.get("circle-stroke-width"),
                                    ee = P.paint.get("circle-stroke-opacity"),
                                    pe = !P.layout.get("circle-sort-key").isConstant();
                                if (G.constantOr(1) === 0 && (j.constantOr(1) === 0 || ee.constantOr(1) === 0)) return;
                                const Ce = S.context,
                                    Me = Ce.gl,
                                    ke = S.depthModeForSublayer(0, un.ReadOnly),
                                    we = Cn.disabled,
                                    nt = S.colorModeForRenderPass(),
                                    bt = [];
                                for (let ze = 0; ze < I.length; ze++) {
                                    const ut = I[ze],
                                        St = L.getTile(ut),
                                        yt = St.getBucket(P);
                                    if (!yt) continue;
                                    const Vt = yt.programConfigurations.get(P.id),
                                        ci = S.useProgram("circle", Vt),
                                        $t = yt.layoutVertexBuffer,
                                        gi = yt.indexBuffer,
                                        Ri = S.style.map.terrain && S.style.map.terrain.getTerrainData(ut),
                                        Ki = {
                                            programConfiguration: Vt,
                                            program: ci,
                                            layoutVertexBuffer: $t,
                                            indexBuffer: gi,
                                            uniformValues: Yt(S, ut, St, P),
                                            terrainData: Ri
                                        };
                                    if (pe) {
                                        const wi = yt.segments.get();
                                        for (const $i of wi) bt.push({
                                            segments: new p.$([$i]),
                                            sortKey: $i.sortKey,
                                            state: Ki
                                        })
                                    } else bt.push({
                                        segments: yt.segments,
                                        sortKey: 0,
                                        state: Ki
                                    })
                                }
                                pe && bt.sort((ze, ut) => ze.sortKey - ut.sortKey);
                                for (const ze of bt) {
                                    const {
                                        programConfiguration: ut,
                                        program: St,
                                        layoutVertexBuffer: yt,
                                        indexBuffer: Vt,
                                        uniformValues: ci,
                                        terrainData: $t
                                    } = ze.state;
                                    St.draw(Ce, Me.TRIANGLES, ke, we, nt, Dn.disabled, ci, $t, P.id, yt, Vt, ze.segments, P.paint, S.transform.zoom, ut)
                                }
                            })(n, u, f, _);
                            break;
                        case "heatmap":
                            (function(S, L, P, I) {
                                if (P.paint.get("heatmap-opacity") !== 0)
                                    if (S.renderPass === "offscreen") {
                                        const G = S.context,
                                            j = G.gl,
                                            ee = Cn.disabled,
                                            pe = new sr([j.ONE, j.ONE], p.aO.transparent, [!0, !0, !0, !0]);
                                        (function(Ce, Me, ke) {
                                            const we = Ce.gl;
                                            Ce.activeTexture.set(we.TEXTURE1), Ce.viewport.set([0, 0, Me.width / 4, Me.height / 4]);
                                            let nt = ke.heatmapFbo;
                                            if (nt) we.bindTexture(we.TEXTURE_2D, nt.colorAttachment.get()), Ce.bindFramebuffer.set(nt.framebuffer);
                                            else {
                                                const bt = we.createTexture();
                                                we.bindTexture(we.TEXTURE_2D, bt), we.texParameteri(we.TEXTURE_2D, we.TEXTURE_WRAP_S, we.CLAMP_TO_EDGE), we.texParameteri(we.TEXTURE_2D, we.TEXTURE_WRAP_T, we.CLAMP_TO_EDGE), we.texParameteri(we.TEXTURE_2D, we.TEXTURE_MIN_FILTER, we.LINEAR), we.texParameteri(we.TEXTURE_2D, we.TEXTURE_MAG_FILTER, we.LINEAR), nt = ke.heatmapFbo = Ce.createFramebuffer(Me.width / 4, Me.height / 4, !1, !1),
                                                    function(ze, ut, St, yt) {
                                                        var Vt, ci;
                                                        const $t = ze.gl,
                                                            gi = (Vt = ze.HALF_FLOAT) !== null && Vt !== void 0 ? Vt : $t.UNSIGNED_BYTE,
                                                            Ri = (ci = ze.RGBA16F) !== null && ci !== void 0 ? ci : $t.RGBA;
                                                        $t.texImage2D($t.TEXTURE_2D, 0, Ri, ut.width / 4, ut.height / 4, 0, $t.RGBA, gi, null), yt.colorAttachment.set(St)
                                                    }(Ce, Me, bt, nt)
                                            }
                                        })(G, S, P), G.clear({
                                            color: p.aO.transparent
                                        });
                                        for (let Ce = 0; Ce < I.length; Ce++) {
                                            const Me = I[Ce];
                                            if (L.hasRenderableParent(Me)) continue;
                                            const ke = L.getTile(Me),
                                                we = ke.getBucket(P);
                                            if (!we) continue;
                                            const nt = we.programConfigurations.get(P.id),
                                                bt = S.useProgram("heatmap", nt),
                                                {
                                                    zoom: ze
                                                } = S.transform;
                                            bt.draw(G, j.TRIANGLES, un.disabled, ee, pe, Dn.disabled, ye(Me.posMatrix, ke, ze, P.paint.get("heatmap-intensity")), null, P.id, we.layoutVertexBuffer, we.indexBuffer, we.segments, P.paint, S.transform.zoom, nt)
                                        }
                                        G.viewport.set([0, 0, S.width, S.height])
                                    } else S.renderPass === "translucent" && (S.context.setColorMode(S.colorModeForRenderPass()), function(G, j) {
                                        const ee = G.context,
                                            pe = ee.gl,
                                            Ce = j.heatmapFbo;
                                        if (!Ce) return;
                                        ee.activeTexture.set(pe.TEXTURE0), pe.bindTexture(pe.TEXTURE_2D, Ce.colorAttachment.get()), ee.activeTexture.set(pe.TEXTURE1);
                                        let Me = j.colorRampTexture;
                                        Me || (Me = j.colorRampTexture = new je(ee, j.colorRamp, pe.RGBA)), Me.bind(pe.LINEAR, pe.CLAMP_TO_EDGE), G.useProgram("heatmapTexture").draw(ee, pe.TRIANGLES, un.disabled, Cn.disabled, G.colorModeForRenderPass(), Dn.disabled, ((ke, we, nt, bt) => {
                                            const ze = p.F();
                                            p.aN(ze, 0, ke.width, ke.height, 0, 0, 1);
                                            const ut = ke.context.gl;
                                            return {
                                                u_matrix: ze,
                                                u_world: [ut.drawingBufferWidth, ut.drawingBufferHeight],
                                                u_image: 0,
                                                u_color_ramp: 1,
                                                u_opacity: we.paint.get("heatmap-opacity")
                                            }
                                        })(G, j), null, j.id, G.viewportBuffer, G.quadTriangleIndexBuffer, G.viewportSegments, j.paint, G.transform.zoom)
                                    }(S, P))
                            })(n, u, f, _);
                            break;
                        case "line":
                            (function(S, L, P, I) {
                                if (S.renderPass !== "translucent") return;
                                const G = P.paint.get("line-opacity"),
                                    j = P.paint.get("line-width");
                                if (G.constantOr(1) === 0 || j.constantOr(1) === 0) return;
                                const ee = S.depthModeForSublayer(0, un.ReadOnly),
                                    pe = S.colorModeForRenderPass(),
                                    Ce = P.paint.get("line-dasharray"),
                                    Me = P.paint.get("line-pattern"),
                                    ke = Me.constantOr(1),
                                    we = P.paint.get("line-gradient"),
                                    nt = P.getCrossfadeParameters(),
                                    bt = ke ? "linePattern" : Ce ? "lineSDF" : we ? "lineGradient" : "line",
                                    ze = S.context,
                                    ut = ze.gl;
                                let St = !0;
                                for (const yt of I) {
                                    const Vt = L.getTile(yt);
                                    if (ke && !Vt.patternsLoaded()) continue;
                                    const ci = Vt.getBucket(P);
                                    if (!ci) continue;
                                    const $t = ci.programConfigurations.get(P.id),
                                        gi = S.context.program.get(),
                                        Ri = S.useProgram(bt, $t),
                                        Ki = St || Ri.program !== gi,
                                        wi = S.style.map.terrain && S.style.map.terrain.getTerrainData(yt),
                                        $i = Me.constantOr(null);
                                    if ($i && Vt.imageAtlas) {
                                        const xn = Vt.imageAtlas,
                                            mn = xn.patternPositions[$i.to.toString()],
                                            wn = xn.patternPositions[$i.from.toString()];
                                        mn && wn && $t.setConstantPatternPositions(mn, wn)
                                    }
                                    const Vi = wi ? yt : null,
                                        Jn = ke ? Mt(S, Vt, P, nt, Vi) : Ce ? si(S, Vt, P, Ce, nt, Vi) : we ? At(S, Vt, P, ci.lineClipsArray.length, Vi) : rt(S, Vt, P, Vi);
                                    if (ke) ze.activeTexture.set(ut.TEXTURE0), Vt.imageAtlasTexture.bind(ut.LINEAR, ut.CLAMP_TO_EDGE), $t.updatePaintBuffers(nt);
                                    else if (Ce && (Ki || S.lineAtlas.dirty)) ze.activeTexture.set(ut.TEXTURE0), S.lineAtlas.bind(ze);
                                    else if (we) {
                                        const xn = ci.gradients[P.id];
                                        let mn = xn.texture;
                                        if (P.gradientVersion !== xn.version) {
                                            let wn = 256;
                                            if (P.stepInterpolant) {
                                                const Tr = L.getSource().maxzoom,
                                                    Hn = yt.canonical.z === Tr ? Math.ceil(1 << S.transform.maxZoom - yt.canonical.z) : 1;
                                                wn = p.ac(p.aT(ci.maxLineLength / p.W * 1024 * Hn), 256, ze.maxTextureSize)
                                            }
                                            xn.gradient = p.aU({
                                                expression: P.gradientExpression(),
                                                evaluationKey: "lineProgress",
                                                resolution: wn,
                                                image: xn.gradient || void 0,
                                                clips: ci.lineClipsArray
                                            }), xn.texture ? xn.texture.update(xn.gradient) : xn.texture = new je(ze, xn.gradient, ut.RGBA), xn.version = P.gradientVersion, mn = xn.texture
                                        }
                                        ze.activeTexture.set(ut.TEXTURE0), mn.bind(P.stepInterpolant ? ut.NEAREST : ut.LINEAR, ut.CLAMP_TO_EDGE)
                                    }
                                    Ri.draw(ze, ut.TRIANGLES, ee, S.stencilModeForClipping(yt), pe, Dn.disabled, Jn, wi, P.id, ci.layoutVertexBuffer, ci.indexBuffer, ci.segments, P.paint, S.transform.zoom, $t, ci.layoutVertexBuffer2), St = !1
                                }
                            })(n, u, f, _);
                            break;
                        case "fill":
                            (function(S, L, P, I) {
                                const G = P.paint.get("fill-color"),
                                    j = P.paint.get("fill-opacity");
                                if (j.constantOr(1) === 0) return;
                                const ee = S.colorModeForRenderPass(),
                                    pe = P.paint.get("fill-pattern"),
                                    Ce = S.opaquePassEnabledForLayer() && !pe.constantOr(1) && G.constantOr(p.aO.transparent).a === 1 && j.constantOr(0) === 1 ? "opaque" : "translucent";
                                if (S.renderPass === Ce) {
                                    const Me = S.depthModeForSublayer(1, S.renderPass === "opaque" ? un.ReadWrite : un.ReadOnly);
                                    Pc(S, L, P, I, Me, ee, !1)
                                }
                                if (S.renderPass === "translucent" && P.paint.get("fill-antialias")) {
                                    const Me = S.depthModeForSublayer(P.getPaintProperty("fill-outline-color") ? 2 : 0, un.ReadOnly);
                                    Pc(S, L, P, I, Me, ee, !0)
                                }
                            })(n, u, f, _);
                            break;
                        case "fill-extrusion":
                            (function(S, L, P, I) {
                                const G = P.paint.get("fill-extrusion-opacity");
                                if (G !== 0 && S.renderPass === "translucent") {
                                    const j = new un(S.context.gl.LEQUAL, un.ReadWrite, S.depthRangeFor3D);
                                    if (G !== 1 || P.paint.get("fill-extrusion-pattern").constantOr(1)) Hl(S, L, P, I, j, Cn.disabled, sr.disabled), Hl(S, L, P, I, j, S.stencilModeFor3D(), S.colorModeForRenderPass());
                                    else {
                                        const ee = S.colorModeForRenderPass();
                                        Hl(S, L, P, I, j, Cn.disabled, ee)
                                    }
                                }
                            })(n, u, f, _);
                            break;
                        case "hillshade":
                            (function(S, L, P, I) {
                                if (S.renderPass !== "offscreen" && S.renderPass !== "translucent") return;
                                const G = S.context,
                                    j = S.depthModeForSublayer(0, un.ReadOnly),
                                    ee = S.colorModeForRenderPass(),
                                    [pe, Ce] = S.renderPass === "translucent" ? S.stencilConfigForOverlap(I) : [{}, I];
                                for (const Me of Ce) {
                                    const ke = L.getTile(Me);
                                    ke.needsHillshadePrepare !== void 0 && ke.needsHillshadePrepare && S.renderPass === "offscreen" ? An(S, ke, P, j, Cn.disabled, ee) : S.renderPass === "translucent" && Is(S, Me, ke, P, j, pe[Me.overscaledZ], ee)
                                }
                                G.viewport.set([0, 0, S.width, S.height])
                            })(n, u, f, _);
                            break;
                        case "raster":
                            (function(S, L, P, I) {
                                if (S.renderPass !== "translucent" || P.paint.get("raster-opacity") === 0 || !I.length) return;
                                const G = S.context,
                                    j = G.gl,
                                    ee = L.getSource(),
                                    pe = S.useProgram("raster"),
                                    Ce = S.colorModeForRenderPass(),
                                    [Me, ke] = ee instanceof Qi ? [{}, I] : S.stencilConfigForOverlap(I),
                                    we = ke[ke.length - 1].overscaledZ,
                                    nt = !S.options.moving;
                                for (const bt of ke) {
                                    const ze = S.depthModeForSublayer(bt.overscaledZ - we, P.paint.get("raster-opacity") === 1 ? un.ReadWrite : un.ReadOnly, j.LESS),
                                        ut = L.getTile(bt);
                                    ut.registerFadeDuration(P.paint.get("raster-fade-duration"));
                                    const St = L.findLoadedParent(bt, 0),
                                        yt = Oi(ut, St, L, P, S.transform, S.style.map.terrain);
                                    let Vt, ci;
                                    const $t = P.paint.get("raster-resampling") === "nearest" ? j.NEAREST : j.LINEAR;
                                    G.activeTexture.set(j.TEXTURE0), ut.texture.bind($t, j.CLAMP_TO_EDGE, j.LINEAR_MIPMAP_NEAREST), G.activeTexture.set(j.TEXTURE1), St ? (St.texture.bind($t, j.CLAMP_TO_EDGE, j.LINEAR_MIPMAP_NEAREST), Vt = Math.pow(2, St.tileID.overscaledZ - ut.tileID.overscaledZ), ci = [ut.tileID.canonical.x * Vt % 1, ut.tileID.canonical.y * Vt % 1]) : ut.texture.bind($t, j.CLAMP_TO_EDGE, j.LINEAR_MIPMAP_NEAREST);
                                    const gi = S.style.map.terrain && S.style.map.terrain.getTerrainData(bt),
                                        Ri = gi ? bt : null,
                                        Ki = Ri ? Ri.posMatrix : S.transform.calculatePosMatrix(bt.toUnwrapped(), nt),
                                        wi = ri(Ki, ci || [0, 0], Vt || 1, yt, P);
                                    ee instanceof Qi ? pe.draw(G, j.TRIANGLES, ze, Cn.disabled, Ce, Dn.disabled, wi, gi, P.id, ee.boundsBuffer, S.quadTriangleIndexBuffer, ee.boundsSegments) : pe.draw(G, j.TRIANGLES, ze, Me[bt.overscaledZ], Ce, Dn.disabled, wi, gi, P.id, S.rasterBoundsBuffer, S.quadTriangleIndexBuffer, S.rasterBoundsSegments)
                                }
                            })(n, u, f, _);
                            break;
                        case "background":
                            (function(S, L, P, I) {
                                const G = P.paint.get("background-color"),
                                    j = P.paint.get("background-opacity");
                                if (j === 0) return;
                                const ee = S.context,
                                    pe = ee.gl,
                                    Ce = S.transform,
                                    Me = Ce.tileSize,
                                    ke = P.paint.get("background-pattern");
                                if (S.isPatternMissing(ke)) return;
                                const we = !ke && G.a === 1 && j === 1 && S.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                                if (S.renderPass !== we) return;
                                const nt = Cn.disabled,
                                    bt = S.depthModeForSublayer(0, we === "opaque" ? un.ReadWrite : un.ReadOnly),
                                    ze = S.colorModeForRenderPass(),
                                    ut = S.useProgram(ke ? "backgroundPattern" : "background"),
                                    St = I || Ce.coveringTiles({
                                        tileSize: Me,
                                        terrain: S.style.map.terrain
                                    });
                                ke && (ee.activeTexture.set(pe.TEXTURE0), S.imageManager.bind(S.context));
                                const yt = P.getCrossfadeParameters();
                                for (const Vt of St) {
                                    const ci = I ? Vt.posMatrix : S.transform.calculatePosMatrix(Vt.toUnwrapped()),
                                        $t = ke ? Gi(ci, j, S, ke, {
                                            tileID: Vt,
                                            tileSize: Me
                                        }, yt) : Rt(ci, j, G),
                                        gi = S.style.map.terrain && S.style.map.terrain.getTerrainData(Vt);
                                    ut.draw(ee, pe.TRIANGLES, bt, nt, ze, Dn.disabled, $t, gi, P.id, S.tileExtentBuffer, S.quadTriangleIndexBuffer, S.tileExtentSegments)
                                }
                            })(n, 0, f, _);
                            break;
                        case "custom":
                            (function(S, L, P) {
                                const I = S.context,
                                    G = P.implementation;
                                if (S.renderPass === "offscreen") {
                                    const j = G.prerender;
                                    j && (S.setCustomLayerDefaults(), I.setColorMode(S.colorModeForRenderPass()), j.call(G, I.gl, S.transform.customLayerMatrix()), I.setDirty(), S.setBaseState())
                                } else if (S.renderPass === "translucent") {
                                    S.setCustomLayerDefaults(), I.setColorMode(S.colorModeForRenderPass()), I.setStencilMode(Cn.disabled);
                                    const j = G.renderingMode === "3d" ? new un(S.context.gl.LEQUAL, un.ReadWrite, S.depthRangeFor3D) : S.depthModeForSublayer(0, un.ReadOnly);
                                    I.setDepthMode(j), G.render(I.gl, S.transform.customLayerMatrix()), I.setDirty(), S.setBaseState(), I.bindFramebuffer.set(null)
                                }
                            })(n, 0, f)
                    }
                }
                translatePosMatrix(n, u, f, _, S) {
                    if (!f[0] && !f[1]) return n;
                    const L = S ? _ === "map" ? this.transform.angle : 0 : _ === "viewport" ? -this.transform.angle : 0;
                    if (L) {
                        const G = Math.sin(L),
                            j = Math.cos(L);
                        f = [f[0] * j - f[1] * G, f[0] * G + f[1] * j]
                    }
                    const P = [S ? f[0] : on(u, f[0], this.transform.zoom), S ? f[1] : on(u, f[1], this.transform.zoom), 0],
                        I = new Float32Array(16);
                    return p.H(I, n, P), I
                }
                saveTileTexture(n) {
                    const u = this._tileTextures[n.size[0]];
                    u ? u.push(n) : this._tileTextures[n.size[0]] = [n]
                }
                getTileTexture(n) {
                    const u = this._tileTextures[n];
                    return u && u.length > 0 ? u.pop() : null
                }
                isPatternMissing(n) {
                    if (!n) return !1;
                    if (!n.from || !n.to) return !0;
                    const u = this.imageManager.getPattern(n.from.toString()),
                        f = this.imageManager.getPattern(n.to.toString());
                    return !u || !f
                }
                useProgram(n, u) {
                    this.cache = this.cache || {};
                    const f = n + (u ? u.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.map.terrain ? "/terrain" : "");
                    return this.cache[f] || (this.cache[f] = new Da(this.context, $n[n], u, ki[n], this._showOverdrawInspector, this.style.map.terrain)), this.cache[f]
                }
                setCustomLayerDefaults() {
                    this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault()
                }
                setBaseState() {
                    const n = this.context.gl;
                    this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(n.FUNC_ADD)
                }
                initDebugOverlayCanvas() {
                    this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new je(this.context, this.debugOverlayCanvas, this.context.gl.RGBA))
                }
                destroy() {
                    this.debugOverlayTexture && this.debugOverlayTexture.destroy()
                }
                overLimit() {
                    const {
                        drawingBufferWidth: n,
                        drawingBufferHeight: u
                    } = this.context.gl;
                    return this.width !== n || this.height !== u
                }
            }
            class Ns {
                constructor(n, u) {
                    this.points = n, this.planes = u
                }
                static fromInvProjectionMatrix(n, u, f) {
                    const _ = Math.pow(2, f),
                        S = [
                            [-1, 1, -1, 1],
                            [1, 1, -1, 1],
                            [1, -1, -1, 1],
                            [-1, -1, -1, 1],
                            [-1, 1, 1, 1],
                            [1, 1, 1, 1],
                            [1, -1, 1, 1],
                            [-1, -1, 1, 1]
                        ].map(P => {
                            const I = 1 / (P = p.af([], P, n))[3] / u * _;
                            return p.a_(P, P, [I, I, 1 / P[3], I])
                        }),
                        L = [
                            [0, 1, 2],
                            [6, 5, 4],
                            [0, 3, 7],
                            [2, 1, 5],
                            [3, 2, 6],
                            [0, 4, 5]
                        ].map(P => {
                            const I = function(pe, Ce) {
                                    var Me = Ce[0],
                                        ke = Ce[1],
                                        we = Ce[2],
                                        nt = Me * Me + ke * ke + we * we;
                                    return nt > 0 && (nt = 1 / Math.sqrt(nt)), pe[0] = Ce[0] * nt, pe[1] = Ce[1] * nt, pe[2] = Ce[2] * nt, pe
                                }([], function(pe, Ce, Me) {
                                    var ke = Ce[0],
                                        we = Ce[1],
                                        nt = Ce[2],
                                        bt = Me[0],
                                        ze = Me[1],
                                        ut = Me[2];
                                    return pe[0] = we * ut - nt * ze, pe[1] = nt * bt - ke * ut, pe[2] = ke * ze - we * bt, pe
                                }([], Li([], S[P[0]], S[P[1]]), Li([], S[P[2]], S[P[1]]))),
                                G = -((j = I)[0] * (ee = S[P[1]])[0] + j[1] * ee[1] + j[2] * ee[2]);
                            var j, ee;
                            return I.concat(G)
                        });
                    return new Ns(S, L)
                }
            }
            class Os {
                constructor(n, u) {
                    this.min = n, this.max = u, this.center = function(f, _, S) {
                        return f[0] = .5 * _[0], f[1] = .5 * _[1], f[2] = .5 * _[2], f
                    }([], function(f, _, S) {
                        return f[0] = _[0] + S[0], f[1] = _[1] + S[1], f[2] = _[2] + S[2], f
                    }([], this.min, this.max))
                }
                quadrant(n) {
                    const u = [n % 2 == 0, n < 2],
                        f = Kt(this.min),
                        _ = Kt(this.max);
                    for (let S = 0; S < u.length; S++) f[S] = u[S] ? this.min[S] : this.center[S], _[S] = u[S] ? this.center[S] : this.max[S];
                    return _[2] = this.max[2], new Os(f, _)
                }
                distanceX(n) {
                    return Math.max(Math.min(this.max[0], n[0]), this.min[0]) - n[0]
                }
                distanceY(n) {
                    return Math.max(Math.min(this.max[1], n[1]), this.min[1]) - n[1]
                }
                intersects(n) {
                    const u = [
                        [this.min[0], this.min[1], this.min[2], 1],
                        [this.max[0], this.min[1], this.min[2], 1],
                        [this.max[0], this.max[1], this.min[2], 1],
                        [this.min[0], this.max[1], this.min[2], 1],
                        [this.min[0], this.min[1], this.max[2], 1],
                        [this.max[0], this.min[1], this.max[2], 1],
                        [this.max[0], this.max[1], this.max[2], 1],
                        [this.min[0], this.max[1], this.max[2], 1]
                    ];
                    let f = !0;
                    for (let _ = 0; _ < n.planes.length; _++) {
                        const S = n.planes[_];
                        let L = 0;
                        for (let P = 0; P < u.length; P++) p.a$(S, u[P]) >= 0 && L++;
                        if (L === 0) return 0;
                        L !== u.length && (f = !1)
                    }
                    if (f) return 2;
                    for (let _ = 0; _ < 3; _++) {
                        let S = Number.MAX_VALUE,
                            L = -Number.MAX_VALUE;
                        for (let P = 0; P < n.points.length; P++) {
                            const I = n.points[P][_] - this.min[_];
                            S = Math.min(S, I), L = Math.max(L, I)
                        }
                        if (L < 0 || S > this.max[_] - this.min[_]) return 0
                    }
                    return 1
                }
            }
            class Qo {
                constructor(n = 0, u = 0, f = 0, _ = 0) {
                    if (isNaN(n) || n < 0 || isNaN(u) || u < 0 || isNaN(f) || f < 0 || isNaN(_) || _ < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
                    this.top = n, this.bottom = u, this.left = f, this.right = _
                }
                interpolate(n, u, f) {
                    return u.top != null && n.top != null && (this.top = p.z.number(n.top, u.top, f)), u.bottom != null && n.bottom != null && (this.bottom = p.z.number(n.bottom, u.bottom, f)), u.left != null && n.left != null && (this.left = p.z.number(n.left, u.left, f)), u.right != null && n.right != null && (this.right = p.z.number(n.right, u.right, f)), this
                }
                getCenter(n, u) {
                    const f = p.ac((this.left + n - this.right) / 2, 0, n),
                        _ = p.ac((this.top + u - this.bottom) / 2, 0, u);
                    return new p.P(f, _)
                }
                equals(n) {
                    return this.top === n.top && this.bottom === n.bottom && this.left === n.left && this.right === n.right
                }
                clone() {
                    return new Qo(this.top, this.bottom, this.left, this.right)
                }
                toJSON() {
                    return {
                        top: this.top,
                        bottom: this.bottom,
                        left: this.left,
                        right: this.right
                    }
                }
            }
            class Zl {
                constructor(n, u, f, _, S) {
                    this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = S === void 0 || !!S, this._minZoom = n || 0, this._maxZoom = u || 22, this._minPitch = f == null ? 0 : f, this._maxPitch = _ == null ? 60 : _, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new p.M(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._unmodified = !0, this._edgeInsets = new Qo, this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this.minElevationForCurrentTile = 0
                }
                clone() {
                    const n = new Zl(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
                    return n.apply(this), n
                }
                apply(n) {
                    this.tileSize = n.tileSize, this.latRange = n.latRange, this.width = n.width, this.height = n.height, this._center = n._center, this._elevation = n._elevation, this.minElevationForCurrentTile = n.minElevationForCurrentTile, this.zoom = n.zoom, this.angle = n.angle, this._fov = n._fov, this._pitch = n._pitch, this._unmodified = n._unmodified, this._edgeInsets = n._edgeInsets.clone(), this._calcMatrices()
                }
                get minZoom() {
                    return this._minZoom
                }
                set minZoom(n) {
                    this._minZoom !== n && (this._minZoom = n, this.zoom = Math.max(this.zoom, n))
                }
                get maxZoom() {
                    return this._maxZoom
                }
                set maxZoom(n) {
                    this._maxZoom !== n && (this._maxZoom = n, this.zoom = Math.min(this.zoom, n))
                }
                get minPitch() {
                    return this._minPitch
                }
                set minPitch(n) {
                    this._minPitch !== n && (this._minPitch = n, this.pitch = Math.max(this.pitch, n))
                }
                get maxPitch() {
                    return this._maxPitch
                }
                set maxPitch(n) {
                    this._maxPitch !== n && (this._maxPitch = n, this.pitch = Math.min(this.pitch, n))
                }
                get renderWorldCopies() {
                    return this._renderWorldCopies
                }
                set renderWorldCopies(n) {
                    n === void 0 ? n = !0 : n === null && (n = !1), this._renderWorldCopies = n
                }
                get worldSize() {
                    return this.tileSize * this.scale
                }
                get centerOffset() {
                    return this.centerPoint._sub(this.size._div(2))
                }
                get size() {
                    return new p.P(this.width, this.height)
                }
                get bearing() {
                    return -this.angle / Math.PI * 180
                }
                set bearing(n) {
                    const u = -p.b0(n, -180, 180) * Math.PI / 180;
                    this.angle !== u && (this._unmodified = !1, this.angle = u, this._calcMatrices(), this.rotationMatrix = function() {
                        var f = new p.A(4);
                        return p.A != Float32Array && (f[1] = 0, f[2] = 0), f[0] = 1, f[3] = 1, f
                    }(), function(f, _, S) {
                        var L = _[0],
                            P = _[1],
                            I = _[2],
                            G = _[3],
                            j = Math.sin(S),
                            ee = Math.cos(S);
                        f[0] = L * ee + I * j, f[1] = P * ee + G * j, f[2] = L * -j + I * ee, f[3] = P * -j + G * ee
                    }(this.rotationMatrix, this.rotationMatrix, this.angle))
                }
                get pitch() {
                    return this._pitch / Math.PI * 180
                }
                set pitch(n) {
                    const u = p.ac(n, this.minPitch, this.maxPitch) / 180 * Math.PI;
                    this._pitch !== u && (this._unmodified = !1, this._pitch = u, this._calcMatrices())
                }
                get fov() {
                    return this._fov / Math.PI * 180
                }
                set fov(n) {
                    n = Math.max(.01, Math.min(60, n)), this._fov !== n && (this._unmodified = !1, this._fov = n / 180 * Math.PI, this._calcMatrices())
                }
                get zoom() {
                    return this._zoom
                }
                set zoom(n) {
                    const u = Math.min(Math.max(n, this.minZoom), this.maxZoom);
                    this._zoom !== u && (this._unmodified = !1, this._zoom = u, this.tileZoom = Math.max(0, Math.floor(u)), this.scale = this.zoomScale(u), this._constrain(), this._calcMatrices())
                }
                get center() {
                    return this._center
                }
                set center(n) {
                    n.lat === this._center.lat && n.lng === this._center.lng || (this._unmodified = !1, this._center = n, this._constrain(), this._calcMatrices())
                }
                get elevation() {
                    return this._elevation
                }
                set elevation(n) {
                    n !== this._elevation && (this._elevation = n, this._constrain(), this._calcMatrices())
                }
                get padding() {
                    return this._edgeInsets.toJSON()
                }
                set padding(n) {
                    this._edgeInsets.equals(n) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, n, 1), this._calcMatrices())
                }
                get centerPoint() {
                    return this._edgeInsets.getCenter(this.width, this.height)
                }
                isPaddingEqual(n) {
                    return this._edgeInsets.equals(n)
                }
                interpolatePadding(n, u, f) {
                    this._unmodified = !1, this._edgeInsets.interpolate(n, u, f), this._constrain(), this._calcMatrices()
                }
                coveringZoomLevel(n) {
                    const u = (n.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / n.tileSize));
                    return Math.max(0, u)
                }
                getVisibleUnwrappedCoordinates(n) {
                    const u = [new p.b1(0, n)];
                    if (this._renderWorldCopies) {
                        const f = this.pointCoordinate(new p.P(0, 0)),
                            _ = this.pointCoordinate(new p.P(this.width, 0)),
                            S = this.pointCoordinate(new p.P(this.width, this.height)),
                            L = this.pointCoordinate(new p.P(0, this.height)),
                            P = Math.floor(Math.min(f.x, _.x, S.x, L.x)),
                            I = Math.floor(Math.max(f.x, _.x, S.x, L.x)),
                            G = 1;
                        for (let j = P - G; j <= I + G; j++) j !== 0 && u.push(new p.b1(j, n))
                    }
                    return u
                }
                coveringTiles(n) {
                    var u, f;
                    let _ = this.coveringZoomLevel(n);
                    const S = _;
                    if (n.minzoom !== void 0 && _ < n.minzoom) return [];
                    n.maxzoom !== void 0 && _ > n.maxzoom && (_ = n.maxzoom);
                    const L = this.pointCoordinate(this.getCameraPoint()),
                        P = p.Y.fromLngLat(this.center),
                        I = Math.pow(2, _),
                        G = [I * L.x, I * L.y, 0],
                        j = [I * P.x, I * P.y, 0],
                        ee = Ns.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, _);
                    let pe = n.minzoom || 0;
                    !n.terrain && this.pitch <= 60 && this._edgeInsets.top < .1 && (pe = _);
                    const Ce = n.terrain ? 2 / Math.min(this.tileSize, n.tileSize) * this.tileSize : 3,
                        Me = ze => ({
                            aabb: new Os([ze * I, 0, 0], [(ze + 1) * I, I, 0]),
                            zoom: 0,
                            x: 0,
                            y: 0,
                            wrap: ze,
                            fullyVisible: !1
                        }),
                        ke = [],
                        we = [],
                        nt = _,
                        bt = n.reparseOverscaled ? S : _;
                    if (this._renderWorldCopies)
                        for (let ze = 1; ze <= 3; ze++) ke.push(Me(-ze)), ke.push(Me(ze));
                    for (ke.push(Me(0)); ke.length > 0;) {
                        const ze = ke.pop(),
                            ut = ze.x,
                            St = ze.y;
                        let yt = ze.fullyVisible;
                        if (!yt) {
                            const Ri = ze.aabb.intersects(ee);
                            if (Ri === 0) continue;
                            yt = Ri === 2
                        }
                        const Vt = n.terrain ? G : j,
                            ci = ze.aabb.distanceX(Vt),
                            $t = ze.aabb.distanceY(Vt),
                            gi = Math.max(Math.abs(ci), Math.abs($t));
                        if (ze.zoom === nt || gi > Ce + (1 << nt - ze.zoom) - 2 && ze.zoom >= pe) {
                            const Ri = nt - ze.zoom,
                                Ki = G[0] - .5 - (ut << Ri),
                                wi = G[1] - .5 - (St << Ri);
                            we.push({
                                tileID: new p.Q(ze.zoom === nt ? bt : ze.zoom, ze.wrap, ze.zoom, ut, St),
                                distanceSq: Ei([j[0] - .5 - ut, j[1] - .5 - St]),
                                tileDistanceToCamera: Math.sqrt(Ki * Ki + wi * wi)
                            })
                        } else
                            for (let Ri = 0; Ri < 4; Ri++) {
                                const Ki = (ut << 1) + Ri % 2,
                                    wi = (St << 1) + (Ri >> 1),
                                    $i = ze.zoom + 1;
                                let Vi = ze.aabb.quadrant(Ri);
                                if (n.terrain) {
                                    const Jn = new p.Q($i, ze.wrap, $i, Ki, wi),
                                        xn = n.terrain.getMinMaxElevation(Jn),
                                        mn = (u = xn.minElevation) !== null && u !== void 0 ? u : this.elevation,
                                        wn = (f = xn.maxElevation) !== null && f !== void 0 ? f : this.elevation;
                                    Vi = new Os([Vi.min[0], Vi.min[1], mn], [Vi.max[0], Vi.max[1], wn])
                                }
                                ke.push({
                                    aabb: Vi,
                                    zoom: $i,
                                    x: Ki,
                                    y: wi,
                                    wrap: ze.wrap,
                                    fullyVisible: yt
                                })
                            }
                    }
                    return we.sort((ze, ut) => ze.distanceSq - ut.distanceSq).map(ze => ze.tileID)
                }
                resize(n, u) {
                    this.width = n, this.height = u, this.pixelsToGLUnits = [2 / n, -2 / u], this._constrain(), this._calcMatrices()
                }
                get unmodified() {
                    return this._unmodified
                }
                zoomScale(n) {
                    return Math.pow(2, n)
                }
                scaleZoom(n) {
                    return Math.log(n) / Math.LN2
                }
                project(n) {
                    const u = p.ac(n.lat, -this.maxValidLatitude, this.maxValidLatitude);
                    return new p.P(p.N(n.lng) * this.worldSize, p.O(u) * this.worldSize)
                }
                unproject(n) {
                    return new p.Y(n.x / this.worldSize, n.y / this.worldSize).toLngLat()
                }
                get point() {
                    return this.project(this.center)
                }
                getCameraPosition() {
                    return {
                        lngLat: this.pointLocation(this.getCameraPoint()),
                        altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation
                    }
                }
                recalculateZoom(n) {
                    const u = this.pointLocation(this.centerPoint, n),
                        f = n.getElevationForLngLatZoom(u, this.tileZoom);
                    if (!(this.elevation - f)) return;
                    const _ = this.getCameraPosition(),
                        S = p.Y.fromLngLat(_.lngLat, _.altitude),
                        L = p.Y.fromLngLat(u, f),
                        P = S.x - L.x,
                        I = S.y - L.y,
                        G = S.z - L.z,
                        j = Math.sqrt(P * P + I * I + G * G),
                        ee = this.scaleZoom(this.cameraToCenterDistance / j / this.tileSize);
                    this._elevation = f, this._center = u, this.zoom = ee
                }
                setLocationAtPoint(n, u) {
                    const f = this.pointCoordinate(u),
                        _ = this.pointCoordinate(this.centerPoint),
                        S = this.locationCoordinate(n),
                        L = new p.Y(S.x - (f.x - _.x), S.y - (f.y - _.y));
                    this.center = this.coordinateLocation(L), this._renderWorldCopies && (this.center = this.center.wrap())
                }
                locationPoint(n, u) {
                    return u ? this.coordinatePoint(this.locationCoordinate(n), u.getElevationForLngLatZoom(n, this.tileZoom), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(n))
                }
                pointLocation(n, u) {
                    return this.coordinateLocation(this.pointCoordinate(n, u))
                }
                locationCoordinate(n) {
                    return p.Y.fromLngLat(n)
                }
                coordinateLocation(n) {
                    return n && n.toLngLat()
                }
                pointCoordinate(n, u) {
                    if (u) {
                        const pe = u.pointCoordinate(n);
                        if (pe != null) return pe
                    }
                    const f = [n.x, n.y, 0, 1],
                        _ = [n.x, n.y, 1, 1];
                    p.af(f, f, this.pixelMatrixInverse), p.af(_, _, this.pixelMatrixInverse);
                    const S = f[3],
                        L = _[3],
                        P = f[1] / S,
                        I = _[1] / L,
                        G = f[2] / S,
                        j = _[2] / L,
                        ee = G === j ? 0 : (0 - G) / (j - G);
                    return new p.Y(p.z.number(f[0] / S, _[0] / L, ee) / this.worldSize, p.z.number(P, I, ee) / this.worldSize)
                }
                coordinatePoint(n, u = 0, f = this.pixelMatrix) {
                    const _ = [n.x * this.worldSize, n.y * this.worldSize, u, 1];
                    return p.af(_, _, f), new p.P(_[0] / _[3], _[1] / _[3])
                }
                getBounds() {
                    const n = Math.max(0, this.height / 2 - this.getHorizon());
                    return new tt().extend(this.pointLocation(new p.P(0, n))).extend(this.pointLocation(new p.P(this.width, n))).extend(this.pointLocation(new p.P(this.width, this.height))).extend(this.pointLocation(new p.P(0, this.height)))
                }
                getMaxBounds() {
                    return this.latRange && this.latRange.length === 2 && this.lngRange && this.lngRange.length === 2 ? new tt([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null
                }
                getHorizon() {
                    return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * .85
                }
                setMaxBounds(n) {
                    n ? (this.lngRange = [n.getWest(), n.getEast()], this.latRange = [n.getSouth(), n.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude])
                }
                calculatePosMatrix(n, u = !1) {
                    const f = n.key,
                        _ = u ? this._alignedPosMatrixCache : this._posMatrixCache;
                    if (_[f]) return _[f];
                    const S = n.canonical,
                        L = this.worldSize / this.zoomScale(S.z),
                        P = S.x + Math.pow(2, S.z) * n.wrap,
                        I = p.an(new Float64Array(16));
                    return p.H(I, I, [P * L, S.y * L, 0]), p.J(I, I, [L / p.W, L / p.W, 1]), p.K(I, u ? this.alignedProjMatrix : this.projMatrix, I), _[f] = new Float32Array(I), _[f]
                }
                customLayerMatrix() {
                    return this.mercatorMatrix.slice()
                }
                _constrain() {
                    if (!this.center || !this.width || !this.height || this._constraining) return;
                    let n = this.lngRange;
                    if (!this._renderWorldCopies && n === null) {
                        const Me = 179.9999999999;
                        n = [-Me, Me]
                    }
                    this._constraining = !0;
                    let u, f, _, S, L = -90,
                        P = 90,
                        I = -180,
                        G = 180;
                    const j = this.size,
                        ee = this._unmodified;
                    if (this.latRange) {
                        const Me = this.latRange;
                        L = p.O(Me[1]) * this.worldSize, P = p.O(Me[0]) * this.worldSize, u = P - L < j.y ? j.y / (P - L) : 0
                    }
                    n && (I = p.b0(p.N(n[0]) * this.worldSize, 0, this.worldSize), G = p.b0(p.N(n[1]) * this.worldSize, 0, this.worldSize), G < I && (G += this.worldSize), f = G - I < j.x ? j.x / (G - I) : 0);
                    const pe = this.point,
                        Ce = Math.max(f || 0, u || 0);
                    if (Ce) return this.center = this.unproject(new p.P(f ? (G + I) / 2 : pe.x, u ? (P + L) / 2 : pe.y)), this.zoom += this.scaleZoom(Ce), this._unmodified = ee, void(this._constraining = !1);
                    if (this.latRange) {
                        const Me = pe.y,
                            ke = j.y / 2;
                        Me - ke < L && (S = L + ke), Me + ke > P && (S = P - ke)
                    }
                    if (n) {
                        const Me = (I + G) / 2;
                        let ke = pe.x;
                        this._renderWorldCopies && (ke = p.b0(pe.x, Me - this.worldSize / 2, Me + this.worldSize / 2));
                        const we = j.x / 2;
                        ke - we < I && (_ = I + we), ke + we > G && (_ = G - we)
                    }
                    _ === void 0 && S === void 0 || (this.center = this.unproject(new p.P(_ !== void 0 ? _ : pe.x, S !== void 0 ? S : pe.y)).wrap()), this._unmodified = ee, this._constraining = !1
                }
                _calcMatrices() {
                    if (!this.height) return;
                    const n = this.centerOffset,
                        u = this.point.x,
                        f = this.point.y;
                    this.cameraToCenterDistance = .5 / Math.tan(this._fov / 2) * this.height, this._pixelPerMeter = p.b2(1, this.center.lat) * this.worldSize;
                    let _ = p.an(new Float64Array(16));
                    p.J(_, _, [this.width / 2, -this.height / 2, 1]), p.H(_, _, [1, -1, 0]), this.labelPlaneMatrix = _, _ = p.an(new Float64Array(16)), p.J(_, _, [1, -1, 1]), p.H(_, _, [-1, -1, 0]), p.J(_, _, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = _;
                    const S = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch),
                        L = Math.min(this.elevation, this.minElevationForCurrentTile),
                        P = S - L * this._pixelPerMeter / Math.cos(this._pitch),
                        I = L < 0 ? P : S,
                        G = Math.PI / 2 + this._pitch,
                        j = this._fov * (.5 + n.y / this.height),
                        ee = Math.sin(j) * I / Math.sin(p.ac(Math.PI - G - j, .01, Math.PI - .01)),
                        pe = this.getHorizon(),
                        Ce = 2 * Math.atan(pe / this.cameraToCenterDistance) * (.5 + n.y / (2 * pe)),
                        Me = Math.sin(Ce) * I / Math.sin(p.ac(Math.PI - G - Ce, .01, Math.PI - .01)),
                        ke = Math.min(ee, Me),
                        we = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * ke + I),
                        nt = this.height / 50;
                    _ = new Float64Array(16), p.b3(_, this._fov, this.width / this.height, nt, we), _[8] = 2 * -n.x / this.width, _[9] = 2 * n.y / this.height, p.J(_, _, [1, -1, 1]), p.H(_, _, [0, 0, -this.cameraToCenterDistance]), p.b4(_, _, this._pitch), p.ad(_, _, this.angle), p.H(_, _, [-u, -f, 0]), this.mercatorMatrix = p.J([], _, [this.worldSize, this.worldSize, this.worldSize]), p.J(_, _, [1, 1, this._pixelPerMeter]), this.pixelMatrix = p.K(new Float64Array(16), this.labelPlaneMatrix, _), p.H(_, _, [0, 0, -this.elevation]), this.projMatrix = _, this.invProjMatrix = p.ar([], _), this.pixelMatrix3D = p.K(new Float64Array(16), this.labelPlaneMatrix, _);
                    const bt = this.width % 2 / 2,
                        ze = this.height % 2 / 2,
                        ut = Math.cos(this.angle),
                        St = Math.sin(this.angle),
                        yt = u - Math.round(u) + ut * bt + St * ze,
                        Vt = f - Math.round(f) + ut * ze + St * bt,
                        ci = new Float64Array(_);
                    if (p.H(ci, ci, [yt > .5 ? yt - 1 : yt, Vt > .5 ? Vt - 1 : Vt, 0]), this.alignedProjMatrix = ci, _ = p.ar(new Float64Array(16), this.pixelMatrix), !_) throw new Error("failed to invert matrix");
                    this.pixelMatrixInverse = _, this._posMatrixCache = {}, this._alignedPosMatrixCache = {}
                }
                maxPitchScaleFactor() {
                    if (!this.pixelMatrixInverse) return 1;
                    const n = this.pointCoordinate(new p.P(0, 0)),
                        u = [n.x * this.worldSize, n.y * this.worldSize, 0, 1];
                    return p.af(u, u, this.pixelMatrix)[3] / this.cameraToCenterDistance
                }
                getCameraPoint() {
                    const n = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
                    return this.centerPoint.add(new p.P(0, n))
                }
                getCameraQueryGeometry(n) {
                    const u = this.getCameraPoint();
                    if (n.length === 1) return [n[0], u];
                    {
                        let f = u.x,
                            _ = u.y,
                            S = u.x,
                            L = u.y;
                        for (const P of n) f = Math.min(f, P.x), _ = Math.min(_, P.y), S = Math.max(S, P.x), L = Math.max(L, P.y);
                        return [new p.P(f, _), new p.P(S, _), new p.P(S, L), new p.P(f, L), new p.P(f, _)]
                    }
                }
                lngLatToCameraDepth(n, u) {
                    const f = this.locationCoordinate(n),
                        _ = [f.x * this.worldSize, f.y * this.worldSize, u, 1];
                    return p.af(_, _, this.projMatrix), _[2] / _[3]
                }
            }

            function fl(b, n) {
                let u, f = !1,
                    _ = null,
                    S = null;
                const L = () => {
                    _ = null, f && (b.apply(S, u), _ = setTimeout(L, n), f = !1)
                };
                return (...P) => (f = !0, S = this, u = P, _ || L(), _)
            }
            class ml {
                constructor(n) {
                    this._getCurrentHash = () => {
                        const u = window.location.hash.replace("#", "");
                        if (this._hashName) {
                            let f;
                            return u.split("&").map(_ => _.split("=")).forEach(_ => {
                                _[0] === this._hashName && (f = _)
                            }), (f && f[1] || "").split("/")
                        }
                        return u.split("/")
                    }, this._onHashChange = () => {
                        const u = this._getCurrentHash();
                        if (u.length >= 3 && !u.some(f => isNaN(f))) {
                            const f = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(u[3] || 0) : this._map.getBearing();
                            return this._map.jumpTo({
                                center: [+u[2], +u[1]],
                                zoom: +u[0],
                                bearing: f,
                                pitch: +(u[4] || 0)
                            }), !0
                        }
                        return !1
                    }, this._updateHashUnthrottled = () => {
                        const u = window.location.href.replace(/(#.+)?$/, this.getHashString());
                        try {
                            window.history.replaceState(window.history.state, null, u)
                        } catch (f) {}
                    }, this._updateHash = fl(this._updateHashUnthrottled, 300), this._hashName = n && encodeURIComponent(n)
                }
                addTo(n) {
                    return this._map = n, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this
                }
                remove() {
                    return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this
                }
                getHashString(n) {
                    const u = this._map.getCenter(),
                        f = Math.round(100 * this._map.getZoom()) / 100,
                        _ = Math.ceil((f * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10),
                        S = Math.pow(10, _),
                        L = Math.round(u.lng * S) / S,
                        P = Math.round(u.lat * S) / S,
                        I = this._map.getBearing(),
                        G = this._map.getPitch();
                    let j = "";
                    if (j += n ? `/${L}/${P}/${f}` : `${f}/${P}/${L}`, (I || G) && (j += "/" + Math.round(10 * I) / 10), G && (j += `/${Math.round(G)}`), this._hashName) {
                        const ee = this._hashName;
                        let pe = !1;
                        const Ce = window.location.hash.slice(1).split("&").map(Me => {
                            const ke = Me.split("=")[0];
                            return ke === ee ? (pe = !0, `${ke}=${j}`) : Me
                        }).filter(Me => Me);
                        return pe || Ce.push(`${ee}=${j}`), `#${Ce.join("&")}`
                    }
                    return `#${j}`
                }
            }
            const Po = {
                    linearity: .3,
                    easing: p.b5(0, 0, .3, 1)
                },
                Dh = p.e({
                    deceleration: 2500,
                    maxSpeed: 1400
                }, Po),
                oo = p.e({
                    deceleration: 20,
                    maxSpeed: 1400
                }, Po),
                Uc = p.e({
                    deceleration: 1e3,
                    maxSpeed: 360
                }, Po),
                Ic = p.e({
                    deceleration: 1e3,
                    maxSpeed: 90
                }, Po);
            class zc {
                constructor(n) {
                    this._map = n, this.clear()
                }
                clear() {
                    this._inertiaBuffer = []
                }
                record(n) {
                    this._drainInertiaBuffer(), this._inertiaBuffer.push({
                        time: be.now(),
                        settings: n
                    })
                }
                _drainInertiaBuffer() {
                    const n = this._inertiaBuffer,
                        u = be.now();
                    for (; n.length > 0 && u - n[0].time > 160;) n.shift()
                }
                _onMoveEnd(n) {
                    if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
                    const u = {
                        zoom: 0,
                        bearing: 0,
                        pitch: 0,
                        pan: new p.P(0, 0),
                        pinchAround: void 0,
                        around: void 0
                    };
                    for (const {
                            settings: S
                        }
                        of this._inertiaBuffer) u.zoom += S.zoomDelta || 0, u.bearing += S.bearingDelta || 0, u.pitch += S.pitchDelta || 0, S.panDelta && u.pan._add(S.panDelta), S.around && (u.around = S.around), S.pinchAround && (u.pinchAround = S.pinchAround);
                    const f = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,
                        _ = {};
                    if (u.pan.mag()) {
                        const S = Do(u.pan.mag(), f, p.e({}, Dh, n || {}));
                        _.offset = u.pan.mult(S.amount / u.pan.mag()), _.center = this._map.transform.center, ko(_, S)
                    }
                    if (u.zoom) {
                        const S = Do(u.zoom, f, oo);
                        _.zoom = this._map.transform.zoom + S.amount, ko(_, S)
                    }
                    if (u.bearing) {
                        const S = Do(u.bearing, f, Uc);
                        _.bearing = this._map.transform.bearing + p.ac(S.amount, -179, 179), ko(_, S)
                    }
                    if (u.pitch) {
                        const S = Do(u.pitch, f, Ic);
                        _.pitch = this._map.transform.pitch + S.amount, ko(_, S)
                    }
                    if (_.zoom || _.bearing) {
                        const S = u.pinchAround === void 0 ? u.around : u.pinchAround;
                        _.around = S ? this._map.unproject(S) : this._map.getCenter()
                    }
                    return this.clear(), p.e(_, {
                        noMoveStart: !0
                    })
                }
            }

            function ko(b, n) {
                (!b.duration || b.duration < n.duration) && (b.duration = n.duration, b.easing = n.easing)
            }

            function Do(b, n, u) {
                const {
                    maxSpeed: f,
                    linearity: _,
                    deceleration: S
                } = u, L = p.ac(b * _ / (n / 1e3), -f, f), P = Math.abs(L) / (S * _);
                return {
                    easing: u.easing,
                    duration: 1e3 * P,
                    amount: L * (P / 2)
                }
            }
            class Aa extends p.k {
                preventDefault() {
                    this._defaultPrevented = !0
                }
                get defaultPrevented() {
                    return this._defaultPrevented
                }
                constructor(n, u, f, _ = {}) {
                    const S = Ee.mousePos(u.getCanvas(), f),
                        L = u.unproject(S);
                    super(n, p.e({
                        point: S,
                        lngLat: L,
                        originalEvent: f
                    }, _)), this._defaultPrevented = !1, this.target = u
                }
            }
            class Ya extends p.k {
                preventDefault() {
                    this._defaultPrevented = !0
                }
                get defaultPrevented() {
                    return this._defaultPrevented
                }
                constructor(n, u, f) {
                    const _ = n === "touchend" ? f.changedTouches : f.touches,
                        S = Ee.touchPos(u.getCanvasContainer(), _),
                        L = S.map(I => u.unproject(I)),
                        P = S.reduce((I, G, j, ee) => I.add(G.div(ee.length)), new p.P(0, 0));
                    super(n, {
                        points: S,
                        point: P,
                        lngLats: L,
                        lngLat: u.unproject(P),
                        originalEvent: f
                    }), this._defaultPrevented = !1
                }
            }
            class Vr extends p.k {
                preventDefault() {
                    this._defaultPrevented = !0
                }
                get defaultPrevented() {
                    return this._defaultPrevented
                }
                constructor(n, u, f) {
                    super(n, {
                        originalEvent: f
                    }), this._defaultPrevented = !1
                }
            }
            class ha {
                constructor(n, u) {
                    this._map = n, this._clickTolerance = u.clickTolerance
                }
                reset() {
                    delete this._mousedownPos
                }
                wheel(n) {
                    return this._firePreventable(new Vr(n.type, this._map, n))
                }
                mousedown(n, u) {
                    return this._mousedownPos = u, this._firePreventable(new Aa(n.type, this._map, n))
                }
                mouseup(n) {
                    this._map.fire(new Aa(n.type, this._map, n))
                }
                click(n, u) {
                    this._mousedownPos && this._mousedownPos.dist(u) >= this._clickTolerance || this._map.fire(new Aa(n.type, this._map, n))
                }
                dblclick(n) {
                    return this._firePreventable(new Aa(n.type, this._map, n))
                }
                mouseover(n) {
                    this._map.fire(new Aa(n.type, this._map, n))
                }
                mouseout(n) {
                    this._map.fire(new Aa(n.type, this._map, n))
                }
                touchstart(n) {
                    return this._firePreventable(new Ya(n.type, this._map, n))
                }
                touchmove(n) {
                    this._map.fire(new Ya(n.type, this._map, n))
                }
                touchend(n) {
                    this._map.fire(new Ya(n.type, this._map, n))
                }
                touchcancel(n) {
                    this._map.fire(new Ya(n.type, this._map, n))
                }
                _firePreventable(n) {
                    if (this._map.fire(n), n.defaultPrevented) return {}
                }
                isEnabled() {
                    return !0
                }
                isActive() {
                    return !1
                }
                enable() {}
                disable() {}
            }
            class Ha {
                constructor(n) {
                    this._map = n
                }
                reset() {
                    this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent
                }
                mousemove(n) {
                    this._map.fire(new Aa(n.type, this._map, n))
                }
                mousedown() {
                    this._delayContextMenu = !0, this._ignoreContextMenu = !1
                }
                mouseup() {
                    this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Aa("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent)
                }
                contextmenu(n) {
                    this._delayContextMenu ? this._contextMenuEvent = n : this._ignoreContextMenu || this._map.fire(new Aa(n.type, this._map, n)), this._map.listens("contextmenu") && n.preventDefault()
                }
                isEnabled() {
                    return !0
                }
                isActive() {
                    return !1
                }
                enable() {}
                disable() {}
            }
            class Fa {
                constructor(n) {
                    this._map = n
                }
                get transform() {
                    return this._map._requestedCameraState || this._map.transform
                }
                get center() {
                    return {
                        lng: this.transform.center.lng,
                        lat: this.transform.center.lat
                    }
                }
                get zoom() {
                    return this.transform.zoom
                }
                get pitch() {
                    return this.transform.pitch
                }
                get bearing() {
                    return this.transform.bearing
                }
                unproject(n) {
                    return this.transform.pointLocation(p.P.convert(n), this._map.terrain)
                }
            }
            class Nc {
                constructor(n, u) {
                    this._map = n, this._tr = new Fa(n), this._el = n.getCanvasContainer(), this._container = n.getContainer(), this._clickTolerance = u.clickTolerance || 1
                }
                isEnabled() {
                    return !!this._enabled
                }
                isActive() {
                    return !!this._active
                }
                enable() {
                    this.isEnabled() || (this._enabled = !0)
                }
                disable() {
                    this.isEnabled() && (this._enabled = !1)
                }
                mousedown(n, u) {
                    this.isEnabled() && n.shiftKey && n.button === 0 && (Ee.disableDrag(), this._startPos = this._lastPos = u, this._active = !0)
                }
                mousemoveWindow(n, u) {
                    if (!this._active) return;
                    const f = u;
                    if (this._lastPos.equals(f) || !this._box && f.dist(this._startPos) < this._clickTolerance) return;
                    const _ = this._startPos;
                    this._lastPos = f, this._box || (this._box = Ee.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", n));
                    const S = Math.min(_.x, f.x),
                        L = Math.max(_.x, f.x),
                        P = Math.min(_.y, f.y),
                        I = Math.max(_.y, f.y);
                    Ee.setTransform(this._box, `translate(${S}px,${P}px)`), this._box.style.width = L - S + "px", this._box.style.height = I - P + "px"
                }
                mouseupWindow(n, u) {
                    if (!this._active || n.button !== 0) return;
                    const f = this._startPos,
                        _ = u;
                    if (this.reset(), Ee.suppressClick(), f.x !== _.x || f.y !== _.y) return this._map.fire(new p.k("boxzoomend", {
                        originalEvent: n
                    })), {
                        cameraAnimation: S => S.fitScreenCoordinates(f, _, this._tr.bearing, {
                            linear: !0
                        })
                    };
                    this._fireEvent("boxzoomcancel", n)
                }
                keydown(n) {
                    this._active && n.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", n))
                }
                reset() {
                    this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (Ee.remove(this._box), this._box = null), Ee.enableDrag(), delete this._startPos, delete this._lastPos
                }
                _fireEvent(n, u) {
                    return this._map.fire(new p.k(n, {
                        originalEvent: u
                    }))
                }
            }

            function Wa(b, n) {
                if (b.length !== n.length) throw new Error(`The number of touches and points are not equal - touches ${b.length}, points ${n.length}`);
                const u = {};
                for (let f = 0; f < b.length; f++) u[b[f].identifier] = n[f];
                return u
            }
            class gl {
                constructor(n) {
                    this.reset(), this.numTouches = n.numTouches
                }
                reset() {
                    delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1
                }
                touchstart(n, u, f) {
                    (this.centroid || f.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = n.timeStamp), f.length === this.numTouches && (this.centroid = function(_) {
                        const S = new p.P(0, 0);
                        for (const L of _) S._add(L);
                        return S.div(_.length)
                    }(u), this.touches = Wa(f, u)))
                }
                touchmove(n, u, f) {
                    if (this.aborted || !this.centroid) return;
                    const _ = Wa(f, u);
                    for (const S in this.touches) {
                        const L = _[S];
                        (!L || L.dist(this.touches[S]) > 30) && (this.aborted = !0)
                    }
                }
                touchend(n, u, f) {
                    if ((!this.centroid || n.timeStamp - this.startTime > 500) && (this.aborted = !0), f.length === 0) {
                        const _ = !this.aborted && this.centroid;
                        if (this.reset(), _) return _
                    }
                }
            }
            class Oc {
                constructor(n) {
                    this.singleTap = new gl(n), this.numTaps = n.numTaps, this.reset()
                }
                reset() {
                    this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset()
                }
                touchstart(n, u, f) {
                    this.singleTap.touchstart(n, u, f)
                }
                touchmove(n, u, f) {
                    this.singleTap.touchmove(n, u, f)
                }
                touchend(n, u, f) {
                    const _ = this.singleTap.touchend(n, u, f);
                    if (_) {
                        const S = n.timeStamp - this.lastTime < 500,
                            L = !this.lastTap || this.lastTap.dist(_) < 30;
                        if (S && L || this.reset(), this.count++, this.lastTime = n.timeStamp, this.lastTap = _, this.count === this.numTaps) return this.reset(), _
                    }
                }
            }
            class Pu {
                constructor(n) {
                    this._tr = new Fa(n), this._zoomIn = new Oc({
                        numTouches: 1,
                        numTaps: 2
                    }), this._zoomOut = new Oc({
                        numTouches: 2,
                        numTaps: 1
                    }), this.reset()
                }
                reset() {
                    this._active = !1, this._zoomIn.reset(), this._zoomOut.reset()
                }
                touchstart(n, u, f) {
                    this._zoomIn.touchstart(n, u, f), this._zoomOut.touchstart(n, u, f)
                }
                touchmove(n, u, f) {
                    this._zoomIn.touchmove(n, u, f), this._zoomOut.touchmove(n, u, f)
                }
                touchend(n, u, f) {
                    const _ = this._zoomIn.touchend(n, u, f),
                        S = this._zoomOut.touchend(n, u, f),
                        L = this._tr;
                    return _ ? (this._active = !0, n.preventDefault(), setTimeout(() => this.reset(), 0), {
                        cameraAnimation: P => P.easeTo({
                            duration: 300,
                            zoom: L.zoom + 1,
                            around: L.unproject(_)
                        }, {
                            originalEvent: n
                        })
                    }) : S ? (this._active = !0, n.preventDefault(), setTimeout(() => this.reset(), 0), {
                        cameraAnimation: P => P.easeTo({
                            duration: 300,
                            zoom: L.zoom - 1,
                            around: L.unproject(S)
                        }, {
                            originalEvent: n
                        })
                    }) : void 0
                }
                touchcancel() {
                    this.reset()
                }
                enable() {
                    this._enabled = !0
                }
                disable() {
                    this._enabled = !1, this.reset()
                }
                isEnabled() {
                    return this._enabled
                }
                isActive() {
                    return this._active
                }
            }
            class yl {
                constructor(n) {
                    this._enabled = !!n.enable, this._moveStateManager = n.moveStateManager, this._clickTolerance = n.clickTolerance || 1, this._moveFunction = n.move, this._activateOnStart = !!n.activateOnStart, n.assignEvents(this), this.reset()
                }
                reset(n) {
                    this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(n)
                }
                _move(...n) {
                    const u = this._moveFunction(...n);
                    if (u.bearingDelta || u.pitchDelta || u.around || u.panDelta) return this._active = !0, u
                }
                dragStart(n, u) {
                    this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(n) && (this._moveStateManager.startMove(n), this._lastPoint = u.length ? u[0] : u, this._activateOnStart && this._lastPoint && (this._active = !0))
                }
                dragMove(n, u) {
                    if (!this.isEnabled()) return;
                    const f = this._lastPoint;
                    if (!f) return;
                    if (n.preventDefault(), !this._moveStateManager.isValidMoveEvent(n)) return void this.reset(n);
                    const _ = u.length ? u[0] : u;
                    return !this._moved && _.dist(f) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = _, this._move(f, _))
                }
                dragEnd(n) {
                    this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(n) && (this._moved && Ee.suppressClick(), this.reset(n))
                }
                enable() {
                    this._enabled = !0
                }
                disable() {
                    this._enabled = !1, this.reset()
                }
                isEnabled() {
                    return this._enabled
                }
                isActive() {
                    return this._active
                }
                getClickTolerance() {
                    return this._clickTolerance
                }
            }
            const Uh = {
                0: 1,
                2: 2
            };
            class lo {
                constructor(n) {
                    this._correctEvent = n.checkCorrectEvent
                }
                startMove(n) {
                    const u = Ee.mouseButton(n);
                    this._eventButton = u
                }
                endMove(n) {
                    delete this._eventButton
                }
                isValidStartEvent(n) {
                    return this._correctEvent(n)
                }
                isValidMoveEvent(n) {
                    return ! function(u, f) {
                        const _ = Uh[f];
                        return u.buttons === void 0 || (u.buttons & _) !== _
                    }(n, this._eventButton)
                }
                isValidEndEvent(n) {
                    return Ee.mouseButton(n) === this._eventButton
                }
            }
            class Ss {
                constructor() {
                    this._firstTouch = void 0
                }
                _isOneFingerTouch(n) {
                    return n.targetTouches.length === 1
                }
                _isSameTouchEvent(n) {
                    return n.targetTouches[0].identifier === this._firstTouch
                }
                startMove(n) {
                    this._firstTouch = n.targetTouches[0].identifier
                }
                endMove(n) {
                    delete this._firstTouch
                }
                isValidStartEvent(n) {
                    return this._isOneFingerTouch(n)
                }
                isValidMoveEvent(n) {
                    return this._isOneFingerTouch(n) && this._isSameTouchEvent(n)
                }
                isValidEndEvent(n) {
                    return this._isOneFingerTouch(n) && this._isSameTouchEvent(n)
                }
            }
            const Ii = b => {
                    b.mousedown = b.dragStart, b.mousemoveWindow = b.dragMove, b.mouseup = b.dragEnd, b.contextmenu = function(n) {
                        n.preventDefault()
                    }
                },
                Vc = ({
                    enable: b,
                    clickTolerance: n,
                    bearingDegreesPerPixelMoved: u = .8
                }) => {
                    const f = new lo({
                        checkCorrectEvent: _ => Ee.mouseButton(_) === 0 && _.ctrlKey || Ee.mouseButton(_) === 2
                    });
                    return new yl({
                        clickTolerance: n,
                        move: (_, S) => ({
                            bearingDelta: (S.x - _.x) * u
                        }),
                        moveStateManager: f,
                        enable: b,
                        assignEvents: Ii
                    })
                },
                Uo = ({
                    enable: b,
                    clickTolerance: n,
                    pitchDegreesPerPixelMoved: u = -.5
                }) => {
                    const f = new lo({
                        checkCorrectEvent: _ => Ee.mouseButton(_) === 0 && _.ctrlKey || Ee.mouseButton(_) === 2
                    });
                    return new yl({
                        clickTolerance: n,
                        move: (_, S) => ({
                            pitchDelta: (S.y - _.y) * u
                        }),
                        moveStateManager: f,
                        enable: b,
                        assignEvents: Ii
                    })
                };
            class vl {
                constructor(n, u) {
                    this._clickTolerance = n.clickTolerance || 1, this._map = u, this.reset()
                }
                reset() {
                    this._active = !1, this._touches = {}, this._sum = new p.P(0, 0)
                }
                minTouchs() {
                    return this._map.cooperativeGestures.isEnabled() ? 2 : 1
                }
                touchstart(n, u, f) {
                    return this._calculateTransform(n, u, f)
                }
                touchmove(n, u, f) {
                    if (this._active && !(f.length < this.minTouchs())) return n.preventDefault(), this._calculateTransform(n, u, f)
                }
                touchend(n, u, f) {
                    this._calculateTransform(n, u, f), this._active && f.length < this.minTouchs() && this.reset()
                }
                touchcancel() {
                    this.reset()
                }
                _calculateTransform(n, u, f) {
                    f.length > 0 && (this._active = !0);
                    const _ = Wa(f, u),
                        S = new p.P(0, 0),
                        L = new p.P(0, 0);
                    let P = 0;
                    for (const G in _) {
                        const j = _[G],
                            ee = this._touches[G];
                        ee && (S._add(j), L._add(j.sub(ee)), P++, _[G] = j)
                    }
                    if (this._touches = _, P < this.minTouchs() || !L.mag()) return;
                    const I = L.div(P);
                    return this._sum._add(I), this._sum.mag() < this._clickTolerance ? void 0 : {
                        around: S.div(P),
                        panDelta: I
                    }
                }
                enable() {
                    this._enabled = !0
                }
                disable() {
                    this._enabled = !1, this.reset()
                }
                isEnabled() {
                    return this._enabled
                }
                isActive() {
                    return this._active
                }
            }
            class Xl {
                constructor() {
                    this.reset()
                }
                reset() {
                    this._active = !1, delete this._firstTwoTouches
                }
                touchstart(n, u, f) {
                    this._firstTwoTouches || f.length < 2 || (this._firstTwoTouches = [f[0].identifier, f[1].identifier], this._start([u[0], u[1]]))
                }
                touchmove(n, u, f) {
                    if (!this._firstTwoTouches) return;
                    n.preventDefault();
                    const [_, S] = this._firstTwoTouches, L = Ti(f, u, _), P = Ti(f, u, S);
                    if (!L || !P) return;
                    const I = this._aroundCenter ? null : L.add(P).div(2);
                    return this._move([L, P], I, n)
                }
                touchend(n, u, f) {
                    if (!this._firstTwoTouches) return;
                    const [_, S] = this._firstTwoTouches, L = Ti(f, u, _), P = Ti(f, u, S);
                    L && P || (this._active && Ee.suppressClick(), this.reset())
                }
                touchcancel() {
                    this.reset()
                }
                enable(n) {
                    this._enabled = !0, this._aroundCenter = !!n && n.around === "center"
                }
                disable() {
                    this._enabled = !1, this.reset()
                }
                isEnabled() {
                    return !!this._enabled
                }
                isActive() {
                    return !!this._active
                }
            }

            function Ti(b, n, u) {
                for (let f = 0; f < b.length; f++)
                    if (b[f].identifier === u) return n[f]
            }

            function jl(b, n) {
                return Math.log(b / n) / Math.LN2
            }
            class Ih extends Xl {
                reset() {
                    super.reset(), delete this._distance, delete this._startDistance
                }
                _start(n) {
                    this._startDistance = this._distance = n[0].dist(n[1])
                }
                _move(n, u) {
                    const f = this._distance;
                    if (this._distance = n[0].dist(n[1]), this._active || !(Math.abs(jl(this._distance, this._startDistance)) < .1)) return this._active = !0, {
                        zoomDelta: jl(this._distance, f),
                        pinchAround: u
                    }
                }
            }

            function zh(b, n) {
                return 180 * b.angleWith(n) / Math.PI
            }
            class Yl extends Xl {
                reset() {
                    super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector
                }
                _start(n) {
                    this._startVector = this._vector = n[0].sub(n[1]), this._minDiameter = n[0].dist(n[1])
                }
                _move(n, u, f) {
                    const _ = this._vector;
                    if (this._vector = n[0].sub(n[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {
                        bearingDelta: zh(this._vector, _),
                        pinchAround: u
                    }
                }
                _isBelowThreshold(n) {
                    this._minDiameter = Math.min(this._minDiameter, n.mag());
                    const u = 25 / (Math.PI * this._minDiameter) * 360,
                        f = zh(n, this._startVector);
                    return Math.abs(f) < u
                }
            }

            function ql(b) {
                return Math.abs(b.y) > Math.abs(b.x)
            }
            class Gc extends Xl {
                constructor(n) {
                    super(), this._currentTouchCount = 0, this._map = n
                }
                reset() {
                    super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints
                }
                touchstart(n, u, f) {
                    super.touchstart(n, u, f), this._currentTouchCount = f.length
                }
                _start(n) {
                    this._lastPoints = n, ql(n[0].sub(n[1])) && (this._valid = !1)
                }
                _move(n, u, f) {
                    if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
                    const _ = n[0].sub(this._lastPoints[0]),
                        S = n[1].sub(this._lastPoints[1]);
                    return this._valid = this.gestureBeginsVertically(_, S, f.timeStamp), this._valid ? (this._lastPoints = n, this._active = !0, {
                        pitchDelta: (_.y + S.y) / 2 * -.5
                    }) : void 0
                }
                gestureBeginsVertically(n, u, f) {
                    if (this._valid !== void 0) return this._valid;
                    const _ = n.mag() >= 2,
                        S = u.mag() >= 2;
                    if (!_ && !S) return;
                    if (!_ || !S) return this._firstMove === void 0 && (this._firstMove = f), f - this._firstMove < 100 && void 0;
                    const L = n.y > 0 == u.y > 0;
                    return ql(n) && ql(u) && L
                }
            }
            const ku = {
                panStep: 100,
                bearingStep: 15,
                pitchStep: 10
            };
            class Nh {
                constructor(n) {
                    this._tr = new Fa(n);
                    const u = ku;
                    this._panStep = u.panStep, this._bearingStep = u.bearingStep, this._pitchStep = u.pitchStep, this._rotationDisabled = !1
                }
                reset() {
                    this._active = !1
                }
                keydown(n) {
                    if (n.altKey || n.ctrlKey || n.metaKey) return;
                    let u = 0,
                        f = 0,
                        _ = 0,
                        S = 0,
                        L = 0;
                    switch (n.keyCode) {
                        case 61:
                        case 107:
                        case 171:
                        case 187:
                            u = 1;
                            break;
                        case 189:
                        case 109:
                        case 173:
                            u = -1;
                            break;
                        case 37:
                            n.shiftKey ? f = -1 : (n.preventDefault(), S = -1);
                            break;
                        case 39:
                            n.shiftKey ? f = 1 : (n.preventDefault(), S = 1);
                            break;
                        case 38:
                            n.shiftKey ? _ = 1 : (n.preventDefault(), L = -1);
                            break;
                        case 40:
                            n.shiftKey ? _ = -1 : (n.preventDefault(), L = 1);
                            break;
                        default:
                            return
                    }
                    return this._rotationDisabled && (f = 0, _ = 0), {
                        cameraAnimation: P => {
                            const I = this._tr;
                            P.easeTo({
                                duration: 300,
                                easeId: "keyboardHandler",
                                easing: co,
                                zoom: u ? Math.round(I.zoom) + u * (n.shiftKey ? 2 : 1) : I.zoom,
                                bearing: I.bearing + f * this._bearingStep,
                                pitch: I.pitch + _ * this._pitchStep,
                                offset: [-S * this._panStep, -L * this._panStep],
                                center: I.center
                            }, {
                                originalEvent: n
                            })
                        }
                    }
                }
                enable() {
                    this._enabled = !0
                }
                disable() {
                    this._enabled = !1, this.reset()
                }
                isEnabled() {
                    return this._enabled
                }
                isActive() {
                    return this._active
                }
                disableRotation() {
                    this._rotationDisabled = !0
                }
                enableRotation() {
                    this._rotationDisabled = !1
                }
            }

            function co(b) {
                return b * (2 - b)
            }
            const cr = 4.000244140625;
            class _l {
                constructor(n, u) {
                    this._onTimeout = f => {
                        this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(f)
                    }, this._map = n, this._tr = new Fa(n), this._triggerRenderFrame = u, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = .0022222222222222222
                }
                setZoomRate(n) {
                    this._defaultZoomRate = n
                }
                setWheelZoomRate(n) {
                    this._wheelZoomRate = n
                }
                isEnabled() {
                    return !!this._enabled
                }
                isActive() {
                    return !!this._active || this._finishTimeout !== void 0
                }
                isZooming() {
                    return !!this._zooming
                }
                enable(n) {
                    this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!n && n.around === "center")
                }
                disable() {
                    this.isEnabled() && (this._enabled = !1)
                }
                wheel(n) {
                    if (!this.isEnabled() || this._map.cooperativeGestures.isEnabled() && !n[this._map.cooperativeGestures._bypassKey]) return;
                    let u = n.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * n.deltaY : n.deltaY;
                    const f = be.now(),
                        _ = f - (this._lastWheelEventTime || 0);
                    this._lastWheelEventTime = f, u !== 0 && u % cr == 0 ? this._type = "wheel" : u !== 0 && Math.abs(u) < 4 ? this._type = "trackpad" : _ > 400 ? (this._type = null, this._lastValue = u, this._timeout = setTimeout(this._onTimeout, 40, n)) : this._type || (this._type = Math.abs(_ * u) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, u += this._lastValue)), n.shiftKey && u && (u /= 4), this._type && (this._lastWheelEvent = n, this._delta -= u, this._active || this._start(n)), n.preventDefault()
                }
                _start(n) {
                    if (!this._delta) return;
                    this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
                    const u = Ee.mousePos(this._map.getCanvas(), n),
                        f = this._tr;
                    this._around = u.y > f.transform.height / 2 - f.transform.getHorizon() ? p.M.convert(this._aroundCenter ? f.center : f.unproject(u)) : p.M.convert(f.center), this._aroundPoint = f.transform.locationPoint(this._around), this._frameId || (this._frameId = !0, this._triggerRenderFrame())
                }
                renderFrame() {
                    if (!this._frameId || (this._frameId = null, !this.isActive())) return;
                    const n = this._tr.transform;
                    if (this._delta !== 0) {
                        const P = this._type === "wheel" && Math.abs(this._delta) > cr ? this._wheelZoomRate : this._defaultZoomRate;
                        let I = 2 / (1 + Math.exp(-Math.abs(this._delta * P)));
                        this._delta < 0 && I !== 0 && (I = 1 / I);
                        const G = typeof this._targetZoom == "number" ? n.zoomScale(this._targetZoom) : n.scale;
                        this._targetZoom = Math.min(n.maxZoom, Math.max(n.minZoom, n.scaleZoom(G * I))), this._type === "wheel" && (this._startZoom = n.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0
                    }
                    const u = typeof this._targetZoom == "number" ? this._targetZoom : n.zoom,
                        f = this._startZoom,
                        _ = this._easing;
                    let S, L = !1;
                    if (this._type === "wheel" && f && _) {
                        const P = Math.min((be.now() - this._lastWheelEventTime) / 200, 1),
                            I = _(P);
                        S = p.z.number(f, u, I), P < 1 ? this._frameId || (this._frameId = !0) : L = !0
                    } else S = u, L = !0;
                    return this._active = !0, L && (this._active = !1, this._finishTimeout = setTimeout(() => {
                        this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout
                    }, 200)), {
                        noInertia: !0,
                        needsRenderFrame: !L,
                        zoomDelta: S - n.zoom,
                        around: this._aroundPoint,
                        originalEvent: this._lastWheelEvent
                    }
                }
                _smoothOutEasing(n) {
                    let u = p.b6;
                    if (this._prevEase) {
                        const f = this._prevEase,
                            _ = (be.now() - f.start) / f.duration,
                            S = f.easing(_ + .01) - f.easing(_),
                            L = .27 / Math.sqrt(S * S + 1e-4) * .01,
                            P = Math.sqrt(.0729 - L * L);
                        u = p.b5(L, P, .25, 1)
                    }
                    return this._prevEase = {
                        start: be.now(),
                        duration: n,
                        easing: u
                    }, u
                }
                reset() {
                    this._active = !1, this._zooming = !1, delete this._targetZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout)
                }
            }
            class $l {
                constructor(n, u) {
                    this._clickZoom = n, this._tapZoom = u
                }
                enable() {
                    this._clickZoom.enable(), this._tapZoom.enable()
                }
                disable() {
                    this._clickZoom.disable(), this._tapZoom.disable()
                }
                isEnabled() {
                    return this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
                }
                isActive() {
                    return this._clickZoom.isActive() || this._tapZoom.isActive()
                }
            }
            class Oh {
                constructor(n) {
                    this._tr = new Fa(n), this.reset()
                }
                reset() {
                    this._active = !1
                }
                dblclick(n, u) {
                    return n.preventDefault(), {
                        cameraAnimation: f => {
                            f.easeTo({
                                duration: 300,
                                zoom: this._tr.zoom + (n.shiftKey ? -1 : 1),
                                around: this._tr.unproject(u)
                            }, {
                                originalEvent: n
                            })
                        }
                    }
                }
                enable() {
                    this._enabled = !0
                }
                disable() {
                    this._enabled = !1, this.reset()
                }
                isEnabled() {
                    return this._enabled
                }
                isActive() {
                    return this._active
                }
            }
            class Vh {
                constructor() {
                    this._tap = new Oc({
                        numTouches: 1,
                        numTaps: 1
                    }), this.reset()
                }
                reset() {
                    this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset()
                }
                touchstart(n, u, f) {
                    if (!this._swipePoint)
                        if (this._tapTime) {
                            const _ = u[0],
                                S = n.timeStamp - this._tapTime < 500,
                                L = this._tapPoint.dist(_) < 30;
                            S && L ? f.length > 0 && (this._swipePoint = _, this._swipeTouch = f[0].identifier) : this.reset()
                        } else this._tap.touchstart(n, u, f)
                }
                touchmove(n, u, f) {
                    if (this._tapTime) {
                        if (this._swipePoint) {
                            if (f[0].identifier !== this._swipeTouch) return;
                            const _ = u[0],
                                S = _.y - this._swipePoint.y;
                            return this._swipePoint = _, n.preventDefault(), this._active = !0, {
                                zoomDelta: S / 128
                            }
                        }
                    } else this._tap.touchmove(n, u, f)
                }
                touchend(n, u, f) {
                    if (this._tapTime) this._swipePoint && f.length === 0 && this.reset();
                    else {
                        const _ = this._tap.touchend(n, u, f);
                        _ && (this._tapTime = n.timeStamp, this._tapPoint = _)
                    }
                }
                touchcancel() {
                    this.reset()
                }
                enable() {
                    this._enabled = !0
                }
                disable() {
                    this._enabled = !1, this.reset()
                }
                isEnabled() {
                    return this._enabled
                }
                isActive() {
                    return this._active
                }
            }
            class Hc {
                constructor(n, u, f) {
                    this._el = n, this._mousePan = u, this._touchPan = f
                }
                enable(n) {
                    this._inertiaOptions = n || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan")
                }
                disable() {
                    this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan")
                }
                isEnabled() {
                    return this._mousePan.isEnabled() && this._touchPan.isEnabled()
                }
                isActive() {
                    return this._mousePan.isActive() || this._touchPan.isActive()
                }
            }
            class Gh {
                constructor(n, u, f) {
                    this._pitchWithRotate = n.pitchWithRotate, this._mouseRotate = u, this._mousePitch = f
                }
                enable() {
                    this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable()
                }
                disable() {
                    this._mouseRotate.disable(), this._mousePitch.disable()
                }
                isEnabled() {
                    return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled())
                }
                isActive() {
                    return this._mouseRotate.isActive() || this._mousePitch.isActive()
                }
            }
            class qa {
                constructor(n, u, f, _) {
                    this._el = n, this._touchZoom = u, this._touchRotate = f, this._tapDragZoom = _, this._rotationDisabled = !1, this._enabled = !0
                }
                enable(n) {
                    this._touchZoom.enable(n), this._rotationDisabled || this._touchRotate.enable(n), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate")
                }
                disable() {
                    this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate")
                }
                isEnabled() {
                    return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled()
                }
                isActive() {
                    return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive()
                }
                disableRotation() {
                    this._rotationDisabled = !0, this._touchRotate.disable()
                }
                enableRotation() {
                    this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable()
                }
            }
            class xl {
                constructor(n, u) {
                    this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = n, this._options = u, this._enabled = !1
                }
                isActive() {
                    return !1
                }
                reset() {}
                _setupUI() {
                    if (this._container) return;
                    const n = this._map.getCanvasContainer();
                    n.classList.add("maplibregl-cooperative-gestures"), this._container = Ee.create("div", "maplibregl-cooperative-gesture-screen", n);
                    let u = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
                    this._bypassKey === "metaKey" && (u = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
                    const f = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"),
                        _ = document.createElement("div");
                    _.className = "maplibregl-desktop-message", _.textContent = u, this._container.appendChild(_);
                    const S = document.createElement("div");
                    S.className = "maplibregl-mobile-message", S.textContent = f, this._container.appendChild(S), this._container.setAttribute("aria-hidden", "true")
                }
                _destoryUI() {
                    this._container && (Ee.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container
                }
                enable() {
                    this._setupUI(), this._enabled = !0
                }
                disable() {
                    this._enabled = !1, this._destoryUI()
                }
                isEnabled() {
                    return this._enabled
                }
                touchmove(n) {
                    this._onCooperativeGesture(n.touches.length === 1)
                }
                wheel(n) {
                    this._map.scrollZoom.isEnabled() && this._onCooperativeGesture(!n[this._bypassKey])
                }
                _onCooperativeGesture(n) {
                    this._enabled && n && (this._container.classList.add("maplibregl-show"), setTimeout(() => {
                        this._container.classList.remove("maplibregl-show")
                    }, 100))
                }
            }
            const Ji = b => b.zoom || b.drag || b.pitch || b.rotate;
            class ln extends p.k {}

            function Io(b) {
                return b.panDelta && b.panDelta.mag() || b.zoomDelta || b.bearingDelta || b.pitchDelta
            }
            class Kl {
                constructor(n, u) {
                    this.handleWindowEvent = _ => {
                        this.handleEvent(_, `${_.type}Window`)
                    }, this.handleEvent = (_, S) => {
                        if (_.type === "blur") return void this.stop(!0);
                        this._updatingCamera = !0;
                        const L = _.type === "renderFrame" ? void 0 : _,
                            P = {
                                needsRenderFrame: !1
                            },
                            I = {},
                            G = {},
                            j = _.touches,
                            ee = j ? this._getMapTouches(j) : void 0,
                            pe = ee ? Ee.touchPos(this._map.getCanvas(), ee) : Ee.mousePos(this._map.getCanvas(), _);
                        for (const {
                                handlerName: ke,
                                handler: we,
                                allowed: nt
                            }
                            of this._handlers) {
                            if (!we.isEnabled()) continue;
                            let bt;
                            this._blockedByActive(G, nt, ke) ? we.reset() : we[S || _.type] && (bt = we[S || _.type](_, pe, ee), this.mergeHandlerResult(P, I, bt, ke, L), bt && bt.needsRenderFrame && this._triggerRenderFrame()), (bt || we.isActive()) && (G[ke] = we)
                        }
                        const Ce = {};
                        for (const ke in this._previousActiveHandlers) G[ke] || (Ce[ke] = L);
                        this._previousActiveHandlers = G, (Object.keys(Ce).length || Io(P)) && (this._changes.push([P, I, Ce]), this._triggerRenderFrame()), (Object.keys(G).length || Io(P)) && this._map._stop(!0), this._updatingCamera = !1;
                        const {
                            cameraAnimation: Me
                        } = P;
                        Me && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], Me(this._map))
                    }, this._map = n, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new zc(n), this._bearingSnap = u.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(u);
                    const f = this._el;
                    this._listeners = [
                        [f, "touchstart", {
                            passive: !0
                        }],
                        [f, "touchmove", {
                            passive: !1
                        }],
                        [f, "touchend", void 0],
                        [f, "touchcancel", void 0],
                        [f, "mousedown", void 0],
                        [f, "mousemove", void 0],
                        [f, "mouseup", void 0],
                        [document, "mousemove", {
                            capture: !0
                        }],
                        [document, "mouseup", void 0],
                        [f, "mouseover", void 0],
                        [f, "mouseout", void 0],
                        [f, "dblclick", void 0],
                        [f, "click", void 0],
                        [f, "keydown", {
                            capture: !1
                        }],
                        [f, "keyup", void 0],
                        [f, "wheel", {
                            passive: !1
                        }],
                        [f, "contextmenu", void 0],
                        [window, "blur", void 0]
                    ];
                    for (const [_, S, L] of this._listeners) Ee.addEventListener(_, S, _ === document ? this.handleWindowEvent : this.handleEvent, L)
                }
                destroy() {
                    for (const [n, u, f] of this._listeners) Ee.removeEventListener(n, u, n === document ? this.handleWindowEvent : this.handleEvent, f)
                }
                _addDefaultHandlers(n) {
                    const u = this._map,
                        f = u.getCanvasContainer();
                    this._add("mapEvent", new ha(u, n));
                    const _ = u.boxZoom = new Nc(u, n);
                    this._add("boxZoom", _), n.interactive && n.boxZoom && _.enable();
                    const S = u.cooperativeGestures = new xl(u, n.cooperativeGestures);
                    this._add("cooperativeGestures", S), n.cooperativeGestures && S.enable();
                    const L = new Pu(u),
                        P = new Oh(u);
                    u.doubleClickZoom = new $l(P, L), this._add("tapZoom", L), this._add("clickZoom", P), n.interactive && n.doubleClickZoom && u.doubleClickZoom.enable();
                    const I = new Vh;
                    this._add("tapDragZoom", I);
                    const G = u.touchPitch = new Gc(u);
                    this._add("touchPitch", G), n.interactive && n.touchPitch && u.touchPitch.enable(n.touchPitch);
                    const j = Vc(n),
                        ee = Uo(n);
                    u.dragRotate = new Gh(n, j, ee), this._add("mouseRotate", j, ["mousePitch"]), this._add("mousePitch", ee, ["mouseRotate"]), n.interactive && n.dragRotate && u.dragRotate.enable();
                    const pe = (({
                            enable: bt,
                            clickTolerance: ze
                        }) => {
                            const ut = new lo({
                                checkCorrectEvent: St => Ee.mouseButton(St) === 0 && !St.ctrlKey
                            });
                            return new yl({
                                clickTolerance: ze,
                                move: (St, yt) => ({
                                    around: yt,
                                    panDelta: yt.sub(St)
                                }),
                                activateOnStart: !0,
                                moveStateManager: ut,
                                enable: bt,
                                assignEvents: Ii
                            })
                        })(n),
                        Ce = new vl(n, u);
                    u.dragPan = new Hc(f, pe, Ce), this._add("mousePan", pe), this._add("touchPan", Ce, ["touchZoom", "touchRotate"]), n.interactive && n.dragPan && u.dragPan.enable(n.dragPan);
                    const Me = new Yl,
                        ke = new Ih;
                    u.touchZoomRotate = new qa(f, ke, Me, I), this._add("touchRotate", Me, ["touchPan", "touchZoom"]), this._add("touchZoom", ke, ["touchPan", "touchRotate"]), n.interactive && n.touchZoomRotate && u.touchZoomRotate.enable(n.touchZoomRotate);
                    const we = u.scrollZoom = new _l(u, () => this._triggerRenderFrame());
                    this._add("scrollZoom", we, ["mousePan"]), n.interactive && n.scrollZoom && u.scrollZoom.enable(n.scrollZoom);
                    const nt = u.keyboard = new Nh(u);
                    this._add("keyboard", nt), n.interactive && n.keyboard && u.keyboard.enable(), this._add("blockableMapEvent", new Ha(u))
                }
                _add(n, u, f) {
                    this._handlers.push({
                        handlerName: n,
                        handler: u,
                        allowed: f
                    }), this._handlersById[n] = u
                }
                stop(n) {
                    if (!this._updatingCamera) {
                        for (const {
                                handler: u
                            }
                            of this._handlers) u.reset();
                        this._inertia.clear(), this._fireEvents({}, {}, n), this._changes = []
                    }
                }
                isActive() {
                    for (const {
                            handler: n
                        }
                        of this._handlers)
                        if (n.isActive()) return !0;
                    return !1
                }
                isZooming() {
                    return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
                }
                isRotating() {
                    return !!this._eventsInProgress.rotate
                }
                isMoving() {
                    return !!Ji(this._eventsInProgress) || this.isZooming()
                }
                _blockedByActive(n, u, f) {
                    for (const _ in n)
                        if (_ !== f && (!u || u.indexOf(_) < 0)) return !0;
                    return !1
                }
                _getMapTouches(n) {
                    const u = [];
                    for (const f of n) this._el.contains(f.target) && u.push(f);
                    return u
                }
                mergeHandlerResult(n, u, f, _, S) {
                    if (!f) return;
                    p.e(n, f);
                    const L = {
                        handlerName: _,
                        originalEvent: f.originalEvent || S
                    };
                    f.zoomDelta !== void 0 && (u.zoom = L), f.panDelta !== void 0 && (u.drag = L), f.pitchDelta !== void 0 && (u.pitch = L), f.bearingDelta !== void 0 && (u.rotate = L)
                }
                _applyChanges() {
                    const n = {},
                        u = {},
                        f = {};
                    for (const [_, S, L] of this._changes) _.panDelta && (n.panDelta = (n.panDelta || new p.P(0, 0))._add(_.panDelta)), _.zoomDelta && (n.zoomDelta = (n.zoomDelta || 0) + _.zoomDelta), _.bearingDelta && (n.bearingDelta = (n.bearingDelta || 0) + _.bearingDelta), _.pitchDelta && (n.pitchDelta = (n.pitchDelta || 0) + _.pitchDelta), _.around !== void 0 && (n.around = _.around), _.pinchAround !== void 0 && (n.pinchAround = _.pinchAround), _.noInertia && (n.noInertia = _.noInertia), p.e(u, S), p.e(f, L);
                    this._updateMapTransform(n, u, f), this._changes = []
                }
                _updateMapTransform(n, u, f) {
                    const _ = this._map,
                        S = _._getTransformForUpdate(),
                        L = _.terrain;
                    if (!(Io(n) || L && this._terrainMovement)) return this._fireEvents(u, f, !0);
                    let {
                        panDelta: P,
                        zoomDelta: I,
                        bearingDelta: G,
                        pitchDelta: j,
                        around: ee,
                        pinchAround: pe
                    } = n;
                    pe !== void 0 && (ee = pe), _._stop(!0), ee = ee || _.transform.centerPoint;
                    const Ce = S.pointLocation(P ? ee.sub(P) : ee);
                    G && (S.bearing += G), j && (S.pitch += j), I && (S.zoom += I), L ? this._terrainMovement || !u.drag && !u.zoom ? u.drag && this._terrainMovement ? S.center = S.pointLocation(S.centerPoint.sub(P)) : S.setLocationAtPoint(Ce, ee) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, S.setLocationAtPoint(Ce, ee), this._map.once("moveend", () => {
                        this._map._elevationFreeze = !1, this._terrainMovement = !1, S.recalculateZoom(_.terrain)
                    })) : S.setLocationAtPoint(Ce, ee), _._applyUpdatedTransform(S), this._map._update(), n.noInertia || this._inertia.record(n), this._fireEvents(u, f, !0)
                }
                _fireEvents(n, u, f) {
                    const _ = Ji(this._eventsInProgress),
                        S = Ji(n),
                        L = {};
                    for (const j in n) {
                        const {
                            originalEvent: ee
                        } = n[j];
                        this._eventsInProgress[j] || (L[`${j}start`] = ee), this._eventsInProgress[j] = n[j]
                    }!_ && S && this._fireEvent("movestart", S.originalEvent);
                    for (const j in L) this._fireEvent(j, L[j]);
                    S && this._fireEvent("move", S.originalEvent);
                    for (const j in n) {
                        const {
                            originalEvent: ee
                        } = n[j];
                        this._fireEvent(j, ee)
                    }
                    const P = {};
                    let I;
                    for (const j in this._eventsInProgress) {
                        const {
                            handlerName: ee,
                            originalEvent: pe
                        } = this._eventsInProgress[j];
                        this._handlersById[ee].isActive() || (delete this._eventsInProgress[j], I = u[ee] || pe, P[`${j}end`] = I)
                    }
                    for (const j in P) this._fireEvent(j, P[j]);
                    const G = Ji(this._eventsInProgress);
                    if (f && (_ || S) && !G) {
                        this._updatingCamera = !0;
                        const j = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),
                            ee = pe => pe !== 0 && -this._bearingSnap < pe && pe < this._bearingSnap;
                        !j || !j.essential && be.prefersReducedMotion ? (this._map.fire(new p.k("moveend", {
                            originalEvent: I
                        })), ee(this._map.getBearing()) && this._map.resetNorth()) : (ee(j.bearing || this._map.getBearing()) && (j.bearing = 0), j.freezeElevation = !0, this._map.easeTo(j, {
                            originalEvent: I
                        })), this._updatingCamera = !1
                    }
                }
                _fireEvent(n, u) {
                    this._map.fire(new p.k(n, u ? {
                        originalEvent: u
                    } : {}))
                }
                _requestFrame() {
                    return this._map.triggerRepaint(), this._map._renderTaskQueue.add(n => {
                        delete this._frameId, this.handleEvent(new ln("renderFrame", {
                            timeStamp: n
                        })), this._applyChanges()
                    })
                }
                _triggerRenderFrame() {
                    this._frameId === void 0 && (this._frameId = this._requestFrame())
                }
            }
            class ec extends p.E {
                constructor(n, u) {
                    super(), this._renderFrameCallback = () => {
                        const f = Math.min((be.now() - this._easeStart) / this._easeOptions.duration, 1);
                        this._onEaseFrame(this._easeOptions.easing(f)), f < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop()
                    }, this._moving = !1, this._zooming = !1, this.transform = n, this._bearingSnap = u.bearingSnap, this.on("moveend", () => {
                        delete this._requestedCameraState
                    })
                }
                getCenter() {
                    return new p.M(this.transform.center.lng, this.transform.center.lat)
                }
                setCenter(n, u) {
                    return this.jumpTo({
                        center: n
                    }, u)
                }
                panBy(n, u, f) {
                    return n = p.P.convert(n).mult(-1), this.panTo(this.transform.center, p.e({
                        offset: n
                    }, u), f)
                }
                panTo(n, u, f) {
                    return this.easeTo(p.e({
                        center: n
                    }, u), f)
                }
                getZoom() {
                    return this.transform.zoom
                }
                setZoom(n, u) {
                    return this.jumpTo({
                        zoom: n
                    }, u), this
                }
                zoomTo(n, u, f) {
                    return this.easeTo(p.e({
                        zoom: n
                    }, u), f)
                }
                zoomIn(n, u) {
                    return this.zoomTo(this.getZoom() + 1, n, u), this
                }
                zoomOut(n, u) {
                    return this.zoomTo(this.getZoom() - 1, n, u), this
                }
                getBearing() {
                    return this.transform.bearing
                }
                setBearing(n, u) {
                    return this.jumpTo({
                        bearing: n
                    }, u), this
                }
                getPadding() {
                    return this.transform.padding
                }
                setPadding(n, u) {
                    return this.jumpTo({
                        padding: n
                    }, u), this
                }
                rotateTo(n, u, f) {
                    return this.easeTo(p.e({
                        bearing: n
                    }, u), f)
                }
                resetNorth(n, u) {
                    return this.rotateTo(0, p.e({
                        duration: 1e3
                    }, n), u), this
                }
                resetNorthPitch(n, u) {
                    return this.easeTo(p.e({
                        bearing: 0,
                        pitch: 0,
                        duration: 1e3
                    }, n), u), this
                }
                snapToNorth(n, u) {
                    return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(n, u) : this
                }
                getPitch() {
                    return this.transform.pitch
                }
                setPitch(n, u) {
                    return this.jumpTo({
                        pitch: n
                    }, u), this
                }
                cameraForBounds(n, u) {
                    n = tt.convert(n);
                    const f = u && u.bearing || 0;
                    return this._cameraForBoxAndBearing(n.getNorthWest(), n.getSouthEast(), f, u)
                }
                _cameraForBoxAndBearing(n, u, f, _) {
                    const S = {
                        top: 0,
                        bottom: 0,
                        right: 0,
                        left: 0
                    };
                    if (typeof(_ = p.e({
                            padding: S,
                            offset: [0, 0],
                            maxZoom: this.transform.maxZoom
                        }, _)).padding == "number") {
                        const Ri = _.padding;
                        _.padding = {
                            top: Ri,
                            bottom: Ri,
                            right: Ri,
                            left: Ri
                        }
                    }
                    _.padding = p.e(S, _.padding);
                    const L = this.transform,
                        P = L.padding,
                        I = new tt(n, u),
                        G = L.project(I.getNorthWest()),
                        j = L.project(I.getNorthEast()),
                        ee = L.project(I.getSouthEast()),
                        pe = L.project(I.getSouthWest()),
                        Ce = p.b7(-f),
                        Me = G.rotate(Ce),
                        ke = j.rotate(Ce),
                        we = ee.rotate(Ce),
                        nt = pe.rotate(Ce),
                        bt = new p.P(Math.max(Me.x, ke.x, nt.x, we.x), Math.max(Me.y, ke.y, nt.y, we.y)),
                        ze = new p.P(Math.min(Me.x, ke.x, nt.x, we.x), Math.min(Me.y, ke.y, nt.y, we.y)),
                        ut = bt.sub(ze),
                        St = (L.width - (P.left + P.right + _.padding.left + _.padding.right)) / ut.x,
                        yt = (L.height - (P.top + P.bottom + _.padding.top + _.padding.bottom)) / ut.y;
                    if (yt < 0 || St < 0) return void p.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
                    const Vt = Math.min(L.scaleZoom(L.scale * Math.min(St, yt)), _.maxZoom),
                        ci = p.P.convert(_.offset),
                        $t = new p.P((_.padding.left - _.padding.right) / 2, (_.padding.top - _.padding.bottom) / 2).rotate(p.b7(f)),
                        gi = ci.add($t).mult(L.scale / L.zoomScale(Vt));
                    return {
                        center: L.unproject(G.add(ee).div(2).sub(gi)),
                        zoom: Vt,
                        bearing: f
                    }
                }
                fitBounds(n, u, f) {
                    return this._fitInternal(this.cameraForBounds(n, u), u, f)
                }
                fitScreenCoordinates(n, u, f, _, S) {
                    return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(p.P.convert(n)), this.transform.pointLocation(p.P.convert(u)), f, _), _, S)
                }
                _fitInternal(n, u, f) {
                    return n ? (delete(u = p.e(n, u)).padding, u.linear ? this.easeTo(u, f) : this.flyTo(u, f)) : this
                }
                jumpTo(n, u) {
                    this.stop();
                    const f = this._getTransformForUpdate();
                    let _ = !1,
                        S = !1,
                        L = !1;
                    return "zoom" in n && f.zoom !== +n.zoom && (_ = !0, f.zoom = +n.zoom), n.center !== void 0 && (f.center = p.M.convert(n.center)), "bearing" in n && f.bearing !== +n.bearing && (S = !0, f.bearing = +n.bearing), "pitch" in n && f.pitch !== +n.pitch && (L = !0, f.pitch = +n.pitch), n.padding == null || f.isPaddingEqual(n.padding) || (f.padding = n.padding), this._applyUpdatedTransform(f), this.fire(new p.k("movestart", u)).fire(new p.k("move", u)), _ && this.fire(new p.k("zoomstart", u)).fire(new p.k("zoom", u)).fire(new p.k("zoomend", u)), S && this.fire(new p.k("rotatestart", u)).fire(new p.k("rotate", u)).fire(new p.k("rotateend", u)), L && this.fire(new p.k("pitchstart", u)).fire(new p.k("pitch", u)).fire(new p.k("pitchend", u)), this.fire(new p.k("moveend", u))
                }
                calculateCameraOptionsFromTo(n, u, f, _ = 0) {
                    const S = p.Y.fromLngLat(n, u),
                        L = p.Y.fromLngLat(f, _),
                        P = L.x - S.x,
                        I = L.y - S.y,
                        G = L.z - S.z,
                        j = Math.hypot(P, I, G);
                    if (j === 0) throw new Error("Can't calculate camera options with same From and To");
                    const ee = Math.hypot(P, I),
                        pe = this.transform.scaleZoom(this.transform.cameraToCenterDistance / j / this.transform.tileSize),
                        Ce = 180 * Math.atan2(P, -I) / Math.PI;
                    let Me = 180 * Math.acos(ee / j) / Math.PI;
                    return Me = G < 0 ? 90 - Me : 90 + Me, {
                        center: L.toLngLat(),
                        zoom: pe,
                        pitch: Me,
                        bearing: Ce
                    }
                }
                easeTo(n, u) {
                    this._stop(!1, n.easeId), ((n = p.e({
                        offset: [0, 0],
                        duration: 500,
                        easing: p.b6
                    }, n)).animate === !1 || !n.essential && be.prefersReducedMotion) && (n.duration = 0);
                    const f = this._getTransformForUpdate(),
                        _ = this.getZoom(),
                        S = this.getBearing(),
                        L = this.getPitch(),
                        P = this.getPadding(),
                        I = "zoom" in n ? +n.zoom : _,
                        G = "bearing" in n ? this._normalizeBearing(n.bearing, S) : S,
                        j = "pitch" in n ? +n.pitch : L,
                        ee = "padding" in n ? n.padding : f.padding,
                        pe = p.P.convert(n.offset);
                    let Ce = f.centerPoint.add(pe);
                    const Me = f.pointLocation(Ce),
                        ke = p.M.convert(n.center || Me);
                    this._normalizeCenter(ke);
                    const we = f.project(Me),
                        nt = f.project(ke).sub(we),
                        bt = f.zoomScale(I - _);
                    let ze, ut;
                    n.around && (ze = p.M.convert(n.around), ut = f.locationPoint(ze));
                    const St = {
                        moving: this._moving,
                        zooming: this._zooming,
                        rotating: this._rotating,
                        pitching: this._pitching
                    };
                    return this._zooming = this._zooming || I !== _, this._rotating = this._rotating || S !== G, this._pitching = this._pitching || j !== L, this._padding = !f.isPaddingEqual(ee), this._easeId = n.easeId, this._prepareEase(u, n.noMoveStart, St), this.terrain && this._prepareElevation(ke), this._ease(yt => {
                        if (this._zooming && (f.zoom = p.z.number(_, I, yt)), this._rotating && (f.bearing = p.z.number(S, G, yt)), this._pitching && (f.pitch = p.z.number(L, j, yt)), this._padding && (f.interpolatePadding(P, ee, yt), Ce = f.centerPoint.add(pe)), this.terrain && !n.freezeElevation && this._updateElevation(yt), ze) f.setLocationAtPoint(ze, ut);
                        else {
                            const Vt = f.zoomScale(f.zoom - _),
                                ci = I > _ ? Math.min(2, bt) : Math.max(.5, bt),
                                $t = Math.pow(ci, 1 - yt),
                                gi = f.unproject(we.add(nt.mult(yt * $t)).mult(Vt));
                            f.setLocationAtPoint(f.renderWorldCopies ? gi.wrap() : gi, Ce)
                        }
                        this._applyUpdatedTransform(f), this._fireMoveEvents(u)
                    }, yt => {
                        this.terrain && this._finalizeElevation(), this._afterEase(u, yt)
                    }, n), this
                }
                _prepareEase(n, u, f = {}) {
                    this._moving = !0, u || f.moving || this.fire(new p.k("movestart", n)), this._zooming && !f.zooming && this.fire(new p.k("zoomstart", n)), this._rotating && !f.rotating && this.fire(new p.k("rotatestart", n)), this._pitching && !f.pitching && this.fire(new p.k("pitchstart", n))
                }
                _prepareElevation(n) {
                    this._elevationCenter = n, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(n, this.transform.tileZoom), this._elevationFreeze = !0
                }
                _updateElevation(n) {
                    this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
                    const u = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
                    if (n < 1 && u !== this._elevationTarget) {
                        const f = this._elevationTarget - this._elevationStart;
                        this._elevationStart += n * (f - (u - (f * n + this._elevationStart)) / (1 - n)), this._elevationTarget = u
                    }
                    this.transform.elevation = p.z.number(this._elevationStart, this._elevationTarget, n)
                }
                _finalizeElevation() {
                    this._elevationFreeze = !1, this.transform.recalculateZoom(this.terrain)
                }
                _getTransformForUpdate() {
                    return this.transformCameraUpdate ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform
                }
                _applyUpdatedTransform(n) {
                    if (!this.transformCameraUpdate) return;
                    const u = n.clone(),
                        {
                            center: f,
                            zoom: _,
                            pitch: S,
                            bearing: L,
                            elevation: P
                        } = this.transformCameraUpdate(u);
                    f && (u.center = f), _ !== void 0 && (u.zoom = _), S !== void 0 && (u.pitch = S), L !== void 0 && (u.bearing = L), P !== void 0 && (u.elevation = P), this.transform.apply(u)
                }
                _fireMoveEvents(n) {
                    this.fire(new p.k("move", n)), this._zooming && this.fire(new p.k("zoom", n)), this._rotating && this.fire(new p.k("rotate", n)), this._pitching && this.fire(new p.k("pitch", n))
                }
                _afterEase(n, u) {
                    if (this._easeId && u && this._easeId === u) return;
                    delete this._easeId;
                    const f = this._zooming,
                        _ = this._rotating,
                        S = this._pitching;
                    this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, f && this.fire(new p.k("zoomend", n)), _ && this.fire(new p.k("rotateend", n)), S && this.fire(new p.k("pitchend", n)), this.fire(new p.k("moveend", n))
                }
                flyTo(n, u) {
                    if (!n.essential && be.prefersReducedMotion) {
                        const Vi = p.L(n, ["center", "zoom", "bearing", "pitch", "around"]);
                        return this.jumpTo(Vi, u)
                    }
                    this.stop(), n = p.e({
                        offset: [0, 0],
                        speed: 1.2,
                        curve: 1.42,
                        easing: p.b6
                    }, n);
                    const f = this._getTransformForUpdate(),
                        _ = this.getZoom(),
                        S = this.getBearing(),
                        L = this.getPitch(),
                        P = this.getPadding(),
                        I = "zoom" in n ? p.ac(+n.zoom, f.minZoom, f.maxZoom) : _,
                        G = "bearing" in n ? this._normalizeBearing(n.bearing, S) : S,
                        j = "pitch" in n ? +n.pitch : L,
                        ee = "padding" in n ? n.padding : f.padding,
                        pe = f.zoomScale(I - _),
                        Ce = p.P.convert(n.offset);
                    let Me = f.centerPoint.add(Ce);
                    const ke = f.pointLocation(Me),
                        we = p.M.convert(n.center || ke);
                    this._normalizeCenter(we);
                    const nt = f.project(ke),
                        bt = f.project(we).sub(nt);
                    let ze = n.curve;
                    const ut = Math.max(f.width, f.height),
                        St = ut / pe,
                        yt = bt.mag();
                    if ("minZoom" in n) {
                        const Vi = p.ac(Math.min(n.minZoom, _, I), f.minZoom, f.maxZoom),
                            Jn = ut / f.zoomScale(Vi - _);
                        ze = Math.sqrt(Jn / yt * 2)
                    }
                    const Vt = ze * ze;

                    function ci(Vi) {
                        const Jn = (St * St - ut * ut + (Vi ? -1 : 1) * Vt * Vt * yt * yt) / (2 * (Vi ? St : ut) * Vt * yt);
                        return Math.log(Math.sqrt(Jn * Jn + 1) - Jn)
                    }

                    function $t(Vi) {
                        return (Math.exp(Vi) - Math.exp(-Vi)) / 2
                    }

                    function gi(Vi) {
                        return (Math.exp(Vi) + Math.exp(-Vi)) / 2
                    }
                    const Ri = ci(!1);
                    let Ki = function(Vi) {
                            return gi(Ri) / gi(Ri + ze * Vi)
                        },
                        wi = function(Vi) {
                            return ut * ((gi(Ri) * ($t(Jn = Ri + ze * Vi) / gi(Jn)) - $t(Ri)) / Vt) / yt;
                            var Jn
                        },
                        $i = (ci(!0) - Ri) / ze;
                    if (Math.abs(yt) < 1e-6 || !isFinite($i)) {
                        if (Math.abs(ut - St) < 1e-6) return this.easeTo(n, u);
                        const Vi = St < ut ? -1 : 1;
                        $i = Math.abs(Math.log(St / ut)) / ze, wi = function() {
                            return 0
                        }, Ki = function(Jn) {
                            return Math.exp(Vi * ze * Jn)
                        }
                    }
                    return n.duration = "duration" in n ? +n.duration : 1e3 * $i / ("screenSpeed" in n ? +n.screenSpeed / ze : +n.speed), n.maxDuration && n.duration > n.maxDuration && (n.duration = 0), this._zooming = !0, this._rotating = S !== G, this._pitching = j !== L, this._padding = !f.isPaddingEqual(ee), this._prepareEase(u, !1), this.terrain && this._prepareElevation(we), this._ease(Vi => {
                        const Jn = Vi * $i,
                            xn = 1 / Ki(Jn);
                        f.zoom = Vi === 1 ? I : _ + f.scaleZoom(xn), this._rotating && (f.bearing = p.z.number(S, G, Vi)), this._pitching && (f.pitch = p.z.number(L, j, Vi)), this._padding && (f.interpolatePadding(P, ee, Vi), Me = f.centerPoint.add(Ce)), this.terrain && !n.freezeElevation && this._updateElevation(Vi);
                        const mn = Vi === 1 ? we : f.unproject(nt.add(bt.mult(wi(Jn))).mult(xn));
                        f.setLocationAtPoint(f.renderWorldCopies ? mn.wrap() : mn, Me), this._applyUpdatedTransform(f), this._fireMoveEvents(u)
                    }, () => {
                        this.terrain && this._finalizeElevation(), this._afterEase(u)
                    }, n), this
                }
                isEasing() {
                    return !!this._easeFrameId
                }
                stop() {
                    return this._stop()
                }
                _stop(n, u) {
                    if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
                        const f = this._onEaseEnd;
                        delete this._onEaseEnd, f.call(this, u)
                    }
                    if (!n) {
                        const f = this.handlers;
                        f && f.stop(!1)
                    }
                    return this
                }
                _ease(n, u, f) {
                    f.animate === !1 || f.duration === 0 ? (n(1), u()) : (this._easeStart = be.now(), this._easeOptions = f, this._onEaseFrame = n, this._onEaseEnd = u, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback))
                }
                _normalizeBearing(n, u) {
                    n = p.b0(n, -180, 180);
                    const f = Math.abs(n - u);
                    return Math.abs(n - 360 - u) < f && (n -= 360), Math.abs(n + 360 - u) < f && (n += 360), n
                }
                _normalizeCenter(n) {
                    const u = this.transform;
                    if (!u.renderWorldCopies || u.lngRange) return;
                    const f = n.lng - u.center.lng;
                    n.lng += f > 180 ? -360 : f < -180 ? 360 : 0
                }
                queryTerrainElevation(n) {
                    return this.terrain ? this.terrain.getElevationForLngLatZoom(p.M.convert(n), this.transform.tileZoom) - this.transform.elevation : null
                }
            }
            const ua = {
                compact: !0,
                customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>'
            };
            class tc {
                constructor(n = ua) {
                    this._toggleAttribution = () => {
                        this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")))
                    }, this._updateData = u => {
                        !u || u.sourceDataType !== "metadata" && u.sourceDataType !== "visibility" && u.dataType !== "style" && u.type !== "terrain" || this._updateAttributions()
                    }, this._updateCompact = () => {
                        this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"))
                    }, this._updateCompactMinimize = () => {
                        this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show")
                    }, this.options = n
                }
                getDefaultPosition() {
                    return "bottom-right"
                }
                onAdd(n) {
                    return this._map = n, this._compact = this.options.compact, this._container = Ee.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = Ee.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = Ee.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container
                }
                onRemove() {
                    Ee.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0
                }
                _setElementTitle(n, u) {
                    const f = this._map._getUIString(`AttributionControl.${u}`);
                    n.title = f, n.setAttribute("aria-label", f)
                }
                _updateAttributions() {
                    if (!this._map.style) return;
                    let n = [];
                    if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? n = n.concat(this.options.customAttribution.map(_ => typeof _ != "string" ? "" : _)) : typeof this.options.customAttribution == "string" && n.push(this.options.customAttribution)), this._map.style.stylesheet) {
                        const _ = this._map.style.stylesheet;
                        this.styleOwner = _.owner, this.styleId = _.id
                    }
                    const u = this._map.style.sourceCaches;
                    for (const _ in u) {
                        const S = u[_];
                        if (S.used || S.usedForTerrain) {
                            const L = S.getSource();
                            L.attribution && n.indexOf(L.attribution) < 0 && n.push(L.attribution)
                        }
                    }
                    n = n.filter(_ => String(_).trim()), n.sort((_, S) => _.length - S.length), n = n.filter((_, S) => {
                        for (let L = S + 1; L < n.length; L++)
                            if (n[L].indexOf(_) >= 0) return !1;
                        return !0
                    });
                    const f = n.join(" | ");
                    f !== this._attribHTML && (this._attribHTML = f, n.length ? (this._innerContainer.innerHTML = f, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null)
                }
            }
            class $a {
                constructor(n = {}) {
                    this._updateCompact = () => {
                        const u = this._container.children;
                        if (u.length) {
                            const f = u[0];
                            this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && f.classList.add("maplibregl-compact") : f.classList.remove("maplibregl-compact")
                        }
                    }, this.options = n
                }
                getDefaultPosition() {
                    return "bottom-left"
                }
                onAdd(n) {
                    this._map = n, this._compact = this.options && this.options.compact, this._container = Ee.create("div", "maplibregl-ctrl");
                    const u = Ee.create("a", "maplibregl-ctrl-logo");
                    return u.target = "_blank", u.rel = "noopener nofollow", u.href = "https://maplibre.org/", u.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), u.setAttribute("rel", "noopener nofollow"), this._container.appendChild(u), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container
                }
                onRemove() {
                    Ee.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0
                }
            }
            class Vs {
                constructor() {
                    this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1
                }
                add(n) {
                    const u = ++this._id;
                    return this._queue.push({
                        callback: n,
                        id: u,
                        cancelled: !1
                    }), u
                }
                remove(n) {
                    const u = this._currentlyRunning,
                        f = u ? this._queue.concat(u) : this._queue;
                    for (const _ of f)
                        if (_.id === n) return void(_.cancelled = !0)
                }
                run(n = 0) {
                    if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
                    const u = this._currentlyRunning = this._queue;
                    this._queue = [];
                    for (const f of u)
                        if (!f.cancelled && (f.callback(n), this._cleared)) break;
                    this._cleared = !1, this._currentlyRunning = !1
                }
                clear() {
                    this._currentlyRunning && (this._cleared = !0), this._queue = []
                }
            }
            var zo = p.X([{
                name: "a_pos3d",
                type: "Int16",
                components: 3
            }]);
            class Ar extends p.E {
                constructor(n) {
                    super(), this.sourceCache = n, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, n.usedForTerrain = !0, n.tileSize = this.tileSize * dp(2, this.deltaZoom)
                }
                destruct() {
                    this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null
                }
                update(n, u) {
                    this.sourceCache.update(n, u), this._renderableTilesKeys = [];
                    const f = {};
                    for (const _ of n.coveringTiles({
                            tileSize: this.tileSize,
                            minzoom: this.minzoom,
                            maxzoom: this.maxzoom,
                            reparseOverscaled: !1,
                            terrain: u
                        })) f[_.key] = !0, this._renderableTilesKeys.push(_.key), this._tiles[_.key] || (_.posMatrix = new Float64Array(16), p.aN(_.posMatrix, 0, p.W, 0, p.W, 0, 1), this._tiles[_.key] = new qn(_, this.tileSize));
                    for (const _ in this._tiles) f[_] || delete this._tiles[_]
                }
                freeRtt(n) {
                    for (const u in this._tiles) {
                        const f = this._tiles[u];
                        (!n || f.tileID.equals(n) || f.tileID.isChildOf(n) || n.isChildOf(f.tileID)) && (f.rtt = [])
                    }
                }
                getRenderableTiles() {
                    return this._renderableTilesKeys.map(n => this.getTileByID(n))
                }
                getTileByID(n) {
                    return this._tiles[n]
                }
                getTerrainCoords(n) {
                    const u = {};
                    for (const f of this._renderableTilesKeys) {
                        const _ = this._tiles[f].tileID;
                        if (_.canonical.equals(n.canonical)) {
                            const S = n.clone();
                            S.posMatrix = new Float64Array(16), p.aN(S.posMatrix, 0, p.W, 0, p.W, 0, 1), u[f] = S
                        } else if (_.canonical.isChildOf(n.canonical)) {
                            const S = n.clone();
                            S.posMatrix = new Float64Array(16);
                            const L = _.canonical.z - n.canonical.z,
                                P = _.canonical.x - (_.canonical.x >> L << L),
                                I = _.canonical.y - (_.canonical.y >> L << L),
                                G = p.W >> L;
                            p.aN(S.posMatrix, 0, G, 0, G, 0, 1), p.H(S.posMatrix, S.posMatrix, [-P * G, -I * G, 0]), u[f] = S
                        } else if (n.canonical.isChildOf(_.canonical)) {
                            const S = n.clone();
                            S.posMatrix = new Float64Array(16);
                            const L = n.canonical.z - _.canonical.z,
                                P = n.canonical.x - (n.canonical.x >> L << L),
                                I = n.canonical.y - (n.canonical.y >> L << L),
                                G = p.W >> L;
                            p.aN(S.posMatrix, 0, p.W, 0, p.W, 0, 1), p.H(S.posMatrix, S.posMatrix, [P * G, I * G, 0]), p.J(S.posMatrix, S.posMatrix, [1 / dp(2, L), 1 / dp(2, L), 0]), u[f] = S
                        }
                    }
                    return u
                }
                getSourceTile(n, u) {
                    const f = this.sourceCache._source;
                    let _ = n.overscaledZ - this.deltaZoom;
                    if (_ > f.maxzoom && (_ = f.maxzoom), _ < f.minzoom) return null;
                    this._sourceTileCache[n.key] || (this._sourceTileCache[n.key] = n.scaledTo(_).key);
                    let S = this.sourceCache.getTileByID(this._sourceTileCache[n.key]);
                    if ((!S || !S.dem) && u)
                        for (; _ >= f.minzoom && (!S || !S.dem);) S = this.sourceCache.getTileByID(n.scaledTo(_--).key);
                    return S
                }
                tilesAfterTime(n = Date.now()) {
                    return Object.values(this._tiles).filter(u => u.timeAdded >= n)
                }
            }
            class kr {
                constructor(n, u, f) {
                    this.painter = n, this.sourceCache = new Ar(u), this.options = f, this.exaggeration = typeof f.exaggeration == "number" ? f.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024
                }
                getDEMElevation(n, u, f, _ = p.W) {
                    var S;
                    if (!(u >= 0 && u < _ && f >= 0 && f < _)) return 0;
                    const L = this.getTerrainData(n),
                        P = (S = L.tile) === null || S === void 0 ? void 0 : S.dem;
                    if (!P) return 0;
                    const I = function(Me, ke, we) {
                            var nt = ke[0],
                                bt = ke[1];
                            return Me[0] = we[0] * nt + we[4] * bt + we[12], Me[1] = we[1] * nt + we[5] * bt + we[13], Me
                        }([], [u / _ * p.W, f / _ * p.W], L.u_terrain_matrix),
                        G = [I[0] * P.dim, I[1] * P.dim],
                        j = Math.floor(G[0]),
                        ee = Math.floor(G[1]),
                        pe = G[0] - j,
                        Ce = G[1] - ee;
                    return P.get(j, ee) * (1 - pe) * (1 - Ce) + P.get(j + 1, ee) * pe * (1 - Ce) + P.get(j, ee + 1) * (1 - pe) * Ce + P.get(j + 1, ee + 1) * pe * Ce
                }
                getElevationForLngLatZoom(n, u) {
                    const {
                        tileID: f,
                        mercatorX: _,
                        mercatorY: S
                    } = this._getOverscaledTileIDFromLngLatZoom(n, u);
                    return this.getElevation(f, _ % p.W, S % p.W, p.W)
                }
                getElevation(n, u, f, _ = p.W) {
                    return this.getDEMElevation(n, u, f, _) * this.exaggeration
                }
                getTerrainData(n) {
                    if (!this._emptyDemTexture) {
                        const _ = this.painter.context,
                            S = new p.R({
                                width: 1,
                                height: 1
                            }, new Uint8Array(4));
                        this._emptyDepthTexture = new je(_, S, _.gl.RGBA, {
                            premultiply: !1
                        }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new je(_, new p.R({
                            width: 1,
                            height: 1
                        }), _.gl.RGBA, {
                            premultiply: !1
                        }), this._emptyDemTexture.bind(_.gl.NEAREST, _.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = p.an([])
                    }
                    const u = this.sourceCache.getSourceTile(n, !0);
                    if (u && u.dem && (!u.demTexture || u.needsTerrainPrepare)) {
                        const _ = this.painter.context;
                        u.demTexture = this.painter.getTileTexture(u.dem.stride), u.demTexture ? u.demTexture.update(u.dem.getPixels(), {
                            premultiply: !1
                        }) : u.demTexture = new je(_, u.dem.getPixels(), _.gl.RGBA, {
                            premultiply: !1
                        }), u.demTexture.bind(_.gl.NEAREST, _.gl.CLAMP_TO_EDGE), u.needsTerrainPrepare = !1
                    }
                    const f = u && u + u.tileID.key + n.key;
                    if (f && !this._demMatrixCache[f]) {
                        const _ = this.sourceCache.sourceCache._source.maxzoom;
                        let S = n.canonical.z - u.tileID.canonical.z;
                        n.overscaledZ > n.canonical.z && (n.canonical.z >= _ ? S = n.canonical.z - _ : p.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
                        const L = n.canonical.x - (n.canonical.x >> S << S),
                            P = n.canonical.y - (n.canonical.y >> S << S),
                            I = p.b8(new Float64Array(16), [1 / (p.W << S), 1 / (p.W << S), 0]);
                        p.H(I, I, [L * p.W, P * p.W, 0]), this._demMatrixCache[n.key] = {
                            matrix: I,
                            coord: n
                        }
                    }
                    return {
                        u_depth: 2,
                        u_terrain: 3,
                        u_terrain_dim: u && u.dem && u.dem.dim || 1,
                        u_terrain_matrix: f ? this._demMatrixCache[n.key].matrix : this._emptyDemMatrix,
                        u_terrain_unpack: u && u.dem && u.dem.getUnpackVector() || this._emptyDemUnpack,
                        u_terrain_exaggeration: this.exaggeration,
                        texture: (u && u.demTexture || this._emptyDemTexture).texture,
                        depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture,
                        tile: u
                    }
                }
                getFramebuffer(n) {
                    const u = this.painter,
                        f = u.width / devicePixelRatio,
                        _ = u.height / devicePixelRatio;
                    return !this._fbo || this._fbo.width === f && this._fbo.height === _ || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new je(u.context, {
                        width: f,
                        height: _,
                        data: null
                    }, u.context.gl.RGBA, {
                        premultiply: !1
                    }), this._fboCoordsTexture.bind(u.context.gl.NEAREST, u.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new je(u.context, {
                        width: f,
                        height: _,
                        data: null
                    }, u.context.gl.RGBA, {
                        premultiply: !1
                    }), this._fboDepthTexture.bind(u.context.gl.NEAREST, u.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = u.context.createFramebuffer(f, _, !0, !1), this._fbo.depthAttachment.set(u.context.createRenderbuffer(u.context.gl.DEPTH_COMPONENT16, f, _))), this._fbo.colorAttachment.set(n === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo
                }
                getCoordsTexture() {
                    const n = this.painter.context;
                    if (this._coordsTexture) return this._coordsTexture;
                    const u = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
                    for (let S = 0, L = 0; S < this._coordsTextureSize; S++)
                        for (let P = 0; P < this._coordsTextureSize; P++, L += 4) u[L + 0] = 255 & P, u[L + 1] = 255 & S, u[L + 2] = P >> 8 << 4 | S >> 8, u[L + 3] = 0;
                    const f = new p.R({
                            width: this._coordsTextureSize,
                            height: this._coordsTextureSize
                        }, new Uint8Array(u.buffer)),
                        _ = new je(n, f, n.gl.RGBA, {
                            premultiply: !1
                        });
                    return _.bind(n.gl.NEAREST, n.gl.CLAMP_TO_EDGE), this._coordsTexture = _, _
                }
                pointCoordinate(n) {
                    const u = new Uint8Array(4),
                        f = this.painter.context,
                        _ = f.gl;
                    f.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), _.readPixels(n.x, this.painter.height / devicePixelRatio - n.y - 1, 1, 1, _.RGBA, _.UNSIGNED_BYTE, u), f.bindFramebuffer.set(null);
                    const S = u[0] + (u[2] >> 4 << 8),
                        L = u[1] + ((15 & u[2]) << 8),
                        P = this.coordsIndex[255 - u[3]],
                        I = P && this.sourceCache.getTileByID(P);
                    if (!I) return null;
                    const G = this._coordsTextureSize,
                        j = (1 << I.tileID.canonical.z) * G;
                    return new p.Y((I.tileID.canonical.x * G + S) / j + I.tileID.wrap, (I.tileID.canonical.y * G + L) / j, this.getElevation(I.tileID, S, L, G))
                }
                depthAtPoint(n) {
                    const u = new Uint8Array(4),
                        f = this.painter.context,
                        _ = f.gl;
                    return f.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), _.readPixels(n.x, this.painter.height / devicePixelRatio - n.y - 1, 1, 1, _.RGBA, _.UNSIGNED_BYTE, u), f.bindFramebuffer.set(null), (u[0] / 16777216 + u[1] / 65536 + u[2] / 256 + u[3]) / 256
                }
                getTerrainMesh() {
                    if (this._mesh) return this._mesh;
                    const n = this.painter.context,
                        u = new p.b9,
                        f = new p.aX,
                        _ = this.meshSize,
                        S = p.W / _,
                        L = _ * _;
                    for (let ee = 0; ee <= _; ee++)
                        for (let pe = 0; pe <= _; pe++) u.emplaceBack(pe * S, ee * S, 0);
                    for (let ee = 0; ee < L; ee += _ + 1)
                        for (let pe = 0; pe < _; pe++) f.emplaceBack(pe + ee, _ + pe + ee + 1, _ + pe + ee + 2), f.emplaceBack(pe + ee, _ + pe + ee + 2, pe + ee + 1);
                    const P = u.length,
                        I = P + 2 * (_ + 1);
                    for (const ee of [0, 1])
                        for (let pe = 0; pe <= _; pe++)
                            for (const Ce of [0, 1]) u.emplaceBack(pe * S, ee * p.W, Ce);
                    for (let ee = 0; ee < 2 * _; ee += 2) f.emplaceBack(I + ee, I + ee + 1, I + ee + 3), f.emplaceBack(I + ee, I + ee + 3, I + ee + 2), f.emplaceBack(P + ee, P + ee + 3, P + ee + 1), f.emplaceBack(P + ee, P + ee + 2, P + ee + 3);
                    const G = u.length,
                        j = G + 2 * (_ + 1);
                    for (const ee of [0, 1])
                        for (let pe = 0; pe <= _; pe++)
                            for (const Ce of [0, 1]) u.emplaceBack(ee * p.W, pe * S, Ce);
                    for (let ee = 0; ee < 2 * _; ee += 2) f.emplaceBack(G + ee, G + ee + 1, G + ee + 3), f.emplaceBack(G + ee, G + ee + 3, G + ee + 2), f.emplaceBack(j + ee, j + ee + 3, j + ee + 1), f.emplaceBack(j + ee, j + ee + 2, j + ee + 3);
                    return this._mesh = {
                        indexBuffer: n.createIndexBuffer(f),
                        vertexBuffer: n.createVertexBuffer(u, zo.members),
                        segments: p.$.simpleSegment(0, 0, u.length, f.length)
                    }, this._mesh
                }
                getMeshFrameDelta(n) {
                    return 2 * Math.PI * p.ba / Math.pow(2, n) / 5
                }
                getMinTileElevationForLngLatZoom(n, u) {
                    var f;
                    const {
                        tileID: _
                    } = this._getOverscaledTileIDFromLngLatZoom(n, u);
                    return (f = this.getMinMaxElevation(_).minElevation) !== null && f !== void 0 ? f : 0
                }
                getMinMaxElevation(n) {
                    const u = this.getTerrainData(n).tile,
                        f = {
                            minElevation: null,
                            maxElevation: null
                        };
                    return u && u.dem && (f.minElevation = u.dem.min * this.exaggeration, f.maxElevation = u.dem.max * this.exaggeration), f
                }
                _getOverscaledTileIDFromLngLatZoom(n, u) {
                    const f = p.Y.fromLngLat(n.wrap()),
                        _ = (1 << u) * p.W,
                        S = f.x * _,
                        L = f.y * _,
                        P = Math.floor(S / p.W),
                        I = Math.floor(L / p.W);
                    return {
                        tileID: new p.Q(u, 0, u, P, I),
                        mercatorX: S,
                        mercatorY: L
                    }
                }
            }
            class Wc {
                constructor(n, u, f) {
                    this._context = n, this._size = u, this._tileSize = f, this._objects = [], this._recentlyUsed = [], this._stamp = 0
                }
                destruct() {
                    for (const n of this._objects) n.texture.destroy(), n.fbo.destroy()
                }
                _createObject(n) {
                    const u = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0),
                        f = new je(this._context, {
                            width: this._tileSize,
                            height: this._tileSize,
                            data: null
                        }, this._context.gl.RGBA);
                    return f.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), u.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), u.colorAttachment.set(f.texture), {
                        id: n,
                        fbo: u,
                        texture: f,
                        stamp: -1,
                        inUse: !1
                    }
                }
                getObjectForId(n) {
                    return this._objects[n]
                }
                useObject(n) {
                    n.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter(u => n.id !== u), this._recentlyUsed.push(n.id)
                }
                stampObject(n) {
                    n.stamp = ++this._stamp
                }
                getOrCreateFreeObject() {
                    for (const u of this._recentlyUsed)
                        if (!this._objects[u].inUse) return this._objects[u];
                    if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
                    const n = this._createObject(this._objects.length);
                    return this._objects.push(n), n
                }
                freeObject(n) {
                    n.inUse = !1
                }
                freeAllObjects() {
                    for (const n of this._objects) this.freeObject(n)
                }
                isFull() {
                    return !(this._objects.length < this._size) && this._objects.some(n => !n.inUse) === !1
                }
            }
            const La = {
                background: !0,
                fill: !0,
                line: !0,
                raster: !0,
                hillshade: !0
            };
            class ic {
                constructor(n, u) {
                    this.painter = n, this.terrain = u, this.pool = new Wc(n.context, 30, u.sourceCache.tileSize * u.qualityFactor)
                }
                destruct() {
                    this.pool.destruct()
                }
                getTexture(n) {
                    return this.pool.getObjectForId(n.rtt[this._stacks.length - 1].id).texture
                }
                prepareForRender(n, u) {
                    this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = n._order.filter(f => !n._layers[f].isHidden(u)), this._coordsDescendingInv = {};
                    for (const f in n.sourceCaches) {
                        this._coordsDescendingInv[f] = {};
                        const _ = n.sourceCaches[f].getVisibleCoordinates();
                        for (const S of _) {
                            const L = this.terrain.sourceCache.getTerrainCoords(S);
                            for (const P in L) this._coordsDescendingInv[f][P] || (this._coordsDescendingInv[f][P] = []), this._coordsDescendingInv[f][P].push(L[P])
                        }
                    }
                    this._coordsDescendingInvStr = {};
                    for (const f of n._order) {
                        const _ = n._layers[f],
                            S = _.source;
                        if (La[_.type] && !this._coordsDescendingInvStr[S]) {
                            this._coordsDescendingInvStr[S] = {};
                            for (const L in this._coordsDescendingInv[S]) this._coordsDescendingInvStr[S][L] = this._coordsDescendingInv[S][L].map(P => P.key).sort().join()
                        }
                    }
                    for (const f of this._renderableTiles)
                        for (const _ in this._coordsDescendingInvStr) {
                            const S = this._coordsDescendingInvStr[_][f.tileID.key];
                            S && S !== f.rttCoords[_] && (f.rtt = [])
                        }
                }
                renderLayer(n) {
                    if (n.isHidden(this.painter.transform.zoom)) return !1;
                    const u = n.type,
                        f = this.painter,
                        _ = this._renderableLayerIds[this._renderableLayerIds.length - 1] === n.id;
                    if (La[u] && (this._prevType && La[this._prevType] || this._stacks.push([]), this._prevType = u, this._stacks[this._stacks.length - 1].push(n.id), !_)) return !0;
                    if (La[this._prevType] || La[u] && _) {
                        this._prevType = u;
                        const S = this._stacks.length - 1,
                            L = this._stacks[S] || [];
                        for (const P of this._renderableTiles) {
                            if (this.pool.isFull() && (Jl(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(P), P.rtt[S]) {
                                const G = this.pool.getObjectForId(P.rtt[S].id);
                                if (G.stamp === P.rtt[S].stamp) {
                                    this.pool.useObject(G);
                                    continue
                                }
                            }
                            const I = this.pool.getOrCreateFreeObject();
                            this.pool.useObject(I), this.pool.stampObject(I), P.rtt[S] = {
                                id: I.id,
                                stamp: I.stamp
                            }, f.context.bindFramebuffer.set(I.fbo.framebuffer), f.context.clear({
                                color: p.aO.transparent,
                                stencil: 0
                            }), f.currentStencilSource = void 0;
                            for (let G = 0; G < L.length; G++) {
                                const j = f.style._layers[L[G]],
                                    ee = j.source ? this._coordsDescendingInv[j.source][P.tileID.key] : [P.tileID];
                                f.context.viewport.set([0, 0, I.fbo.width, I.fbo.height]), f._renderTileClippingMasks(j, ee), f.renderLayer(f, f.style.sourceCaches[j.source], j, ee), j.source && (P.rttCoords[j.source] = this._coordsDescendingInvStr[j.source][P.tileID.key])
                            }
                        }
                        return Jl(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects(), La[u]
                    }
                    return !1
                }
            }
            const Jc = {
                    "AttributionControl.ToggleAttribution": "Toggle attribution",
                    "AttributionControl.MapFeedback": "Map feedback",
                    "FullscreenControl.Enter": "Enter fullscreen",
                    "FullscreenControl.Exit": "Exit fullscreen",
                    "GeolocateControl.FindMyLocation": "Find my location",
                    "GeolocateControl.LocationNotAvailable": "Location not available",
                    "LogoControl.Title": "MapLibre logo",
                    "NavigationControl.ResetBearing": "Reset bearing to north",
                    "NavigationControl.ZoomIn": "Zoom in",
                    "NavigationControl.ZoomOut": "Zoom out",
                    "ScaleControl.Feet": "ft",
                    "ScaleControl.Meters": "m",
                    "ScaleControl.Kilometers": "km",
                    "ScaleControl.Miles": "mi",
                    "ScaleControl.NauticalMiles": "nm",
                    "TerrainControl.Enable": "Enable terrain",
                    "TerrainControl.Disable": "Disable terrain",
                    "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map",
                    "CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map",
                    "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map"
                },
                ho = se,
                nc = {
                    center: [0, 0],
                    zoom: 0,
                    bearing: 0,
                    pitch: 0,
                    minZoom: -2,
                    maxZoom: 22,
                    minPitch: 0,
                    maxPitch: 60,
                    interactive: !0,
                    scrollZoom: !0,
                    boxZoom: !0,
                    dragRotate: !0,
                    dragPan: !0,
                    keyboard: !0,
                    doubleClickZoom: !0,
                    touchZoomRotate: !0,
                    touchPitch: !0,
                    cooperativeGestures: !1,
                    bearingSnap: 7,
                    clickTolerance: 3,
                    pitchWithRotate: !0,
                    hash: !1,
                    attributionControl: ua,
                    maplibreLogo: !1,
                    failIfMajorPerformanceCaveat: !1,
                    preserveDrawingBuffer: !1,
                    trackResize: !0,
                    renderWorldCopies: !0,
                    refreshExpiredTiles: !0,
                    maxTileCacheSize: null,
                    maxTileCacheZoomLevels: p.a.MAX_TILE_CACHE_ZOOM_LEVELS,
                    localIdeographFontFamily: "sans-serif",
                    transformRequest: null,
                    transformCameraUpdate: null,
                    fadeDuration: 300,
                    crossSourceCollisions: !0,
                    validateStyle: !0,
                    maxCanvasSize: [4096, 4096]
                },
                uo = b => {
                    b.touchstart = b.dragStart, b.touchmoveWindow = b.dragMove, b.touchend = b.dragEnd
                },
                Zc = {
                    showCompass: !0,
                    showZoom: !0,
                    visualizePitch: !1
                };
            class bl {
                constructor(n, u, f = !1) {
                    this.mousedown = L => {
                        this.startMouse(p.e({}, L, {
                            ctrlKey: !0,
                            preventDefault: () => L.preventDefault()
                        }), Ee.mousePos(this.element, L)), Ee.addEventListener(window, "mousemove", this.mousemove), Ee.addEventListener(window, "mouseup", this.mouseup)
                    }, this.mousemove = L => {
                        this.moveMouse(L, Ee.mousePos(this.element, L))
                    }, this.mouseup = L => {
                        this.mouseRotate.dragEnd(L), this.mousePitch && this.mousePitch.dragEnd(L), this.offTemp()
                    }, this.touchstart = L => {
                        L.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = Ee.touchPos(this.element, L.targetTouches)[0], this.startTouch(L, this._startPos), Ee.addEventListener(window, "touchmove", this.touchmove, {
                            passive: !1
                        }), Ee.addEventListener(window, "touchend", this.touchend))
                    }, this.touchmove = L => {
                        L.targetTouches.length !== 1 ? this.reset() : (this._lastPos = Ee.touchPos(this.element, L.targetTouches)[0], this.moveTouch(L, this._lastPos))
                    }, this.touchend = L => {
                        L.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp()
                    }, this.reset = () => {
                        this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), this.touchRotate.reset(), this.touchPitch && this.touchPitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp()
                    }, this._clickTolerance = 10;
                    const _ = n.dragRotate._mouseRotate.getClickTolerance(),
                        S = n.dragRotate._mousePitch.getClickTolerance();
                    this.element = u, this.mouseRotate = Vc({
                        clickTolerance: _,
                        enable: !0
                    }), this.touchRotate = (({
                        enable: L,
                        clickTolerance: P,
                        bearingDegreesPerPixelMoved: I = .8
                    }) => {
                        const G = new Ss;
                        return new yl({
                            clickTolerance: P,
                            move: (j, ee) => ({
                                bearingDelta: (ee.x - j.x) * I
                            }),
                            moveStateManager: G,
                            enable: L,
                            assignEvents: uo
                        })
                    })({
                        clickTolerance: _,
                        enable: !0
                    }), this.map = n, f && (this.mousePitch = Uo({
                        clickTolerance: S,
                        enable: !0
                    }), this.touchPitch = (({
                        enable: L,
                        clickTolerance: P,
                        pitchDegreesPerPixelMoved: I = -.5
                    }) => {
                        const G = new Ss;
                        return new yl({
                            clickTolerance: P,
                            move: (j, ee) => ({
                                pitchDelta: (ee.y - j.y) * I
                            }),
                            moveStateManager: G,
                            enable: L,
                            assignEvents: uo
                        })
                    })({
                        clickTolerance: S,
                        enable: !0
                    })), Ee.addEventListener(u, "mousedown", this.mousedown), Ee.addEventListener(u, "touchstart", this.touchstart, {
                        passive: !1
                    }), Ee.addEventListener(u, "touchcancel", this.reset)
                }
                startMouse(n, u) {
                    this.mouseRotate.dragStart(n, u), this.mousePitch && this.mousePitch.dragStart(n, u), Ee.disableDrag()
                }
                startTouch(n, u) {
                    this.touchRotate.dragStart(n, u), this.touchPitch && this.touchPitch.dragStart(n, u), Ee.disableDrag()
                }
                moveMouse(n, u) {
                    const f = this.map,
                        {
                            bearingDelta: _
                        } = this.mouseRotate.dragMove(n, u) || {};
                    if (_ && f.setBearing(f.getBearing() + _), this.mousePitch) {
                        const {
                            pitchDelta: S
                        } = this.mousePitch.dragMove(n, u) || {};
                        S && f.setPitch(f.getPitch() + S)
                    }
                }
                moveTouch(n, u) {
                    const f = this.map,
                        {
                            bearingDelta: _
                        } = this.touchRotate.dragMove(n, u) || {};
                    if (_ && f.setBearing(f.getBearing() + _), this.touchPitch) {
                        const {
                            pitchDelta: S
                        } = this.touchPitch.dragMove(n, u) || {};
                        S && f.setPitch(f.getPitch() + S)
                    }
                }
                off() {
                    const n = this.element;
                    Ee.removeEventListener(n, "mousedown", this.mousedown), Ee.removeEventListener(n, "touchstart", this.touchstart, {
                        passive: !1
                    }), Ee.removeEventListener(window, "touchmove", this.touchmove, {
                        passive: !1
                    }), Ee.removeEventListener(window, "touchend", this.touchend), Ee.removeEventListener(n, "touchcancel", this.reset), this.offTemp()
                }
                offTemp() {
                    Ee.enableDrag(), Ee.removeEventListener(window, "mousemove", this.mousemove), Ee.removeEventListener(window, "mouseup", this.mouseup), Ee.removeEventListener(window, "touchmove", this.touchmove, {
                        passive: !1
                    }), Ee.removeEventListener(window, "touchend", this.touchend)
                }
            }
            let As;

            function rc(b, n, u) {
                const f = new p.M(b.lng, b.lat);
                if (b = new p.M(b.lng, b.lat), n) {
                    const _ = new p.M(b.lng - 360, b.lat),
                        S = new p.M(b.lng + 360, b.lat),
                        L = u.locationPoint(b).distSqr(n);
                    u.locationPoint(_).distSqr(n) < L ? b = _ : u.locationPoint(S).distSqr(n) < L && (b = S)
                }
                for (; Math.abs(b.lng - u.center.lng) > 180;) {
                    const _ = u.locationPoint(b);
                    if (_.x >= 0 && _.y >= 0 && _.x <= u.width && _.y <= u.height) break;
                    b.lng > u.center.lng ? b.lng -= 360 : b.lng += 360
                }
                return b.lng !== f.lng && u.locationPoint(b).y > u.height / 2 - u.getHorizon() ? b : f
            }
            const wl = {
                center: "translate(-50%,-50%)",
                top: "translate(-50%,0)",
                "top-left": "translate(0,0)",
                "top-right": "translate(-100%,0)",
                bottom: "translate(-50%,-100%)",
                "bottom-left": "translate(0,-100%)",
                "bottom-right": "translate(-100%,-100%)",
                left: "translate(0,-50%)",
                right: "translate(-100%,-50%)"
            };

            function El(b, n, u) {
                const f = b.classList;
                for (const _ in wl) f.remove(`maplibregl-${u}-anchor-${_}`);
                f.add(`maplibregl-${u}-anchor-${n}`)
            }
            class Sl extends p.E {
                constructor(n) {
                    if (super(), this._onKeyPress = u => {
                            const f = u.code,
                                _ = u.charCode || u.keyCode;
                            f !== "Space" && f !== "Enter" && _ !== 32 && _ !== 13 || this.togglePopup()
                        }, this._onMapClick = u => {
                            const f = u.originalEvent.target,
                                _ = this._element;
                            this._popup && (f === _ || _.contains(f)) && this.togglePopup()
                        }, this._update = u => {
                            var f;
                            if (!this._map) return;
                            const _ = this._map.loaded() && !this._map.isMoving();
                            ((u == null ? void 0 : u.type) === "terrain" || (u == null ? void 0 : u.type) === "render" && !_) && this._map.once("render", this._update), this._lngLat = this._map.transform.renderWorldCopies ? rc(this._lngLat, this._flatPos, this._map.transform) : (f = this._lngLat) === null || f === void 0 ? void 0 : f.wrap(), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationPoint(this._lngLat)._add(this._offset));
                            let S = "";
                            this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? S = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (S = `rotateZ(${this._rotation-this._map.getBearing()}deg)`);
                            let L = "";
                            this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? L = "rotateX(0deg)" : this._pitchAlignment === "map" && (L = `rotateX(${this._map.getPitch()}deg)`), u && u.type !== "moveend" || (this._pos = this._pos.round()), Ee.setTransform(this._element, `${wl[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${L} ${S}`), be.frameAsync(new AbortController).then(() => {
                                this._updateOpacity(u && u.type === "moveend")
                            }).catch(() => {})
                        }, this._onMove = u => {
                            if (!this._isDragging) {
                                const f = this._clickTolerance || this._map._clickTolerance;
                                this._isDragging = u.point.dist(this._pointerdownPos) >= f
                            }
                            this._isDragging && (this._pos = u.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new p.k("dragstart"))), this.fire(new p.k("drag")))
                        }, this._onUp = () => {
                            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new p.k("dragend")), this._state = "inactive"
                        }, this._addDragHandler = u => {
                            this._element.contains(u.originalEvent.target) && (u.preventDefault(), this._positionDelta = u.point.sub(this._pos).add(this._offset), this._pointerdownPos = u.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp))
                        }, this._anchor = n && n.anchor || "center", this._color = n && n.color || "#3FB1CE", this._scale = n && n.scale || 1, this._draggable = n && n.draggable || !1, this._clickTolerance = n && n.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = n && n.rotation || 0, this._rotationAlignment = n && n.rotationAlignment || "auto", this._pitchAlignment = n && n.pitchAlignment && n.pitchAlignment !== "auto" ? n.pitchAlignment : this._rotationAlignment, this.setOpacity(), this.setOpacity(n == null ? void 0 : n.opacity, n == null ? void 0 : n.opacityWhenCovered), n && n.element) this._element = n.element, this._offset = p.P.convert(n && n.offset || [0, 0]);
                    else {
                        this._defaultMarker = !0, this._element = Ee.create("div"), this._element.setAttribute("aria-label", "Map marker");
                        const u = Ee.createNS("http://www.w3.org/2000/svg", "svg"),
                            f = 41,
                            _ = 27;
                        u.setAttributeNS(null, "display", "block"), u.setAttributeNS(null, "height", `${f}px`), u.setAttributeNS(null, "width", `${_}px`), u.setAttributeNS(null, "viewBox", `0 0 ${_} ${f}`);
                        const S = Ee.createNS("http://www.w3.org/2000/svg", "g");
                        S.setAttributeNS(null, "stroke", "none"), S.setAttributeNS(null, "stroke-width", "1"), S.setAttributeNS(null, "fill", "none"), S.setAttributeNS(null, "fill-rule", "evenodd");
                        const L = Ee.createNS("http://www.w3.org/2000/svg", "g");
                        L.setAttributeNS(null, "fill-rule", "nonzero");
                        const P = Ee.createNS("http://www.w3.org/2000/svg", "g");
                        P.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), P.setAttributeNS(null, "fill", "#000000");
                        const I = [{
                            rx: "10.5",
                            ry: "5.25002273"
                        }, {
                            rx: "10.5",
                            ry: "5.25002273"
                        }, {
                            rx: "9.5",
                            ry: "4.77275007"
                        }, {
                            rx: "8.5",
                            ry: "4.29549936"
                        }, {
                            rx: "7.5",
                            ry: "3.81822308"
                        }, {
                            rx: "6.5",
                            ry: "3.34094679"
                        }, {
                            rx: "5.5",
                            ry: "2.86367051"
                        }, {
                            rx: "4.5",
                            ry: "2.38636864"
                        }];
                        for (const nt of I) {
                            const bt = Ee.createNS("http://www.w3.org/2000/svg", "ellipse");
                            bt.setAttributeNS(null, "opacity", "0.04"), bt.setAttributeNS(null, "cx", "10.5"), bt.setAttributeNS(null, "cy", "5.80029008"), bt.setAttributeNS(null, "rx", nt.rx), bt.setAttributeNS(null, "ry", nt.ry), P.appendChild(bt)
                        }
                        const G = Ee.createNS("http://www.w3.org/2000/svg", "g");
                        G.setAttributeNS(null, "fill", this._color);
                        const j = Ee.createNS("http://www.w3.org/2000/svg", "path");
                        j.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), G.appendChild(j);
                        const ee = Ee.createNS("http://www.w3.org/2000/svg", "g");
                        ee.setAttributeNS(null, "opacity", "0.25"), ee.setAttributeNS(null, "fill", "#000000");
                        const pe = Ee.createNS("http://www.w3.org/2000/svg", "path");
                        pe.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), ee.appendChild(pe);
                        const Ce = Ee.createNS("http://www.w3.org/2000/svg", "g");
                        Ce.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), Ce.setAttributeNS(null, "fill", "#FFFFFF");
                        const Me = Ee.createNS("http://www.w3.org/2000/svg", "g");
                        Me.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
                        const ke = Ee.createNS("http://www.w3.org/2000/svg", "circle");
                        ke.setAttributeNS(null, "fill", "#000000"), ke.setAttributeNS(null, "opacity", "0.25"), ke.setAttributeNS(null, "cx", "5.5"), ke.setAttributeNS(null, "cy", "5.5"), ke.setAttributeNS(null, "r", "5.4999962");
                        const we = Ee.createNS("http://www.w3.org/2000/svg", "circle");
                        we.setAttributeNS(null, "fill", "#FFFFFF"), we.setAttributeNS(null, "cx", "5.5"), we.setAttributeNS(null, "cy", "5.5"), we.setAttributeNS(null, "r", "5.4999962"), Me.appendChild(ke), Me.appendChild(we), L.appendChild(P), L.appendChild(G), L.appendChild(ee), L.appendChild(Ce), L.appendChild(Me), u.appendChild(L), u.setAttributeNS(null, "height", f * this._scale + "px"), u.setAttributeNS(null, "width", _ * this._scale + "px"), this._element.appendChild(u), this._offset = p.P.convert(n && n.offset || [0, -14])
                    }
                    if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", u => {
                            u.preventDefault()
                        }), this._element.addEventListener("mousedown", u => {
                            u.preventDefault()
                        }), El(this._element, this._anchor, "marker"), n && n.className)
                        for (const u of n.className.split(" ")) this._element.classList.add(u);
                    this._popup = null
                }
                addTo(n) {
                    return this.remove(), this._map = n, n.getCanvasContainer().appendChild(this._element), n.on("move", this._update), n.on("moveend", this._update), n.on("terrain", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this
                }
                remove() {
                    return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), Ee.remove(this._element), this._popup && this._popup.remove(), this
                }
                getLngLat() {
                    return this._lngLat
                }
                setLngLat(n) {
                    return this._lngLat = p.M.convert(n), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this
                }
                getElement() {
                    return this._element
                }
                setPopup(n) {
                    if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), n) {
                        if (!("offset" in n.options)) {
                            const _ = Math.abs(13.5) / Math.SQRT2;
                            n.options.offset = this._defaultMarker ? {
                                top: [0, 0],
                                "top-left": [0, 0],
                                "top-right": [0, 0],
                                bottom: [0, -38.1],
                                "bottom-left": [_, -1 * (38.1 - 13.5 + _)],
                                "bottom-right": [-_, -1 * (38.1 - 13.5 + _)],
                                left: [13.5, -1 * (38.1 - 13.5)],
                                right: [-13.5, -1 * (38.1 - 13.5)]
                            } : this._offset
                        }
                        this._popup = n, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress)
                    }
                    return this
                }
                getPopup() {
                    return this._popup
                }
                togglePopup() {
                    const n = this._popup;
                    return n ? (n.isOpen() ? n.remove() : (n.setLngLat(this._lngLat), n.addTo(this._map)), this) : this
                }
                _updateOpacity(n = !1) {
                    var u;
                    if (!(!((u = this._map) === null || u === void 0) && u.terrain)) return void(this._element.style.opacity !== this._opacity && (this._element.style.opacity = this._opacity));
                    if (n) this._opacityTimeout = null;
                    else {
                        if (this._opacityTimeout) return;
                        this._opacityTimeout = setTimeout(() => {
                            this._opacityTimeout = null
                        }, 100)
                    }
                    const f = this._map,
                        _ = f.terrain.depthAtPoint(this._pos),
                        S = f.terrain.getElevationForLngLatZoom(this._lngLat, f.transform.tileZoom);
                    if (f.transform.lngLatToCameraDepth(this._lngLat, S) - _ < .006) return void(this._element.style.opacity = this._opacity);
                    const L = -this._offset.y / f.transform._pixelPerMeter,
                        P = Math.sin(f.getPitch() * Math.PI / 180) * L,
                        I = f.terrain.depthAtPoint(new p.P(this._pos.x, this._pos.y - this._offset.y)),
                        G = f.transform.lngLatToCameraDepth(this._lngLat, S + P);
                    this._element.style.opacity = G - I > .006 ? this._opacityWhenCovered : this._opacity
                }
                getOffset() {
                    return this._offset
                }
                setOffset(n) {
                    return this._offset = p.P.convert(n), this._update(), this
                }
                addClassName(n) {
                    this._element.classList.add(n)
                }
                removeClassName(n) {
                    this._element.classList.remove(n)
                }
                toggleClassName(n) {
                    return this._element.classList.toggle(n)
                }
                setDraggable(n) {
                    return this._draggable = !!n, this._map && (n ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this
                }
                isDraggable() {
                    return this._draggable
                }
                setRotation(n) {
                    return this._rotation = n || 0, this._update(), this
                }
                getRotation() {
                    return this._rotation
                }
                setRotationAlignment(n) {
                    return this._rotationAlignment = n || "auto", this._update(), this
                }
                getRotationAlignment() {
                    return this._rotationAlignment
                }
                setPitchAlignment(n) {
                    return this._pitchAlignment = n && n !== "auto" ? n : this._rotationAlignment, this._update(), this
                }
                getPitchAlignment() {
                    return this._pitchAlignment
                }
                setOpacity(n, u) {
                    return n === void 0 && u === void 0 && (this._opacity = "1", this._opacityWhenCovered = "0.2"), n !== void 0 && (this._opacity = n), u !== void 0 && (this._opacityWhenCovered = u), this._map && this._updateOpacity(!0), this
                }
            }
            const ac = {
                positionOptions: {
                    enableHighAccuracy: !1,
                    maximumAge: 0,
                    timeout: 6e3
                },
                fitBoundsOptions: {
                    maxZoom: 15
                },
                trackUserLocation: !1,
                showAccuracyCircle: !0,
                showUserLocation: !0
            };
            let Gs = 0,
                po = !1;
            const Xc = {
                maxWidth: 100,
                unit: "metric"
            };

            function Al(b, n, u) {
                const f = u && u.maxWidth || 100,
                    _ = b._container.clientHeight / 2,
                    S = b.unproject([0, _]),
                    L = b.unproject([f, _]),
                    P = S.distanceTo(L);
                if (u && u.unit === "imperial") {
                    const I = 3.2808 * P;
                    I > 5280 ? fo(n, f, I / 5280, b._getUIString("ScaleControl.Miles")) : fo(n, f, I, b._getUIString("ScaleControl.Feet"))
                } else u && u.unit === "nautical" ? fo(n, f, P / 1852, b._getUIString("ScaleControl.NauticalMiles")) : P >= 1e3 ? fo(n, f, P / 1e3, b._getUIString("ScaleControl.Kilometers")) : fo(n, f, P, b._getUIString("ScaleControl.Meters"))
            }

            function fo(b, n, u, f) {
                const _ = function(S) {
                    const L = Math.pow(10, `${Math.floor(S)}`.length - 1);
                    let P = S / L;
                    return P = P >= 10 ? 10 : P >= 5 ? 5 : P >= 3 ? 3 : P >= 2 ? 2 : P >= 1 ? 1 : function(I) {
                        const G = Math.pow(10, Math.ceil(-Math.log(I) / Math.LN10));
                        return Math.round(I * G) / G
                    }(P), L * P
                }(u);
                b.style.width = n * (_ / u) + "px", b.innerHTML = `${_}&nbsp;${f}`
            }
            const jc = {
                    closeButton: !0,
                    closeOnClick: !0,
                    focusAfterOpen: !0,
                    className: "",
                    maxWidth: "240px",
                    subpixelPositioning: !1
                },
                sc = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");

            function oc(b) {
                if (b) {
                    if (typeof b == "number") {
                        const n = Math.round(Math.abs(b) / Math.SQRT2);
                        return {
                            center: new p.P(0, 0),
                            top: new p.P(0, b),
                            "top-left": new p.P(n, n),
                            "top-right": new p.P(-n, n),
                            bottom: new p.P(0, -b),
                            "bottom-left": new p.P(n, -n),
                            "bottom-right": new p.P(-n, -n),
                            left: new p.P(b, 0),
                            right: new p.P(-b, 0)
                        }
                    }
                    if (b instanceof p.P || Array.isArray(b)) {
                        const n = p.P.convert(b);
                        return {
                            center: n,
                            top: n,
                            "top-left": n,
                            "top-right": n,
                            bottom: n,
                            "bottom-left": n,
                            "bottom-right": n,
                            left: n,
                            right: n
                        }
                    }
                    return {
                        center: p.P.convert(b.center || [0, 0]),
                        top: p.P.convert(b.top || [0, 0]),
                        "top-left": p.P.convert(b["top-left"] || [0, 0]),
                        "top-right": p.P.convert(b["top-right"] || [0, 0]),
                        bottom: p.P.convert(b.bottom || [0, 0]),
                        "bottom-left": p.P.convert(b["bottom-left"] || [0, 0]),
                        "bottom-right": p.P.convert(b["bottom-right"] || [0, 0]),
                        left: p.P.convert(b.left || [0, 0]),
                        right: p.P.convert(b.right || [0, 0])
                    }
                }
                return oc(new p.P(0, 0))
            }
            const Yc = se;
            C.AJAXError = p.bd, C.Evented = p.E, C.LngLat = p.M, C.MercatorCoordinate = p.Y, C.Point = p.P, C.addProtocol = p.be, C.config = p.a, C.removeProtocol = p.bf, C.AttributionControl = tc, C.BoxZoomHandler = Nc, C.CanvasSource = yn, C.CooperativeGesturesHandler = xl, C.DoubleClickZoomHandler = $l, C.DragPanHandler = Hc, C.DragRotateHandler = Gh, C.EdgeInsets = Qo, C.FullscreenControl = class extends p.E {
                constructor(b = {}) {
                    super(), this._onFullscreenChange = () => {
                        var n;
                        let u = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
                        for (; !((n = u == null ? void 0 : u.shadowRoot) === null || n === void 0) && n.fullscreenElement;) u = u.shadowRoot.fullscreenElement;
                        u === this._container !== this._fullscreen && this._handleFullscreenChange()
                    }, this._onClickFullscreen = () => {
                        this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen()
                    }, this._fullscreen = !1, b && b.container && (b.container instanceof HTMLElement ? this._container = b.container : p.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange")
                }
                onAdd(b) {
                    return this._map = b, this._container || (this._container = this._map.getContainer()), this._controlContainer = Ee.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer
                }
                onRemove() {
                    Ee.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange)
                }
                _setupUI() {
                    const b = this._fullscreenButton = Ee.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
                    Ee.create("span", "maplibregl-ctrl-icon", b).setAttribute("aria-hidden", "true"), b.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange)
                }
                _updateTitle() {
                    const b = this._getTitle();
                    this._fullscreenButton.setAttribute("aria-label", b), this._fullscreenButton.title = b
                }
                _getTitle() {
                    return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter")
                }
                _isFullscreen() {
                    return this._fullscreen
                }
                _handleFullscreenChange() {
                    this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new p.k("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new p.k("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable())
                }
                _exitFullscreen() {
                    window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen()
                }
                _requestFullscreen() {
                    this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen()
                }
                _togglePseudoFullScreen() {
                    this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize()
                }
            }, C.GeoJSONSource = Wt, C.GeolocateControl = class extends p.E {
                constructor(b) {
                    super(), this._onSuccess = n => {
                        if (this._map) {
                            if (this._isOutOfMapMaxBounds(n)) return this._setErrorState(), this.fire(new p.k("outofmaxbounds", n)), this._updateMarker(), void this._finish();
                            if (this.options.trackUserLocation) switch (this._lastKnownPosition = n, this._watchState) {
                                case "WAITING_ACTIVE":
                                case "ACTIVE_LOCK":
                                case "ACTIVE_ERROR":
                                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                                    break;
                                case "BACKGROUND":
                                case "BACKGROUND_ERROR":
                                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                                    break;
                                default:
                                    throw new Error(`Unexpected watchState ${this._watchState}`)
                            }
                            this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(n), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(n), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new p.k("geolocate", n)), this._finish()
                        }
                    }, this._updateCamera = n => {
                        const u = new p.M(n.coords.longitude, n.coords.latitude),
                            f = n.coords.accuracy,
                            _ = this._map.getBearing(),
                            S = p.e({
                                bearing: _
                            }, this.options.fitBoundsOptions),
                            L = tt.fromLngLat(u, f);
                        this._map.fitBounds(L, S, {
                            geolocateSource: !0
                        })
                    }, this._updateMarker = n => {
                        if (n) {
                            const u = new p.M(n.coords.longitude, n.coords.latitude);
                            this._accuracyCircleMarker.setLngLat(u).addTo(this._map), this._userLocationDotMarker.setLngLat(u).addTo(this._map), this._accuracy = n.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
                        } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove()
                    }, this._onZoom = () => {
                        this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
                    }, this._onError = n => {
                        if (this._map) {
                            if (this.options.trackUserLocation)
                                if (n.code === 1) {
                                    this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                                    const u = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                    this._geolocateButton.title = u, this._geolocateButton.setAttribute("aria-label", u), this._geolocationWatchID !== void 0 && this._clearWatch()
                                } else {
                                    if (n.code === 3 && po) return;
                                    this._setErrorState()
                                } this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new p.k("error", n)), this._finish()
                        }
                    }, this._finish = () => {
                        this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0
                    }, this._setupUI = n => {
                        if (this._map) {
                            if (this._container.addEventListener("contextmenu", u => u.preventDefault()), this._geolocateButton = Ee.create("button", "maplibregl-ctrl-geolocate", this._container), Ee.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", n === !1) {
                                p.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                                const u = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                this._geolocateButton.disabled = !0, this._geolocateButton.title = u, this._geolocateButton.setAttribute("aria-label", u)
                            } else {
                                const u = this._map._getUIString("GeolocateControl.FindMyLocation");
                                this._geolocateButton.title = u, this._geolocateButton.setAttribute("aria-label", u)
                            }
                            this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = Ee.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Sl({
                                element: this._dotElement
                            }), this._circleElement = Ee.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Sl({
                                element: this._circleElement,
                                pitchAlignment: "map"
                            }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", u => {
                                u.geolocateSource || this._watchState !== "ACTIVE_LOCK" || u.originalEvent && u.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new p.k("trackuserlocationend")))
                            })
                        }
                    }, this.options = p.e({}, ac, b)
                }
                onAdd(b) {
                    return this._map = b, this._container = Ee.create("div", "maplibregl-ctrl maplibregl-ctrl-group"),
                        function(n = !1) {
                            return p._(this, void 0, void 0, function*() {
                                if (As !== void 0 && !n) return As;
                                if (window.navigator.permissions === void 0) return As = !!window.navigator.geolocation, As;
                                try {
                                    As = (yield window.navigator.permissions.query({
                                        name: "geolocation"
                                    })).state !== "denied"
                                } catch (u) {
                                    As = !!window.navigator.geolocation
                                }
                                return As
                            })
                        }().then(n => this._setupUI(n)), this._container
                }
                onRemove() {
                    this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), Ee.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Gs = 0, po = !1
                }
                _isOutOfMapMaxBounds(b) {
                    const n = this._map.getMaxBounds(),
                        u = b.coords;
                    return n && (u.longitude < n.getWest() || u.longitude > n.getEast() || u.latitude < n.getSouth() || u.latitude > n.getNorth())
                }
                _setErrorState() {
                    switch (this._watchState) {
                        case "WAITING_ACTIVE":
                            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                            break;
                        case "ACTIVE_LOCK":
                            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                            break;
                        case "BACKGROUND":
                            this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                            break;
                        case "ACTIVE_ERROR":
                            break;
                        default:
                            throw new Error(`Unexpected watchState ${this._watchState}`)
                    }
                }
                _updateCircleRadius() {
                    const b = this._map.getBounds(),
                        n = b.getSouthEast(),
                        u = b.getNorthEast(),
                        f = n.distanceTo(u),
                        _ = Math.ceil(this._accuracy / (f / this._map._container.clientHeight) * 2);
                    this._circleElement.style.width = `${_}px`, this._circleElement.style.height = `${_}px`
                }
                trigger() {
                    if (!this._setup) return p.w("Geolocate control triggered before added to a map"), !1;
                    if (this.options.trackUserLocation) {
                        switch (this._watchState) {
                            case "OFF":
                                this._watchState = "WAITING_ACTIVE", this.fire(new p.k("trackuserlocationstart"));
                                break;
                            case "WAITING_ACTIVE":
                            case "ACTIVE_LOCK":
                            case "ACTIVE_ERROR":
                            case "BACKGROUND_ERROR":
                                Gs--, po = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new p.k("trackuserlocationend"));
                                break;
                            case "BACKGROUND":
                                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new p.k("trackuserlocationstart"));
                                break;
                            default:
                                throw new Error(`Unexpected watchState ${this._watchState}`)
                        }
                        switch (this._watchState) {
                            case "WAITING_ACTIVE":
                                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                                break;
                            case "ACTIVE_LOCK":
                                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                                break;
                            case "OFF":
                                break;
                            default:
                                throw new Error(`Unexpected watchState ${this._watchState}`)
                        }
                        if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
                        else if (this._geolocationWatchID === void 0) {
                            let b;
                            this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Gs++, Gs > 1 ? (b = {
                                maximumAge: 6e5,
                                timeout: 0
                            }, po = !0) : (b = this.options.positionOptions, po = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, b)
                        }
                    } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
                    return !0
                }
                _clearWatch() {
                    window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null)
                }
            }, C.Hash = ml, C.ImageSource = Qi, C.KeyboardHandler = Nh, C.LngLatBounds = tt, C.LogoControl = $a, C.Map = class extends ec {
                constructor(b) {
                    if (p.bb.mark(p.bc.create), (b = p.e({}, nc, b)).minZoom != null && b.maxZoom != null && b.minZoom > b.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
                    if (b.minPitch != null && b.maxPitch != null && b.minPitch > b.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
                    if (b.minPitch != null && b.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
                    if (b.maxPitch != null && b.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
                    if (super(new Zl(b.minZoom, b.maxZoom, b.minPitch, b.maxPitch, b.renderWorldCopies), {
                            bearingSnap: b.bearingSnap
                        }), this._contextLost = n => {
                            n.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new p.k("webglcontextlost", {
                                originalEvent: n
                            }))
                        }, this._contextRestored = n => {
                            this._setupPainter(), this.resize(), this._update(), this.fire(new p.k("webglcontextrestored", {
                                originalEvent: n
                            }))
                        }, this._onMapScroll = n => {
                            if (n.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1
                        }, this._onWindowOnline = () => {
                            this._update()
                        }, this._interactive = b.interactive, this._maxTileCacheSize = b.maxTileCacheSize, this._maxTileCacheZoomLevels = b.maxTileCacheZoomLevels, this._failIfMajorPerformanceCaveat = b.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = b.preserveDrawingBuffer, this._antialias = b.antialias, this._trackResize = b.trackResize, this._bearingSnap = b.bearingSnap, this._refreshExpiredTiles = b.refreshExpiredTiles, this._fadeDuration = b.fadeDuration, this._crossSourceCollisions = b.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = b.collectResourceTiming, this._renderTaskQueue = new Vs, this._controls = [], this._mapId = p.a3(), this._locale = p.e({}, Jc, b.locale), this._clickTolerance = b.clickTolerance, this._overridePixelRatio = b.pixelRatio, this._maxCanvasSize = b.maxCanvasSize, this.transformCameraUpdate = b.transformCameraUpdate, this._imageQueueHandle = jt.addThrottleControl(() => this.isMoving()), this._requestManager = new $e(b.transformRequest), typeof b.container == "string") {
                        if (this._container = document.getElementById(b.container), !this._container) throw new Error(`Container '${b.container}' not found.`)
                    } else {
                        if (!(b.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                        this._container = b.container
                    }
                    if (b.maxBounds && this.setMaxBounds(b.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(!1)), this.on("moveend", () => this._update(!1)), this.on("zoom", () => this._update(!0)), this.on("terrain", () => {
                            this.painter.terrainFacilitator.dirty = !0, this._update(!0)
                        }), this.once("idle", () => {
                            this._idleTriggered = !0
                        }), typeof window != "undefined") {
                        addEventListener("online", this._onWindowOnline, !1);
                        let n = !1;
                        const u = fl(f => {
                            this._trackResize && !this._removed && this.resize(f)._update()
                        }, 50);
                        this._resizeObserver = new ResizeObserver(f => {
                            n ? u(f) : n = !0
                        }), this._resizeObserver.observe(this._container)
                    }
                    this.handlers = new Kl(this, b), this._hash = b.hash && new ml(typeof b.hash == "string" && b.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
                        center: b.center,
                        zoom: b.zoom,
                        bearing: b.bearing,
                        pitch: b.pitch
                    }), b.bounds && (this.resize(), this.fitBounds(b.bounds, p.e({}, b.fitBoundsOptions, {
                        duration: 0
                    })))), this.resize(), this._localIdeographFontFamily = b.localIdeographFontFamily, this._validateStyle = b.validateStyle, b.style && this.setStyle(b.style, {
                        localIdeographFontFamily: b.localIdeographFontFamily
                    }), b.attributionControl && this.addControl(new tc(typeof b.attributionControl == "boolean" ? void 0 : b.attributionControl)), b.maplibreLogo && this.addControl(new $a, b.logoPosition), this.on("style.load", () => {
                        this.transform.unmodified && this.jumpTo(this.style.stylesheet)
                    }), this.on("data", n => {
                        this._update(n.dataType === "style"), this.fire(new p.k(`${n.dataType}data`, n))
                    }), this.on("dataloading", n => {
                        this.fire(new p.k(`${n.dataType}dataloading`, n))
                    }), this.on("dataabort", n => {
                        this.fire(new p.k("sourcedataabort", n))
                    })
                }
                _getMapId() {
                    return this._mapId
                }
                addControl(b, n) {
                    if (n === void 0 && (n = b.getDefaultPosition ? b.getDefaultPosition() : "top-right"), !b || !b.onAdd) return this.fire(new p.j(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
                    const u = b.onAdd(this);
                    this._controls.push(b);
                    const f = this._controlPositions[n];
                    return n.indexOf("bottom") !== -1 ? f.insertBefore(u, f.firstChild) : f.appendChild(u), this
                }
                removeControl(b) {
                    if (!b || !b.onRemove) return this.fire(new p.j(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
                    const n = this._controls.indexOf(b);
                    return n > -1 && this._controls.splice(n, 1), b.onRemove(this), this
                }
                hasControl(b) {
                    return this._controls.indexOf(b) > -1
                }
                calculateCameraOptionsFromTo(b, n, u, f) {
                    return f == null && this.terrain && (f = this.terrain.getElevationForLngLatZoom(u, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(b, n, u, f)
                }
                resize(b) {
                    var n;
                    const u = this._containerDimensions(),
                        f = u[0],
                        _ = u[1],
                        S = this._getClampedPixelRatio(f, _);
                    if (this._resizeCanvas(f, _, S), this.painter.resize(f, _, S), this.painter.overLimit()) {
                        const P = this.painter.context.gl;
                        this._maxCanvasSize = [P.drawingBufferWidth, P.drawingBufferHeight];
                        const I = this._getClampedPixelRatio(f, _);
                        this._resizeCanvas(f, _, I), this.painter.resize(f, _, I)
                    }
                    this.transform.resize(f, _), (n = this._requestedCameraState) === null || n === void 0 || n.resize(f, _);
                    const L = !this._moving;
                    return L && (this.stop(), this.fire(new p.k("movestart", b)).fire(new p.k("move", b))), this.fire(new p.k("resize", b)), L && this.fire(new p.k("moveend", b)), this
                }
                _getClampedPixelRatio(b, n) {
                    const {
                        0: u,
                        1: f
                    } = this._maxCanvasSize, _ = this.getPixelRatio(), S = b * _, L = n * _;
                    return Math.min(S > u ? u / S : 1, L > f ? f / L : 1) * _
                }
                getPixelRatio() {
                    var b;
                    return (b = this._overridePixelRatio) !== null && b !== void 0 ? b : devicePixelRatio
                }
                setPixelRatio(b) {
                    this._overridePixelRatio = b, this.resize()
                }
                getBounds() {
                    return this.transform.getBounds()
                }
                getMaxBounds() {
                    return this.transform.getMaxBounds()
                }
                setMaxBounds(b) {
                    return this.transform.setMaxBounds(tt.convert(b)), this._update()
                }
                setMinZoom(b) {
                    if ((b = b == null ? -2 : b) >= -2 && b <= this.transform.maxZoom) return this.transform.minZoom = b, this._update(), this.getZoom() < b && this.setZoom(b), this;
                    throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")
                }
                getMinZoom() {
                    return this.transform.minZoom
                }
                setMaxZoom(b) {
                    if ((b = b == null ? 22 : b) >= this.transform.minZoom) return this.transform.maxZoom = b, this._update(), this.getZoom() > b && this.setZoom(b), this;
                    throw new Error("maxZoom must be greater than the current minZoom")
                }
                getMaxZoom() {
                    return this.transform.maxZoom
                }
                setMinPitch(b) {
                    if ((b = b == null ? 0 : b) < 0) throw new Error("minPitch must be greater than or equal to 0");
                    if (b >= 0 && b <= this.transform.maxPitch) return this.transform.minPitch = b, this._update(), this.getPitch() < b && this.setPitch(b), this;
                    throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")
                }
                getMinPitch() {
                    return this.transform.minPitch
                }
                setMaxPitch(b) {
                    if ((b = b == null ? 60 : b) > 85) throw new Error("maxPitch must be less than or equal to 85");
                    if (b >= this.transform.minPitch) return this.transform.maxPitch = b, this._update(), this.getPitch() > b && this.setPitch(b), this;
                    throw new Error("maxPitch must be greater than the current minPitch")
                }
                getMaxPitch() {
                    return this.transform.maxPitch
                }
                getRenderWorldCopies() {
                    return this.transform.renderWorldCopies
                }
                setRenderWorldCopies(b) {
                    return this.transform.renderWorldCopies = b, this._update()
                }
                project(b) {
                    return this.transform.locationPoint(p.M.convert(b), this.style && this.terrain)
                }
                unproject(b) {
                    return this.transform.pointLocation(p.P.convert(b), this.terrain)
                }
                isMoving() {
                    var b;
                    return this._moving || ((b = this.handlers) === null || b === void 0 ? void 0 : b.isMoving())
                }
                isZooming() {
                    var b;
                    return this._zooming || ((b = this.handlers) === null || b === void 0 ? void 0 : b.isZooming())
                }
                isRotating() {
                    var b;
                    return this._rotating || ((b = this.handlers) === null || b === void 0 ? void 0 : b.isRotating())
                }
                _createDelegatedListener(b, n, u) {
                    if (b === "mouseenter" || b === "mouseover") {
                        let f = !1;
                        return {
                            layer: n,
                            listener: u,
                            delegates: {
                                mousemove: S => {
                                    const L = this.getLayer(n) ? this.queryRenderedFeatures(S.point, {
                                        layers: [n]
                                    }) : [];
                                    L.length ? f || (f = !0, u.call(this, new Aa(b, this, S.originalEvent, {
                                        features: L
                                    }))) : f = !1
                                },
                                mouseout: () => {
                                    f = !1
                                }
                            }
                        }
                    }
                    if (b === "mouseleave" || b === "mouseout") {
                        let f = !1;
                        return {
                            layer: n,
                            listener: u,
                            delegates: {
                                mousemove: L => {
                                    (this.getLayer(n) ? this.queryRenderedFeatures(L.point, {
                                        layers: [n]
                                    }) : []).length ? f = !0 : f && (f = !1, u.call(this, new Aa(b, this, L.originalEvent)))
                                },
                                mouseout: L => {
                                    f && (f = !1, u.call(this, new Aa(b, this, L.originalEvent)))
                                }
                            }
                        }
                    } {
                        const f = _ => {
                            const S = this.getLayer(n) ? this.queryRenderedFeatures(_.point, {
                                layers: [n]
                            }) : [];
                            S.length && (_.features = S, u.call(this, _), delete _.features)
                        };
                        return {
                            layer: n,
                            listener: u,
                            delegates: {
                                [b]: f
                            }
                        }
                    }
                }
                on(b, n, u) {
                    if (u === void 0) return super.on(b, n);
                    const f = this._createDelegatedListener(b, n, u);
                    this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[b] = this._delegatedListeners[b] || [], this._delegatedListeners[b].push(f);
                    for (const _ in f.delegates) this.on(_, f.delegates[_]);
                    return this
                }
                once(b, n, u) {
                    if (u === void 0) return super.once(b, n);
                    const f = this._createDelegatedListener(b, n, u);
                    for (const _ in f.delegates) this.once(_, f.delegates[_]);
                    return this
                }
                off(b, n, u) {
                    return u === void 0 ? super.off(b, n) : (this._delegatedListeners && this._delegatedListeners[b] && (f => {
                        const _ = this._delegatedListeners[b];
                        for (let S = 0; S < _.length; S++) {
                            const L = _[S];
                            if (L.layer === n && L.listener === u) {
                                for (const P in L.delegates) this.off(P, L.delegates[P]);
                                return _.splice(S, 1), this
                            }
                        }
                    })(), this)
                }
                queryRenderedFeatures(b, n) {
                    if (!this.style) return [];
                    let u;
                    const f = b instanceof p.P || Array.isArray(b),
                        _ = f ? b : [
                            [0, 0],
                            [this.transform.width, this.transform.height]
                        ];
                    if (n = n || (f ? {} : b) || {}, _ instanceof p.P || typeof _[0] == "number") u = [p.P.convert(_)];
                    else {
                        const S = p.P.convert(_[0]),
                            L = p.P.convert(_[1]);
                        u = [S, new p.P(L.x, S.y), L, new p.P(S.x, L.y), S]
                    }
                    return this.style.queryRenderedFeatures(u, n, this.transform)
                }
                querySourceFeatures(b, n) {
                    return this.style.querySourceFeatures(b, n)
                }
                setStyle(b, n) {
                    return (n = p.e({}, {
                        localIdeographFontFamily: this._localIdeographFontFamily,
                        validate: this._validateStyle
                    }, n)).diff !== !1 && n.localIdeographFontFamily === this._localIdeographFontFamily && this.style && b ? (this._diffStyle(b, n), this) : (this._localIdeographFontFamily = n.localIdeographFontFamily, this._updateStyle(b, n))
                }
                setTransformRequest(b) {
                    return this._requestManager.setTransformRequest(b), this
                }
                _getUIString(b) {
                    const n = this._locale[b];
                    if (n == null) throw new Error(`Missing UI string '${b}'`);
                    return n
                }
                _updateStyle(b, n) {
                    if (n.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", () => this._updateStyle(b, n));
                    const u = this.style && n.transformStyle ? this.style.serialize() : void 0;
                    return this.style && (this.style.setEventedParent(null), this.style._remove(!b)), b ? (this.style = new Nr(this, n || {}), this.style.setEventedParent(this, {
                        style: this.style
                    }), typeof b == "string" ? this.style.loadURL(b, n, u) : this.style.loadJSON(b, n, u), this) : (delete this.style, this)
                }
                _lazyInitEmptyStyle() {
                    this.style || (this.style = new Nr(this, {}), this.style.setEventedParent(this, {
                        style: this.style
                    }), this.style.loadEmpty())
                }
                _diffStyle(b, n) {
                    if (typeof b == "string") {
                        const u = this._requestManager.transformRequest(b, di.Style);
                        p.h(u, new AbortController).then(f => {
                            this._updateDiff(f.data, n)
                        }).catch(f => {
                            f && this.fire(new p.j(f))
                        })
                    } else typeof b == "object" && this._updateDiff(b, n)
                }
                _updateDiff(b, n) {
                    try {
                        this.style.setState(b, n) && this._update(!0)
                    } catch (u) {
                        p.w(`Unable to perform style diff: ${u.message||u.error||u}.  Rebuilding the style from scratch.`), this._updateStyle(b, n)
                    }
                }
                getStyle() {
                    if (this.style) return this.style.serialize()
                }
                isStyleLoaded() {
                    return this.style ? this.style.loaded() : p.w("There is no style added to the map.")
                }
                addSource(b, n) {
                    return this._lazyInitEmptyStyle(), this.style.addSource(b, n), this._update(!0)
                }
                isSourceLoaded(b) {
                    const n = this.style && this.style.sourceCaches[b];
                    if (n !== void 0) return n.loaded();
                    this.fire(new p.j(new Error(`There is no source with ID '${b}'`)))
                }
                setTerrain(b) {
                    if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), b) {
                        const n = this.style.sourceCaches[b.source];
                        if (!n) throw new Error(`cannot load terrain, because there exists no source with ID: ${b.source}`);
                        this.terrain === null && n.reload();
                        for (const u in this.style._layers) {
                            const f = this.style._layers[u];
                            f.type === "hillshade" && f.source === b.source && p.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.")
                        }
                        this.terrain = new kr(this.painter, n, b), this.painter.renderToTexture = new ic(this.painter, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._terrainDataCallback = u => {
                            u.dataType === "style" ? this.terrain.sourceCache.freeRtt() : u.dataType === "source" && u.tile && (u.sourceId !== b.source || this._elevationFreeze || (this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.terrain.sourceCache.freeRtt(u.tile.tileID))
                        }, this.style.on("data", this._terrainDataCallback)
                    } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0;
                    return this.fire(new p.k("terrain", {
                        terrain: b
                    })), this
                }
                getTerrain() {
                    var b, n;
                    return (n = (b = this.terrain) === null || b === void 0 ? void 0 : b.options) !== null && n !== void 0 ? n : null
                }
                areTilesLoaded() {
                    const b = this.style && this.style.sourceCaches;
                    for (const n in b) {
                        const u = b[n]._tiles;
                        for (const f in u) {
                            const _ = u[f];
                            if (_.state !== "loaded" && _.state !== "errored") return !1
                        }
                    }
                    return !0
                }
                removeSource(b) {
                    return this.style.removeSource(b), this._update(!0)
                }
                getSource(b) {
                    return this.style.getSource(b)
                }
                addImage(b, n, u = {}) {
                    const {
                        pixelRatio: f = 1,
                        sdf: _ = !1,
                        stretchX: S,
                        stretchY: L,
                        content: P
                    } = u;
                    if (this._lazyInitEmptyStyle(), !(n instanceof HTMLImageElement || p.b(n))) {
                        if (n.width === void 0 || n.height === void 0) return this.fire(new p.j(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                        {
                            const {
                                width: I,
                                height: G,
                                data: j
                            } = n, ee = n;
                            return this.style.addImage(b, {
                                data: new p.R({
                                    width: I,
                                    height: G
                                }, new Uint8Array(j)),
                                pixelRatio: f,
                                stretchX: S,
                                stretchY: L,
                                content: P,
                                sdf: _,
                                version: 0,
                                userImage: ee
                            }), ee.onAdd && ee.onAdd(this, b), this
                        }
                    } {
                        const {
                            width: I,
                            height: G,
                            data: j
                        } = be.getImageData(n);
                        this.style.addImage(b, {
                            data: new p.R({
                                width: I,
                                height: G
                            }, j),
                            pixelRatio: f,
                            stretchX: S,
                            stretchY: L,
                            content: P,
                            sdf: _,
                            version: 0
                        })
                    }
                }
                updateImage(b, n) {
                    const u = this.style.getImage(b);
                    if (!u) return this.fire(new p.j(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
                    const f = n instanceof HTMLImageElement || p.b(n) ? be.getImageData(n) : n,
                        {
                            width: _,
                            height: S,
                            data: L
                        } = f;
                    if (_ === void 0 || S === void 0) return this.fire(new p.j(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                    if (_ !== u.data.width || S !== u.data.height) return this.fire(new p.j(new Error("The width and height of the updated image must be that same as the previous version of the image")));
                    const P = !(n instanceof HTMLImageElement || p.b(n));
                    return u.data.replace(L, P), this.style.updateImage(b, u), this
                }
                getImage(b) {
                    return this.style.getImage(b)
                }
                hasImage(b) {
                    return b ? !!this.style.getImage(b) : (this.fire(new p.j(new Error("Missing required image id"))), !1)
                }
                removeImage(b) {
                    this.style.removeImage(b)
                }
                loadImage(b) {
                    return jt.getImage(this._requestManager.transformRequest(b, di.Image), new AbortController)
                }
                listImages() {
                    return this.style.listImages()
                }
                addLayer(b, n) {
                    return this._lazyInitEmptyStyle(), this.style.addLayer(b, n), this._update(!0)
                }
                moveLayer(b, n) {
                    return this.style.moveLayer(b, n), this._update(!0)
                }
                removeLayer(b) {
                    return this.style.removeLayer(b), this._update(!0)
                }
                getLayer(b) {
                    return this.style.getLayer(b)
                }
                getLayersOrder() {
                    return this.style.getLayersOrder()
                }
                setLayerZoomRange(b, n, u) {
                    return this.style.setLayerZoomRange(b, n, u), this._update(!0)
                }
                setFilter(b, n, u = {}) {
                    return this.style.setFilter(b, n, u), this._update(!0)
                }
                getFilter(b) {
                    return this.style.getFilter(b)
                }
                setPaintProperty(b, n, u, f = {}) {
                    return this.style.setPaintProperty(b, n, u, f), this._update(!0)
                }
                getPaintProperty(b, n) {
                    return this.style.getPaintProperty(b, n)
                }
                setLayoutProperty(b, n, u, f = {}) {
                    return this.style.setLayoutProperty(b, n, u, f), this._update(!0)
                }
                getLayoutProperty(b, n) {
                    return this.style.getLayoutProperty(b, n)
                }
                setGlyphs(b, n = {}) {
                    return this._lazyInitEmptyStyle(), this.style.setGlyphs(b, n), this._update(!0)
                }
                getGlyphs() {
                    return this.style.getGlyphsUrl()
                }
                addSprite(b, n, u = {}) {
                    return this._lazyInitEmptyStyle(), this.style.addSprite(b, n, u, f => {
                        f || this._update(!0)
                    }), this
                }
                removeSprite(b) {
                    return this._lazyInitEmptyStyle(), this.style.removeSprite(b), this._update(!0)
                }
                getSprite() {
                    return this.style.getSprite()
                }
                setSprite(b, n = {}) {
                    return this._lazyInitEmptyStyle(), this.style.setSprite(b, n, u => {
                        u || this._update(!0)
                    }), this
                }
                setLight(b, n = {}) {
                    return this._lazyInitEmptyStyle(), this.style.setLight(b, n), this._update(!0)
                }
                getLight() {
                    return this.style.getLight()
                }
                setFeatureState(b, n) {
                    return this.style.setFeatureState(b, n), this._update()
                }
                removeFeatureState(b, n) {
                    return this.style.removeFeatureState(b, n), this._update()
                }
                getFeatureState(b) {
                    return this.style.getFeatureState(b)
                }
                getContainer() {
                    return this._container
                }
                getCanvasContainer() {
                    return this._canvasContainer
                }
                getCanvas() {
                    return this._canvas
                }
                _containerDimensions() {
                    let b = 0,
                        n = 0;
                    return this._container && (b = this._container.clientWidth || 400, n = this._container.clientHeight || 300), [b, n]
                }
                _setupContainer() {
                    const b = this._container;
                    b.classList.add("maplibregl-map");
                    const n = this._canvasContainer = Ee.create("div", "maplibregl-canvas-container", b);
                    this._interactive && n.classList.add("maplibregl-interactive"), this._canvas = Ee.create("canvas", "maplibregl-canvas", n), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
                    const u = this._containerDimensions(),
                        f = this._getClampedPixelRatio(u[0], u[1]);
                    this._resizeCanvas(u[0], u[1], f);
                    const _ = this._controlContainer = Ee.create("div", "maplibregl-control-container", b),
                        S = this._controlPositions = {};
                    ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(L => {
                        S[L] = Ee.create("div", `maplibregl-ctrl-${L} `, _)
                    }), this._container.addEventListener("scroll", this._onMapScroll, !1)
                }
                _resizeCanvas(b, n, u) {
                    this._canvas.width = Math.floor(u * b), this._canvas.height = Math.floor(u * n), this._canvas.style.width = `${b}px`, this._canvas.style.height = `${n}px`
                }
                _setupPainter() {
                    const b = {
                        alpha: !0,
                        stencil: !0,
                        depth: !0,
                        failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
                        preserveDrawingBuffer: this._preserveDrawingBuffer,
                        antialias: this._antialias || !1
                    };
                    let n = null;
                    this._canvas.addEventListener("webglcontextcreationerror", f => {
                        n = {
                            requestedAttributes: b
                        }, f && (n.statusMessage = f.statusMessage, n.type = f.type)
                    }, {
                        once: !0
                    });
                    const u = this._canvas.getContext("webgl2", b) || this._canvas.getContext("webgl", b);
                    if (!u) {
                        const f = "Failed to initialize WebGL";
                        throw n ? (n.message = f, new Error(JSON.stringify(n))) : new Error(f)
                    }
                    this.painter = new kh(u, this.transform), Lt.testSupport(u)
                }
                loaded() {
                    return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded()
                }
                _update(b) {
                    return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || b, this._sourcesDirty = !0, this.triggerRepaint(), this) : this
                }
                _requestRenderFrame(b) {
                    return this._update(), this._renderTaskQueue.add(b)
                }
                _cancelRenderFrame(b) {
                    this._renderTaskQueue.remove(b)
                }
                _render(b) {
                    const n = this._idleTriggered ? this._fadeDuration : 0;
                    if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(b), this._removed) return;
                    let u = !1;
                    if (this.style && this._styleDirty) {
                        this._styleDirty = !1;
                        const _ = this.transform.zoom,
                            S = be.now();
                        this.style.zoomHistory.update(_, S);
                        const L = new p.a8(_, {
                                now: S,
                                fadeDuration: n,
                                zoomHistory: this.style.zoomHistory,
                                transition: this.style.getTransition()
                            }),
                            P = L.crossFadingFactor();
                        P === 1 && P === this._crossFadingFactor || (u = !0, this._crossFadingFactor = P), this.style.update(L)
                    }
                    this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._elevationFreeze || (this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, n, this._crossSourceCollisions), this.painter.render(this.style, {
                        showTileBoundaries: this.showTileBoundaries,
                        showOverdrawInspector: this._showOverdrawInspector,
                        rotating: this.isRotating(),
                        zooming: this.isZooming(),
                        moving: this.isMoving(),
                        fadeDuration: n,
                        showPadding: this.showPadding
                    }), this.fire(new p.k("render")), this.loaded() && !this._loaded && (this._loaded = !0, p.bb.mark(p.bc.load), this.fire(new p.k("load"))), this.style && (this.style.hasTransitions() || u) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
                    const f = this._sourcesDirty || this._styleDirty || this._placementDirty;
                    return f || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new p.k("idle")), !this._loaded || this._fullyLoaded || f || (this._fullyLoaded = !0, p.bb.mark(p.bc.fullLoad)), this
                }
                redraw() {
                    return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this
                }
                remove() {
                    var b;
                    this._hash && this._hash.remove();
                    for (const u of this._controls) u.onRemove(this);
                    this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window != "undefined" && removeEventListener("online", this._onWindowOnline, !1), jt.removeThrottleControl(this._imageQueueHandle), (b = this._resizeObserver) === null || b === void 0 || b.disconnect();
                    const n = this.painter.context.gl.getExtension("WEBGL_lose_context");
                    n && n.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), Ee.remove(this._canvasContainer), Ee.remove(this._controlContainer), this._container.classList.remove("maplibregl-map"), p.bb.clearMetrics(), this._removed = !0, this.fire(new p.k("remove"))
                }
                triggerRepaint() {
                    this.style && !this._frameRequest && (this._frameRequest = new AbortController, be.frameAsync(this._frameRequest).then(b => {
                        p.bb.frame(b), this._frameRequest = null, this._render(b)
                    }).catch(() => {}))
                }
                get showTileBoundaries() {
                    return !!this._showTileBoundaries
                }
                set showTileBoundaries(b) {
                    this._showTileBoundaries !== b && (this._showTileBoundaries = b, this._update())
                }
                get showPadding() {
                    return !!this._showPadding
                }
                set showPadding(b) {
                    this._showPadding !== b && (this._showPadding = b, this._update())
                }
                get showCollisionBoxes() {
                    return !!this._showCollisionBoxes
                }
                set showCollisionBoxes(b) {
                    this._showCollisionBoxes !== b && (this._showCollisionBoxes = b, b ? this.style._generateCollisionBoxes() : this._update())
                }
                get showOverdrawInspector() {
                    return !!this._showOverdrawInspector
                }
                set showOverdrawInspector(b) {
                    this._showOverdrawInspector !== b && (this._showOverdrawInspector = b, this._update())
                }
                get repaint() {
                    return !!this._repaint
                }
                set repaint(b) {
                    this._repaint !== b && (this._repaint = b, this.triggerRepaint())
                }
                get vertices() {
                    return !!this._vertices
                }
                set vertices(b) {
                    this._vertices = b, this._update()
                }
                get version() {
                    return ho
                }
                getCameraTargetElevation() {
                    return this.transform.elevation
                }
            }, C.MapMouseEvent = Aa, C.MapTouchEvent = Ya, C.MapWheelEvent = Vr, C.Marker = Sl, C.NavigationControl = class {
                constructor(b) {
                    this._updateZoomButtons = () => {
                        const n = this._map.getZoom(),
                            u = n === this._map.getMaxZoom(),
                            f = n === this._map.getMinZoom();
                        this._zoomInButton.disabled = u, this._zoomOutButton.disabled = f, this._zoomInButton.setAttribute("aria-disabled", u.toString()), this._zoomOutButton.setAttribute("aria-disabled", f.toString())
                    }, this._rotateCompassArrow = () => {
                        const n = this.options.visualizePitch ? `scale(${1/Math.pow(Math.cos(this._map.transform.pitch*(Math.PI/180)),.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle*(180/Math.PI)}deg)` : `rotate(${this._map.transform.angle*(180/Math.PI)}deg)`;
                        this._compassIcon.style.transform = n
                    }, this._setButtonTitle = (n, u) => {
                        const f = this._map._getUIString(`NavigationControl.${u}`);
                        n.title = f, n.setAttribute("aria-label", f)
                    }, this.options = p.e({}, Zc, b), this._container = Ee.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", n => n.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", n => this._map.zoomIn({}, {
                        originalEvent: n
                    })), Ee.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", n => this._map.zoomOut({}, {
                        originalEvent: n
                    })), Ee.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", n => {
                        this.options.visualizePitch ? this._map.resetNorthPitch({}, {
                            originalEvent: n
                        }) : this._map.resetNorth({}, {
                            originalEvent: n
                        })
                    }), this._compassIcon = Ee.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"))
                }
                onAdd(b) {
                    return this._map = b, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new bl(this._map, this._compass, this.options.visualizePitch)), this._container
                }
                onRemove() {
                    Ee.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map
                }
                _createButton(b, n) {
                    const u = Ee.create("button", b, this._container);
                    return u.type = "button", u.addEventListener("click", n), u
                }
            }, C.Popup = class extends p.E {
                constructor(b) {
                    super(), this.remove = () => (this._content && Ee.remove(this._content), this._container && (Ee.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map), this.fire(new p.k("close")), this), this._onMouseUp = n => {
                        this._update(n.point)
                    }, this._onMouseMove = n => {
                        this._update(n.point)
                    }, this._onDrag = n => {
                        this._update(n.point)
                    }, this._update = n => {
                        var u;
                        if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
                        if (!this._container) {
                            if (this._container = Ee.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = Ee.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className)
                                for (const P of this.options.className.split(" ")) this._container.classList.add(P);
                            this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer")
                        }
                        if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = this._map.transform.renderWorldCopies && !this._trackPointer ? rc(this._lngLat, this._flatPos, this._map.transform) : (u = this._lngLat) === null || u === void 0 ? void 0 : u.wrap(), this._trackPointer && !n) return;
                        const f = this._flatPos = this._pos = this._trackPointer && n ? n : this._map.project(this._lngLat);
                        this._map.terrain && (this._flatPos = this._trackPointer && n ? n : this._map.transform.locationPoint(this._lngLat));
                        let _ = this.options.anchor;
                        const S = oc(this.options.offset);
                        if (!_) {
                            const P = this._container.offsetWidth,
                                I = this._container.offsetHeight;
                            let G;
                            G = f.y + S.bottom.y < I ? ["top"] : f.y > this._map.transform.height - I ? ["bottom"] : [], f.x < P / 2 ? G.push("left") : f.x > this._map.transform.width - P / 2 && G.push("right"), _ = G.length === 0 ? "bottom" : G.join("-")
                        }
                        let L = f.add(S[_]);
                        this.options.subpixelPositioning || (L = L.round()), Ee.setTransform(this._container, `${wl[_]} translate(${L.x}px,${L.y}px)`), El(this._container, _, "popup")
                    }, this._onClose = () => {
                        this.remove()
                    }, this.options = p.e(Object.create(jc), b)
                }
                addTo(b) {
                    return this._map && this.remove(), this._map = b, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new p.k("open")), this
                }
                isOpen() {
                    return !!this._map
                }
                getLngLat() {
                    return this._lngLat
                }
                setLngLat(b) {
                    return this._lngLat = p.M.convert(b), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this
                }
                trackPointer() {
                    return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this
                }
                getElement() {
                    return this._container
                }
                setText(b) {
                    return this.setDOMContent(document.createTextNode(b))
                }
                setHTML(b) {
                    const n = document.createDocumentFragment(),
                        u = document.createElement("body");
                    let f;
                    for (u.innerHTML = b; f = u.firstChild, f;) n.appendChild(f);
                    return this.setDOMContent(n)
                }
                getMaxWidth() {
                    var b;
                    return (b = this._container) === null || b === void 0 ? void 0 : b.style.maxWidth
                }
                setMaxWidth(b) {
                    return this.options.maxWidth = b, this._update(), this
                }
                setDOMContent(b) {
                    if (this._content)
                        for (; this._content.hasChildNodes();) this._content.firstChild && this._content.removeChild(this._content.firstChild);
                    else this._content = Ee.create("div", "maplibregl-popup-content", this._container);
                    return this._content.appendChild(b), this._createCloseButton(), this._update(), this._focusFirstElement(), this
                }
                addClassName(b) {
                    this._container && this._container.classList.add(b)
                }
                removeClassName(b) {
                    this._container && this._container.classList.remove(b)
                }
                setOffset(b) {
                    return this.options.offset = b, this._update(), this
                }
                toggleClassName(b) {
                    if (this._container) return this._container.classList.toggle(b)
                }
                setSubpixelPositioning(b) {
                    this.options.subpixelPositioning = b
                }
                _createCloseButton() {
                    this.options.closeButton && (this._closeButton = Ee.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose))
                }
                _focusFirstElement() {
                    if (!this.options.focusAfterOpen || !this._container) return;
                    const b = this._container.querySelector(sc);
                    b && b.focus()
                }
            }, C.RasterDEMTileSource = ii, C.RasterTileSource = Ot, C.ScaleControl = class {
                constructor(b) {
                    this._onMove = () => {
                        Al(this._map, this._container, this.options)
                    }, this.setUnit = n => {
                        this.options.unit = n, Al(this._map, this._container, this.options)
                    }, this.options = p.e({}, Xc, b)
                }
                getDefaultPosition() {
                    return "bottom-left"
                }
                onAdd(b) {
                    return this._map = b, this._container = Ee.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", b.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container
                }
                onRemove() {
                    Ee.remove(this._container), this._map.off("move", this._onMove), this._map = void 0
                }
            }, C.ScrollZoomHandler = _l, C.Style = Nr, C.TerrainControl = class {
                constructor(b) {
                    this._toggleTerrain = () => {
                        this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon()
                    }, this._updateTerrainIcon = () => {
                        this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"))
                    }, this.options = b
                }
                onAdd(b) {
                    return this._map = b, this._container = Ee.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = Ee.create("button", "maplibregl-ctrl-terrain", this._container), Ee.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container
                }
                onRemove() {
                    Ee.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0
                }
            }, C.TwoFingersTouchPitchHandler = Gc, C.TwoFingersTouchRotateHandler = Yl, C.TwoFingersTouchZoomHandler = Ih, C.TwoFingersTouchZoomRotateHandler = qa, C.VectorTileSource = Le, C.VideoSource = sn, C.addSourceType = (b, n) => p._(void 0, void 0, void 0, function*() {
                if (rn(b)) throw new Error(`A source type called "${b}" already exists.`);
                ((u, f) => {
                    Yi[u] = f
                })(b, n)
            }), C.clearPrewarmedResources = function() {
                const b = ei;
                b && (b.isPreloaded() && b.numActive() === 1 ? (b.release(Qt), ei = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"))
            }, C.getMaxParallelImageRequests = function() {
                return p.a.MAX_PARALLEL_IMAGE_REQUESTS
            }, C.getRTLTextPluginStatus = function() {
                return Pt().getRTLTextPluginStatus()
            }, C.getVersion = function() {
                return Yc
            }, C.getWorkerCount = function() {
                return Ve.workerCount
            }, C.getWorkerUrl = function() {
                return p.a.WORKER_URL
            }, C.importScriptInWorkers = function(b) {
                return Ne().broadcast("importScript", b)
            }, C.prewarm = function() {
                oe().acquire(Qt)
            }, C.setMaxParallelImageRequests = function(b) {
                p.a.MAX_PARALLEL_IMAGE_REQUESTS = b
            }, C.setRTLTextPlugin = function(b, n) {
                return Pt().setRTLTextPlugin(b, n)
            }, C.setWorkerCount = function(b) {
                Ve.workerCount = b
            }, C.setWorkerUrl = function(b) {
                p.a.WORKER_URL = b
            }
        });
        var Y = y;
        return Y
    })
})(df);
var Fp = df.exports,
    ff = {
        exports: {}
    },
    mf = {
        exports: {}
    },
    Qp = {
        exports: {}
    };
/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
(function(ue, R) {
    (function(y, z) {
        z(R)
    })(uf, function(y) {
        const z = "127",
            sn = "300 es";

        function yn() {}
        Object.assign(yn.prototype, {
            addEventListener: function(s, e) {
                this._listeners === void 0 && (this._listeners = {});
                const r = this._listeners;
                r[s] === void 0 && (r[s] = []), r[s].indexOf(e) === -1 && r[s].push(e)
            },
            hasEventListener: function(s, e) {
                if (this._listeners === void 0) return !1;
                const r = this._listeners;
                return r[s] !== void 0 && r[s].indexOf(e) !== -1
            },
            removeEventListener: function(s, e) {
                if (this._listeners === void 0) return;
                const r = this._listeners[s];
                if (r !== void 0) {
                    const h = r.indexOf(e);
                    h !== -1 && r.splice(h, 1)
                }
            },
            dispatchEvent: function(s) {
                if (this._listeners === void 0) return;
                const e = this._listeners[s.type];
                if (e !== void 0) {
                    s.target = this;
                    const r = e.slice(0);
                    for (let h = 0, c = r.length; h < c; h++) r[h].call(this, s);
                    s.target = null
                }
            }
        });
        const Yi = [];
        for (let s = 0; s < 256; s++) Yi[s] = (s < 16 ? "0" : "") + s.toString(16);
        let rn = 1234567;
        const Mi = {
            DEG2RAD: Math.PI / 180,
            RAD2DEG: 180 / Math.PI,
            generateUUID: function() {
                const s = 4294967295 * Math.random() | 0,
                    e = 4294967295 * Math.random() | 0,
                    r = 4294967295 * Math.random() | 0,
                    h = 4294967295 * Math.random() | 0;
                return (Yi[255 & s] + Yi[s >> 8 & 255] + Yi[s >> 16 & 255] + Yi[s >> 24 & 255] + "-" + Yi[255 & e] + Yi[e >> 8 & 255] + "-" + Yi[e >> 16 & 15 | 64] + Yi[e >> 24 & 255] + "-" + Yi[63 & r | 128] + Yi[r >> 8 & 255] + "-" + Yi[r >> 16 & 255] + Yi[r >> 24 & 255] + Yi[255 & h] + Yi[h >> 8 & 255] + Yi[h >> 16 & 255] + Yi[h >> 24 & 255]).toUpperCase()
            },
            clamp: function(s, e, r) {
                return Math.max(e, Math.min(r, s))
            },
            euclideanModulo: function(s, e) {
                return (s % e + e) % e
            },
            mapLinear: function(s, e, r, h, c) {
                return h + (s - e) * (c - h) / (r - e)
            },
            inverseLerp: function(s, e, r) {
                return s !== e ? (r - s) / (e - s) : 0
            },
            lerp: function(s, e, r) {
                return (1 - r) * s + r * e
            },
            damp: function(s, e, r, h) {
                return Mi.lerp(s, e, 1 - Math.exp(-r * h))
            },
            pingpong: function(s, e = 1) {
                return e - Math.abs(Mi.euclideanModulo(s, 2 * e) - e)
            },
            smoothstep: function(s, e, r) {
                return s <= e ? 0 : s >= r ? 1 : (s = (s - e) / (r - e)) * s * (3 - 2 * s)
            },
            smootherstep: function(s, e, r) {
                return s <= e ? 0 : s >= r ? 1 : (s = (s - e) / (r - e)) * s * s * (s * (6 * s - 15) + 10)
            },
            randInt: function(s, e) {
                return s + Math.floor(Math.random() * (e - s + 1))
            },
            randFloat: function(s, e) {
                return s + Math.random() * (e - s)
            },
            randFloatSpread: function(s) {
                return s * (.5 - Math.random())
            },
            seededRandom: function(s) {
                return s !== void 0 && (rn = s % 2147483647), rn = 16807 * rn % 2147483647, (rn - 1) / 2147483646
            },
            degToRad: function(s) {
                return s * Mi.DEG2RAD
            },
            radToDeg: function(s) {
                return s * Mi.RAD2DEG
            },
            isPowerOfTwo: function(s) {
                return (s & s - 1) == 0 && s !== 0
            },
            ceilPowerOfTwo: function(s) {
                return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2))
            },
            floorPowerOfTwo: function(s) {
                return Math.pow(2, Math.floor(Math.log(s) / Math.LN2))
            },
            setQuaternionFromProperEuler: function(s, e, r, h, c) {
                const v = Math.cos,
                    w = Math.sin,
                    E = v(r / 2),
                    T = w(r / 2),
                    B = v((e + h) / 2),
                    Q = w((e + h) / 2),
                    k = v((e - h) / 2),
                    i = w((e - h) / 2),
                    t = v((h - e) / 2),
                    a = w((h - e) / 2);
                switch (c) {
                    case "XYX":
                        s.set(E * Q, T * k, T * i, E * B);
                        break;
                    case "YZY":
                        s.set(T * i, E * Q, T * k, E * B);
                        break;
                    case "ZXZ":
                        s.set(T * k, T * i, E * Q, E * B);
                        break;
                    case "XZX":
                        s.set(E * Q, T * a, T * t, E * B);
                        break;
                    case "YXY":
                        s.set(T * t, E * Q, T * a, E * B);
                        break;
                    case "ZYZ":
                        s.set(T * a, T * t, E * Q, E * B);
                        break;
                    default:
                        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + c)
                }
            }
        };
        class Ht {
            constructor(e = 0, r = 0) {
                this.x = e, this.y = r
            }
            get width() {
                return this.x
            }
            set width(e) {
                this.x = e
            }
            get height() {
                return this.y
            }
            set height(e) {
                this.y = e
            }
            set(e, r) {
                return this.x = e, this.y = r, this
            }
            setScalar(e) {
                return this.x = e, this.y = e, this
            }
            setX(e) {
                return this.x = e, this
            }
            setY(e) {
                return this.y = e, this
            }
            setComponent(e, r) {
                switch (e) {
                    case 0:
                        this.x = r;
                        break;
                    case 1:
                        this.y = r;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y)
            }
            copy(e) {
                return this.x = e.x, this.y = e.y, this
            }
            add(e, r) {
                return r !== void 0 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, r)) : (this.x += e.x, this.y += e.y, this)
            }
            addScalar(e) {
                return this.x += e, this.y += e, this
            }
            addVectors(e, r) {
                return this.x = e.x + r.x, this.y = e.y + r.y, this
            }
            addScaledVector(e, r) {
                return this.x += e.x * r, this.y += e.y * r, this
            }
            sub(e, r) {
                return r !== void 0 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, r)) : (this.x -= e.x, this.y -= e.y, this)
            }
            subScalar(e) {
                return this.x -= e, this.y -= e, this
            }
            subVectors(e, r) {
                return this.x = e.x - r.x, this.y = e.y - r.y, this
            }
            multiply(e) {
                return this.x *= e.x, this.y *= e.y, this
            }
            multiplyScalar(e) {
                return this.x *= e, this.y *= e, this
            }
            divide(e) {
                return this.x /= e.x, this.y /= e.y, this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            applyMatrix3(e) {
                const r = this.x,
                    h = this.y,
                    c = e.elements;
                return this.x = c[0] * r + c[3] * h + c[6], this.y = c[1] * r + c[4] * h + c[7], this
            }
            min(e) {
                return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
            }
            clamp(e, r) {
                return this.x = Math.max(e.x, Math.min(r.x, this.x)), this.y = Math.max(e.y, Math.min(r.y, this.y)), this
            }
            clampScalar(e, r) {
                return this.x = Math.max(e, Math.min(r, this.x)), this.y = Math.max(e, Math.min(r, this.y)), this
            }
            clampLength(e, r) {
                const h = this.length();
                return this.divideScalar(h || 1).multiplyScalar(Math.max(e, Math.min(r, h)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y
            }
            cross(e) {
                return this.x * e.y - this.y * e.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }
            distanceTo(e) {
                return Math.sqrt(this.distanceToSquared(e))
            }
            distanceToSquared(e) {
                const r = this.x - e.x,
                    h = this.y - e.y;
                return r * r + h * h
            }
            manhattanDistanceTo(e) {
                return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, r) {
                return this.x += (e.x - this.x) * r, this.y += (e.y - this.y) * r, this
            }
            lerpVectors(e, r, h) {
                return this.x = e.x + (r.x - e.x) * h, this.y = e.y + (r.y - e.y) * h, this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y
            }
            fromArray(e, r = 0) {
                return this.x = e[r], this.y = e[r + 1], this
            }
            toArray(e = [], r = 0) {
                return e[r] = this.x, e[r + 1] = this.y, e
            }
            fromBufferAttribute(e, r, h) {
                return h !== void 0 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(r), this.y = e.getY(r), this
            }
            rotateAround(e, r) {
                const h = Math.cos(r),
                    c = Math.sin(r),
                    v = this.x - e.x,
                    w = this.y - e.y;
                return this.x = v * h - w * c + e.x, this.y = v * c + w * h + e.y, this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this
            }
        }
        Ht.prototype.isVector2 = !0;
        class Pt {
            constructor() {
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }
            set(e, r, h, c, v, w, E, T, B) {
                const Q = this.elements;
                return Q[0] = e, Q[1] = c, Q[2] = E, Q[3] = r, Q[4] = v, Q[5] = T, Q[6] = h, Q[7] = w, Q[8] = B, this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            }
            copy(e) {
                const r = this.elements,
                    h = e.elements;
                return r[0] = h[0], r[1] = h[1], r[2] = h[2], r[3] = h[3], r[4] = h[4], r[5] = h[5], r[6] = h[6], r[7] = h[7], r[8] = h[8], this
            }
            extractBasis(e, r, h) {
                return e.setFromMatrix3Column(this, 0), r.setFromMatrix3Column(this, 1), h.setFromMatrix3Column(this, 2), this
            }
            setFromMatrix4(e) {
                const r = e.elements;
                return this.set(r[0], r[4], r[8], r[1], r[5], r[9], r[2], r[6], r[10]), this
            }
            multiply(e) {
                return this.multiplyMatrices(this, e)
            }
            premultiply(e) {
                return this.multiplyMatrices(e, this)
            }
            multiplyMatrices(e, r) {
                const h = e.elements,
                    c = r.elements,
                    v = this.elements,
                    w = h[0],
                    E = h[3],
                    T = h[6],
                    B = h[1],
                    Q = h[4],
                    k = h[7],
                    i = h[2],
                    t = h[5],
                    a = h[8],
                    l = c[0],
                    d = c[3],
                    g = c[6],
                    x = c[1],
                    A = c[4],
                    M = c[7],
                    F = c[2],
                    D = c[5],
                    U = c[8];
                return v[0] = w * l + E * x + T * F, v[3] = w * d + E * A + T * D, v[6] = w * g + E * M + T * U, v[1] = B * l + Q * x + k * F, v[4] = B * d + Q * A + k * D, v[7] = B * g + Q * M + k * U, v[2] = i * l + t * x + a * F, v[5] = i * d + t * A + a * D, v[8] = i * g + t * M + a * U, this
            }
            multiplyScalar(e) {
                const r = this.elements;
                return r[0] *= e, r[3] *= e, r[6] *= e, r[1] *= e, r[4] *= e, r[7] *= e, r[2] *= e, r[5] *= e, r[8] *= e, this
            }
            determinant() {
                const e = this.elements,
                    r = e[0],
                    h = e[1],
                    c = e[2],
                    v = e[3],
                    w = e[4],
                    E = e[5],
                    T = e[6],
                    B = e[7],
                    Q = e[8];
                return r * w * Q - r * E * B - h * v * Q + h * E * T + c * v * B - c * w * T
            }
            invert() {
                const e = this.elements,
                    r = e[0],
                    h = e[1],
                    c = e[2],
                    v = e[3],
                    w = e[4],
                    E = e[5],
                    T = e[6],
                    B = e[7],
                    Q = e[8],
                    k = Q * w - E * B,
                    i = E * T - Q * v,
                    t = B * v - w * T,
                    a = r * k + h * i + c * t;
                if (a === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const l = 1 / a;
                return e[0] = k * l, e[1] = (c * B - Q * h) * l, e[2] = (E * h - c * w) * l, e[3] = i * l, e[4] = (Q * r - c * T) * l, e[5] = (c * v - E * r) * l, e[6] = t * l, e[7] = (h * T - B * r) * l, e[8] = (w * r - h * v) * l, this
            }
            transpose() {
                let e;
                const r = this.elements;
                return e = r[1], r[1] = r[3], r[3] = e, e = r[2], r[2] = r[6], r[6] = e, e = r[5], r[5] = r[7], r[7] = e, this
            }
            getNormalMatrix(e) {
                return this.setFromMatrix4(e).invert().transpose()
            }
            transposeIntoArray(e) {
                const r = this.elements;
                return e[0] = r[0], e[1] = r[3], e[2] = r[6], e[3] = r[1], e[4] = r[4], e[5] = r[7], e[6] = r[2], e[7] = r[5], e[8] = r[8], this
            }
            setUvTransform(e, r, h, c, v, w, E) {
                const T = Math.cos(v),
                    B = Math.sin(v);
                return this.set(h * T, h * B, -h * (T * w + B * E) + w + e, -c * B, c * T, -c * (-B * w + T * E) + E + r, 0, 0, 1), this
            }
            scale(e, r) {
                const h = this.elements;
                return h[0] *= e, h[3] *= e, h[6] *= e, h[1] *= r, h[4] *= r, h[7] *= r, this
            }
            rotate(e) {
                const r = Math.cos(e),
                    h = Math.sin(e),
                    c = this.elements,
                    v = c[0],
                    w = c[3],
                    E = c[6],
                    T = c[1],
                    B = c[4],
                    Q = c[7];
                return c[0] = r * v + h * T, c[3] = r * w + h * B, c[6] = r * E + h * Q, c[1] = -h * v + r * T, c[4] = -h * w + r * B, c[7] = -h * E + r * Q, this
            }
            translate(e, r) {
                const h = this.elements;
                return h[0] += e * h[2], h[3] += e * h[5], h[6] += e * h[8], h[1] += r * h[2], h[4] += r * h[5], h[7] += r * h[8], this
            }
            equals(e) {
                const r = this.elements,
                    h = e.elements;
                for (let c = 0; c < 9; c++)
                    if (r[c] !== h[c]) return !1;
                return !0
            }
            fromArray(e, r = 0) {
                for (let h = 0; h < 9; h++) this.elements[h] = e[h + r];
                return this
            }
            toArray(e = [], r = 0) {
                const h = this.elements;
                return e[r] = h[0], e[r + 1] = h[1], e[r + 2] = h[2], e[r + 3] = h[3], e[r + 4] = h[4], e[r + 5] = h[5], e[r + 6] = h[6], e[r + 7] = h[7], e[r + 8] = h[8], e
            }
            clone() {
                return new this.constructor().fromArray(this.elements)
            }
        }
        let qn;
        Pt.prototype.isMatrix3 = !0;
        const ji = {
            getDataURL: function(s) {
                if (/^data:/i.test(s.src) || typeof HTMLCanvasElement == "undefined") return s.src;
                let e;
                if (s instanceof HTMLCanvasElement) e = s;
                else {
                    qn === void 0 && (qn = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), qn.width = s.width, qn.height = s.height;
                    const r = qn.getContext("2d");
                    s instanceof ImageData ? r.putImageData(s, 0, 0) : r.drawImage(s, 0, 0, s.width, s.height), e = qn
                }
                return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", s), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
            }
        };
        let na = 0;
        class cn extends yn {
            constructor(e = cn.DEFAULT_IMAGE, r = cn.DEFAULT_MAPPING, h = 1001, c = 1001, v = 1006, w = 1008, E = 1023, T = 1009, B = 1, Q = 3e3) {
                super(), Object.defineProperty(this, "id", {
                    value: na++
                }), this.uuid = Mi.generateUUID(), this.name = "", this.image = e, this.mipmaps = [], this.mapping = r, this.wrapS = h, this.wrapT = c, this.magFilter = v, this.minFilter = w, this.anisotropy = B, this.format = E, this.internalFormat = null, this.type = T, this.offset = new Ht(0, 0), this.repeat = new Ht(1, 1), this.center = new Ht(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Pt, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = Q, this.version = 0, this.onUpdate = null
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(e) {
                return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this
            }
            toJSON(e) {
                const r = e === void 0 || typeof e == "string";
                if (!r && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
                const h = {
                    metadata: {
                        version: 4.5,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    type: this.type,
                    encoding: this.encoding,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                if (this.image !== void 0) {
                    const c = this.image;
                    if (c.uuid === void 0 && (c.uuid = Mi.generateUUID()), !r && e.images[c.uuid] === void 0) {
                        let v;
                        if (Array.isArray(c)) {
                            v = [];
                            for (let w = 0, E = c.length; w < E; w++) c[w].isDataTexture ? v.push(yi(c[w].image)) : v.push(yi(c[w]))
                        } else v = yi(c);
                        e.images[c.uuid] = {
                            uuid: c.uuid,
                            url: v
                        }
                    }
                    h.image = c.uuid
                }
                return r || (e.textures[this.uuid] = h), h
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            transformUv(e) {
                if (this.mapping !== 300) return e;
                if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                    case 1e3:
                        e.x = e.x - Math.floor(e.x);
                        break;
                    case 1001:
                        e.x = e.x < 0 ? 0 : 1;
                        break;
                    case 1002:
                        Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                }
                if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                    case 1e3:
                        e.y = e.y - Math.floor(e.y);
                        break;
                    case 1001:
                        e.y = e.y < 0 ? 0 : 1;
                        break;
                    case 1002:
                        Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                }
                return this.flipY && (e.y = 1 - e.y), e
            }
            set needsUpdate(e) {
                e === !0 && this.version++
            }
        }

        function yi(s) {
            return typeof HTMLImageElement != "undefined" && s instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && s instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && s instanceof ImageBitmap ? ji.getDataURL(s) : s.data ? {
                data: Array.prototype.slice.call(s.data),
                width: s.width,
                height: s.height,
                type: s.data.constructor.name
            } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
        }
        cn.DEFAULT_IMAGE = void 0, cn.DEFAULT_MAPPING = 300, cn.prototype.isTexture = !0;
        class Si {
            constructor(e = 0, r = 0, h = 0, c = 1) {
                this.x = e, this.y = r, this.z = h, this.w = c
            }
            get width() {
                return this.z
            }
            set width(e) {
                this.z = e
            }
            get height() {
                return this.w
            }
            set height(e) {
                this.w = e
            }
            set(e, r, h, c) {
                return this.x = e, this.y = r, this.z = h, this.w = c, this
            }
            setScalar(e) {
                return this.x = e, this.y = e, this.z = e, this.w = e, this
            }
            setX(e) {
                return this.x = e, this
            }
            setY(e) {
                return this.y = e, this
            }
            setZ(e) {
                return this.z = e, this
            }
            setW(e) {
                return this.w = e, this
            }
            setComponent(e, r) {
                switch (e) {
                    case 0:
                        this.x = r;
                        break;
                    case 1:
                        this.y = r;
                        break;
                    case 2:
                        this.z = r;
                        break;
                    case 3:
                        this.w = r;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z, this.w)
            }
            copy(e) {
                return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this
            }
            add(e, r) {
                return r !== void 0 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, r)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
            }
            addScalar(e) {
                return this.x += e, this.y += e, this.z += e, this.w += e, this
            }
            addVectors(e, r) {
                return this.x = e.x + r.x, this.y = e.y + r.y, this.z = e.z + r.z, this.w = e.w + r.w, this
            }
            addScaledVector(e, r) {
                return this.x += e.x * r, this.y += e.y * r, this.z += e.z * r, this.w += e.w * r, this
            }
            sub(e, r) {
                return r !== void 0 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, r)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
            }
            subScalar(e) {
                return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
            }
            subVectors(e, r) {
                return this.x = e.x - r.x, this.y = e.y - r.y, this.z = e.z - r.z, this.w = e.w - r.w, this
            }
            multiply(e) {
                return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
            }
            multiplyScalar(e) {
                return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
            }
            applyMatrix4(e) {
                const r = this.x,
                    h = this.y,
                    c = this.z,
                    v = this.w,
                    w = e.elements;
                return this.x = w[0] * r + w[4] * h + w[8] * c + w[12] * v, this.y = w[1] * r + w[5] * h + w[9] * c + w[13] * v, this.z = w[2] * r + w[6] * h + w[10] * c + w[14] * v, this.w = w[3] * r + w[7] * h + w[11] * c + w[15] * v, this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            setAxisAngleFromQuaternion(e) {
                this.w = 2 * Math.acos(e.w);
                const r = Math.sqrt(1 - e.w * e.w);
                return r < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / r, this.y = e.y / r, this.z = e.z / r), this
            }
            setAxisAngleFromRotationMatrix(e) {
                let r, h, c, v;
                const T = e.elements,
                    B = T[0],
                    Q = T[4],
                    k = T[8],
                    i = T[1],
                    t = T[5],
                    a = T[9],
                    l = T[2],
                    d = T[6],
                    g = T[10];
                if (Math.abs(Q - i) < .01 && Math.abs(k - l) < .01 && Math.abs(a - d) < .01) {
                    if (Math.abs(Q + i) < .1 && Math.abs(k + l) < .1 && Math.abs(a + d) < .1 && Math.abs(B + t + g - 3) < .1) return this.set(1, 0, 0, 0), this;
                    r = Math.PI;
                    const A = (B + 1) / 2,
                        M = (t + 1) / 2,
                        F = (g + 1) / 2,
                        D = (Q + i) / 4,
                        U = (k + l) / 4,
                        N = (a + d) / 4;
                    return A > M && A > F ? A < .01 ? (h = 0, c = .707106781, v = .707106781) : (h = Math.sqrt(A), c = D / h, v = U / h) : M > F ? M < .01 ? (h = .707106781, c = 0, v = .707106781) : (c = Math.sqrt(M), h = D / c, v = N / c) : F < .01 ? (h = .707106781, c = .707106781, v = 0) : (v = Math.sqrt(F), h = U / v, c = N / v), this.set(h, c, v, r), this
                }
                let x = Math.sqrt((d - a) * (d - a) + (k - l) * (k - l) + (i - Q) * (i - Q));
                return Math.abs(x) < .001 && (x = 1), this.x = (d - a) / x, this.y = (k - l) / x, this.z = (i - Q) / x, this.w = Math.acos((B + t + g - 1) / 2), this
            }
            min(e) {
                return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
            }
            clamp(e, r) {
                return this.x = Math.max(e.x, Math.min(r.x, this.x)), this.y = Math.max(e.y, Math.min(r.y, this.y)), this.z = Math.max(e.z, Math.min(r.z, this.z)), this.w = Math.max(e.w, Math.min(r.w, this.w)), this
            }
            clampScalar(e, r) {
                return this.x = Math.max(e, Math.min(r, this.x)), this.y = Math.max(e, Math.min(r, this.y)), this.z = Math.max(e, Math.min(r, this.z)), this.w = Math.max(e, Math.min(r, this.w)), this
            }
            clampLength(e, r) {
                const h = this.length();
                return this.divideScalar(h || 1).multiplyScalar(Math.max(e, Math.min(r, h)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, r) {
                return this.x += (e.x - this.x) * r, this.y += (e.y - this.y) * r, this.z += (e.z - this.z) * r, this.w += (e.w - this.w) * r, this
            }
            lerpVectors(e, r, h) {
                return this.x = e.x + (r.x - e.x) * h, this.y = e.y + (r.y - e.y) * h, this.z = e.z + (r.z - e.z) * h, this.w = e.w + (r.w - e.w) * h, this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
            }
            fromArray(e, r = 0) {
                return this.x = e[r], this.y = e[r + 1], this.z = e[r + 2], this.w = e[r + 3], this
            }
            toArray(e = [], r = 0) {
                return e[r] = this.x, e[r + 1] = this.y, e[r + 2] = this.z, e[r + 3] = this.w, e
            }
            fromBufferAttribute(e, r, h) {
                return h !== void 0 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(r), this.y = e.getY(r), this.z = e.getZ(r), this.w = e.getW(r), this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
            }
        }
        Si.prototype.isVector4 = !0;
        class qi extends yn {
            constructor(e, r, h) {
                super(), this.width = e, this.height = r, this.depth = 1, this.scissor = new Si(0, 0, e, r), this.scissorTest = !1, this.viewport = new Si(0, 0, e, r), h = h || {}, this.texture = new cn(void 0, h.mapping, h.wrapS, h.wrapT, h.magFilter, h.minFilter, h.format, h.type, h.anisotropy, h.encoding), this.texture.image = {}, this.texture.image.width = e, this.texture.image.height = r, this.texture.image.depth = 1, this.texture.generateMipmaps = h.generateMipmaps !== void 0 && h.generateMipmaps, this.texture.minFilter = h.minFilter !== void 0 ? h.minFilter : 1006, this.depthBuffer = h.depthBuffer === void 0 || h.depthBuffer, this.stencilBuffer = h.stencilBuffer !== void 0 && h.stencilBuffer, this.depthTexture = h.depthTexture !== void 0 ? h.depthTexture : null
            }
            setTexture(e) {
                e.image = {
                    width: this.width,
                    height: this.height,
                    depth: this.depth
                }, this.texture = e
            }
            setSize(e, r, h = 1) {
                this.width === e && this.height === r && this.depth === h || (this.width = e, this.height = r, this.depth = h, this.texture.image.width = e, this.texture.image.height = r, this.texture.image.depth = h, this.dispose()), this.viewport.set(0, 0, e, r), this.scissor.set(0, 0, e, r)
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(e) {
                return this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        qi.prototype.isWebGLRenderTarget = !0;
        class Nn extends qi {
            constructor(e, r, h) {
                super(e, r, h), this.samples = 4
            }
            copy(e) {
                return super.copy.call(this, e), this.samples = e.samples, this
            }
        }
        Nn.prototype.isWebGLMultisampleRenderTarget = !0;
        class Bn {
            constructor(e = 0, r = 0, h = 0, c = 1) {
                this._x = e, this._y = r, this._z = h, this._w = c
            }
            static slerp(e, r, h, c) {
                return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), h.slerpQuaternions(e, r, c)
            }
            static slerpFlat(e, r, h, c, v, w, E) {
                let T = h[c + 0],
                    B = h[c + 1],
                    Q = h[c + 2],
                    k = h[c + 3];
                const i = v[w + 0],
                    t = v[w + 1],
                    a = v[w + 2],
                    l = v[w + 3];
                if (E === 0) return e[r + 0] = T, e[r + 1] = B, e[r + 2] = Q, void(e[r + 3] = k);
                if (E === 1) return e[r + 0] = i, e[r + 1] = t, e[r + 2] = a, void(e[r + 3] = l);
                if (k !== l || T !== i || B !== t || Q !== a) {
                    let d = 1 - E;
                    const g = T * i + B * t + Q * a + k * l,
                        x = g >= 0 ? 1 : -1,
                        A = 1 - g * g;
                    if (A > Number.EPSILON) {
                        const F = Math.sqrt(A),
                            D = Math.atan2(F, g * x);
                        d = Math.sin(d * D) / F, E = Math.sin(E * D) / F
                    }
                    const M = E * x;
                    if (T = T * d + i * M, B = B * d + t * M, Q = Q * d + a * M, k = k * d + l * M, d === 1 - E) {
                        const F = 1 / Math.sqrt(T * T + B * B + Q * Q + k * k);
                        T *= F, B *= F, Q *= F, k *= F
                    }
                }
                e[r] = T, e[r + 1] = B, e[r + 2] = Q, e[r + 3] = k
            }
            static multiplyQuaternionsFlat(e, r, h, c, v, w) {
                const E = h[c],
                    T = h[c + 1],
                    B = h[c + 2],
                    Q = h[c + 3],
                    k = v[w],
                    i = v[w + 1],
                    t = v[w + 2],
                    a = v[w + 3];
                return e[r] = E * a + Q * k + T * t - B * i, e[r + 1] = T * a + Q * i + B * k - E * t, e[r + 2] = B * a + Q * t + E * i - T * k, e[r + 3] = Q * a - E * k - T * i - B * t, e
            }
            get x() {
                return this._x
            }
            set x(e) {
                this._x = e, this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(e) {
                this._y = e, this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(e) {
                this._z = e, this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(e) {
                this._w = e, this._onChangeCallback()
            }
            set(e, r, h, c) {
                return this._x = e, this._y = r, this._z = h, this._w = c, this._onChangeCallback(), this
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._w)
            }
            copy(e) {
                return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
            }
            setFromEuler(e, r) {
                if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                const h = e._x,
                    c = e._y,
                    v = e._z,
                    w = e._order,
                    E = Math.cos,
                    T = Math.sin,
                    B = E(h / 2),
                    Q = E(c / 2),
                    k = E(v / 2),
                    i = T(h / 2),
                    t = T(c / 2),
                    a = T(v / 2);
                switch (w) {
                    case "XYZ":
                        this._x = i * Q * k + B * t * a, this._y = B * t * k - i * Q * a, this._z = B * Q * a + i * t * k, this._w = B * Q * k - i * t * a;
                        break;
                    case "YXZ":
                        this._x = i * Q * k + B * t * a, this._y = B * t * k - i * Q * a, this._z = B * Q * a - i * t * k, this._w = B * Q * k + i * t * a;
                        break;
                    case "ZXY":
                        this._x = i * Q * k - B * t * a, this._y = B * t * k + i * Q * a, this._z = B * Q * a + i * t * k, this._w = B * Q * k - i * t * a;
                        break;
                    case "ZYX":
                        this._x = i * Q * k - B * t * a, this._y = B * t * k + i * Q * a, this._z = B * Q * a - i * t * k, this._w = B * Q * k + i * t * a;
                        break;
                    case "YZX":
                        this._x = i * Q * k + B * t * a, this._y = B * t * k + i * Q * a, this._z = B * Q * a - i * t * k, this._w = B * Q * k - i * t * a;
                        break;
                    case "XZY":
                        this._x = i * Q * k - B * t * a, this._y = B * t * k - i * Q * a, this._z = B * Q * a + i * t * k, this._w = B * Q * k + i * t * a;
                        break;
                    default:
                        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + w)
                }
                return r !== !1 && this._onChangeCallback(), this
            }
            setFromAxisAngle(e, r) {
                const h = r / 2,
                    c = Math.sin(h);
                return this._x = e.x * c, this._y = e.y * c, this._z = e.z * c, this._w = Math.cos(h), this._onChangeCallback(), this
            }
            setFromRotationMatrix(e) {
                const r = e.elements,
                    h = r[0],
                    c = r[4],
                    v = r[8],
                    w = r[1],
                    E = r[5],
                    T = r[9],
                    B = r[2],
                    Q = r[6],
                    k = r[10],
                    i = h + E + k;
                if (i > 0) {
                    const t = .5 / Math.sqrt(i + 1);
                    this._w = .25 / t, this._x = (Q - T) * t, this._y = (v - B) * t, this._z = (w - c) * t
                } else if (h > E && h > k) {
                    const t = 2 * Math.sqrt(1 + h - E - k);
                    this._w = (Q - T) / t, this._x = .25 * t, this._y = (c + w) / t, this._z = (v + B) / t
                } else if (E > k) {
                    const t = 2 * Math.sqrt(1 + E - h - k);
                    this._w = (v - B) / t, this._x = (c + w) / t, this._y = .25 * t, this._z = (T + Q) / t
                } else {
                    const t = 2 * Math.sqrt(1 + k - h - E);
                    this._w = (w - c) / t, this._x = (v + B) / t, this._y = (T + Q) / t, this._z = .25 * t
                }
                return this._onChangeCallback(), this
            }
            setFromUnitVectors(e, r) {
                let h = e.dot(r) + 1;
                return h < Number.EPSILON ? (h = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = h) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = h)) : (this._x = e.y * r.z - e.z * r.y, this._y = e.z * r.x - e.x * r.z, this._z = e.x * r.y - e.y * r.x, this._w = h), this.normalize()
            }
            angleTo(e) {
                return 2 * Math.acos(Math.abs(Mi.clamp(this.dot(e), -1, 1)))
            }
            rotateTowards(e, r) {
                const h = this.angleTo(e);
                if (h === 0) return this;
                const c = Math.min(1, r / h);
                return this.slerp(e, c), this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
            }
            dot(e) {
                return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let e = this.length();
                return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
            }
            multiply(e, r) {
                return r !== void 0 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, r)) : this.multiplyQuaternions(this, e)
            }
            premultiply(e) {
                return this.multiplyQuaternions(e, this)
            }
            multiplyQuaternions(e, r) {
                const h = e._x,
                    c = e._y,
                    v = e._z,
                    w = e._w,
                    E = r._x,
                    T = r._y,
                    B = r._z,
                    Q = r._w;
                return this._x = h * Q + w * E + c * B - v * T, this._y = c * Q + w * T + v * E - h * B, this._z = v * Q + w * B + h * T - c * E, this._w = w * Q - h * E - c * T - v * B, this._onChangeCallback(), this
            }
            slerp(e, r) {
                if (r === 0) return this;
                if (r === 1) return this.copy(e);
                const h = this._x,
                    c = this._y,
                    v = this._z,
                    w = this._w;
                let E = w * e._w + h * e._x + c * e._y + v * e._z;
                if (E < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, E = -E) : this.copy(e), E >= 1) return this._w = w, this._x = h, this._y = c, this._z = v, this;
                const T = 1 - E * E;
                if (T <= Number.EPSILON) {
                    const t = 1 - r;
                    return this._w = t * w + r * this._w, this._x = t * h + r * this._x, this._y = t * c + r * this._y, this._z = t * v + r * this._z, this.normalize(), this._onChangeCallback(), this
                }
                const B = Math.sqrt(T),
                    Q = Math.atan2(B, E),
                    k = Math.sin((1 - r) * Q) / B,
                    i = Math.sin(r * Q) / B;
                return this._w = w * k + this._w * i, this._x = h * k + this._x * i, this._y = c * k + this._y * i, this._z = v * k + this._z * i, this._onChangeCallback(), this
            }
            slerpQuaternions(e, r, h) {
                this.copy(e).slerp(r, h)
            }
            equals(e) {
                return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
            }
            fromArray(e, r = 0) {
                return this._x = e[r], this._y = e[r + 1], this._z = e[r + 2], this._w = e[r + 3], this._onChangeCallback(), this
            }
            toArray(e = [], r = 0) {
                return e[r] = this._x, e[r + 1] = this._y, e[r + 2] = this._z, e[r + 3] = this._w, e
            }
            fromBufferAttribute(e, r) {
                return this._x = e.getX(r), this._y = e.getY(r), this._z = e.getZ(r), this._w = e.getW(r), this
            }
            _onChange(e) {
                return this._onChangeCallback = e, this
            }
            _onChangeCallback() {}
        }
        Bn.prototype.isQuaternion = !0;
        class ge {
            constructor(e = 0, r = 0, h = 0) {
                this.x = e, this.y = r, this.z = h
            }
            set(e, r, h) {
                return h === void 0 && (h = this.z), this.x = e, this.y = r, this.z = h, this
            }
            setScalar(e) {
                return this.x = e, this.y = e, this.z = e, this
            }
            setX(e) {
                return this.x = e, this
            }
            setY(e) {
                return this.y = e, this
            }
            setZ(e) {
                return this.z = e, this
            }
            setComponent(e, r) {
                switch (e) {
                    case 0:
                        this.x = r;
                        break;
                    case 1:
                        this.y = r;
                        break;
                    case 2:
                        this.z = r;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z)
            }
            copy(e) {
                return this.x = e.x, this.y = e.y, this.z = e.z, this
            }
            add(e, r) {
                return r !== void 0 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, r)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
            }
            addScalar(e) {
                return this.x += e, this.y += e, this.z += e, this
            }
            addVectors(e, r) {
                return this.x = e.x + r.x, this.y = e.y + r.y, this.z = e.z + r.z, this
            }
            addScaledVector(e, r) {
                return this.x += e.x * r, this.y += e.y * r, this.z += e.z * r, this
            }
            sub(e, r) {
                return r !== void 0 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, r)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
            }
            subScalar(e) {
                return this.x -= e, this.y -= e, this.z -= e, this
            }
            subVectors(e, r) {
                return this.x = e.x - r.x, this.y = e.y - r.y, this.z = e.z - r.z, this
            }
            multiply(e, r) {
                return r !== void 0 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, r)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
            }
            multiplyScalar(e) {
                return this.x *= e, this.y *= e, this.z *= e, this
            }
            multiplyVectors(e, r) {
                return this.x = e.x * r.x, this.y = e.y * r.y, this.z = e.z * r.z, this
            }
            applyEuler(e) {
                return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(On.setFromEuler(e))
            }
            applyAxisAngle(e, r) {
                return this.applyQuaternion(On.setFromAxisAngle(e, r))
            }
            applyMatrix3(e) {
                const r = this.x,
                    h = this.y,
                    c = this.z,
                    v = e.elements;
                return this.x = v[0] * r + v[3] * h + v[6] * c, this.y = v[1] * r + v[4] * h + v[7] * c, this.z = v[2] * r + v[5] * h + v[8] * c, this
            }
            applyNormalMatrix(e) {
                return this.applyMatrix3(e).normalize()
            }
            applyMatrix4(e) {
                const r = this.x,
                    h = this.y,
                    c = this.z,
                    v = e.elements,
                    w = 1 / (v[3] * r + v[7] * h + v[11] * c + v[15]);
                return this.x = (v[0] * r + v[4] * h + v[8] * c + v[12]) * w, this.y = (v[1] * r + v[5] * h + v[9] * c + v[13]) * w, this.z = (v[2] * r + v[6] * h + v[10] * c + v[14]) * w, this
            }
            applyQuaternion(e) {
                const r = this.x,
                    h = this.y,
                    c = this.z,
                    v = e.x,
                    w = e.y,
                    E = e.z,
                    T = e.w,
                    B = T * r + w * c - E * h,
                    Q = T * h + E * r - v * c,
                    k = T * c + v * h - w * r,
                    i = -v * r - w * h - E * c;
                return this.x = B * T + i * -v + Q * -E - k * -w, this.y = Q * T + i * -w + k * -v - B * -E, this.z = k * T + i * -E + B * -w - Q * -v, this
            }
            project(e) {
                return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
            }
            unproject(e) {
                return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
            }
            transformDirection(e) {
                const r = this.x,
                    h = this.y,
                    c = this.z,
                    v = e.elements;
                return this.x = v[0] * r + v[4] * h + v[8] * c, this.y = v[1] * r + v[5] * h + v[9] * c, this.z = v[2] * r + v[6] * h + v[10] * c, this.normalize()
            }
            divide(e) {
                return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            min(e) {
                return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
            }
            clamp(e, r) {
                return this.x = Math.max(e.x, Math.min(r.x, this.x)), this.y = Math.max(e.y, Math.min(r.y, this.y)), this.z = Math.max(e.z, Math.min(r.z, this.z)), this
            }
            clampScalar(e, r) {
                return this.x = Math.max(e, Math.min(r, this.x)), this.y = Math.max(e, Math.min(r, this.y)), this.z = Math.max(e, Math.min(r, this.z)), this
            }
            clampLength(e, r) {
                const h = this.length();
                return this.divideScalar(h || 1).multiplyScalar(Math.max(e, Math.min(r, h)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y + this.z * e.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, r) {
                return this.x += (e.x - this.x) * r, this.y += (e.y - this.y) * r, this.z += (e.z - this.z) * r, this
            }
            lerpVectors(e, r, h) {
                return this.x = e.x + (r.x - e.x) * h, this.y = e.y + (r.y - e.y) * h, this.z = e.z + (r.z - e.z) * h, this
            }
            cross(e, r) {
                return r !== void 0 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, r)) : this.crossVectors(this, e)
            }
            crossVectors(e, r) {
                const h = e.x,
                    c = e.y,
                    v = e.z,
                    w = r.x,
                    E = r.y,
                    T = r.z;
                return this.x = c * T - v * E, this.y = v * w - h * T, this.z = h * E - c * w, this
            }
            projectOnVector(e) {
                const r = e.lengthSq();
                if (r === 0) return this.set(0, 0, 0);
                const h = e.dot(this) / r;
                return this.copy(e).multiplyScalar(h)
            }
            projectOnPlane(e) {
                return ga.copy(this).projectOnVector(e), this.sub(ga)
            }
            reflect(e) {
                return this.sub(ga.copy(e).multiplyScalar(2 * this.dot(e)))
            }
            angleTo(e) {
                const r = Math.sqrt(this.lengthSq() * e.lengthSq());
                if (r === 0) return Math.PI / 2;
                const h = this.dot(e) / r;
                return Math.acos(Mi.clamp(h, -1, 1))
            }
            distanceTo(e) {
                return Math.sqrt(this.distanceToSquared(e))
            }
            distanceToSquared(e) {
                const r = this.x - e.x,
                    h = this.y - e.y,
                    c = this.z - e.z;
                return r * r + h * h + c * c
            }
            manhattanDistanceTo(e) {
                return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
            }
            setFromSpherical(e) {
                return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
            }
            setFromSphericalCoords(e, r, h) {
                const c = Math.sin(r) * e;
                return this.x = c * Math.sin(h), this.y = Math.cos(r) * e, this.z = c * Math.cos(h), this
            }
            setFromCylindrical(e) {
                return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
            }
            setFromCylindricalCoords(e, r, h) {
                return this.x = e * Math.sin(r), this.y = h, this.z = e * Math.cos(r), this
            }
            setFromMatrixPosition(e) {
                const r = e.elements;
                return this.x = r[12], this.y = r[13], this.z = r[14], this
            }
            setFromMatrixScale(e) {
                const r = this.setFromMatrixColumn(e, 0).length(),
                    h = this.setFromMatrixColumn(e, 1).length(),
                    c = this.setFromMatrixColumn(e, 2).length();
                return this.x = r, this.y = h, this.z = c, this
            }
            setFromMatrixColumn(e, r) {
                return this.fromArray(e.elements, 4 * r)
            }
            setFromMatrix3Column(e, r) {
                return this.fromArray(e.elements, 3 * r)
            }
            equals(e) {
                return e.x === this.x && e.y === this.y && e.z === this.z
            }
            fromArray(e, r = 0) {
                return this.x = e[r], this.y = e[r + 1], this.z = e[r + 2], this
            }
            toArray(e = [], r = 0) {
                return e[r] = this.x, e[r + 1] = this.y, e[r + 2] = this.z, e
            }
            fromBufferAttribute(e, r, h) {
                return h !== void 0 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(r), this.y = e.getY(r), this.z = e.getZ(r), this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
            }
        }
        ge.prototype.isVector3 = !0;
        const ga = new ge,
            On = new Bn;
        class Te {
            constructor(e = new ge(1 / 0, 1 / 0, 1 / 0), r = new ge(-1 / 0, -1 / 0, -1 / 0)) {
                this.min = e, this.max = r
            }
            set(e, r) {
                return this.min.copy(e), this.max.copy(r), this
            }
            setFromArray(e) {
                let r = 1 / 0,
                    h = 1 / 0,
                    c = 1 / 0,
                    v = -1 / 0,
                    w = -1 / 0,
                    E = -1 / 0;
                for (let T = 0, B = e.length; T < B; T += 3) {
                    const Q = e[T],
                        k = e[T + 1],
                        i = e[T + 2];
                    Q < r && (r = Q), k < h && (h = k), i < c && (c = i), Q > v && (v = Q), k > w && (w = k), i > E && (E = i)
                }
                return this.min.set(r, h, c), this.max.set(v, w, E), this
            }
            setFromBufferAttribute(e) {
                let r = 1 / 0,
                    h = 1 / 0,
                    c = 1 / 0,
                    v = -1 / 0,
                    w = -1 / 0,
                    E = -1 / 0;
                for (let T = 0, B = e.count; T < B; T++) {
                    const Q = e.getX(T),
                        k = e.getY(T),
                        i = e.getZ(T);
                    Q < r && (r = Q), k < h && (h = k), i < c && (c = i), Q > v && (v = Q), k > w && (w = k), i > E && (E = i)
                }
                return this.min.set(r, h, c), this.max.set(v, w, E), this
            }
            setFromPoints(e) {
                this.makeEmpty();
                for (let r = 0, h = e.length; r < h; r++) this.expandByPoint(e[r]);
                return this
            }
            setFromCenterAndSize(e, r) {
                const h = he.copy(r).multiplyScalar(.5);
                return this.min.copy(e).sub(h), this.max.copy(e).add(h), this
            }
            setFromObject(e) {
                return this.makeEmpty(), this.expandByObject(e)
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(e) {
                return this.min.copy(e.min), this.max.copy(e.max), this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(e) {
                return e === void 0 && (console.warn("THREE.Box3: .getCenter() target is now required"), e = new ge), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(e) {
                return e === void 0 && (console.warn("THREE.Box3: .getSize() target is now required"), e = new ge), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
            }
            expandByPoint(e) {
                return this.min.min(e), this.max.max(e), this
            }
            expandByVector(e) {
                return this.min.sub(e), this.max.add(e), this
            }
            expandByScalar(e) {
                return this.min.addScalar(-e), this.max.addScalar(e), this
            }
            expandByObject(e) {
                e.updateWorldMatrix(!1, !1);
                const r = e.geometry;
                r !== void 0 && (r.boundingBox === null && r.computeBoundingBox(), fe.copy(r.boundingBox), fe.applyMatrix4(e.matrixWorld), this.union(fe));
                const h = e.children;
                for (let c = 0, v = h.length; c < v; c++) this.expandByObject(h[c]);
                return this
            }
            containsPoint(e) {
                return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
            }
            containsBox(e) {
                return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
            }
            getParameter(e, r) {
                return r === void 0 && (console.warn("THREE.Box3: .getParameter() target is now required"), r = new ge), r.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(e) {
                return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
            }
            intersectsSphere(e) {
                return this.clampPoint(e.center, he), he.distanceToSquared(e.center) <= e.radius * e.radius
            }
            intersectsPlane(e) {
                let r, h;
                return e.normal.x > 0 ? (r = e.normal.x * this.min.x, h = e.normal.x * this.max.x) : (r = e.normal.x * this.max.x, h = e.normal.x * this.min.x), e.normal.y > 0 ? (r += e.normal.y * this.min.y, h += e.normal.y * this.max.y) : (r += e.normal.y * this.max.y, h += e.normal.y * this.min.y), e.normal.z > 0 ? (r += e.normal.z * this.min.z, h += e.normal.z * this.max.z) : (r += e.normal.z * this.max.z, h += e.normal.z * this.min.z), r <= -e.constant && h >= -e.constant
            }
            intersectsTriangle(e) {
                if (this.isEmpty()) return !1;
                this.getCenter(Jt), zt.subVectors(this.max, Jt), Ae.subVectors(e.a, Jt), qe.subVectors(e.b, Jt), et.subVectors(e.c, Jt), it.subVectors(qe, Ae), We.subVectors(et, qe), ft.subVectors(Ae, et);
                let r = [0, -it.z, it.y, 0, -We.z, We.y, 0, -ft.z, ft.y, it.z, 0, -it.x, We.z, 0, -We.x, ft.z, 0, -ft.x, -it.y, it.x, 0, -We.y, We.x, 0, -ft.y, ft.x, 0];
                return !!Zi(r, Ae, qe, et, zt) && (r = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Zi(r, Ae, qe, et, zt) && (It.crossVectors(it, We), r = [It.x, It.y, It.z], Zi(r, Ae, qe, et, zt)))
            }
            clampPoint(e, r) {
                return r === void 0 && (console.warn("THREE.Box3: .clampPoint() target is now required"), r = new ge), r.copy(e).clamp(this.min, this.max)
            }
            distanceToPoint(e) {
                return he.copy(e).clamp(this.min, this.max).sub(e).length()
            }
            getBoundingSphere(e) {
                return e === void 0 && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(e.center), e.radius = .5 * this.getSize(he).length(), e
            }
            intersect(e) {
                return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
            }
            union(e) {
                return this.min.min(e.min), this.max.max(e.max), this
            }
            applyMatrix4(e) {
                return this.isEmpty() || (te[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), te[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), te[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), te[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), te[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), te[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), te[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), te[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(te)), this
            }
            translate(e) {
                return this.min.add(e), this.max.add(e), this
            }
            equals(e) {
                return e.min.equals(this.min) && e.max.equals(this.max)
            }
        }
        Te.prototype.isBox3 = !0;
        const te = [new ge, new ge, new ge, new ge, new ge, new ge, new ge, new ge],
            he = new ge,
            fe = new Te,
            Ae = new ge,
            qe = new ge,
            et = new ge,
            it = new ge,
            We = new ge,
            ft = new ge,
            Jt = new ge,
            zt = new ge,
            It = new ge,
            zi = new ge;

        function Zi(s, e, r, h, c) {
            for (let v = 0, w = s.length - 3; v <= w; v += 3) {
                zi.fromArray(s, v);
                const E = c.x * Math.abs(zi.x) + c.y * Math.abs(zi.y) + c.z * Math.abs(zi.z),
                    T = e.dot(zi),
                    B = r.dot(zi),
                    Q = h.dot(zi);
                if (Math.max(-Math.max(T, B, Q), Math.min(T, B, Q)) > E) return !1
            }
            return !0
        }
        const dn = new Te,
            on = new ge,
            vn = new ge,
            Pn = new ge;
        class Fn {
            constructor(e = new ge, r = -1) {
                this.center = e, this.radius = r
            }
            set(e, r) {
                return this.center.copy(e), this.radius = r, this
            }
            setFromPoints(e, r) {
                const h = this.center;
                r !== void 0 ? h.copy(r) : dn.setFromPoints(e).getCenter(h);
                let c = 0;
                for (let v = 0, w = e.length; v < w; v++) c = Math.max(c, h.distanceToSquared(e[v]));
                return this.radius = Math.sqrt(c), this
            }
            copy(e) {
                return this.center.copy(e.center), this.radius = e.radius, this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0), this.radius = -1, this
            }
            containsPoint(e) {
                return e.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(e) {
                return e.distanceTo(this.center) - this.radius
            }
            intersectsSphere(e) {
                const r = this.radius + e.radius;
                return e.center.distanceToSquared(this.center) <= r * r
            }
            intersectsBox(e) {
                return e.intersectsSphere(this)
            }
            intersectsPlane(e) {
                return Math.abs(e.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(e, r) {
                const h = this.center.distanceToSquared(e);
                return r === void 0 && (console.warn("THREE.Sphere: .clampPoint() target is now required"), r = new ge), r.copy(e), h > this.radius * this.radius && (r.sub(this.center).normalize(), r.multiplyScalar(this.radius).add(this.center)), r
            }
            getBoundingBox(e) {
                return e === void 0 && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e = new Te), this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
            }
            applyMatrix4(e) {
                return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
            }
            translate(e) {
                return this.center.add(e), this
            }
            expandByPoint(e) {
                Pn.subVectors(e, this.center);
                const r = Pn.lengthSq();
                if (r > this.radius * this.radius) {
                    const h = Math.sqrt(r),
                        c = .5 * (h - this.radius);
                    this.center.add(Pn.multiplyScalar(c / h)), this.radius += c
                }
                return this
            }
            union(e) {
                return vn.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(on.copy(e.center).add(vn)), this.expandByPoint(on.copy(e.center).sub(vn)), this
            }
            equals(e) {
                return e.center.equals(this.center) && e.radius === this.radius
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        const kn = new ge,
            hn = new ge,
            Vn = new ge,
            Gn = new ge,
            zr = new ge,
            br = new ge,
            ur = new ge;
        class wr {
            constructor(e = new ge, r = new ge(0, 0, -1)) {
                this.origin = e, this.direction = r
            }
            set(e, r) {
                return this.origin.copy(e), this.direction.copy(r), this
            }
            copy(e) {
                return this.origin.copy(e.origin), this.direction.copy(e.direction), this
            }
            at(e, r) {
                return r === void 0 && (console.warn("THREE.Ray: .at() target is now required"), r = new ge), r.copy(this.direction).multiplyScalar(e).add(this.origin)
            }
            lookAt(e) {
                return this.direction.copy(e).sub(this.origin).normalize(), this
            }
            recast(e) {
                return this.origin.copy(this.at(e, kn)), this
            }
            closestPointToPoint(e, r) {
                r === void 0 && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), r = new ge), r.subVectors(e, this.origin);
                const h = r.dot(this.direction);
                return h < 0 ? r.copy(this.origin) : r.copy(this.direction).multiplyScalar(h).add(this.origin)
            }
            distanceToPoint(e) {
                return Math.sqrt(this.distanceSqToPoint(e))
            }
            distanceSqToPoint(e) {
                const r = kn.subVectors(e, this.origin).dot(this.direction);
                return r < 0 ? this.origin.distanceToSquared(e) : (kn.copy(this.direction).multiplyScalar(r).add(this.origin), kn.distanceToSquared(e))
            }
            distanceSqToSegment(e, r, h, c) {
                hn.copy(e).add(r).multiplyScalar(.5), Vn.copy(r).sub(e).normalize(), Gn.copy(this.origin).sub(hn);
                const v = .5 * e.distanceTo(r),
                    w = -this.direction.dot(Vn),
                    E = Gn.dot(this.direction),
                    T = -Gn.dot(Vn),
                    B = Gn.lengthSq(),
                    Q = Math.abs(1 - w * w);
                let k, i, t, a;
                if (Q > 0)
                    if (k = w * T - E, i = w * E - T, a = v * Q, k >= 0)
                        if (i >= -a)
                            if (i <= a) {
                                const l = 1 / Q;
                                k *= l, i *= l, t = k * (k + w * i + 2 * E) + i * (w * k + i + 2 * T) + B
                            } else i = v, k = Math.max(0, -(w * i + E)), t = -k * k + i * (i + 2 * T) + B;
                else i = -v, k = Math.max(0, -(w * i + E)), t = -k * k + i * (i + 2 * T) + B;
                else i <= -a ? (k = Math.max(0, -(-w * v + E)), i = k > 0 ? -v : Math.min(Math.max(-v, -T), v), t = -k * k + i * (i + 2 * T) + B) : i <= a ? (k = 0, i = Math.min(Math.max(-v, -T), v), t = i * (i + 2 * T) + B) : (k = Math.max(0, -(w * v + E)), i = k > 0 ? v : Math.min(Math.max(-v, -T), v), t = -k * k + i * (i + 2 * T) + B);
                else i = w > 0 ? -v : v, k = Math.max(0, -(w * i + E)), t = -k * k + i * (i + 2 * T) + B;
                return h && h.copy(this.direction).multiplyScalar(k).add(this.origin), c && c.copy(Vn).multiplyScalar(i).add(hn), t
            }
            intersectSphere(e, r) {
                kn.subVectors(e.center, this.origin);
                const h = kn.dot(this.direction),
                    c = kn.dot(kn) - h * h,
                    v = e.radius * e.radius;
                if (c > v) return null;
                const w = Math.sqrt(v - c),
                    E = h - w,
                    T = h + w;
                return E < 0 && T < 0 ? null : E < 0 ? this.at(T, r) : this.at(E, r)
            }
            intersectsSphere(e) {
                return this.distanceSqToPoint(e.center) <= e.radius * e.radius
            }
            distanceToPlane(e) {
                const r = e.normal.dot(this.direction);
                if (r === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
                const h = -(this.origin.dot(e.normal) + e.constant) / r;
                return h >= 0 ? h : null
            }
            intersectPlane(e, r) {
                const h = this.distanceToPlane(e);
                return h === null ? null : this.at(h, r)
            }
            intersectsPlane(e) {
                const r = e.distanceToPoint(this.origin);
                return r === 0 ? !0 : e.normal.dot(this.direction) * r < 0
            }
            intersectBox(e, r) {
                let h, c, v, w, E, T;
                const B = 1 / this.direction.x,
                    Q = 1 / this.direction.y,
                    k = 1 / this.direction.z,
                    i = this.origin;
                return B >= 0 ? (h = (e.min.x - i.x) * B, c = (e.max.x - i.x) * B) : (h = (e.max.x - i.x) * B, c = (e.min.x - i.x) * B), Q >= 0 ? (v = (e.min.y - i.y) * Q, w = (e.max.y - i.y) * Q) : (v = (e.max.y - i.y) * Q, w = (e.min.y - i.y) * Q), h > w || v > c ? null : ((v > h || h != h) && (h = v), (w < c || c != c) && (c = w), k >= 0 ? (E = (e.min.z - i.z) * k, T = (e.max.z - i.z) * k) : (E = (e.max.z - i.z) * k, T = (e.min.z - i.z) * k), h > T || E > c ? null : ((E > h || h != h) && (h = E), (T < c || c != c) && (c = T), c < 0 ? null : this.at(h >= 0 ? h : c, r)))
            }
            intersectsBox(e) {
                return this.intersectBox(e, kn) !== null
            }
            intersectTriangle(e, r, h, c, v) {
                zr.subVectors(r, e), br.subVectors(h, e), ur.crossVectors(zr, br);
                let w, E = this.direction.dot(ur);
                if (E > 0) {
                    if (c) return null;
                    w = 1
                } else {
                    if (!(E < 0)) return null;
                    w = -1, E = -E
                }
                Gn.subVectors(this.origin, e);
                const T = w * this.direction.dot(br.crossVectors(Gn, br));
                if (T < 0) return null;
                const B = w * this.direction.dot(zr.cross(Gn));
                if (B < 0 || T + B > E) return null;
                const Q = -w * Gn.dot(ur);
                return Q < 0 ? null : this.at(Q / E, v)
            }
            applyMatrix4(e) {
                return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
            }
            equals(e) {
                return e.origin.equals(this.origin) && e.direction.equals(this.direction)
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        class Ui {
            constructor() {
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }
            set(e, r, h, c, v, w, E, T, B, Q, k, i, t, a, l, d) {
                const g = this.elements;
                return g[0] = e, g[4] = r, g[8] = h, g[12] = c, g[1] = v, g[5] = w, g[9] = E, g[13] = T, g[2] = B, g[6] = Q, g[10] = k, g[14] = i, g[3] = t, g[7] = a, g[11] = l, g[15] = d, this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }
            clone() {
                return new Ui().fromArray(this.elements)
            }
            copy(e) {
                const r = this.elements,
                    h = e.elements;
                return r[0] = h[0], r[1] = h[1], r[2] = h[2], r[3] = h[3], r[4] = h[4], r[5] = h[5], r[6] = h[6], r[7] = h[7], r[8] = h[8], r[9] = h[9], r[10] = h[10], r[11] = h[11], r[12] = h[12], r[13] = h[13], r[14] = h[14], r[15] = h[15], this
            }
            copyPosition(e) {
                const r = this.elements,
                    h = e.elements;
                return r[12] = h[12], r[13] = h[13], r[14] = h[14], this
            }
            setFromMatrix3(e) {
                const r = e.elements;
                return this.set(r[0], r[3], r[6], 0, r[1], r[4], r[7], 0, r[2], r[5], r[8], 0, 0, 0, 0, 1), this
            }
            extractBasis(e, r, h) {
                return e.setFromMatrixColumn(this, 0), r.setFromMatrixColumn(this, 1), h.setFromMatrixColumn(this, 2), this
            }
            makeBasis(e, r, h) {
                return this.set(e.x, r.x, h.x, 0, e.y, r.y, h.y, 0, e.z, r.z, h.z, 0, 0, 0, 0, 1), this
            }
            extractRotation(e) {
                const r = this.elements,
                    h = e.elements,
                    c = 1 / ya.setFromMatrixColumn(e, 0).length(),
                    v = 1 / ya.setFromMatrixColumn(e, 1).length(),
                    w = 1 / ya.setFromMatrixColumn(e, 2).length();
                return r[0] = h[0] * c, r[1] = h[1] * c, r[2] = h[2] * c, r[3] = 0, r[4] = h[4] * v, r[5] = h[5] * v, r[6] = h[6] * v, r[7] = 0, r[8] = h[8] * w, r[9] = h[9] * w, r[10] = h[10] * w, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, this
            }
            makeRotationFromEuler(e) {
                e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                const r = this.elements,
                    h = e.x,
                    c = e.y,
                    v = e.z,
                    w = Math.cos(h),
                    E = Math.sin(h),
                    T = Math.cos(c),
                    B = Math.sin(c),
                    Q = Math.cos(v),
                    k = Math.sin(v);
                if (e.order === "XYZ") {
                    const i = w * Q,
                        t = w * k,
                        a = E * Q,
                        l = E * k;
                    r[0] = T * Q, r[4] = -T * k, r[8] = B, r[1] = t + a * B, r[5] = i - l * B, r[9] = -E * T, r[2] = l - i * B, r[6] = a + t * B, r[10] = w * T
                } else if (e.order === "YXZ") {
                    const i = T * Q,
                        t = T * k,
                        a = B * Q,
                        l = B * k;
                    r[0] = i + l * E, r[4] = a * E - t, r[8] = w * B, r[1] = w * k, r[5] = w * Q, r[9] = -E, r[2] = t * E - a, r[6] = l + i * E, r[10] = w * T
                } else if (e.order === "ZXY") {
                    const i = T * Q,
                        t = T * k,
                        a = B * Q,
                        l = B * k;
                    r[0] = i - l * E, r[4] = -w * k, r[8] = a + t * E, r[1] = t + a * E, r[5] = w * Q, r[9] = l - i * E, r[2] = -w * B, r[6] = E, r[10] = w * T
                } else if (e.order === "ZYX") {
                    const i = w * Q,
                        t = w * k,
                        a = E * Q,
                        l = E * k;
                    r[0] = T * Q, r[4] = a * B - t, r[8] = i * B + l, r[1] = T * k, r[5] = l * B + i, r[9] = t * B - a, r[2] = -B, r[6] = E * T, r[10] = w * T
                } else if (e.order === "YZX") {
                    const i = w * T,
                        t = w * B,
                        a = E * T,
                        l = E * B;
                    r[0] = T * Q, r[4] = l - i * k, r[8] = a * k + t, r[1] = k, r[5] = w * Q, r[9] = -E * Q, r[2] = -B * Q, r[6] = t * k + a, r[10] = i - l * k
                } else if (e.order === "XZY") {
                    const i = w * T,
                        t = w * B,
                        a = E * T,
                        l = E * B;
                    r[0] = T * Q, r[4] = -k, r[8] = B * Q, r[1] = i * k + l, r[5] = w * Q, r[9] = t * k - a, r[2] = a * k - t, r[6] = E * Q, r[10] = l * k + i
                }
                return r[3] = 0, r[7] = 0, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, this
            }
            makeRotationFromQuaternion(e) {
                return this.compose(Qs, e, Ra)
            }
            lookAt(e, r, h) {
                const c = this.elements;
                return Lr.subVectors(e, r), Lr.lengthSq() === 0 && (Lr.z = 1), Lr.normalize(), rr.crossVectors(h, Lr), rr.lengthSq() === 0 && (Math.abs(h.z) === 1 ? Lr.x += 1e-4 : Lr.z += 1e-4, Lr.normalize(), rr.crossVectors(h, Lr)), rr.normalize(), Fr.crossVectors(Lr, rr), c[0] = rr.x, c[4] = Fr.x, c[8] = Lr.x, c[1] = rr.y, c[5] = Fr.y, c[9] = Lr.y, c[2] = rr.z, c[6] = Fr.z, c[10] = Lr.z, this
            }
            multiply(e, r) {
                return r !== void 0 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, r)) : this.multiplyMatrices(this, e)
            }
            premultiply(e) {
                return this.multiplyMatrices(e, this)
            }
            multiplyMatrices(e, r) {
                const h = e.elements,
                    c = r.elements,
                    v = this.elements,
                    w = h[0],
                    E = h[4],
                    T = h[8],
                    B = h[12],
                    Q = h[1],
                    k = h[5],
                    i = h[9],
                    t = h[13],
                    a = h[2],
                    l = h[6],
                    d = h[10],
                    g = h[14],
                    x = h[3],
                    A = h[7],
                    M = h[11],
                    F = h[15],
                    D = c[0],
                    U = c[4],
                    N = c[8],
                    H = c[12],
                    X = c[1],
                    ne = c[5],
                    le = c[9],
                    ce = c[13],
                    Qe = c[2],
                    Se = c[6],
                    Re = c[10],
                    ot = c[14],
                    dt = c[3],
                    Ct = c[7],
                    Nt = c[11],
                    qt = c[15];
                return v[0] = w * D + E * X + T * Qe + B * dt, v[4] = w * U + E * ne + T * Se + B * Ct, v[8] = w * N + E * le + T * Re + B * Nt, v[12] = w * H + E * ce + T * ot + B * qt, v[1] = Q * D + k * X + i * Qe + t * dt, v[5] = Q * U + k * ne + i * Se + t * Ct, v[9] = Q * N + k * le + i * Re + t * Nt, v[13] = Q * H + k * ce + i * ot + t * qt, v[2] = a * D + l * X + d * Qe + g * dt, v[6] = a * U + l * ne + d * Se + g * Ct, v[10] = a * N + l * le + d * Re + g * Nt, v[14] = a * H + l * ce + d * ot + g * qt, v[3] = x * D + A * X + M * Qe + F * dt, v[7] = x * U + A * ne + M * Se + F * Ct, v[11] = x * N + A * le + M * Re + F * Nt, v[15] = x * H + A * ce + M * ot + F * qt, this
            }
            multiplyScalar(e) {
                const r = this.elements;
                return r[0] *= e, r[4] *= e, r[8] *= e, r[12] *= e, r[1] *= e, r[5] *= e, r[9] *= e, r[13] *= e, r[2] *= e, r[6] *= e, r[10] *= e, r[14] *= e, r[3] *= e, r[7] *= e, r[11] *= e, r[15] *= e, this
            }
            determinant() {
                const e = this.elements,
                    r = e[0],
                    h = e[4],
                    c = e[8],
                    v = e[12],
                    w = e[1],
                    E = e[5],
                    T = e[9],
                    B = e[13],
                    Q = e[2],
                    k = e[6],
                    i = e[10],
                    t = e[14];
                return e[3] * (+v * T * k - c * B * k - v * E * i + h * B * i + c * E * t - h * T * t) + e[7] * (+r * T * t - r * B * i + v * w * i - c * w * t + c * B * Q - v * T * Q) + e[11] * (+r * B * k - r * E * t - v * w * k + h * w * t + v * E * Q - h * B * Q) + e[15] * (-c * E * Q - r * T * k + r * E * i + c * w * k - h * w * i + h * T * Q)
            }
            transpose() {
                const e = this.elements;
                let r;
                return r = e[1], e[1] = e[4], e[4] = r, r = e[2], e[2] = e[8], e[8] = r, r = e[6], e[6] = e[9], e[9] = r, r = e[3], e[3] = e[12], e[12] = r, r = e[7], e[7] = e[13], e[13] = r, r = e[11], e[11] = e[14], e[14] = r, this
            }
            setPosition(e, r, h) {
                const c = this.elements;
                return e.isVector3 ? (c[12] = e.x, c[13] = e.y, c[14] = e.z) : (c[12] = e, c[13] = r, c[14] = h), this
            }
            invert() {
                const e = this.elements,
                    r = e[0],
                    h = e[1],
                    c = e[2],
                    v = e[3],
                    w = e[4],
                    E = e[5],
                    T = e[6],
                    B = e[7],
                    Q = e[8],
                    k = e[9],
                    i = e[10],
                    t = e[11],
                    a = e[12],
                    l = e[13],
                    d = e[14],
                    g = e[15],
                    x = k * d * B - l * i * B + l * T * t - E * d * t - k * T * g + E * i * g,
                    A = a * i * B - Q * d * B - a * T * t + w * d * t + Q * T * g - w * i * g,
                    M = Q * l * B - a * k * B + a * E * t - w * l * t - Q * E * g + w * k * g,
                    F = a * k * T - Q * l * T - a * E * i + w * l * i + Q * E * d - w * k * d,
                    D = r * x + h * A + c * M + v * F;
                if (D === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const U = 1 / D;
                return e[0] = x * U, e[1] = (l * i * v - k * d * v - l * c * t + h * d * t + k * c * g - h * i * g) * U, e[2] = (E * d * v - l * T * v + l * c * B - h * d * B - E * c * g + h * T * g) * U, e[3] = (k * T * v - E * i * v - k * c * B + h * i * B + E * c * t - h * T * t) * U, e[4] = A * U, e[5] = (Q * d * v - a * i * v + a * c * t - r * d * t - Q * c * g + r * i * g) * U, e[6] = (a * T * v - w * d * v - a * c * B + r * d * B + w * c * g - r * T * g) * U, e[7] = (w * i * v - Q * T * v + Q * c * B - r * i * B - w * c * t + r * T * t) * U, e[8] = M * U, e[9] = (a * k * v - Q * l * v - a * h * t + r * l * t + Q * h * g - r * k * g) * U, e[10] = (w * l * v - a * E * v + a * h * B - r * l * B - w * h * g + r * E * g) * U, e[11] = (Q * E * v - w * k * v - Q * h * B + r * k * B + w * h * t - r * E * t) * U, e[12] = F * U, e[13] = (Q * l * c - a * k * c + a * h * i - r * l * i - Q * h * d + r * k * d) * U, e[14] = (a * E * c - w * l * c - a * h * T + r * l * T + w * h * d - r * E * d) * U, e[15] = (w * k * c - Q * E * c + Q * h * T - r * k * T - w * h * i + r * E * i) * U, this
            }
            scale(e) {
                const r = this.elements,
                    h = e.x,
                    c = e.y,
                    v = e.z;
                return r[0] *= h, r[4] *= c, r[8] *= v, r[1] *= h, r[5] *= c, r[9] *= v, r[2] *= h, r[6] *= c, r[10] *= v, r[3] *= h, r[7] *= c, r[11] *= v, this
            }
            getMaxScaleOnAxis() {
                const e = this.elements,
                    r = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                    h = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                    c = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                return Math.sqrt(Math.max(r, h, c))
            }
            makeTranslation(e, r, h) {
                return this.set(1, 0, 0, e, 0, 1, 0, r, 0, 0, 1, h, 0, 0, 0, 1), this
            }
            makeRotationX(e) {
                const r = Math.cos(e),
                    h = Math.sin(e);
                return this.set(1, 0, 0, 0, 0, r, -h, 0, 0, h, r, 0, 0, 0, 0, 1), this
            }
            makeRotationY(e) {
                const r = Math.cos(e),
                    h = Math.sin(e);
                return this.set(r, 0, h, 0, 0, 1, 0, 0, -h, 0, r, 0, 0, 0, 0, 1), this
            }
            makeRotationZ(e) {
                const r = Math.cos(e),
                    h = Math.sin(e);
                return this.set(r, -h, 0, 0, h, r, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }
            makeRotationAxis(e, r) {
                const h = Math.cos(r),
                    c = Math.sin(r),
                    v = 1 - h,
                    w = e.x,
                    E = e.y,
                    T = e.z,
                    B = v * w,
                    Q = v * E;
                return this.set(B * w + h, B * E - c * T, B * T + c * E, 0, B * E + c * T, Q * E + h, Q * T - c * w, 0, B * T - c * E, Q * T + c * w, v * T * T + h, 0, 0, 0, 0, 1), this
            }
            makeScale(e, r, h) {
                return this.set(e, 0, 0, 0, 0, r, 0, 0, 0, 0, h, 0, 0, 0, 0, 1), this
            }
            makeShear(e, r, h) {
                return this.set(1, r, h, 0, e, 1, h, 0, e, r, 1, 0, 0, 0, 0, 1), this
            }
            compose(e, r, h) {
                const c = this.elements,
                    v = r._x,
                    w = r._y,
                    E = r._z,
                    T = r._w,
                    B = v + v,
                    Q = w + w,
                    k = E + E,
                    i = v * B,
                    t = v * Q,
                    a = v * k,
                    l = w * Q,
                    d = w * k,
                    g = E * k,
                    x = T * B,
                    A = T * Q,
                    M = T * k,
                    F = h.x,
                    D = h.y,
                    U = h.z;
                return c[0] = (1 - (l + g)) * F, c[1] = (t + M) * F, c[2] = (a - A) * F, c[3] = 0, c[4] = (t - M) * D, c[5] = (1 - (i + g)) * D, c[6] = (d + x) * D, c[7] = 0, c[8] = (a + A) * U, c[9] = (d - x) * U, c[10] = (1 - (i + l)) * U, c[11] = 0, c[12] = e.x, c[13] = e.y, c[14] = e.z, c[15] = 1, this
            }
            decompose(e, r, h) {
                const c = this.elements;
                let v = ya.set(c[0], c[1], c[2]).length();
                const w = ya.set(c[4], c[5], c[6]).length(),
                    E = ya.set(c[8], c[9], c[10]).length();
                this.determinant() < 0 && (v = -v), e.x = c[12], e.y = c[13], e.z = c[14], _n.copy(this);
                const T = 1 / v,
                    B = 1 / w,
                    Q = 1 / E;
                return _n.elements[0] *= T, _n.elements[1] *= T, _n.elements[2] *= T, _n.elements[4] *= B, _n.elements[5] *= B, _n.elements[6] *= B, _n.elements[8] *= Q, _n.elements[9] *= Q, _n.elements[10] *= Q, r.setFromRotationMatrix(_n), h.x = v, h.y = w, h.z = E, this
            }
            makePerspective(e, r, h, c, v, w) {
                w === void 0 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                const E = this.elements,
                    T = 2 * v / (r - e),
                    B = 2 * v / (h - c),
                    Q = (r + e) / (r - e),
                    k = (h + c) / (h - c),
                    i = -(w + v) / (w - v),
                    t = -2 * w * v / (w - v);
                return E[0] = T, E[4] = 0, E[8] = Q, E[12] = 0, E[1] = 0, E[5] = B, E[9] = k, E[13] = 0, E[2] = 0, E[6] = 0, E[10] = i, E[14] = t, E[3] = 0, E[7] = 0, E[11] = -1, E[15] = 0, this
            }
            makeOrthographic(e, r, h, c, v, w) {
                const E = this.elements,
                    T = 1 / (r - e),
                    B = 1 / (h - c),
                    Q = 1 / (w - v),
                    k = (r + e) * T,
                    i = (h + c) * B,
                    t = (w + v) * Q;
                return E[0] = 2 * T, E[4] = 0, E[8] = 0, E[12] = -k, E[1] = 0, E[5] = 2 * B, E[9] = 0, E[13] = -i, E[2] = 0, E[6] = 0, E[10] = -2 * Q, E[14] = -t, E[3] = 0, E[7] = 0, E[11] = 0, E[15] = 1, this
            }
            equals(e) {
                const r = this.elements,
                    h = e.elements;
                for (let c = 0; c < 16; c++)
                    if (r[c] !== h[c]) return !1;
                return !0
            }
            fromArray(e, r = 0) {
                for (let h = 0; h < 16; h++) this.elements[h] = e[h + r];
                return this
            }
            toArray(e = [], r = 0) {
                const h = this.elements;
                return e[r] = h[0], e[r + 1] = h[1], e[r + 2] = h[2], e[r + 3] = h[3], e[r + 4] = h[4], e[r + 5] = h[5], e[r + 6] = h[6], e[r + 7] = h[7], e[r + 8] = h[8], e[r + 9] = h[9], e[r + 10] = h[10], e[r + 11] = h[11], e[r + 12] = h[12], e[r + 13] = h[13], e[r + 14] = h[14], e[r + 15] = h[15], e
            }
        }
        Ui.prototype.isMatrix4 = !0;
        const ya = new ge,
            _n = new Ui,
            Qs = new ge(0, 0, 0),
            Ra = new ge(1, 1, 1),
            rr = new ge,
            Fr = new ge,
            Lr = new ge,
            ra = new Ui,
            $r = new Bn;
        class gr {
            constructor(e = 0, r = 0, h = 0, c = gr.DefaultOrder) {
                this._x = e, this._y = r, this._z = h, this._order = c
            }
            get x() {
                return this._x
            }
            set x(e) {
                this._x = e, this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(e) {
                this._y = e, this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(e) {
                this._z = e, this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(e) {
                this._order = e, this._onChangeCallback()
            }
            set(e, r, h, c) {
                return this._x = e, this._y = r, this._z = h, this._order = c || this._order, this._onChangeCallback(), this
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._order)
            }
            copy(e) {
                return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
            }
            setFromRotationMatrix(e, r, h) {
                const c = Mi.clamp,
                    v = e.elements,
                    w = v[0],
                    E = v[4],
                    T = v[8],
                    B = v[1],
                    Q = v[5],
                    k = v[9],
                    i = v[2],
                    t = v[6],
                    a = v[10];
                switch (r = r || this._order) {
                    case "XYZ":
                        this._y = Math.asin(c(T, -1, 1)), Math.abs(T) < .9999999 ? (this._x = Math.atan2(-k, a), this._z = Math.atan2(-E, w)) : (this._x = Math.atan2(t, Q), this._z = 0);
                        break;
                    case "YXZ":
                        this._x = Math.asin(-c(k, -1, 1)), Math.abs(k) < .9999999 ? (this._y = Math.atan2(T, a), this._z = Math.atan2(B, Q)) : (this._y = Math.atan2(-i, w), this._z = 0);
                        break;
                    case "ZXY":
                        this._x = Math.asin(c(t, -1, 1)), Math.abs(t) < .9999999 ? (this._y = Math.atan2(-i, a), this._z = Math.atan2(-E, Q)) : (this._y = 0, this._z = Math.atan2(B, w));
                        break;
                    case "ZYX":
                        this._y = Math.asin(-c(i, -1, 1)), Math.abs(i) < .9999999 ? (this._x = Math.atan2(t, a), this._z = Math.atan2(B, w)) : (this._x = 0, this._z = Math.atan2(-E, Q));
                        break;
                    case "YZX":
                        this._z = Math.asin(c(B, -1, 1)), Math.abs(B) < .9999999 ? (this._x = Math.atan2(-k, Q), this._y = Math.atan2(-i, w)) : (this._x = 0, this._y = Math.atan2(T, a));
                        break;
                    case "XZY":
                        this._z = Math.asin(-c(E, -1, 1)), Math.abs(E) < .9999999 ? (this._x = Math.atan2(t, Q), this._y = Math.atan2(T, w)) : (this._x = Math.atan2(-k, a), this._y = 0);
                        break;
                    default:
                        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + r)
                }
                return this._order = r, h !== !1 && this._onChangeCallback(), this
            }
            setFromQuaternion(e, r, h) {
                return ra.makeRotationFromQuaternion(e), this.setFromRotationMatrix(ra, r, h)
            }
            setFromVector3(e, r) {
                return this.set(e.x, e.y, e.z, r || this._order)
            }
            reorder(e) {
                return $r.setFromEuler(this), this.setFromQuaternion($r, e)
            }
            equals(e) {
                return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
            }
            fromArray(e) {
                return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this
            }
            toArray(e = [], r = 0) {
                return e[r] = this._x, e[r + 1] = this._y, e[r + 2] = this._z, e[r + 3] = this._order, e
            }
            toVector3(e) {
                return e ? e.set(this._x, this._y, this._z) : new ge(this._x, this._y, this._z)
            }
            _onChange(e) {
                return this._onChangeCallback = e, this
            }
            _onChangeCallback() {}
        }
        gr.prototype.isEuler = !0, gr.DefaultOrder = "XYZ", gr.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
        class Jr {
            constructor() {
                this.mask = 1
            }
            set(e) {
                this.mask = 1 << e | 0
            }
            enable(e) {
                this.mask |= 1 << e | 0
            }
            enableAll() {
                this.mask = -1
            }
            toggle(e) {
                this.mask ^= 1 << e | 0
            }
            disable(e) {
                this.mask &= ~(1 << e | 0)
            }
            disableAll() {
                this.mask = 0
            }
            test(e) {
                return (this.mask & e.mask) != 0
            }
        }
        let or = 0;
        const wa = new ge,
            la = new Bn,
            Ln = new Ui,
            ja = new ge,
            Nr = new ge,
            Ps = new ge,
            va = new Bn,
            $n = new ge(1, 0, 0),
            Qn = new ge(0, 1, 0),
            os = new ge(0, 0, 1),
            Va = {
                type: "added"
            },
            Da = {
                type: "removed"
            };

        function Z() {
            Object.defineProperty(this, "id", {
                value: or++
            }), this.uuid = Mi.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Z.DefaultUp.clone();
            const s = new ge,
                e = new gr,
                r = new Bn,
                h = new ge(1, 1, 1);
            e._onChange(function() {
                r.setFromEuler(e, !1)
            }), r._onChange(function() {
                e.setFromQuaternion(r, void 0, !1)
            }), Object.defineProperties(this, {
                position: {
                    configurable: !0,
                    enumerable: !0,
                    value: s
                },
                rotation: {
                    configurable: !0,
                    enumerable: !0,
                    value: e
                },
                quaternion: {
                    configurable: !0,
                    enumerable: !0,
                    value: r
                },
                scale: {
                    configurable: !0,
                    enumerable: !0,
                    value: h
                },
                modelViewMatrix: {
                    value: new Ui
                },
                normalMatrix: {
                    value: new Pt
                }
            }), this.matrix = new Ui, this.matrixWorld = new Ui, this.matrixAutoUpdate = Z.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Jr, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
        }
        Z.DefaultUp = new ge(0, 1, 0), Z.DefaultMatrixAutoUpdate = !0, Z.prototype = Object.assign(Object.create(yn.prototype), {
            constructor: Z,
            isObject3D: !0,
            onBeforeRender: function() {},
            onAfterRender: function() {},
            applyMatrix4: function(s) {
                this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(s), this.matrix.decompose(this.position, this.quaternion, this.scale)
            },
            applyQuaternion: function(s) {
                return this.quaternion.premultiply(s), this
            },
            setRotationFromAxisAngle: function(s, e) {
                this.quaternion.setFromAxisAngle(s, e)
            },
            setRotationFromEuler: function(s) {
                this.quaternion.setFromEuler(s, !0)
            },
            setRotationFromMatrix: function(s) {
                this.quaternion.setFromRotationMatrix(s)
            },
            setRotationFromQuaternion: function(s) {
                this.quaternion.copy(s)
            },
            rotateOnAxis: function(s, e) {
                return la.setFromAxisAngle(s, e), this.quaternion.multiply(la), this
            },
            rotateOnWorldAxis: function(s, e) {
                return la.setFromAxisAngle(s, e), this.quaternion.premultiply(la), this
            },
            rotateX: function(s) {
                return this.rotateOnAxis($n, s)
            },
            rotateY: function(s) {
                return this.rotateOnAxis(Qn, s)
            },
            rotateZ: function(s) {
                return this.rotateOnAxis(os, s)
            },
            translateOnAxis: function(s, e) {
                return wa.copy(s).applyQuaternion(this.quaternion), this.position.add(wa.multiplyScalar(e)), this
            },
            translateX: function(s) {
                return this.translateOnAxis($n, s)
            },
            translateY: function(s) {
                return this.translateOnAxis(Qn, s)
            },
            translateZ: function(s) {
                return this.translateOnAxis(os, s)
            },
            localToWorld: function(s) {
                return s.applyMatrix4(this.matrixWorld)
            },
            worldToLocal: function(s) {
                return s.applyMatrix4(Ln.copy(this.matrixWorld).invert())
            },
            lookAt: function(s, e, r) {
                s.isVector3 ? ja.copy(s) : ja.set(s, e, r);
                const h = this.parent;
                this.updateWorldMatrix(!0, !1), Nr.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ln.lookAt(Nr, ja, this.up) : Ln.lookAt(ja, Nr, this.up), this.quaternion.setFromRotationMatrix(Ln), h && (Ln.extractRotation(h.matrixWorld), la.setFromRotationMatrix(Ln), this.quaternion.premultiply(la.invert()))
            },
            add: function(s) {
                if (arguments.length > 1) {
                    for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
                    return this
                }
                return s === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", s), this) : (s && s.isObject3D ? (s.parent !== null && s.parent.remove(s), s.parent = this, this.children.push(s), s.dispatchEvent(Va)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", s), this)
            },
            remove: function(s) {
                if (arguments.length > 1) {
                    for (let r = 0; r < arguments.length; r++) this.remove(arguments[r]);
                    return this
                }
                const e = this.children.indexOf(s);
                return e !== -1 && (s.parent = null, this.children.splice(e, 1), s.dispatchEvent(Da)), this
            },
            clear: function() {
                for (let s = 0; s < this.children.length; s++) {
                    const e = this.children[s];
                    e.parent = null, e.dispatchEvent(Da)
                }
                return this.children.length = 0, this
            },
            attach: function(s) {
                return this.updateWorldMatrix(!0, !1), Ln.copy(this.matrixWorld).invert(), s.parent !== null && (s.parent.updateWorldMatrix(!0, !1), Ln.multiply(s.parent.matrixWorld)), s.applyMatrix4(Ln), this.add(s), s.updateWorldMatrix(!1, !0), this
            },
            getObjectById: function(s) {
                return this.getObjectByProperty("id", s)
            },
            getObjectByName: function(s) {
                return this.getObjectByProperty("name", s)
            },
            getObjectByProperty: function(s, e) {
                if (this[s] === e) return this;
                for (let r = 0, h = this.children.length; r < h; r++) {
                    const c = this.children[r].getObjectByProperty(s, e);
                    if (c !== void 0) return c
                }
            },
            getWorldPosition: function(s) {
                return s === void 0 && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), s = new ge), this.updateWorldMatrix(!0, !1), s.setFromMatrixPosition(this.matrixWorld)
            },
            getWorldQuaternion: function(s) {
                return s === void 0 && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), s = new Bn), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Nr, s, Ps), s
            },
            getWorldScale: function(s) {
                return s === void 0 && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), s = new ge), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Nr, va, s), s
            },
            getWorldDirection: function(s) {
                s === void 0 && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), s = new ge), this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return s.set(e[8], e[9], e[10]).normalize()
            },
            raycast: function() {},
            traverse: function(s) {
                s(this);
                const e = this.children;
                for (let r = 0, h = e.length; r < h; r++) e[r].traverse(s)
            },
            traverseVisible: function(s) {
                if (this.visible === !1) return;
                s(this);
                const e = this.children;
                for (let r = 0, h = e.length; r < h; r++) e[r].traverseVisible(s)
            },
            traverseAncestors: function(s) {
                const e = this.parent;
                e !== null && (s(e), e.traverseAncestors(s))
            },
            updateMatrix: function() {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            },
            updateMatrixWorld: function(s) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || s) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, s = !0);
                const e = this.children;
                for (let r = 0, h = e.length; r < h; r++) e[r].updateMatrixWorld(s)
            },
            updateWorldMatrix: function(s, e) {
                const r = this.parent;
                if (s === !0 && r !== null && r.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e === !0) {
                    const h = this.children;
                    for (let c = 0, v = h.length; c < v; c++) h[c].updateWorldMatrix(!1, !0)
                }
            },
            toJSON: function(s) {
                const e = s === void 0 || typeof s == "string",
                    r = {};
                e && (s = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {}
                }, r.metadata = {
                    version: 4.5,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                const h = {};

                function c(w, E) {
                    return w[E.uuid] === void 0 && (w[E.uuid] = E.toJSON(s)), E.uuid
                }
                if (h.uuid = this.uuid, h.type = this.type, this.name !== "" && (h.name = this.name), this.castShadow === !0 && (h.castShadow = !0), this.receiveShadow === !0 && (h.receiveShadow = !0), this.visible === !1 && (h.visible = !1), this.frustumCulled === !1 && (h.frustumCulled = !1), this.renderOrder !== 0 && (h.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (h.userData = this.userData), h.layers = this.layers.mask, h.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (h.matrixAutoUpdate = !1), this.isInstancedMesh && (h.type = "InstancedMesh", h.count = this.count, h.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (h.instanceColor = this.instanceColor.toJSON())), this.isMesh || this.isLine || this.isPoints) {
                    h.geometry = c(s.geometries, this.geometry);
                    const w = this.geometry.parameters;
                    if (w !== void 0 && w.shapes !== void 0) {
                        const E = w.shapes;
                        if (Array.isArray(E))
                            for (let T = 0, B = E.length; T < B; T++) {
                                const Q = E[T];
                                c(s.shapes, Q)
                            } else c(s.shapes, E)
                    }
                }
                if (this.isSkinnedMesh && (h.bindMode = this.bindMode, h.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (c(s.skeletons, this.skeleton), h.skeleton = this.skeleton.uuid)), this.material !== void 0)
                    if (Array.isArray(this.material)) {
                        const w = [];
                        for (let E = 0, T = this.material.length; E < T; E++) w.push(c(s.materials, this.material[E]));
                        h.material = w
                    } else h.material = c(s.materials, this.material);
                if (this.children.length > 0) {
                    h.children = [];
                    for (let w = 0; w < this.children.length; w++) h.children.push(this.children[w].toJSON(s).object)
                }
                if (this.animations.length > 0) {
                    h.animations = [];
                    for (let w = 0; w < this.animations.length; w++) {
                        const E = this.animations[w];
                        h.animations.push(c(s.animations, E))
                    }
                }
                if (e) {
                    const w = v(s.geometries),
                        E = v(s.materials),
                        T = v(s.textures),
                        B = v(s.images),
                        Q = v(s.shapes),
                        k = v(s.skeletons),
                        i = v(s.animations);
                    w.length > 0 && (r.geometries = w), E.length > 0 && (r.materials = E), T.length > 0 && (r.textures = T), B.length > 0 && (r.images = B), Q.length > 0 && (r.shapes = Q), k.length > 0 && (r.skeletons = k), i.length > 0 && (r.animations = i)
                }
                return r.object = h, r;

                function v(w) {
                    const E = [];
                    for (const T in w) {
                        const B = w[T];
                        delete B.metadata, E.push(B)
                    }
                    return E
                }
            },
            clone: function(s) {
                return new this.constructor().copy(this, s)
            },
            copy: function(s, e = !0) {
                if (this.name = s.name, this.up.copy(s.up), this.position.copy(s.position), this.rotation.order = s.rotation.order, this.quaternion.copy(s.quaternion), this.scale.copy(s.scale), this.matrix.copy(s.matrix), this.matrixWorld.copy(s.matrixWorld), this.matrixAutoUpdate = s.matrixAutoUpdate, this.matrixWorldNeedsUpdate = s.matrixWorldNeedsUpdate, this.layers.mask = s.layers.mask, this.visible = s.visible, this.castShadow = s.castShadow, this.receiveShadow = s.receiveShadow, this.frustumCulled = s.frustumCulled, this.renderOrder = s.renderOrder, this.userData = JSON.parse(JSON.stringify(s.userData)), e === !0)
                    for (let r = 0; r < s.children.length; r++) {
                        const h = s.children[r];
                        this.add(h.clone())
                    }
                return this
            }
        });
        const q = new ge,
            de = new ge,
            Pe = new Pt;
        class Et {
            constructor(e = new ge(1, 0, 0), r = 0) {
                this.normal = e, this.constant = r
            }
            set(e, r) {
                return this.normal.copy(e), this.constant = r, this
            }
            setComponents(e, r, h, c) {
                return this.normal.set(e, r, h), this.constant = c, this
            }
            setFromNormalAndCoplanarPoint(e, r) {
                return this.normal.copy(e), this.constant = -r.dot(this.normal), this
            }
            setFromCoplanarPoints(e, r, h) {
                const c = q.subVectors(h, r).cross(de.subVectors(e, r)).normalize();
                return this.setFromNormalAndCoplanarPoint(c, e), this
            }
            copy(e) {
                return this.normal.copy(e.normal), this.constant = e.constant, this
            }
            normalize() {
                const e = 1 / this.normal.length();
                return this.normal.multiplyScalar(e), this.constant *= e, this
            }
            negate() {
                return this.constant *= -1, this.normal.negate(), this
            }
            distanceToPoint(e) {
                return this.normal.dot(e) + this.constant
            }
            distanceToSphere(e) {
                return this.distanceToPoint(e.center) - e.radius
            }
            projectPoint(e, r) {
                return r === void 0 && (console.warn("THREE.Plane: .projectPoint() target is now required"), r = new ge), r.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
            }
            intersectLine(e, r) {
                r === void 0 && (console.warn("THREE.Plane: .intersectLine() target is now required"), r = new ge);
                const h = e.delta(q),
                    c = this.normal.dot(h);
                if (c === 0) return this.distanceToPoint(e.start) === 0 ? r.copy(e.start) : null;
                const v = -(e.start.dot(this.normal) + this.constant) / c;
                return v < 0 || v > 1 ? null : r.copy(h).multiplyScalar(v).add(e.start)
            }
            intersectsLine(e) {
                const r = this.distanceToPoint(e.start),
                    h = this.distanceToPoint(e.end);
                return r < 0 && h > 0 || h < 0 && r > 0
            }
            intersectsBox(e) {
                return e.intersectsPlane(this)
            }
            intersectsSphere(e) {
                return e.intersectsPlane(this)
            }
            coplanarPoint(e) {
                return e === void 0 && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e = new ge), e.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(e, r) {
                const h = r || Pe.getNormalMatrix(e),
                    c = this.coplanarPoint(q).applyMatrix4(e),
                    v = this.normal.applyMatrix3(h).normalize();
                return this.constant = -c.dot(v), this
            }
            translate(e) {
                return this.constant -= e.dot(this.normal), this
            }
            equals(e) {
                return e.normal.equals(this.normal) && e.constant === this.constant
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        Et.prototype.isPlane = !0;
        const Ft = new ge,
            _t = new ge,
            Yt = new ge,
            J = new ge,
            W = new ge,
            re = new ge,
            ye = new ge,
            me = new ge,
            rt = new ge,
            At = new ge;
        class Mt {
            constructor(e = new ge, r = new ge, h = new ge) {
                this.a = e, this.b = r, this.c = h
            }
            static getNormal(e, r, h, c) {
                c === void 0 && (console.warn("THREE.Triangle: .getNormal() target is now required"), c = new ge), c.subVectors(h, r), Ft.subVectors(e, r), c.cross(Ft);
                const v = c.lengthSq();
                return v > 0 ? c.multiplyScalar(1 / Math.sqrt(v)) : c.set(0, 0, 0)
            }
            static getBarycoord(e, r, h, c, v) {
                Ft.subVectors(c, r), _t.subVectors(h, r), Yt.subVectors(e, r);
                const w = Ft.dot(Ft),
                    E = Ft.dot(_t),
                    T = Ft.dot(Yt),
                    B = _t.dot(_t),
                    Q = _t.dot(Yt),
                    k = w * B - E * E;
                if (v === void 0 && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), v = new ge), k === 0) return v.set(-2, -1, -1);
                const i = 1 / k,
                    t = (B * T - E * Q) * i,
                    a = (w * Q - E * T) * i;
                return v.set(1 - t - a, a, t)
            }
            static containsPoint(e, r, h, c) {
                return this.getBarycoord(e, r, h, c, J), J.x >= 0 && J.y >= 0 && J.x + J.y <= 1
            }
            static getUV(e, r, h, c, v, w, E, T) {
                return this.getBarycoord(e, r, h, c, J), T.set(0, 0), T.addScaledVector(v, J.x), T.addScaledVector(w, J.y), T.addScaledVector(E, J.z), T
            }
            static isFrontFacing(e, r, h, c) {
                return Ft.subVectors(h, r), _t.subVectors(e, r), Ft.cross(_t).dot(c) < 0
            }
            set(e, r, h) {
                return this.a.copy(e), this.b.copy(r), this.c.copy(h), this
            }
            setFromPointsAndIndices(e, r, h, c) {
                return this.a.copy(e[r]), this.b.copy(e[h]), this.c.copy(e[c]), this
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(e) {
                return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
            }
            getArea() {
                return Ft.subVectors(this.c, this.b), _t.subVectors(this.a, this.b), .5 * Ft.cross(_t).length()
            }
            getMidpoint(e) {
                return e === void 0 && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e = new ge), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(e) {
                return Mt.getNormal(this.a, this.b, this.c, e)
            }
            getPlane(e) {
                return e === void 0 && (console.warn("THREE.Triangle: .getPlane() target is now required"), e = new Et), e.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(e, r) {
                return Mt.getBarycoord(e, this.a, this.b, this.c, r)
            }
            getUV(e, r, h, c, v) {
                return Mt.getUV(e, this.a, this.b, this.c, r, h, c, v)
            }
            containsPoint(e) {
                return Mt.containsPoint(e, this.a, this.b, this.c)
            }
            isFrontFacing(e) {
                return Mt.isFrontFacing(this.a, this.b, this.c, e)
            }
            intersectsBox(e) {
                return e.intersectsTriangle(this)
            }
            closestPointToPoint(e, r) {
                r === void 0 && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), r = new ge);
                const h = this.a,
                    c = this.b,
                    v = this.c;
                let w, E;
                W.subVectors(c, h), re.subVectors(v, h), me.subVectors(e, h);
                const T = W.dot(me),
                    B = re.dot(me);
                if (T <= 0 && B <= 0) return r.copy(h);
                rt.subVectors(e, c);
                const Q = W.dot(rt),
                    k = re.dot(rt);
                if (Q >= 0 && k <= Q) return r.copy(c);
                const i = T * k - Q * B;
                if (i <= 0 && T >= 0 && Q <= 0) return w = T / (T - Q), r.copy(h).addScaledVector(W, w);
                At.subVectors(e, v);
                const t = W.dot(At),
                    a = re.dot(At);
                if (a >= 0 && t <= a) return r.copy(v);
                const l = t * B - T * a;
                if (l <= 0 && B >= 0 && a <= 0) return E = B / (B - a), r.copy(h).addScaledVector(re, E);
                const d = Q * a - t * k;
                if (d <= 0 && k - Q >= 0 && t - a >= 0) return ye.subVectors(v, c), E = (k - Q) / (k - Q + (t - a)), r.copy(c).addScaledVector(ye, E);
                const g = 1 / (d + l + i);
                return w = l * g, E = i * g, r.copy(h).addScaledVector(W, w).addScaledVector(re, E)
            }
            equals(e) {
                return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
            }
        }
        let si = 0;

        function ti() {
            Object.defineProperty(this, "id", {
                value: si++
            }), this.uuid = Mi.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0
        }
        ti.prototype = Object.assign(Object.create(yn.prototype), {
            constructor: ti,
            isMaterial: !0,
            onBeforeCompile: function() {},
            customProgramCacheKey: function() {
                return this.onBeforeCompile.toString()
            },
            setValues: function(s) {
                if (s !== void 0)
                    for (const e in s) {
                        const r = s[e];
                        if (r === void 0) {
                            console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                            continue
                        }
                        if (e === "shading") {
                            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = r === 1;
                            continue
                        }
                        const h = this[e];
                        h !== void 0 ? h && h.isColor ? h.set(r) : h && h.isVector3 && r && r.isVector3 ? h.copy(r) : this[e] = r : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                    }
            },
            toJSON: function(s) {
                const e = s === void 0 || typeof s == "string";
                e && (s = {
                    textures: {},
                    images: {}
                });
                const r = {
                    metadata: {
                        version: 4.5,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };

                function h(c) {
                    const v = [];
                    for (const w in c) {
                        const E = c[w];
                        delete E.metadata, v.push(E)
                    }
                    return v
                }
                if (r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.color && this.color.isColor && (r.color = this.color.getHex()), this.roughness !== void 0 && (r.roughness = this.roughness), this.metalness !== void 0 && (r.metalness = this.metalness), this.sheen && this.sheen.isColor && (r.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (r.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (r.specular = this.specular.getHex()), this.shininess !== void 0 && (r.shininess = this.shininess), this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (r.clearcoatMap = this.clearcoatMap.toJSON(s).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(s).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(s).uuid, r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (r.map = this.map.toJSON(s).uuid), this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(s).uuid), this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(s).uuid), this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(s).uuid, r.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(s).uuid, r.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(s).uuid, r.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(s).uuid, r.normalMapType = this.normalMapType, r.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(s).uuid, r.displacementScale = this.displacementScale, r.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(s).uuid), this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(s).uuid), this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(s).uuid), this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(s).uuid), this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(s).uuid, r.reflectivity = this.reflectivity, r.refractionRatio = this.refractionRatio, this.combine !== void 0 && (r.combine = this.combine), this.envMapIntensity !== void 0 && (r.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(s).uuid), this.size !== void 0 && (r.size = this.size), this.shadowSide !== null && (r.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (r.sizeAttenuation = this.sizeAttenuation), this.blending !== 1 && (r.blending = this.blending), this.side !== 0 && (r.side = this.side), this.vertexColors && (r.vertexColors = !0), this.opacity < 1 && (r.opacity = this.opacity), this.transparent === !0 && (r.transparent = this.transparent), r.depthFunc = this.depthFunc, r.depthTest = this.depthTest, r.depthWrite = this.depthWrite, r.colorWrite = this.colorWrite, r.stencilWrite = this.stencilWrite, r.stencilWriteMask = this.stencilWriteMask, r.stencilFunc = this.stencilFunc, r.stencilRef = this.stencilRef, r.stencilFuncMask = this.stencilFuncMask, r.stencilFail = this.stencilFail, r.stencilZFail = this.stencilZFail, r.stencilZPass = this.stencilZPass, this.rotation && this.rotation !== 0 && (r.rotation = this.rotation), this.polygonOffset === !0 && (r.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (r.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (r.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && this.linewidth !== 1 && (r.linewidth = this.linewidth), this.dashSize !== void 0 && (r.dashSize = this.dashSize), this.gapSize !== void 0 && (r.gapSize = this.gapSize), this.scale !== void 0 && (r.scale = this.scale), this.dithering === !0 && (r.dithering = !0), this.alphaTest > 0 && (r.alphaTest = this.alphaTest), this.alphaToCoverage === !0 && (r.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (r.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (r.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (r.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (r.wireframeLinejoin = this.wireframeLinejoin), this.morphTargets === !0 && (r.morphTargets = !0), this.morphNormals === !0 && (r.morphNormals = !0), this.skinning === !0 && (r.skinning = !0), this.flatShading === !0 && (r.flatShading = this.flatShading), this.visible === !1 && (r.visible = !1), this.toneMapped === !1 && (r.toneMapped = !1), JSON.stringify(this.userData) !== "{}" && (r.userData = this.userData), e) {
                    const c = h(s.textures),
                        v = h(s.images);
                    c.length > 0 && (r.textures = c), v.length > 0 && (r.images = v)
                }
                return r
            },
            clone: function() {
                return new this.constructor().copy(this)
            },
            copy: function(s) {
                this.name = s.name, this.fog = s.fog, this.blending = s.blending, this.side = s.side, this.vertexColors = s.vertexColors, this.opacity = s.opacity, this.transparent = s.transparent, this.blendSrc = s.blendSrc, this.blendDst = s.blendDst, this.blendEquation = s.blendEquation, this.blendSrcAlpha = s.blendSrcAlpha, this.blendDstAlpha = s.blendDstAlpha, this.blendEquationAlpha = s.blendEquationAlpha, this.depthFunc = s.depthFunc, this.depthTest = s.depthTest, this.depthWrite = s.depthWrite, this.stencilWriteMask = s.stencilWriteMask, this.stencilFunc = s.stencilFunc, this.stencilRef = s.stencilRef, this.stencilFuncMask = s.stencilFuncMask, this.stencilFail = s.stencilFail, this.stencilZFail = s.stencilZFail, this.stencilZPass = s.stencilZPass, this.stencilWrite = s.stencilWrite;
                const e = s.clippingPlanes;
                let r = null;
                if (e !== null) {
                    const h = e.length;
                    r = new Array(h);
                    for (let c = 0; c !== h; ++c) r[c] = e[c].clone()
                }
                return this.clippingPlanes = r, this.clipIntersection = s.clipIntersection, this.clipShadows = s.clipShadows, this.shadowSide = s.shadowSide, this.colorWrite = s.colorWrite, this.precision = s.precision, this.polygonOffset = s.polygonOffset, this.polygonOffsetFactor = s.polygonOffsetFactor, this.polygonOffsetUnits = s.polygonOffsetUnits, this.dithering = s.dithering, this.alphaTest = s.alphaTest, this.alphaToCoverage = s.alphaToCoverage, this.premultipliedAlpha = s.premultipliedAlpha, this.visible = s.visible, this.toneMapped = s.toneMapped, this.userData = JSON.parse(JSON.stringify(s.userData)), this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), Object.defineProperty(ti.prototype, "needsUpdate", {
            set: function(s) {
                s === !0 && this.version++
            }
        });
        const ni = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            },
            ri = {
                h: 0,
                s: 0,
                l: 0
            },
            Wi = {
                h: 0,
                s: 0,
                l: 0
            };

        function Ci(s, e, r) {
            return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? s + 6 * (e - s) * r : r < .5 ? e : r < 2 / 3 ? s + 6 * (e - s) * (2 / 3 - r) : s
        }

        function Pi(s) {
            return s < .04045 ? .0773993808 * s : Math.pow(.9478672986 * s + .0521327014, 2.4)
        }

        function ai(s) {
            return s < .0031308 ? 12.92 * s : 1.055 * Math.pow(s, .41666) - .055
        }
        class Rt {
            constructor(e, r, h) {
                return r === void 0 && h === void 0 ? this.set(e) : this.setRGB(e, r, h)
            }
            set(e) {
                return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this
            }
            setScalar(e) {
                return this.r = e, this.g = e, this.b = e, this
            }
            setHex(e) {
                return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
            }
            setRGB(e, r, h) {
                return this.r = e, this.g = r, this.b = h, this
            }
            setHSL(e, r, h) {
                if (e = Mi.euclideanModulo(e, 1), r = Mi.clamp(r, 0, 1), h = Mi.clamp(h, 0, 1), r === 0) this.r = this.g = this.b = h;
                else {
                    const c = h <= .5 ? h * (1 + r) : h + r - h * r,
                        v = 2 * h - c;
                    this.r = Ci(v, c, e + 1 / 3), this.g = Ci(v, c, e), this.b = Ci(v, c, e - 1 / 3)
                }
                return this
            }
            setStyle(e) {
                function r(c) {
                    c !== void 0 && parseFloat(c) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                }
                let h;
                if (h = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
                    let c;
                    const v = h[1],
                        w = h[2];
                    switch (v) {
                        case "rgb":
                        case "rgba":
                            if (c = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(w)) return this.r = Math.min(255, parseInt(c[1], 10)) / 255, this.g = Math.min(255, parseInt(c[2], 10)) / 255, this.b = Math.min(255, parseInt(c[3], 10)) / 255, r(c[4]), this;
                            if (c = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(w)) return this.r = Math.min(100, parseInt(c[1], 10)) / 100, this.g = Math.min(100, parseInt(c[2], 10)) / 100, this.b = Math.min(100, parseInt(c[3], 10)) / 100, r(c[4]), this;
                            break;
                        case "hsl":
                        case "hsla":
                            if (c = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(w)) {
                                const E = parseFloat(c[1]) / 360,
                                    T = parseInt(c[2], 10) / 100,
                                    B = parseInt(c[3], 10) / 100;
                                return r(c[4]), this.setHSL(E, T, B)
                            }
                    }
                } else if (h = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                    const c = h[1],
                        v = c.length;
                    if (v === 3) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, this;
                    if (v === 6) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this
                }
                return e && e.length > 0 ? this.setColorName(e) : this
            }
            setColorName(e) {
                const r = ni[e];
                return r !== void 0 ? this.setHex(r) : console.warn("THREE.Color: Unknown color " + e), this
            }
            clone() {
                return new this.constructor(this.r, this.g, this.b)
            }
            copy(e) {
                return this.r = e.r, this.g = e.g, this.b = e.b, this
            }
            copyGammaToLinear(e, r = 2) {
                return this.r = Math.pow(e.r, r), this.g = Math.pow(e.g, r), this.b = Math.pow(e.b, r), this
            }
            copyLinearToGamma(e, r = 2) {
                const h = r > 0 ? 1 / r : 1;
                return this.r = Math.pow(e.r, h), this.g = Math.pow(e.g, h), this.b = Math.pow(e.b, h), this
            }
            convertGammaToLinear(e) {
                return this.copyGammaToLinear(this, e), this
            }
            convertLinearToGamma(e) {
                return this.copyLinearToGamma(this, e), this
            }
            copySRGBToLinear(e) {
                return this.r = Pi(e.r), this.g = Pi(e.g), this.b = Pi(e.b), this
            }
            copyLinearToSRGB(e) {
                return this.r = ai(e.r), this.g = ai(e.g), this.b = ai(e.b), this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this), this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this), this
            }
            getHex() {
                return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
            }
            getHexString() {
                return ("000000" + this.getHex().toString(16)).slice(-6)
            }
            getHSL(e) {
                e === void 0 && (console.warn("THREE.Color: .getHSL() target is now required"), e = {
                    h: 0,
                    s: 0,
                    l: 0
                });
                const r = this.r,
                    h = this.g,
                    c = this.b,
                    v = Math.max(r, h, c),
                    w = Math.min(r, h, c);
                let E, T;
                const B = (w + v) / 2;
                if (w === v) E = 0, T = 0;
                else {
                    const Q = v - w;
                    switch (T = B <= .5 ? Q / (v + w) : Q / (2 - v - w), v) {
                        case r:
                            E = (h - c) / Q + (h < c ? 6 : 0);
                            break;
                        case h:
                            E = (c - r) / Q + 2;
                            break;
                        case c:
                            E = (r - h) / Q + 4
                    }
                    E /= 6
                }
                return e.h = E, e.s = T, e.l = B, e
            }
            getStyle() {
                return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
            }
            offsetHSL(e, r, h) {
                return this.getHSL(ri), ri.h += e, ri.s += r, ri.l += h, this.setHSL(ri.h, ri.s, ri.l), this
            }
            add(e) {
                return this.r += e.r, this.g += e.g, this.b += e.b, this
            }
            addColors(e, r) {
                return this.r = e.r + r.r, this.g = e.g + r.g, this.b = e.b + r.b, this
            }
            addScalar(e) {
                return this.r += e, this.g += e, this.b += e, this
            }
            sub(e) {
                return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
            }
            multiply(e) {
                return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
            }
            multiplyScalar(e) {
                return this.r *= e, this.g *= e, this.b *= e, this
            }
            lerp(e, r) {
                return this.r += (e.r - this.r) * r, this.g += (e.g - this.g) * r, this.b += (e.b - this.b) * r, this
            }
            lerpColors(e, r, h) {
                return this.r = e.r + (r.r - e.r) * h, this.g = e.g + (r.g - e.g) * h, this.b = e.b + (r.b - e.b) * h, this
            }
            lerpHSL(e, r) {
                this.getHSL(ri), e.getHSL(Wi);
                const h = Mi.lerp(ri.h, Wi.h, r),
                    c = Mi.lerp(ri.s, Wi.s, r),
                    v = Mi.lerp(ri.l, Wi.l, r);
                return this.setHSL(h, c, v), this
            }
            equals(e) {
                return e.r === this.r && e.g === this.g && e.b === this.b
            }
            fromArray(e, r = 0) {
                return this.r = e[r], this.g = e[r + 1], this.b = e[r + 2], this
            }
            toArray(e = [], r = 0) {
                return e[r] = this.r, e[r + 1] = this.g, e[r + 2] = this.b, e
            }
            fromBufferAttribute(e, r) {
                return this.r = e.getX(r), this.g = e.getY(r), this.b = e.getZ(r), e.normalized === !0 && (this.r /= 255, this.g /= 255, this.b /= 255), this
            }
            toJSON() {
                return this.getHex()
            }
        }
        Rt.NAMES = ni, Rt.prototype.isColor = !0, Rt.prototype.r = 1, Rt.prototype.g = 1, Rt.prototype.b = 1;
        class Gi extends ti {
            constructor(e) {
                super(), this.type = "MeshBasicMaterial", this.color = new Rt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this
            }
        }
        Gi.prototype.isMeshBasicMaterial = !0;
        const ki = new ge,
            pn = new Ht;

        function pi(s, e, r) {
            if (Array.isArray(s)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.name = "", this.array = s, this.itemSize = e, this.count = s !== void 0 ? s.length / e : 0, this.normalized = r === !0, this.usage = 35044, this.updateRange = {
                offset: 0,
                count: -1
            }, this.version = 0
        }

        function Hi(s, e, r) {
            pi.call(this, new Int8Array(s), e, r)
        }

        function en(s, e, r) {
            pi.call(this, new Uint8Array(s), e, r)
        }

        function Bi(s, e, r) {
            pi.call(this, new Uint8ClampedArray(s), e, r)
        }

        function Xi(s, e, r) {
            pi.call(this, new Int16Array(s), e, r)
        }

        function Un(s, e, r) {
            pi.call(this, new Uint16Array(s), e, r)
        }

        function lr(s, e, r) {
            pi.call(this, new Int32Array(s), e, r)
        }

        function Qr(s, e, r) {
            pi.call(this, new Uint32Array(s), e, r)
        }

        function aa(s, e, r) {
            pi.call(this, new Uint16Array(s), e, r)
        }

        function Ai(s, e, r) {
            pi.call(this, new Float32Array(s), e, r)
        }

        function ca(s, e, r) {
            pi.call(this, new Float64Array(s), e, r)
        }

        function Ea(s) {
            if (s.length === 0) return -1 / 0;
            let e = s[0];
            for (let r = 1, h = s.length; r < h; ++r) s[r] > e && (e = s[r]);
            return e
        }
        Object.defineProperty(pi.prototype, "needsUpdate", {
            set: function(s) {
                s === !0 && this.version++
            }
        }), Object.assign(pi.prototype, {
            isBufferAttribute: !0,
            onUploadCallback: function() {},
            setUsage: function(s) {
                return this.usage = s, this
            },
            copy: function(s) {
                return this.name = s.name, this.array = new s.array.constructor(s.array), this.itemSize = s.itemSize, this.count = s.count, this.normalized = s.normalized, this.usage = s.usage, this
            },
            copyAt: function(s, e, r) {
                s *= this.itemSize, r *= e.itemSize;
                for (let h = 0, c = this.itemSize; h < c; h++) this.array[s + h] = e.array[r + h];
                return this
            },
            copyArray: function(s) {
                return this.array.set(s), this
            },
            copyColorsArray: function(s) {
                const e = this.array;
                let r = 0;
                for (let h = 0, c = s.length; h < c; h++) {
                    let v = s[h];
                    v === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", h), v = new Rt), e[r++] = v.r, e[r++] = v.g, e[r++] = v.b
                }
                return this
            },
            copyVector2sArray: function(s) {
                const e = this.array;
                let r = 0;
                for (let h = 0, c = s.length; h < c; h++) {
                    let v = s[h];
                    v === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", h), v = new Ht), e[r++] = v.x, e[r++] = v.y
                }
                return this
            },
            copyVector3sArray: function(s) {
                const e = this.array;
                let r = 0;
                for (let h = 0, c = s.length; h < c; h++) {
                    let v = s[h];
                    v === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", h), v = new ge), e[r++] = v.x, e[r++] = v.y, e[r++] = v.z
                }
                return this
            },
            copyVector4sArray: function(s) {
                const e = this.array;
                let r = 0;
                for (let h = 0, c = s.length; h < c; h++) {
                    let v = s[h];
                    v === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", h), v = new Si), e[r++] = v.x, e[r++] = v.y, e[r++] = v.z, e[r++] = v.w
                }
                return this
            },
            applyMatrix3: function(s) {
                if (this.itemSize === 2)
                    for (let e = 0, r = this.count; e < r; e++) pn.fromBufferAttribute(this, e), pn.applyMatrix3(s), this.setXY(e, pn.x, pn.y);
                else if (this.itemSize === 3)
                    for (let e = 0, r = this.count; e < r; e++) ki.fromBufferAttribute(this, e), ki.applyMatrix3(s), this.setXYZ(e, ki.x, ki.y, ki.z);
                return this
            },
            applyMatrix4: function(s) {
                for (let e = 0, r = this.count; e < r; e++) ki.x = this.getX(e), ki.y = this.getY(e), ki.z = this.getZ(e), ki.applyMatrix4(s), this.setXYZ(e, ki.x, ki.y, ki.z);
                return this
            },
            applyNormalMatrix: function(s) {
                for (let e = 0, r = this.count; e < r; e++) ki.x = this.getX(e), ki.y = this.getY(e), ki.z = this.getZ(e), ki.applyNormalMatrix(s), this.setXYZ(e, ki.x, ki.y, ki.z);
                return this
            },
            transformDirection: function(s) {
                for (let e = 0, r = this.count; e < r; e++) ki.x = this.getX(e), ki.y = this.getY(e), ki.z = this.getZ(e), ki.transformDirection(s), this.setXYZ(e, ki.x, ki.y, ki.z);
                return this
            },
            set: function(s, e = 0) {
                return this.array.set(s, e), this
            },
            getX: function(s) {
                return this.array[s * this.itemSize]
            },
            setX: function(s, e) {
                return this.array[s * this.itemSize] = e, this
            },
            getY: function(s) {
                return this.array[s * this.itemSize + 1]
            },
            setY: function(s, e) {
                return this.array[s * this.itemSize + 1] = e, this
            },
            getZ: function(s) {
                return this.array[s * this.itemSize + 2]
            },
            setZ: function(s, e) {
                return this.array[s * this.itemSize + 2] = e, this
            },
            getW: function(s) {
                return this.array[s * this.itemSize + 3]
            },
            setW: function(s, e) {
                return this.array[s * this.itemSize + 3] = e, this
            },
            setXY: function(s, e, r) {
                return s *= this.itemSize, this.array[s + 0] = e, this.array[s + 1] = r, this
            },
            setXYZ: function(s, e, r, h) {
                return s *= this.itemSize, this.array[s + 0] = e, this.array[s + 1] = r, this.array[s + 2] = h, this
            },
            setXYZW: function(s, e, r, h, c) {
                return s *= this.itemSize, this.array[s + 0] = e, this.array[s + 1] = r, this.array[s + 2] = h, this.array[s + 3] = c, this
            },
            onUpload: function(s) {
                return this.onUploadCallback = s, this
            },
            clone: function() {
                return new this.constructor(this.array, this.itemSize).copy(this)
            },
            toJSON: function() {
                const s = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.prototype.slice.call(this.array),
                    normalized: this.normalized
                };
                return this.name !== "" && (s.name = this.name), this.usage !== 35044 && (s.usage = this.usage), this.updateRange.offset === 0 && this.updateRange.count === -1 || (s.updateRange = this.updateRange), s
            }
        }), Hi.prototype = Object.create(pi.prototype), Hi.prototype.constructor = Hi, en.prototype = Object.create(pi.prototype), en.prototype.constructor = en, Bi.prototype = Object.create(pi.prototype), Bi.prototype.constructor = Bi, Xi.prototype = Object.create(pi.prototype), Xi.prototype.constructor = Xi, Un.prototype = Object.create(pi.prototype), Un.prototype.constructor = Un, lr.prototype = Object.create(pi.prototype), lr.prototype.constructor = lr, Qr.prototype = Object.create(pi.prototype), Qr.prototype.constructor = Qr, aa.prototype = Object.create(pi.prototype), aa.prototype.constructor = aa, aa.prototype.isFloat16BufferAttribute = !0, Ai.prototype = Object.create(pi.prototype), Ai.prototype.constructor = Ai, ca.prototype = Object.create(pi.prototype), ca.prototype.constructor = ca;
        const Kr = {
            Int8Array,
            Uint8Array,
            Uint8ClampedArray,
            Int16Array,
            Uint16Array,
            Int32Array,
            Uint32Array,
            Float32Array,
            Float64Array
        };

        function Er(s, e) {
            return new Kr[s](e)
        }
        let ro = 0;
        const Or = new Ui,
            ls = new Z,
            ms = new ge,
            _a = new Te,
            ks = new Te,
            Pr = new ge;

        function an() {
            Object.defineProperty(this, "id", {
                value: ro++
            }), this.uuid = Mi.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                start: 0,
                count: 1 / 0
            }, this.userData = {}
        }
        an.prototype = Object.assign(Object.create(yn.prototype), {
            constructor: an,
            isBufferGeometry: !0,
            getIndex: function() {
                return this.index
            },
            setIndex: function(s) {
                return Array.isArray(s) ? this.index = new(Ea(s) > 65535 ? Qr : Un)(s, 1) : this.index = s, this
            },
            getAttribute: function(s) {
                return this.attributes[s]
            },
            setAttribute: function(s, e) {
                return this.attributes[s] = e, this
            },
            deleteAttribute: function(s) {
                return delete this.attributes[s], this
            },
            hasAttribute: function(s) {
                return this.attributes[s] !== void 0
            },
            addGroup: function(s, e, r = 0) {
                this.groups.push({
                    start: s,
                    count: e,
                    materialIndex: r
                })
            },
            clearGroups: function() {
                this.groups = []
            },
            setDrawRange: function(s, e) {
                this.drawRange.start = s, this.drawRange.count = e
            },
            applyMatrix4: function(s) {
                const e = this.attributes.position;
                e !== void 0 && (e.applyMatrix4(s), e.needsUpdate = !0);
                const r = this.attributes.normal;
                if (r !== void 0) {
                    const c = new Pt().getNormalMatrix(s);
                    r.applyNormalMatrix(c), r.needsUpdate = !0
                }
                const h = this.attributes.tangent;
                return h !== void 0 && (h.transformDirection(s), h.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this
            },
            rotateX: function(s) {
                return Or.makeRotationX(s), this.applyMatrix4(Or), this
            },
            rotateY: function(s) {
                return Or.makeRotationY(s), this.applyMatrix4(Or), this
            },
            rotateZ: function(s) {
                return Or.makeRotationZ(s), this.applyMatrix4(Or), this
            },
            translate: function(s, e, r) {
                return Or.makeTranslation(s, e, r), this.applyMatrix4(Or), this
            },
            scale: function(s, e, r) {
                return Or.makeScale(s, e, r), this.applyMatrix4(Or), this
            },
            lookAt: function(s) {
                return ls.lookAt(s), ls.updateMatrix(), this.applyMatrix4(ls.matrix), this
            },
            center: function() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(ms).negate(), this.translate(ms.x, ms.y, ms.z), this
            },
            setFromPoints: function(s) {
                const e = [];
                for (let r = 0, h = s.length; r < h; r++) {
                    const c = s[r];
                    e.push(c.x, c.y, c.z || 0)
                }
                return this.setAttribute("position", new Ai(e, 3)), this
            },
            computeBoundingBox: function() {
                this.boundingBox === null && (this.boundingBox = new Te);
                const s = this.attributes.position,
                    e = this.morphAttributes.position;
                if (s && s.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new ge(-1 / 0, -1 / 0, -1 / 0), new ge(1 / 0, 1 / 0, 1 / 0));
                if (s !== void 0) {
                    if (this.boundingBox.setFromBufferAttribute(s), e)
                        for (let r = 0, h = e.length; r < h; r++) {
                            const c = e[r];
                            _a.setFromBufferAttribute(c), this.morphTargetsRelative ? (Pr.addVectors(this.boundingBox.min, _a.min), this.boundingBox.expandByPoint(Pr), Pr.addVectors(this.boundingBox.max, _a.max), this.boundingBox.expandByPoint(Pr)) : (this.boundingBox.expandByPoint(_a.min), this.boundingBox.expandByPoint(_a.max))
                        }
                } else this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            },
            computeBoundingSphere: function() {
                this.boundingSphere === null && (this.boundingSphere = new Fn);
                const s = this.attributes.position,
                    e = this.morphAttributes.position;
                if (s && s.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new ge, 1 / 0);
                if (s) {
                    const r = this.boundingSphere.center;
                    if (_a.setFromBufferAttribute(s), e)
                        for (let c = 0, v = e.length; c < v; c++) {
                            const w = e[c];
                            ks.setFromBufferAttribute(w), this.morphTargetsRelative ? (Pr.addVectors(_a.min, ks.min), _a.expandByPoint(Pr), Pr.addVectors(_a.max, ks.max), _a.expandByPoint(Pr)) : (_a.expandByPoint(ks.min), _a.expandByPoint(ks.max))
                        }
                    _a.getCenter(r);
                    let h = 0;
                    for (let c = 0, v = s.count; c < v; c++) Pr.fromBufferAttribute(s, c), h = Math.max(h, r.distanceToSquared(Pr));
                    if (e)
                        for (let c = 0, v = e.length; c < v; c++) {
                            const w = e[c],
                                E = this.morphTargetsRelative;
                            for (let T = 0, B = w.count; T < B; T++) Pr.fromBufferAttribute(w, T), E && (ms.fromBufferAttribute(s, T), Pr.add(ms)), h = Math.max(h, r.distanceToSquared(Pr))
                        }
                    this.boundingSphere.radius = Math.sqrt(h), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            },
            computeFaceNormals: function() {},
            computeTangents: function() {
                const s = this.index,
                    e = this.attributes;
                if (s === null || e.position === void 0 || e.normal === void 0 || e.uv === void 0) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                const r = s.array,
                    h = e.position.array,
                    c = e.normal.array,
                    v = e.uv.array,
                    w = h.length / 3;
                e.tangent === void 0 && this.setAttribute("tangent", new pi(new Float32Array(4 * w), 4));
                const E = e.tangent.array,
                    T = [],
                    B = [];
                for (let H = 0; H < w; H++) T[H] = new ge, B[H] = new ge;
                const Q = new ge,
                    k = new ge,
                    i = new ge,
                    t = new Ht,
                    a = new Ht,
                    l = new Ht,
                    d = new ge,
                    g = new ge;

                function x(H, X, ne) {
                    Q.fromArray(h, 3 * H), k.fromArray(h, 3 * X), i.fromArray(h, 3 * ne), t.fromArray(v, 2 * H), a.fromArray(v, 2 * X), l.fromArray(v, 2 * ne), k.sub(Q), i.sub(Q), a.sub(t), l.sub(t);
                    const le = 1 / (a.x * l.y - l.x * a.y);
                    isFinite(le) && (d.copy(k).multiplyScalar(l.y).addScaledVector(i, -a.y).multiplyScalar(le), g.copy(i).multiplyScalar(a.x).addScaledVector(k, -l.x).multiplyScalar(le), T[H].add(d), T[X].add(d), T[ne].add(d), B[H].add(g), B[X].add(g), B[ne].add(g))
                }
                let A = this.groups;
                A.length === 0 && (A = [{
                    start: 0,
                    count: r.length
                }]);
                for (let H = 0, X = A.length; H < X; ++H) {
                    const ne = A[H],
                        le = ne.start;
                    for (let ce = le, Qe = le + ne.count; ce < Qe; ce += 3) x(r[ce + 0], r[ce + 1], r[ce + 2])
                }
                const M = new ge,
                    F = new ge,
                    D = new ge,
                    U = new ge;

                function N(H) {
                    D.fromArray(c, 3 * H), U.copy(D);
                    const X = T[H];
                    M.copy(X), M.sub(D.multiplyScalar(D.dot(X))).normalize(), F.crossVectors(U, X);
                    const ne = F.dot(B[H]) < 0 ? -1 : 1;
                    E[4 * H] = M.x, E[4 * H + 1] = M.y, E[4 * H + 2] = M.z, E[4 * H + 3] = ne
                }
                for (let H = 0, X = A.length; H < X; ++H) {
                    const ne = A[H],
                        le = ne.start;
                    for (let ce = le, Qe = le + ne.count; ce < Qe; ce += 3) N(r[ce + 0]), N(r[ce + 1]), N(r[ce + 2])
                }
            },
            computeVertexNormals: function() {
                const s = this.index,
                    e = this.getAttribute("position");
                if (e !== void 0) {
                    let r = this.getAttribute("normal");
                    if (r === void 0) r = new pi(new Float32Array(3 * e.count), 3), this.setAttribute("normal", r);
                    else
                        for (let k = 0, i = r.count; k < i; k++) r.setXYZ(k, 0, 0, 0);
                    const h = new ge,
                        c = new ge,
                        v = new ge,
                        w = new ge,
                        E = new ge,
                        T = new ge,
                        B = new ge,
                        Q = new ge;
                    if (s)
                        for (let k = 0, i = s.count; k < i; k += 3) {
                            const t = s.getX(k + 0),
                                a = s.getX(k + 1),
                                l = s.getX(k + 2);
                            h.fromBufferAttribute(e, t), c.fromBufferAttribute(e, a), v.fromBufferAttribute(e, l), B.subVectors(v, c), Q.subVectors(h, c), B.cross(Q), w.fromBufferAttribute(r, t), E.fromBufferAttribute(r, a), T.fromBufferAttribute(r, l), w.add(B), E.add(B), T.add(B), r.setXYZ(t, w.x, w.y, w.z), r.setXYZ(a, E.x, E.y, E.z), r.setXYZ(l, T.x, T.y, T.z)
                        } else
                            for (let k = 0, i = e.count; k < i; k += 3) h.fromBufferAttribute(e, k + 0), c.fromBufferAttribute(e, k + 1), v.fromBufferAttribute(e, k + 2), B.subVectors(v, c), Q.subVectors(h, c), B.cross(Q), r.setXYZ(k + 0, B.x, B.y, B.z), r.setXYZ(k + 1, B.x, B.y, B.z), r.setXYZ(k + 2, B.x, B.y, B.z);
                    this.normalizeNormals(), r.needsUpdate = !0
                }
            },
            merge: function(s, e) {
                if (!s || !s.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", s);
                e === void 0 && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                const r = this.attributes;
                for (const h in r) {
                    if (s.attributes[h] === void 0) continue;
                    const c = r[h].array,
                        v = s.attributes[h],
                        w = v.array,
                        E = v.itemSize * e,
                        T = Math.min(w.length, c.length - E);
                    for (let B = 0, Q = E; B < T; B++, Q++) c[Q] = w[B]
                }
                return this
            },
            normalizeNormals: function() {
                const s = this.attributes.normal;
                for (let e = 0, r = s.count; e < r; e++) Pr.fromBufferAttribute(s, e), Pr.normalize(), s.setXYZ(e, Pr.x, Pr.y, Pr.z)
            },
            toNonIndexed: function() {
                function s(w, E) {
                    const T = w.array,
                        B = w.itemSize,
                        Q = w.normalized,
                        k = new T.constructor(E.length * B);
                    let i = 0,
                        t = 0;
                    for (let a = 0, l = E.length; a < l; a++) {
                        i = E[a] * B;
                        for (let d = 0; d < B; d++) k[t++] = T[i++]
                    }
                    return new pi(k, B, Q)
                }
                if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                const e = new an,
                    r = this.index.array,
                    h = this.attributes;
                for (const w in h) {
                    const E = s(h[w], r);
                    e.setAttribute(w, E)
                }
                const c = this.morphAttributes;
                for (const w in c) {
                    const E = [],
                        T = c[w];
                    for (let B = 0, Q = T.length; B < Q; B++) {
                        const k = s(T[B], r);
                        E.push(k)
                    }
                    e.morphAttributes[w] = E
                }
                e.morphTargetsRelative = this.morphTargetsRelative;
                const v = this.groups;
                for (let w = 0, E = v.length; w < E; w++) {
                    const T = v[w];
                    e.addGroup(T.start, T.count, T.materialIndex)
                }
                return e
            },
            toJSON: function() {
                const s = {
                    metadata: {
                        version: 4.5,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), Object.keys(this.userData).length > 0 && (s.userData = this.userData), this.parameters !== void 0) {
                    const E = this.parameters;
                    for (const T in E) E[T] !== void 0 && (s[T] = E[T]);
                    return s
                }
                s.data = {
                    attributes: {}
                };
                const e = this.index;
                e !== null && (s.data.index = {
                    type: e.array.constructor.name,
                    array: Array.prototype.slice.call(e.array)
                });
                const r = this.attributes;
                for (const E in r) {
                    const T = r[E];
                    s.data.attributes[E] = T.toJSON(s.data)
                }
                const h = {};
                let c = !1;
                for (const E in this.morphAttributes) {
                    const T = this.morphAttributes[E],
                        B = [];
                    for (let Q = 0, k = T.length; Q < k; Q++) {
                        const i = T[Q];
                        B.push(i.toJSON(s.data))
                    }
                    B.length > 0 && (h[E] = B, c = !0)
                }
                c && (s.data.morphAttributes = h, s.data.morphTargetsRelative = this.morphTargetsRelative);
                const v = this.groups;
                v.length > 0 && (s.data.groups = JSON.parse(JSON.stringify(v)));
                const w = this.boundingSphere;
                return w !== null && (s.data.boundingSphere = {
                    center: w.center.toArray(),
                    radius: w.radius
                }), s
            },
            clone: function() {
                return new an().copy(this)
            },
            copy: function(s) {
                this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                const e = {};
                this.name = s.name;
                const r = s.index;
                r !== null && this.setIndex(r.clone(e));
                const h = s.attributes;
                for (const T in h) {
                    const B = h[T];
                    this.setAttribute(T, B.clone(e))
                }
                const c = s.morphAttributes;
                for (const T in c) {
                    const B = [],
                        Q = c[T];
                    for (let k = 0, i = Q.length; k < i; k++) B.push(Q[k].clone(e));
                    this.morphAttributes[T] = B
                }
                this.morphTargetsRelative = s.morphTargetsRelative;
                const v = s.groups;
                for (let T = 0, B = v.length; T < B; T++) {
                    const Q = v[T];
                    this.addGroup(Q.start, Q.count, Q.materialIndex)
                }
                const w = s.boundingBox;
                w !== null && (this.boundingBox = w.clone());
                const E = s.boundingSphere;
                return E !== null && (this.boundingSphere = E.clone()), this.drawRange.start = s.drawRange.start, this.drawRange.count = s.drawRange.count, this.userData = s.userData, this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        });
        const Nl = new Ui,
            gs = new wr,
            cl = new Fn,
            cs = new ge,
            Ua = new ge,
            ys = new ge,
            Ol = new ge,
            hl = new ge,
            vs = new ge,
            ul = new ge,
            _s = new ge,
            xs = new ge,
            dl = new Ht,
            Bo = new Ht,
            Mn = new Ht,
            Ro = new ge,
            Vl = new ge;

        function ar(s = new an, e = new Gi) {
            Z.call(this), this.type = "Mesh", this.geometry = s, this.material = e, this.updateMorphTargets()
        }

        function Ds(s, e, r, h, c, v, w, E, T, B, Q, k) {
            cs.fromBufferAttribute(c, B), Ua.fromBufferAttribute(c, Q), ys.fromBufferAttribute(c, k);
            const i = s.morphTargetInfluences;
            if (e.morphTargets && v && i) {
                ul.set(0, 0, 0), _s.set(0, 0, 0), xs.set(0, 0, 0);
                for (let a = 0, l = v.length; a < l; a++) {
                    const d = i[a],
                        g = v[a];
                    d !== 0 && (Ol.fromBufferAttribute(g, B), hl.fromBufferAttribute(g, Q), vs.fromBufferAttribute(g, k), w ? (ul.addScaledVector(Ol, d), _s.addScaledVector(hl, d), xs.addScaledVector(vs, d)) : (ul.addScaledVector(Ol.sub(cs), d), _s.addScaledVector(hl.sub(Ua), d), xs.addScaledVector(vs.sub(ys), d)))
                }
                cs.add(ul), Ua.add(_s), ys.add(xs)
            }
            s.isSkinnedMesh && e.skinning && (s.boneTransform(B, cs), s.boneTransform(Q, Ua), s.boneTransform(k, ys));
            const t = function(a, l, d, g, x, A, M, F) {
                let D;
                if (D = l.side === 1 ? g.intersectTriangle(M, A, x, !0, F) : g.intersectTriangle(x, A, M, l.side !== 2, F), D === null) return null;
                Vl.copy(F), Vl.applyMatrix4(a.matrixWorld);
                const U = d.ray.origin.distanceTo(Vl);
                return U < d.near || U > d.far ? null : {
                    distance: U,
                    point: Vl.clone(),
                    object: a
                }
            }(s, e, r, h, cs, Ua, ys, Ro);
            if (t) {
                E && (dl.fromBufferAttribute(E, B), Bo.fromBufferAttribute(E, Q), Mn.fromBufferAttribute(E, k), t.uv = Mt.getUV(Ro, cs, Ua, ys, dl, Bo, Mn, new Ht)), T && (dl.fromBufferAttribute(T, B), Bo.fromBufferAttribute(T, Q), Mn.fromBufferAttribute(T, k), t.uv2 = Mt.getUV(Ro, cs, Ua, ys, dl, Bo, Mn, new Ht));
                const a = {
                    a: B,
                    b: Q,
                    c: k,
                    normal: new ge,
                    materialIndex: 0
                };
                Mt.getNormal(cs, Ua, ys, a.normal), t.face = a
            }
            return t
        }
        ar.prototype = Object.assign(Object.create(Z.prototype), {
            constructor: ar,
            isMesh: !0,
            copy: function(s) {
                return Z.prototype.copy.call(this, s), s.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = s.morphTargetInfluences.slice()), s.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, s.morphTargetDictionary)), this.material = s.material, this.geometry = s.geometry, this
            },
            updateMorphTargets: function() {
                const s = this.geometry;
                if (s.isBufferGeometry) {
                    const e = s.morphAttributes,
                        r = Object.keys(e);
                    if (r.length > 0) {
                        const h = e[r[0]];
                        if (h !== void 0) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let c = 0, v = h.length; c < v; c++) {
                                const w = h[c].name || String(c);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[w] = c
                            }
                        }
                    }
                } else {
                    const e = s.morphTargets;
                    e !== void 0 && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            },
            raycast: function(s, e) {
                const r = this.geometry,
                    h = this.material,
                    c = this.matrixWorld;
                if (h === void 0 || (r.boundingSphere === null && r.computeBoundingSphere(), cl.copy(r.boundingSphere), cl.applyMatrix4(c), s.ray.intersectsSphere(cl) === !1) || (Nl.copy(c).invert(), gs.copy(s.ray).applyMatrix4(Nl), r.boundingBox !== null && gs.intersectsBox(r.boundingBox) === !1)) return;
                let v;
                if (r.isBufferGeometry) {
                    const w = r.index,
                        E = r.attributes.position,
                        T = r.morphAttributes.position,
                        B = r.morphTargetsRelative,
                        Q = r.attributes.uv,
                        k = r.attributes.uv2,
                        i = r.groups,
                        t = r.drawRange;
                    if (w !== null)
                        if (Array.isArray(h))
                            for (let a = 0, l = i.length; a < l; a++) {
                                const d = i[a],
                                    g = h[d.materialIndex];
                                for (let x = Math.max(d.start, t.start), A = Math.min(d.start + d.count, t.start + t.count); x < A; x += 3) {
                                    const M = w.getX(x),
                                        F = w.getX(x + 1),
                                        D = w.getX(x + 2);
                                    v = Ds(this, g, s, gs, E, T, B, Q, k, M, F, D), v && (v.faceIndex = Math.floor(x / 3), v.face.materialIndex = d.materialIndex, e.push(v))
                                }
                            } else
                                for (let a = Math.max(0, t.start), l = Math.min(w.count, t.start + t.count); a < l; a += 3) {
                                    const d = w.getX(a),
                                        g = w.getX(a + 1),
                                        x = w.getX(a + 2);
                                    v = Ds(this, h, s, gs, E, T, B, Q, k, d, g, x), v && (v.faceIndex = Math.floor(a / 3), e.push(v))
                                } else if (E !== void 0)
                                    if (Array.isArray(h))
                                        for (let a = 0, l = i.length; a < l; a++) {
                                            const d = i[a],
                                                g = h[d.materialIndex];
                                            for (let x = Math.max(d.start, t.start), A = Math.min(d.start + d.count, t.start + t.count); x < A; x += 3) v = Ds(this, g, s, gs, E, T, B, Q, k, x, x + 1, x + 2), v && (v.faceIndex = Math.floor(x / 3), v.face.materialIndex = d.materialIndex, e.push(v))
                                        } else
                                            for (let a = Math.max(0, t.start), l = Math.min(E.count, t.start + t.count); a < l; a += 3) v = Ds(this, h, s, gs, E, T, B, Q, k, a, a + 1, a + 2), v && (v.faceIndex = Math.floor(a / 3), e.push(v))
                } else r.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        });
        class sr extends an {
            constructor(e = 1, r = 1, h = 1, c = 1, v = 1, w = 1) {
                super(), this.type = "BoxGeometry", this.parameters = {
                    width: e,
                    height: r,
                    depth: h,
                    widthSegments: c,
                    heightSegments: v,
                    depthSegments: w
                };
                const E = this;
                c = Math.floor(c), v = Math.floor(v), w = Math.floor(w);
                const T = [],
                    B = [],
                    Q = [],
                    k = [];
                let i = 0,
                    t = 0;

                function a(l, d, g, x, A, M, F, D, U, N, H) {
                    const X = M / U,
                        ne = F / N,
                        le = M / 2,
                        ce = F / 2,
                        Qe = D / 2,
                        Se = U + 1,
                        Re = N + 1;
                    let ot = 0,
                        dt = 0;
                    const Ct = new ge;
                    for (let Nt = 0; Nt < Re; Nt++) {
                        const qt = Nt * ne - ce;
                        for (let Fe = 0; Fe < Se; Fe++) {
                            const Be = Fe * X - le;
                            Ct[l] = Be * x, Ct[d] = qt * A, Ct[g] = Qe, B.push(Ct.x, Ct.y, Ct.z), Ct[l] = 0, Ct[d] = 0, Ct[g] = D > 0 ? 1 : -1, Q.push(Ct.x, Ct.y, Ct.z), k.push(Fe / U), k.push(1 - Nt / N), ot += 1
                        }
                    }
                    for (let Nt = 0; Nt < N; Nt++)
                        for (let qt = 0; qt < U; qt++) {
                            const Fe = i + qt + Se * Nt,
                                Be = i + qt + Se * (Nt + 1),
                                mt = i + (qt + 1) + Se * (Nt + 1),
                                lt = i + (qt + 1) + Se * Nt;
                            T.push(Fe, Be, lt), T.push(Be, mt, lt), dt += 6
                        }
                    E.addGroup(t, dt, H), t += dt, i += ot
                }
                a("z", "y", "x", -1, -1, h, r, e, w, v, 0), a("z", "y", "x", 1, -1, h, r, -e, w, v, 1), a("x", "z", "y", 1, 1, e, h, r, c, w, 2), a("x", "z", "y", 1, -1, e, h, -r, c, w, 3), a("x", "y", "z", 1, -1, e, r, h, c, v, 4), a("x", "y", "z", -1, -1, e, r, -h, c, v, 5), this.setIndex(T), this.setAttribute("position", new Ai(B, 3)), this.setAttribute("normal", new Ai(Q, 3)), this.setAttribute("uv", new Ai(k, 2))
            }
        }

        function Fo(s) {
            const e = {};
            for (const r in s) {
                e[r] = {};
                for (const h in s[r]) {
                    const c = s[r][h];
                    c && (c.isColor || c.isMatrix3 || c.isMatrix4 || c.isVector2 || c.isVector3 || c.isVector4 || c.isTexture || c.isQuaternion) ? e[r][h] = c.clone() : Array.isArray(c) ? e[r][h] = c.slice() : e[r][h] = c
                }
            }
            return e
        }

        function un(s) {
            const e = {};
            for (let r = 0; r < s.length; r++) {
                const h = Fo(s[r]);
                for (const c in h) e[c] = h[c]
            }
            return e
        }
        const Gl = {
            clone: Fo,
            merge: un
        };

        function Cn(s) {
            ti.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, this.fragmentShader = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1
            }, this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0]
            }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, s !== void 0 && (s.attributes !== void 0 && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(s))
        }

        function Dn() {
            Z.call(this), this.type = "Camera", this.matrixWorldInverse = new Ui, this.projectionMatrix = new Ui, this.projectionMatrixInverse = new Ui
        }

        function dr(s = 50, e = 1, r = .1, h = 2e3) {
            Dn.call(this), this.type = "PerspectiveCamera", this.fov = s, this.zoom = 1, this.near = r, this.far = h, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
        }
        Cn.prototype = Object.create(ti.prototype), Cn.prototype.constructor = Cn, Cn.prototype.isShaderMaterial = !0, Cn.prototype.copy = function(s) {
            return ti.prototype.copy.call(this, s), this.fragmentShader = s.fragmentShader, this.vertexShader = s.vertexShader, this.uniforms = Fo(s.uniforms), this.defines = Object.assign({}, s.defines), this.wireframe = s.wireframe, this.wireframeLinewidth = s.wireframeLinewidth, this.lights = s.lights, this.clipping = s.clipping, this.skinning = s.skinning, this.morphTargets = s.morphTargets, this.morphNormals = s.morphNormals, this.extensions = Object.assign({}, s.extensions), this.glslVersion = s.glslVersion, this
        }, Cn.prototype.toJSON = function(s) {
            const e = ti.prototype.toJSON.call(this, s);
            e.glslVersion = this.glslVersion, e.uniforms = {};
            for (const h in this.uniforms) {
                const c = this.uniforms[h].value;
                c && c.isTexture ? e.uniforms[h] = {
                    type: "t",
                    value: c.toJSON(s).uuid
                } : c && c.isColor ? e.uniforms[h] = {
                    type: "c",
                    value: c.getHex()
                } : c && c.isVector2 ? e.uniforms[h] = {
                    type: "v2",
                    value: c.toArray()
                } : c && c.isVector3 ? e.uniforms[h] = {
                    type: "v3",
                    value: c.toArray()
                } : c && c.isVector4 ? e.uniforms[h] = {
                    type: "v4",
                    value: c.toArray()
                } : c && c.isMatrix3 ? e.uniforms[h] = {
                    type: "m3",
                    value: c.toArray()
                } : c && c.isMatrix4 ? e.uniforms[h] = {
                    type: "m4",
                    value: c.toArray()
                } : e.uniforms[h] = {
                    value: c
                }
            }
            Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
            const r = {};
            for (const h in this.extensions) this.extensions[h] === !0 && (r[h] = !0);
            return Object.keys(r).length > 0 && (e.extensions = r), e
        }, Dn.prototype = Object.assign(Object.create(Z.prototype), {
            constructor: Dn,
            isCamera: !0,
            copy: function(s, e) {
                return Z.prototype.copy.call(this, s, e), this.matrixWorldInverse.copy(s.matrixWorldInverse), this.projectionMatrix.copy(s.projectionMatrix), this.projectionMatrixInverse.copy(s.projectionMatrixInverse), this
            },
            getWorldDirection: function(s) {
                s === void 0 && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), s = new ge), this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return s.set(-e[8], -e[9], -e[10]).normalize()
            },
            updateMatrixWorld: function(s) {
                Z.prototype.updateMatrixWorld.call(this, s), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            },
            updateWorldMatrix: function(s, e) {
                Z.prototype.updateWorldMatrix.call(this, s, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            },
            clone: function() {
                return new this.constructor().copy(this)
            }
        }), dr.prototype = Object.assign(Object.create(Dn.prototype), {
            constructor: dr,
            isPerspectiveCamera: !0,
            copy: function(s, e) {
                return Dn.prototype.copy.call(this, s, e), this.fov = s.fov, this.zoom = s.zoom, this.near = s.near, this.far = s.far, this.focus = s.focus, this.aspect = s.aspect, this.view = s.view === null ? null : Object.assign({}, s.view), this.filmGauge = s.filmGauge, this.filmOffset = s.filmOffset, this
            },
            setFocalLength: function(s) {
                const e = .5 * this.getFilmHeight() / s;
                this.fov = 2 * Mi.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
            },
            getFocalLength: function() {
                const s = Math.tan(.5 * Mi.DEG2RAD * this.fov);
                return .5 * this.getFilmHeight() / s
            },
            getEffectiveFOV: function() {
                return 2 * Mi.RAD2DEG * Math.atan(Math.tan(.5 * Mi.DEG2RAD * this.fov) / this.zoom)
            },
            getFilmWidth: function() {
                return this.filmGauge * Math.min(this.aspect, 1)
            },
            getFilmHeight: function() {
                return this.filmGauge / Math.max(this.aspect, 1)
            },
            setViewOffset: function(s, e, r, h, c, v) {
                this.aspect = s / e, this.view === null && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = s, this.view.fullHeight = e, this.view.offsetX = r, this.view.offsetY = h, this.view.width = c, this.view.height = v, this.updateProjectionMatrix()
            },
            clearViewOffset: function() {
                this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function() {
                const s = this.near;
                let e = s * Math.tan(.5 * Mi.DEG2RAD * this.fov) / this.zoom,
                    r = 2 * e,
                    h = this.aspect * r,
                    c = -.5 * h;
                const v = this.view;
                if (this.view !== null && this.view.enabled) {
                    const E = v.fullWidth,
                        T = v.fullHeight;
                    c += v.offsetX * h / E, e -= v.offsetY * r / T, h *= v.width / E, r *= v.height / T
                }
                const w = this.filmOffset;
                w !== 0 && (c += s * w / this.getFilmWidth()), this.projectionMatrix.makePerspective(c, c + h, e, e - r, s, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            },
            toJSON: function(s) {
                const e = Z.prototype.toJSON.call(this, s);
                return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, this.view !== null && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
            }
        });
        const bs = 90;
        class Lo extends Z {
            constructor(e, r, h) {
                if (super(), this.type = "CubeCamera", h.isWebGLCubeRenderTarget !== !0) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                this.renderTarget = h;
                const c = new dr(bs, 1, e, r);
                c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new ge(1, 0, 0)), this.add(c);
                const v = new dr(bs, 1, e, r);
                v.layers = this.layers, v.up.set(0, -1, 0), v.lookAt(new ge(-1, 0, 0)), this.add(v);
                const w = new dr(bs, 1, e, r);
                w.layers = this.layers, w.up.set(0, 0, 1), w.lookAt(new ge(0, 1, 0)), this.add(w);
                const E = new dr(bs, 1, e, r);
                E.layers = this.layers, E.up.set(0, 0, -1), E.lookAt(new ge(0, -1, 0)), this.add(E);
                const T = new dr(bs, 1, e, r);
                T.layers = this.layers, T.up.set(0, -1, 0), T.lookAt(new ge(0, 0, 1)), this.add(T);
                const B = new dr(bs, 1, e, r);
                B.layers = this.layers, B.up.set(0, -1, 0), B.lookAt(new ge(0, 0, -1)), this.add(B)
            }
            update(e, r) {
                this.parent === null && this.updateMatrixWorld();
                const h = this.renderTarget,
                    [c, v, w, E, T, B] = this.children,
                    Q = e.xr.enabled,
                    k = e.getRenderTarget();
                e.xr.enabled = !1;
                const i = h.texture.generateMipmaps;
                h.texture.generateMipmaps = !1, e.setRenderTarget(h, 0), e.render(r, c), e.setRenderTarget(h, 1), e.render(r, v), e.setRenderTarget(h, 2), e.render(r, w), e.setRenderTarget(h, 3), e.render(r, E), e.setRenderTarget(h, 4), e.render(r, T), h.texture.generateMipmaps = i, e.setRenderTarget(h, 5), e.render(r, B), e.setRenderTarget(k), e.xr.enabled = Q
            }
        }
        class ao extends cn {
            constructor(e, r, h, c, v, w, E, T, B, Q) {
                super(e = e !== void 0 ? e : [], r = r !== void 0 ? r : 301, h, c, v, w, E = E !== void 0 ? E : 1022, T, B, Q), this._needsFlipEnvMap = !0, this.flipY = !1
            }
            get images() {
                return this.image
            }
            set images(e) {
                this.image = e
            }
        }
        ao.prototype.isCubeTexture = !0;
        class so extends qi {
            constructor(e, r, h) {
                Number.isInteger(r) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), r = h), super(e, e, r), r = r || {}, this.texture = new ao(void 0, r.mapping, r.wrapS, r.wrapT, r.magFilter, r.minFilter, r.format, r.type, r.anisotropy, r.encoding), this.texture.generateMipmaps = r.generateMipmaps !== void 0 && r.generateMipmaps, this.texture.minFilter = r.minFilter !== void 0 ? r.minFilter : 1006, this.texture._needsFlipEnvMap = !1
            }
            fromEquirectangularTexture(e, r) {
                this.texture.type = r.type, this.texture.format = 1023, this.texture.encoding = r.encoding, this.texture.generateMipmaps = r.generateMipmaps, this.texture.minFilter = r.minFilter, this.texture.magFilter = r.magFilter;
                const h = {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
                    },
                    c = new sr(5, 5, 5),
                    v = new Cn({
                        name: "CubemapFromEquirect",
                        uniforms: Fo(h.uniforms),
                        vertexShader: h.vertexShader,
                        fragmentShader: h.fragmentShader,
                        side: 1,
                        blending: 0
                    });
                v.uniforms.tEquirect.value = r;
                const w = new ar(c, v),
                    E = r.minFilter;
                return r.minFilter === 1008 && (r.minFilter = 1006), new Lo(1, 10, this).update(e, w), r.minFilter = E, w.geometry.dispose(), w.material.dispose(), this
            }
            clear(e, r, h, c) {
                const v = e.getRenderTarget();
                for (let w = 0; w < 6; w++) e.setRenderTarget(this, w), e.clear(r, h, c);
                e.setRenderTarget(v)
            }
        }
        so.prototype.isWebGLCubeRenderTarget = !0;
        class ws extends cn {
            constructor(e, r, h, c, v, w, E, T, B, Q, k, i) {
                super(null, w, E, T, B, Q, c, v, k, i), this.image = {
                    data: e || null,
                    width: r || 1,
                    height: h || 1
                }, this.magFilter = B !== void 0 ? B : 1003, this.minFilter = Q !== void 0 ? Q : 1003, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
            }
        }
        ws.prototype.isDataTexture = !0;
        const Es = new Fn,
            pl = new ge;
        class Us {
            constructor(e = new Et, r = new Et, h = new Et, c = new Et, v = new Et, w = new Et) {
                this.planes = [e, r, h, c, v, w]
            }
            set(e, r, h, c, v, w) {
                const E = this.planes;
                return E[0].copy(e), E[1].copy(r), E[2].copy(h), E[3].copy(c), E[4].copy(v), E[5].copy(w), this
            }
            copy(e) {
                const r = this.planes;
                for (let h = 0; h < 6; h++) r[h].copy(e.planes[h]);
                return this
            }
            setFromProjectionMatrix(e) {
                const r = this.planes,
                    h = e.elements,
                    c = h[0],
                    v = h[1],
                    w = h[2],
                    E = h[3],
                    T = h[4],
                    B = h[5],
                    Q = h[6],
                    k = h[7],
                    i = h[8],
                    t = h[9],
                    a = h[10],
                    l = h[11],
                    d = h[12],
                    g = h[13],
                    x = h[14],
                    A = h[15];
                return r[0].setComponents(E - c, k - T, l - i, A - d).normalize(), r[1].setComponents(E + c, k + T, l + i, A + d).normalize(), r[2].setComponents(E + v, k + B, l + t, A + g).normalize(), r[3].setComponents(E - v, k - B, l - t, A - g).normalize(), r[4].setComponents(E - w, k - Q, l - a, A - x).normalize(), r[5].setComponents(E + w, k + Q, l + a, A + x).normalize(), this
            }
            intersectsObject(e) {
                const r = e.geometry;
                return r.boundingSphere === null && r.computeBoundingSphere(), Es.copy(r.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(Es)
            }
            intersectsSprite(e) {
                return Es.center.set(0, 0, 0), Es.radius = .7071067811865476, Es.applyMatrix4(e.matrixWorld), this.intersectsSphere(Es)
            }
            intersectsSphere(e) {
                const r = this.planes,
                    h = e.center,
                    c = -e.radius;
                for (let v = 0; v < 6; v++)
                    if (r[v].distanceToPoint(h) < c) return !1;
                return !0
            }
            intersectsBox(e) {
                const r = this.planes;
                for (let h = 0; h < 6; h++) {
                    const c = r[h];
                    if (pl.x = c.normal.x > 0 ? e.max.x : e.min.x, pl.y = c.normal.y > 0 ? e.max.y : e.min.y, pl.z = c.normal.z > 0 ? e.max.z : e.min.z, c.distanceToPoint(pl) < 0) return !1
                }
                return !0
            }
            containsPoint(e) {
                const r = this.planes;
                for (let h = 0; h < 6; h++)
                    if (r[h].distanceToPoint(e) < 0) return !1;
                return !0
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }

        function Pc() {
            let s = null,
                e = !1,
                r = null,
                h = null;

            function c(v, w) {
                r(v, w), h = s.requestAnimationFrame(c)
            }
            return {
                start: function() {
                    e !== !0 && r !== null && (h = s.requestAnimationFrame(c), e = !0)
                },
                stop: function() {
                    s.cancelAnimationFrame(h), e = !1
                },
                setAnimationLoop: function(v) {
                    r = v
                },
                setContext: function(v) {
                    s = v
                }
            }
        }

        function Hl(s, e) {
            const r = e.isWebGL2,
                h = new WeakMap;
            return {
                get: function(c) {
                    return c.isInterleavedBufferAttribute && (c = c.data), h.get(c)
                },
                remove: function(c) {
                    c.isInterleavedBufferAttribute && (c = c.data);
                    const v = h.get(c);
                    v && (s.deleteBuffer(v.buffer), h.delete(c))
                },
                update: function(c, v) {
                    if (c.isGLBufferAttribute) {
                        const E = h.get(c);
                        return void((!E || E.version < c.version) && h.set(c, {
                            buffer: c.buffer,
                            type: c.type,
                            bytesPerElement: c.elementSize,
                            version: c.version
                        }))
                    }
                    c.isInterleavedBufferAttribute && (c = c.data);
                    const w = h.get(c);
                    w === void 0 ? h.set(c, function(E, T) {
                        const B = E.array,
                            Q = E.usage,
                            k = s.createBuffer();
                        s.bindBuffer(T, k), s.bufferData(T, B, Q), E.onUploadCallback();
                        let i = 5126;
                        return B instanceof Float32Array ? i = 5126 : B instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : B instanceof Uint16Array ? E.isFloat16BufferAttribute ? r ? i = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : i = 5123 : B instanceof Int16Array ? i = 5122 : B instanceof Uint32Array ? i = 5125 : B instanceof Int32Array ? i = 5124 : B instanceof Int8Array ? i = 5120 : B instanceof Uint8Array && (i = 5121), {
                            buffer: k,
                            type: i,
                            bytesPerElement: B.BYTES_PER_ELEMENT,
                            version: E.version
                        }
                    }(c, v)) : w.version < c.version && (function(E, T, B) {
                        const Q = T.array,
                            k = T.updateRange;
                        s.bindBuffer(B, E), k.count === -1 ? s.bufferSubData(B, 0, Q) : (r ? s.bufferSubData(B, k.offset * Q.BYTES_PER_ELEMENT, Q, k.offset, k.count) : s.bufferSubData(B, k.offset * Q.BYTES_PER_ELEMENT, Q.subarray(k.offset, k.offset + k.count)), k.count = -1)
                    }(w.buffer, c, v), w.version = c.version)
                }
            }
        }
        class Is extends an {
            constructor(e = 1, r = 1, h = 1, c = 1) {
                super(), this.type = "PlaneGeometry", this.parameters = {
                    width: e,
                    height: r,
                    widthSegments: h,
                    heightSegments: c
                };
                const v = e / 2,
                    w = r / 2,
                    E = Math.floor(h),
                    T = Math.floor(c),
                    B = E + 1,
                    Q = T + 1,
                    k = e / E,
                    i = r / T,
                    t = [],
                    a = [],
                    l = [],
                    d = [];
                for (let g = 0; g < Q; g++) {
                    const x = g * i - w;
                    for (let A = 0; A < B; A++) {
                        const M = A * k - v;
                        a.push(M, -x, 0), l.push(0, 0, 1), d.push(A / E), d.push(1 - g / T)
                    }
                }
                for (let g = 0; g < T; g++)
                    for (let x = 0; x < E; x++) {
                        const A = x + B * g,
                            M = x + B * (g + 1),
                            F = x + 1 + B * (g + 1),
                            D = x + 1 + B * g;
                        t.push(A, M, D), t.push(M, F, D)
                    }
                this.setIndex(t), this.setAttribute("position", new Ai(a, 3)), this.setAttribute("normal", new Ai(l, 3)), this.setAttribute("uv", new Ai(d, 2))
            }
        }
        const An = {
                alphamap_fragment: `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,
                alphamap_pars_fragment: `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
                alphatest_fragment: `#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif`,
                aomap_fragment: `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif`,
                aomap_pars_fragment: `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
                begin_vertex: "vec3 transformed = vec3( position );",
                beginnormal_vertex: `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
                bsdfs: `vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
	return Fr * fresnel + F0;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	return specularColor * brdf.x + brdf.y;
}
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;
	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
#if defined( USE_SHEEN )
float D_Charlie(float roughness, float NoH) {
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float NoV, float NoL) {
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}
vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`,
                bumpmap_pars_fragment: `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
                clipping_planes_fragment: `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
                clipping_planes_pars_fragment: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
                clipping_planes_pars_vertex: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
                clipping_planes_vertex: `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
                color_fragment: `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
                color_pars_fragment: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
                color_pars_vertex: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
                color_vertex: `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
                common: `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,
                cube_uv_reflection_fragment: `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
                defaultnormal_vertex: `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
                displacementmap_pars_vertex: `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
                displacementmap_vertex: `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,
                emissivemap_fragment: `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
                emissivemap_pars_fragment: `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
                encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                encodings_pars_fragment: `
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,
                envmap_fragment: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifndef ENVMAP_TYPE_CUBE_UV
		envColor = envMapTexelToLinear( envColor );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
                envmap_common_pars_fragment: `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
                envmap_pars_fragment: `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
                envmap_pars_vertex: `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
                envmap_physical_pars_fragment: `#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		#else
			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif`,
                envmap_vertex: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
                fog_vertex: `#ifdef USE_FOG
	fogDepth = - mvPosition.z;
#endif`,
                fog_pars_vertex: `#ifdef USE_FOG
	varying float fogDepth;
#endif`,
                fog_fragment: `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
                fog_pars_fragment: `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
                gradientmap_pars_fragment: `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,
                lightmap_fragment: `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
#endif`,
                lightmap_pars_fragment: `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
                lights_lambert_vertex: `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`,
                lights_pars_begin: `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif`,
                lights_toon_fragment: `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
                lights_toon_pars_fragment: `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,
                lights_phong_fragment: `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
                lights_phong_pars_fragment: `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,
                lights_physical_fragment: `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );
#ifdef REFLECTIVITY
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#endif
#ifdef CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheen;
#endif`,
                lights_physical_pars_fragment: `struct PhysicalMaterial {
	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;
#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(		0, 1,		0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifdef CLEARCOAT
		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = ccDotNL * directLight.color;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			ccIrradiance *= PI;
		#endif
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
	#else
		float clearcoatDHR = 0.0;
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif
	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef CLEARCOAT
		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
	#else
		float clearcoatDHR = 0.0;
	#endif
	float clearcoatInv = 1.0 - clearcoatDHR;
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
                lights_fragment_begin: `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
                lights_fragment_maps: `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );
	#ifdef CLEARCOAT
		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );
	#endif
#endif`,
                lights_fragment_end: `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
                logdepthbuf_fragment: `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
                logdepthbuf_pars_fragment: `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
                logdepthbuf_pars_vertex: `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
                logdepthbuf_vertex: `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
                map_fragment: `#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,
                map_pars_fragment: `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
                map_particle_fragment: `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
                map_particle_pars_fragment: `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
                metalnessmap_fragment: `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
                metalnessmap_pars_fragment: `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
                morphnormal_vertex: `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`,
                morphtarget_pars_vertex: `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,
                morphtarget_vertex: `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`,
                normal_fragment_begin: `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,
                normal_fragment_maps: `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
                normalmap_pars_fragment: `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,
                clearcoat_normal_fragment_begin: `#ifdef CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
                clearcoat_normal_fragment_maps: `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,
                clearcoat_pars_fragment: `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,
                packing: `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,
                premultiplied_alpha_fragment: `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
                project_vertex: `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
                dithering_fragment: `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
                dithering_pars_fragment: `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
                roughnessmap_fragment: `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
                roughnessmap_pars_fragment: `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
                shadowmap_pars_fragment: `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
							texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
							f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
							texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
							f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
                shadowmap_pars_vertex: `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
                shadowmap_vertex: `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,
                shadowmask_pars_fragment: `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
                skinbase_vertex: `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
                skinning_pars_vertex: `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,
                skinning_vertex: `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
                skinnormal_vertex: `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
                specularmap_fragment: `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
                specularmap_pars_fragment: `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
                tonemapping_fragment: `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
                tonemapping_pars_fragment: `#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(	1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,	1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,	1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
                transmissionmap_fragment: `#ifdef USE_TRANSMISSIONMAP
	totalTransmission *= texture2D( transmissionMap, vUv ).r;
#endif`,
                transmissionmap_pars_fragment: `#ifdef USE_TRANSMISSIONMAP
	uniform sampler2D transmissionMap;
#endif`,
                uv_pars_fragment: `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,
                uv_pars_vertex: `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,
                uv_vertex: `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
                uv2_pars_fragment: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
                uv2_pars_vertex: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,
                uv2_vertex: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,
                worldpos_vertex: `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,
                background_frag: `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
                background_vert: `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
                cube_frag: `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
                cube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
                depth_frag: `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
                depth_vert: `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
                distanceRGBA_frag: `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
                distanceRGBA_vert: `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
                equirect_frag: `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
                equirect_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
                linedashed_frag: `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
                linedashed_vert: `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
                meshbasic_frag: `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                meshbasic_vert: `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
                meshlambert_frag: `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                meshlambert_vert: `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                meshmatcap_frag: `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                meshmatcap_vert: `#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
                meshtoon_frag: `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                meshtoon_vert: `#define TOON
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                meshphong_frag: `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                meshphong_vert: `#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                meshphysical_frag: `#define STANDARD
#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define TRANSMISSION
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef TRANSMISSION
	uniform float transmission;
#endif
#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif
#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <transmissionmap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#ifdef TRANSMISSION
		float totalTransmission = transmission;
	#endif
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <transmissionmap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#ifdef TRANSMISSION
		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );
	#endif
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                meshphysical_vert: `#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                normal_frag: `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,
                normal_vert: `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
                points_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
                points_vert: `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
                shadow_frag: `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
                shadow_vert: `#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                sprite_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
                sprite_vert: `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
            },
            Oi = {
                common: {
                    diffuse: {
                        value: new Rt(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    uvTransform: {
                        value: new Pt
                    },
                    uv2Transform: {
                        value: new Pt
                    },
                    alphaMap: {
                        value: null
                    }
                },
                specularmap: {
                    specularMap: {
                        value: null
                    }
                },
                envmap: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    reflectivity: {
                        value: 1
                    },
                    refractionRatio: {
                        value: .98
                    },
                    maxMipLevel: {
                        value: 0
                    }
                },
                aomap: {
                    aoMap: {
                        value: null
                    },
                    aoMapIntensity: {
                        value: 1
                    }
                },
                lightmap: {
                    lightMap: {
                        value: null
                    },
                    lightMapIntensity: {
                        value: 1
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        value: null
                    }
                },
                bumpmap: {
                    bumpMap: {
                        value: null
                    },
                    bumpScale: {
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        value: null
                    },
                    normalScale: {
                        value: new Ht(1, 1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        value: null
                    },
                    displacementScale: {
                        value: 1
                    },
                    displacementBias: {
                        value: 0
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        value: null
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        value: null
                    }
                },
                gradientmap: {
                    gradientMap: {
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        value: 25e-5
                    },
                    fogNear: {
                        value: 1
                    },
                    fogFar: {
                        value: 2e3
                    },
                    fogColor: {
                        value: new Rt(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        value: []
                    },
                    lightProbe: {
                        value: []
                    },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {}
                        }
                    },
                    directionalLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: {
                        value: []
                    },
                    directionalShadowMatrix: {
                        value: []
                    },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {}
                        }
                    },
                    spotLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotShadowMap: {
                        value: []
                    },
                    spotShadowMatrix: {
                        value: []
                    },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {}
                        }
                    },
                    pointLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {},
                            shadowCameraNear: {},
                            shadowCameraFar: {}
                        }
                    },
                    pointShadowMap: {
                        value: []
                    },
                    pointShadowMatrix: {
                        value: []
                    },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    },
                    rectAreaLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            width: {},
                            height: {}
                        }
                    },
                    ltc_1: {
                        value: null
                    },
                    ltc_2: {
                        value: null
                    }
                },
                points: {
                    diffuse: {
                        value: new Rt(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    size: {
                        value: 1
                    },
                    scale: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    uvTransform: {
                        value: new Pt
                    }
                },
                sprite: {
                    diffuse: {
                        value: new Rt(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    center: {
                        value: new Ht(.5, .5)
                    },
                    rotation: {
                        value: 0
                    },
                    map: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    uvTransform: {
                        value: new Pt
                    }
                }
            },
            Ga = {
                basic: {
                    uniforms: un([Oi.common, Oi.specularmap, Oi.envmap, Oi.aomap, Oi.lightmap, Oi.fog]),
                    vertexShader: An.meshbasic_vert,
                    fragmentShader: An.meshbasic_frag
                },
                lambert: {
                    uniforms: un([Oi.common, Oi.specularmap, Oi.envmap, Oi.aomap, Oi.lightmap, Oi.emissivemap, Oi.fog, Oi.lights, {
                        emissive: {
                            value: new Rt(0)
                        }
                    }]),
                    vertexShader: An.meshlambert_vert,
                    fragmentShader: An.meshlambert_frag
                },
                phong: {
                    uniforms: un([Oi.common, Oi.specularmap, Oi.envmap, Oi.aomap, Oi.lightmap, Oi.emissivemap, Oi.bumpmap, Oi.normalmap, Oi.displacementmap, Oi.fog, Oi.lights, {
                        emissive: {
                            value: new Rt(0)
                        },
                        specular: {
                            value: new Rt(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: An.meshphong_vert,
                    fragmentShader: An.meshphong_frag
                },
                standard: {
                    uniforms: un([Oi.common, Oi.envmap, Oi.aomap, Oi.lightmap, Oi.emissivemap, Oi.bumpmap, Oi.normalmap, Oi.displacementmap, Oi.roughnessmap, Oi.metalnessmap, Oi.fog, Oi.lights, {
                        emissive: {
                            value: new Rt(0)
                        },
                        roughness: {
                            value: 1
                        },
                        metalness: {
                            value: 0
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: An.meshphysical_vert,
                    fragmentShader: An.meshphysical_frag
                },
                toon: {
                    uniforms: un([Oi.common, Oi.aomap, Oi.lightmap, Oi.emissivemap, Oi.bumpmap, Oi.normalmap, Oi.displacementmap, Oi.gradientmap, Oi.fog, Oi.lights, {
                        emissive: {
                            value: new Rt(0)
                        }
                    }]),
                    vertexShader: An.meshtoon_vert,
                    fragmentShader: An.meshtoon_frag
                },
                matcap: {
                    uniforms: un([Oi.common, Oi.bumpmap, Oi.normalmap, Oi.displacementmap, Oi.fog, {
                        matcap: {
                            value: null
                        }
                    }]),
                    vertexShader: An.meshmatcap_vert,
                    fragmentShader: An.meshmatcap_frag
                },
                points: {
                    uniforms: un([Oi.points, Oi.fog]),
                    vertexShader: An.points_vert,
                    fragmentShader: An.points_frag
                },
                dashed: {
                    uniforms: un([Oi.common, Oi.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: An.linedashed_vert,
                    fragmentShader: An.linedashed_frag
                },
                depth: {
                    uniforms: un([Oi.common, Oi.displacementmap]),
                    vertexShader: An.depth_vert,
                    fragmentShader: An.depth_frag
                },
                normal: {
                    uniforms: un([Oi.common, Oi.bumpmap, Oi.normalmap, Oi.displacementmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: An.normal_vert,
                    fragmentShader: An.normal_frag
                },
                sprite: {
                    uniforms: un([Oi.sprite, Oi.fog]),
                    vertexShader: An.sprite_vert,
                    fragmentShader: An.sprite_frag
                },
                background: {
                    uniforms: {
                        uvTransform: {
                            value: new Pt
                        },
                        t2D: {
                            value: null
                        }
                    },
                    vertexShader: An.background_vert,
                    fragmentShader: An.background_frag
                },
                cube: {
                    uniforms: un([Oi.envmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: An.cube_vert,
                    fragmentShader: An.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: An.equirect_vert,
                    fragmentShader: An.equirect_frag
                },
                distanceRGBA: {
                    uniforms: un([Oi.common, Oi.displacementmap, {
                        referencePosition: {
                            value: new ge
                        },
                        nearDistance: {
                            value: 1
                        },
                        farDistance: {
                            value: 1e3
                        }
                    }]),
                    vertexShader: An.distanceRGBA_vert,
                    fragmentShader: An.distanceRGBA_frag
                },
                shadow: {
                    uniforms: un([Oi.lights, Oi.fog, {
                        color: {
                            value: new Rt(0)
                        },
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: An.shadow_vert,
                    fragmentShader: An.shadow_frag
                }
            };

        function Wl(s, e, r, h, c) {
            const v = new Rt(0);
            let w, E, T = 0,
                B = null,
                Q = 0,
                k = null;

            function i(t, a) {
                r.buffers.color.setClear(t.r, t.g, t.b, a, c)
            }
            return {
                getClearColor: function() {
                    return v
                },
                setClearColor: function(t, a = 1) {
                    v.set(t), T = a, i(v, T)
                },
                getClearAlpha: function() {
                    return T
                },
                setClearAlpha: function(t) {
                    T = t, i(v, T)
                },
                render: function(t, a, l, d) {
                    let g = a.isScene === !0 ? a.background : null;
                    g && g.isTexture && (g = e.get(g));
                    const x = s.xr,
                        A = x.getSession && x.getSession();
                    A && A.environmentBlendMode === "additive" && (g = null), g === null ? i(v, T) : g && g.isColor && (i(g, 1), d = !0), (s.autoClear || d) && s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil), g && (g.isCubeTexture || g.mapping === 306) ? (E === void 0 && (E = new ar(new sr(1, 1, 1), new Cn({
                        name: "BackgroundCubeMaterial",
                        uniforms: Fo(Ga.cube.uniforms),
                        vertexShader: Ga.cube.vertexShader,
                        fragmentShader: Ga.cube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), E.geometry.deleteAttribute("normal"), E.geometry.deleteAttribute("uv"), E.onBeforeRender = function(M, F, D) {
                        this.matrixWorld.copyPosition(D.matrixWorld)
                    }, Object.defineProperty(E.material, "envMap", {
                        get: function() {
                            return this.uniforms.envMap.value
                        }
                    }), h.update(E)), E.material.uniforms.envMap.value = g, E.material.uniforms.flipEnvMap.value = g.isCubeTexture && g._needsFlipEnvMap ? -1 : 1, B === g && Q === g.version && k === s.toneMapping || (E.material.needsUpdate = !0, B = g, Q = g.version, k = s.toneMapping), t.unshift(E, E.geometry, E.material, 0, 0, null)) : g && g.isTexture && (w === void 0 && (w = new ar(new Is(2, 2), new Cn({
                        name: "BackgroundMaterial",
                        uniforms: Fo(Ga.background.uniforms),
                        vertexShader: Ga.background.vertexShader,
                        fragmentShader: Ga.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), w.geometry.deleteAttribute("normal"), Object.defineProperty(w.material, "map", {
                        get: function() {
                            return this.uniforms.t2D.value
                        }
                    }), h.update(w)), w.material.uniforms.t2D.value = g, g.matrixAutoUpdate === !0 && g.updateMatrix(), w.material.uniforms.uvTransform.value.copy(g.matrix), B === g && Q === g.version && k === s.toneMapping || (w.material.needsUpdate = !0, B = g, Q = g.version, k = s.toneMapping), t.unshift(w, w.geometry, w.material, 0, 0, null))
                }
            }
        }

        function kc(s, e, r, h) {
            const c = s.getParameter(34921),
                v = h.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                w = h.isWebGL2 || v !== null,
                E = {},
                T = i(null);
            let B = T;

            function Q(M) {
                return h.isWebGL2 ? s.bindVertexArray(M) : v.bindVertexArrayOES(M)
            }

            function k(M) {
                return h.isWebGL2 ? s.deleteVertexArray(M) : v.deleteVertexArrayOES(M)
            }

            function i(M) {
                const F = [],
                    D = [],
                    U = [];
                for (let N = 0; N < c; N++) F[N] = 0, D[N] = 0, U[N] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: F,
                    enabledAttributes: D,
                    attributeDivisors: U,
                    object: M,
                    attributes: {},
                    index: null
                }
            }

            function t() {
                const M = B.newAttributes;
                for (let F = 0, D = M.length; F < D; F++) M[F] = 0
            }

            function a(M) {
                l(M, 0)
            }

            function l(M, F) {
                const D = B.newAttributes,
                    U = B.enabledAttributes,
                    N = B.attributeDivisors;
                D[M] = 1, U[M] === 0 && (s.enableVertexAttribArray(M), U[M] = 1), N[M] !== F && ((h.isWebGL2 ? s : e.get("ANGLE_instanced_arrays"))[h.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](M, F), N[M] = F)
            }

            function d() {
                const M = B.newAttributes,
                    F = B.enabledAttributes;
                for (let D = 0, U = F.length; D < U; D++) F[D] !== M[D] && (s.disableVertexAttribArray(D), F[D] = 0)
            }

            function g(M, F, D, U, N, H) {
                h.isWebGL2 !== !0 || D !== 5124 && D !== 5125 ? s.vertexAttribPointer(M, F, D, U, N, H) : s.vertexAttribIPointer(M, F, D, N, H)
            }

            function x() {
                A(), B !== T && (B = T, Q(B.object))
            }

            function A() {
                T.geometry = null, T.program = null, T.wireframe = !1
            }
            return {
                setup: function(M, F, D, U, N) {
                    let H = !1;
                    if (w) {
                        const X = function(ne, le, ce) {
                            const Qe = ce.wireframe === !0;
                            let Se = E[ne.id];
                            Se === void 0 && (Se = {}, E[ne.id] = Se);
                            let Re = Se[le.id];
                            Re === void 0 && (Re = {}, Se[le.id] = Re);
                            let ot = Re[Qe];
                            return ot === void 0 && (ot = i(h.isWebGL2 ? s.createVertexArray() : v.createVertexArrayOES()), Re[Qe] = ot), ot
                        }(U, D, F);
                        B !== X && (B = X, Q(B.object)), H = function(ne, le) {
                            const ce = B.attributes,
                                Qe = ne.attributes;
                            let Se = 0;
                            for (const Re in Qe) {
                                const ot = ce[Re],
                                    dt = Qe[Re];
                                if (ot === void 0 || ot.attribute !== dt || ot.data !== dt.data) return !0;
                                Se++
                            }
                            return B.attributesNum !== Se || B.index !== le
                        }(U, N), H && function(ne, le) {
                            const ce = {},
                                Qe = ne.attributes;
                            let Se = 0;
                            for (const Re in Qe) {
                                const ot = Qe[Re],
                                    dt = {};
                                dt.attribute = ot, ot.data && (dt.data = ot.data), ce[Re] = dt, Se++
                            }
                            B.attributes = ce, B.attributesNum = Se, B.index = le
                        }(U, N)
                    } else {
                        const X = F.wireframe === !0;
                        B.geometry === U.id && B.program === D.id && B.wireframe === X || (B.geometry = U.id, B.program = D.id, B.wireframe = X, H = !0)
                    }
                    M.isInstancedMesh === !0 && (H = !0), N !== null && r.update(N, 34963), H && (function(X, ne, le, ce) {
                        if (h.isWebGL2 === !1 && (X.isInstancedMesh || ce.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null) return;
                        t();
                        const Qe = ce.attributes,
                            Se = le.getAttributes(),
                            Re = ne.defaultAttributeValues;
                        for (const ot in Se) {
                            const dt = Se[ot];
                            if (dt >= 0) {
                                const Ct = Qe[ot];
                                if (Ct !== void 0) {
                                    const Nt = Ct.normalized,
                                        qt = Ct.itemSize,
                                        Fe = r.get(Ct);
                                    if (Fe === void 0) continue;
                                    const Be = Fe.buffer,
                                        mt = Fe.type,
                                        lt = Fe.bytesPerElement;
                                    if (Ct.isInterleavedBufferAttribute) {
                                        const Xe = Ct.data,
                                            Zt = Xe.stride,
                                            Ie = Ct.offset;
                                        Xe && Xe.isInstancedInterleavedBuffer ? (l(dt, Xe.meshPerAttribute), ce._maxInstanceCount === void 0 && (ce._maxInstanceCount = Xe.meshPerAttribute * Xe.count)) : a(dt), s.bindBuffer(34962, Be), g(dt, qt, mt, Nt, Zt * lt, Ie * lt)
                                    } else Ct.isInstancedBufferAttribute ? (l(dt, Ct.meshPerAttribute), ce._maxInstanceCount === void 0 && (ce._maxInstanceCount = Ct.meshPerAttribute * Ct.count)) : a(dt), s.bindBuffer(34962, Be), g(dt, qt, mt, Nt, 0, 0)
                                } else if (ot === "instanceMatrix") {
                                    const Nt = r.get(X.instanceMatrix);
                                    if (Nt === void 0) continue;
                                    const qt = Nt.buffer,
                                        Fe = Nt.type;
                                    l(dt + 0, 1), l(dt + 1, 1), l(dt + 2, 1), l(dt + 3, 1), s.bindBuffer(34962, qt), s.vertexAttribPointer(dt + 0, 4, Fe, !1, 64, 0), s.vertexAttribPointer(dt + 1, 4, Fe, !1, 64, 16), s.vertexAttribPointer(dt + 2, 4, Fe, !1, 64, 32), s.vertexAttribPointer(dt + 3, 4, Fe, !1, 64, 48)
                                } else if (ot === "instanceColor") {
                                    const Nt = r.get(X.instanceColor);
                                    if (Nt === void 0) continue;
                                    const qt = Nt.buffer,
                                        Fe = Nt.type;
                                    l(dt, 1), s.bindBuffer(34962, qt), s.vertexAttribPointer(dt, 3, Fe, !1, 12, 0)
                                } else if (Re !== void 0) {
                                    const Nt = Re[ot];
                                    if (Nt !== void 0) switch (Nt.length) {
                                        case 2:
                                            s.vertexAttrib2fv(dt, Nt);
                                            break;
                                        case 3:
                                            s.vertexAttrib3fv(dt, Nt);
                                            break;
                                        case 4:
                                            s.vertexAttrib4fv(dt, Nt);
                                            break;
                                        default:
                                            s.vertexAttrib1fv(dt, Nt)
                                    }
                                }
                            }
                        }
                        d()
                    }(M, F, D, U), N !== null && s.bindBuffer(34963, r.get(N).buffer))
                },
                reset: x,
                resetDefaultState: A,
                dispose: function() {
                    x();
                    for (const M in E) {
                        const F = E[M];
                        for (const D in F) {
                            const U = F[D];
                            for (const N in U) k(U[N].object), delete U[N];
                            delete F[D]
                        }
                        delete E[M]
                    }
                },
                releaseStatesOfGeometry: function(M) {
                    if (E[M.id] === void 0) return;
                    const F = E[M.id];
                    for (const D in F) {
                        const U = F[D];
                        for (const N in U) k(U[N].object), delete U[N];
                        delete F[D]
                    }
                    delete E[M.id]
                },
                releaseStatesOfProgram: function(M) {
                    for (const F in E) {
                        const D = E[F];
                        if (D[M.id] === void 0) continue;
                        const U = D[M.id];
                        for (const N in U) k(U[N].object), delete U[N];
                        delete D[M.id]
                    }
                },
                initAttributes: t,
                enableAttribute: a,
                disableUnusedAttributes: d
            }
        }

        function Qu(s, e, r, h) {
            const c = h.isWebGL2;
            let v;
            this.setMode = function(w) {
                v = w
            }, this.render = function(w, E) {
                s.drawArrays(v, w, E), r.update(E, v, 1)
            }, this.renderInstances = function(w, E, T) {
                if (T === 0) return;
                let B, Q;
                if (c) B = s, Q = "drawArraysInstanced";
                else if (B = e.get("ANGLE_instanced_arrays"), Q = "drawArraysInstancedANGLE", B === null) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                B[Q](v, w, E, T), r.update(E, v, T)
            }
        }

        function Ph(s, e, r) {
            let h;

            function c(A) {
                if (A === "highp") {
                    if (s.getShaderPrecisionFormat(35633, 36338).precision > 0 && s.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                    A = "mediump"
                }
                return A === "mediump" && s.getShaderPrecisionFormat(35633, 36337).precision > 0 && s.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
            }
            const v = typeof WebGL2RenderingContext != "undefined" && s instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext != "undefined" && s instanceof WebGL2ComputeRenderingContext;
            let w = r.precision !== void 0 ? r.precision : "highp";
            const E = c(w);
            E !== w && (console.warn("THREE.WebGLRenderer:", w, "not supported, using", E, "instead."), w = E);
            const T = r.logarithmicDepthBuffer === !0,
                B = s.getParameter(34930),
                Q = s.getParameter(35660),
                k = s.getParameter(3379),
                i = s.getParameter(34076),
                t = s.getParameter(34921),
                a = s.getParameter(36347),
                l = s.getParameter(36348),
                d = s.getParameter(36349),
                g = Q > 0,
                x = v || e.has("OES_texture_float");
            return {
                isWebGL2: v,
                getMaxAnisotropy: function() {
                    if (h !== void 0) return h;
                    if (e.has("EXT_texture_filter_anisotropic") === !0) {
                        const A = e.get("EXT_texture_filter_anisotropic");
                        h = s.getParameter(A.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    } else h = 0;
                    return h
                },
                getMaxPrecision: c,
                precision: w,
                logarithmicDepthBuffer: T,
                maxTextures: B,
                maxVertexTextures: Q,
                maxTextureSize: k,
                maxCubemapSize: i,
                maxAttributes: t,
                maxVertexUniforms: a,
                maxVaryings: l,
                maxFragmentUniforms: d,
                vertexTextures: g,
                floatFragmentTextures: x,
                floatVertexTextures: g && x,
                maxSamples: v ? s.getParameter(36183) : 0
            }
        }

        function Sr(s) {
            const e = this;
            let r = null,
                h = 0,
                c = !1,
                v = !1;
            const w = new Et,
                E = new Pt,
                T = {
                    value: null,
                    needsUpdate: !1
                };

            function B() {
                T.value !== r && (T.value = r, T.needsUpdate = h > 0), e.numPlanes = h, e.numIntersection = 0
            }

            function Q(k, i, t, a) {
                const l = k !== null ? k.length : 0;
                let d = null;
                if (l !== 0) {
                    if (d = T.value, a !== !0 || d === null) {
                        const g = t + 4 * l,
                            x = i.matrixWorldInverse;
                        E.getNormalMatrix(x), (d === null || d.length < g) && (d = new Float32Array(g));
                        for (let A = 0, M = t; A !== l; ++A, M += 4) w.copy(k[A]).applyMatrix4(x, E), w.normal.toArray(d, M), d[M + 3] = w.constant
                    }
                    T.value = d, T.needsUpdate = !0
                }
                return e.numPlanes = l, e.numIntersection = 0, d
            }
            this.uniform = T, this.numPlanes = 0, this.numIntersection = 0, this.init = function(k, i, t) {
                const a = k.length !== 0 || i || h !== 0 || c;
                return c = i, r = Q(k, t, 0), h = k.length, a
            }, this.beginShadows = function() {
                v = !0, Q(null)
            }, this.endShadows = function() {
                v = !1, B()
            }, this.setState = function(k, i, t) {
                const a = k.clippingPlanes,
                    l = k.clipIntersection,
                    d = k.clipShadows,
                    g = s.get(k);
                if (!c || a === null || a.length === 0 || v && !d) v ? Q(null) : B();
                else {
                    const x = v ? 0 : h,
                        A = 4 * x;
                    let M = g.clippingState || null;
                    T.value = M, M = Q(a, i, A, t);
                    for (let F = 0; F !== A; ++F) M[F] = r[F];
                    g.clippingState = M, this.numIntersection = l ? this.numPlanes : 0, this.numPlanes += x
                }
            }
        }

        function zs(s) {
            let e = new WeakMap;

            function r(c, v) {
                return v === 303 ? c.mapping = 301 : v === 304 && (c.mapping = 302), c
            }

            function h(c) {
                const v = c.target;
                v.removeEventListener("dispose", h);
                const w = e.get(v);
                w !== void 0 && (e.delete(v), w.dispose())
            }
            return {
                get: function(c) {
                    if (c && c.isTexture) {
                        const v = c.mapping;
                        if (v === 303 || v === 304) {
                            if (e.has(c)) return r(e.get(c).texture, c.mapping);
                            {
                                const w = c.image;
                                if (w && w.height > 0) {
                                    const E = s.getRenderTarget(),
                                        T = new so(w.height / 2);
                                    return T.fromEquirectangularTexture(s, c), e.set(c, T), s.setRenderTarget(E), c.addEventListener("dispose", h), r(T.texture, c.mapping)
                                }
                                return null
                            }
                        }
                    }
                    return c
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }

        function Sa(s) {
            const e = {};

            function r(h) {
                if (e[h] !== void 0) return e[h];
                let c;
                switch (h) {
                    case "WEBGL_depth_texture":
                        c = s.getExtension("WEBGL_depth_texture") || s.getExtension("MOZ_WEBGL_depth_texture") || s.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        c = s.getExtension("EXT_texture_filter_anisotropic") || s.getExtension("MOZ_EXT_texture_filter_anisotropic") || s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        c = s.getExtension("WEBGL_compressed_texture_s3tc") || s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        c = s.getExtension("WEBGL_compressed_texture_pvrtc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        c = s.getExtension(h)
                }
                return e[h] = c, c
            }
            return {
                has: function(h) {
                    return r(h) !== null
                },
                init: function(h) {
                    h.isWebGL2 ? r("EXT_color_buffer_float") : (r("WEBGL_depth_texture"), r("OES_texture_float"), r("OES_texture_half_float"), r("OES_texture_half_float_linear"), r("OES_standard_derivatives"), r("OES_element_index_uint"), r("OES_vertex_array_object"), r("ANGLE_instanced_arrays")), r("OES_texture_float_linear"), r("EXT_color_buffer_half_float")
                },
                get: function(h) {
                    const c = r(h);
                    return c === null && console.warn("THREE.WebGLRenderer: " + h + " extension not supported."), c
                }
            }
        }

        function Dc(s, e, r, h) {
            const c = {},
                v = new WeakMap;

            function w(T) {
                const B = T.target;
                B.index !== null && e.remove(B.index);
                for (const k in B.attributes) e.remove(B.attributes[k]);
                B.removeEventListener("dispose", w), delete c[B.id];
                const Q = v.get(B);
                Q && (e.remove(Q), v.delete(B)), h.releaseStatesOfGeometry(B), B.isInstancedBufferGeometry === !0 && delete B._maxInstanceCount, r.memory.geometries--
            }

            function E(T) {
                const B = [],
                    Q = T.index,
                    k = T.attributes.position;
                let i = 0;
                if (Q !== null) {
                    const l = Q.array;
                    i = Q.version;
                    for (let d = 0, g = l.length; d < g; d += 3) {
                        const x = l[d + 0],
                            A = l[d + 1],
                            M = l[d + 2];
                        B.push(x, A, A, M, M, x)
                    }
                } else {
                    const l = k.array;
                    i = k.version;
                    for (let d = 0, g = l.length / 3 - 1; d < g; d += 3) {
                        const x = d + 0,
                            A = d + 1,
                            M = d + 2;
                        B.push(x, A, A, M, M, x)
                    }
                }
                const t = new(Ea(B) > 65535 ? Qr : Un)(B, 1);
                t.version = i;
                const a = v.get(T);
                a && e.remove(a), v.set(T, t)
            }
            return {
                get: function(T, B) {
                    return c[B.id] === !0 || (B.addEventListener("dispose", w), c[B.id] = !0, r.memory.geometries++), B
                },
                update: function(T) {
                    const B = T.attributes;
                    for (const k in B) e.update(B[k], 34962);
                    const Q = T.morphAttributes;
                    for (const k in Q) {
                        const i = Q[k];
                        for (let t = 0, a = i.length; t < a; t++) e.update(i[t], 34962)
                    }
                },
                getWireframeAttribute: function(T) {
                    const B = v.get(T);
                    if (B) {
                        const Q = T.index;
                        Q !== null && B.version < Q.version && E(T)
                    } else E(T);
                    return v.get(T)
                }
            }
        }

        function Jl(s, e, r, h) {
            const c = h.isWebGL2;
            let v, w, E;
            this.setMode = function(T) {
                v = T
            }, this.setIndex = function(T) {
                w = T.type, E = T.bytesPerElement
            }, this.render = function(T, B) {
                s.drawElements(v, B, w, T * E), r.update(B, v, 1)
            }, this.renderInstances = function(T, B, Q) {
                if (Q === 0) return;
                let k, i;
                if (c) k = s, i = "drawElementsInstanced";
                else if (k = e.get("ANGLE_instanced_arrays"), i = "drawElementsInstancedANGLE", k === null) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                k[i](v, B, w, T * E, Q), r.update(B, v, Q)
            }
        }

        function kh(s) {
            const e = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: e,
                programs: null,
                autoReset: !0,
                reset: function() {
                    e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                },
                update: function(r, h, c) {
                    switch (e.calls++, h) {
                        case 4:
                            e.triangles += c * (r / 3);
                            break;
                        case 1:
                            e.lines += c * (r / 2);
                            break;
                        case 3:
                            e.lines += c * (r - 1);
                            break;
                        case 2:
                            e.lines += c * r;
                            break;
                        case 0:
                            e.points += c * r;
                            break;
                        default:
                            console.error("THREE.WebGLInfo: Unknown draw mode:", h)
                    }
                }
            }
        }

        function Ns(s, e) {
            return s[0] - e[0]
        }

        function Os(s, e) {
            return Math.abs(e[1]) - Math.abs(s[1])
        }

        function Qo(s) {
            const e = {},
                r = new Float32Array(8),
                h = [];
            for (let c = 0; c < 8; c++) h[c] = [c, 0];
            return {
                update: function(c, v, w, E) {
                    const T = c.morphTargetInfluences,
                        B = T === void 0 ? 0 : T.length;
                    let Q = e[v.id];
                    if (Q === void 0) {
                        Q = [];
                        for (let l = 0; l < B; l++) Q[l] = [l, 0];
                        e[v.id] = Q
                    }
                    for (let l = 0; l < B; l++) {
                        const d = Q[l];
                        d[0] = l, d[1] = T[l]
                    }
                    Q.sort(Os);
                    for (let l = 0; l < 8; l++) l < B && Q[l][1] ? (h[l][0] = Q[l][0], h[l][1] = Q[l][1]) : (h[l][0] = Number.MAX_SAFE_INTEGER, h[l][1] = 0);
                    h.sort(Ns);
                    const k = w.morphTargets && v.morphAttributes.position,
                        i = w.morphNormals && v.morphAttributes.normal;
                    let t = 0;
                    for (let l = 0; l < 8; l++) {
                        const d = h[l],
                            g = d[0],
                            x = d[1];
                        g !== Number.MAX_SAFE_INTEGER && x ? (k && v.getAttribute("morphTarget" + l) !== k[g] && v.setAttribute("morphTarget" + l, k[g]), i && v.getAttribute("morphNormal" + l) !== i[g] && v.setAttribute("morphNormal" + l, i[g]), r[l] = x, t += x) : (k && v.hasAttribute("morphTarget" + l) === !0 && v.deleteAttribute("morphTarget" + l), i && v.hasAttribute("morphNormal" + l) === !0 && v.deleteAttribute("morphNormal" + l), r[l] = 0)
                    }
                    const a = v.morphTargetsRelative ? 1 : 1 - t;
                    E.getUniforms().setValue(s, "morphTargetBaseInfluence", a), E.getUniforms().setValue(s, "morphTargetInfluences", r)
                }
            }
        }

        function Zl(s, e, r, h) {
            let c = new WeakMap;

            function v(w) {
                const E = w.target;
                E.removeEventListener("dispose", v), r.remove(E.instanceMatrix), E.instanceColor !== null && r.remove(E.instanceColor)
            }
            return {
                update: function(w) {
                    const E = h.render.frame,
                        T = w.geometry,
                        B = e.get(w, T);
                    return c.get(B) !== E && (e.update(B), c.set(B, E)), w.isInstancedMesh && (w.hasEventListener("dispose", v) === !1 && w.addEventListener("dispose", v), r.update(w.instanceMatrix, 34962), w.instanceColor !== null && r.update(w.instanceColor, 34962)), B
                },
                dispose: function() {
                    c = new WeakMap
                }
            }
        }
        Ga.physical = {
            uniforms: un([Ga.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatNormalScale: {
                    value: new Ht(1, 1)
                },
                clearcoatNormalMap: {
                    value: null
                },
                sheen: {
                    value: new Rt(0)
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                }
            }]),
            vertexShader: An.meshphysical_vert,
            fragmentShader: An.meshphysical_frag
        };
        class fl extends cn {
            constructor(e = null, r = 1, h = 1, c = 1) {
                super(null), this.image = {
                    data: e,
                    width: r,
                    height: h,
                    depth: c
                }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
            }
        }
        fl.prototype.isDataTexture2DArray = !0;
        class ml extends cn {
            constructor(e = null, r = 1, h = 1, c = 1) {
                super(null), this.image = {
                    data: e,
                    width: r,
                    height: h,
                    depth: c
                }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
            }
        }
        ml.prototype.isDataTexture3D = !0;
        const Po = new cn,
            Dh = new fl,
            oo = new ml,
            Uc = new ao,
            Ic = [],
            zc = [],
            ko = new Float32Array(16),
            Do = new Float32Array(9),
            Aa = new Float32Array(4);

        function Ya(s, e, r) {
            const h = s[0];
            if (h <= 0 || h > 0) return s;
            const c = e * r;
            let v = Ic[c];
            if (v === void 0 && (v = new Float32Array(c), Ic[c] = v), e !== 0) {
                h.toArray(v, 0);
                for (let w = 1, E = 0; w !== e; ++w) E += r, s[w].toArray(v, E)
            }
            return v
        }

        function Vr(s, e) {
            if (s.length !== e.length) return !1;
            for (let r = 0, h = s.length; r < h; r++)
                if (s[r] !== e[r]) return !1;
            return !0
        }

        function ha(s, e) {
            for (let r = 0, h = e.length; r < h; r++) s[r] = e[r]
        }

        function Ha(s, e) {
            let r = zc[e];
            r === void 0 && (r = new Int32Array(e), zc[e] = r);
            for (let h = 0; h !== e; ++h) r[h] = s.allocateTextureUnit();
            return r
        }

        function Fa(s, e) {
            const r = this.cache;
            r[0] !== e && (s.uniform1f(this.addr, e), r[0] = e)
        }

        function Nc(s, e) {
            const r = this.cache;
            if (e.x !== void 0) r[0] === e.x && r[1] === e.y || (s.uniform2f(this.addr, e.x, e.y), r[0] = e.x, r[1] = e.y);
            else {
                if (Vr(r, e)) return;
                s.uniform2fv(this.addr, e), ha(r, e)
            }
        }

        function Wa(s, e) {
            const r = this.cache;
            if (e.x !== void 0) r[0] === e.x && r[1] === e.y && r[2] === e.z || (s.uniform3f(this.addr, e.x, e.y, e.z), r[0] = e.x, r[1] = e.y, r[2] = e.z);
            else if (e.r !== void 0) r[0] === e.r && r[1] === e.g && r[2] === e.b || (s.uniform3f(this.addr, e.r, e.g, e.b), r[0] = e.r, r[1] = e.g, r[2] = e.b);
            else {
                if (Vr(r, e)) return;
                s.uniform3fv(this.addr, e), ha(r, e)
            }
        }

        function gl(s, e) {
            const r = this.cache;
            if (e.x !== void 0) r[0] === e.x && r[1] === e.y && r[2] === e.z && r[3] === e.w || (s.uniform4f(this.addr, e.x, e.y, e.z, e.w), r[0] = e.x, r[1] = e.y, r[2] = e.z, r[3] = e.w);
            else {
                if (Vr(r, e)) return;
                s.uniform4fv(this.addr, e), ha(r, e)
            }
        }

        function Oc(s, e) {
            const r = this.cache,
                h = e.elements;
            if (h === void 0) {
                if (Vr(r, e)) return;
                s.uniformMatrix2fv(this.addr, !1, e), ha(r, e)
            } else {
                if (Vr(r, h)) return;
                Aa.set(h), s.uniformMatrix2fv(this.addr, !1, Aa), ha(r, h)
            }
        }

        function Pu(s, e) {
            const r = this.cache,
                h = e.elements;
            if (h === void 0) {
                if (Vr(r, e)) return;
                s.uniformMatrix3fv(this.addr, !1, e), ha(r, e)
            } else {
                if (Vr(r, h)) return;
                Do.set(h), s.uniformMatrix3fv(this.addr, !1, Do), ha(r, h)
            }
        }

        function yl(s, e) {
            const r = this.cache,
                h = e.elements;
            if (h === void 0) {
                if (Vr(r, e)) return;
                s.uniformMatrix4fv(this.addr, !1, e), ha(r, e)
            } else {
                if (Vr(r, h)) return;
                ko.set(h), s.uniformMatrix4fv(this.addr, !1, ko), ha(r, h)
            }
        }

        function Uh(s, e) {
            const r = this.cache;
            r[0] !== e && (s.uniform1i(this.addr, e), r[0] = e)
        }

        function lo(s, e) {
            const r = this.cache;
            Vr(r, e) || (s.uniform2iv(this.addr, e), ha(r, e))
        }

        function Ss(s, e) {
            const r = this.cache;
            Vr(r, e) || (s.uniform3iv(this.addr, e), ha(r, e))
        }

        function Ii(s, e) {
            const r = this.cache;
            Vr(r, e) || (s.uniform4iv(this.addr, e), ha(r, e))
        }

        function Vc(s, e) {
            const r = this.cache;
            r[0] !== e && (s.uniform1ui(this.addr, e), r[0] = e)
        }

        function Uo(s, e) {
            const r = this.cache;
            Vr(r, e) || (s.uniform2uiv(this.addr, e), ha(r, e))
        }

        function vl(s, e) {
            const r = this.cache;
            Vr(r, e) || (s.uniform3uiv(this.addr, e), ha(r, e))
        }

        function Xl(s, e) {
            const r = this.cache;
            Vr(r, e) || (s.uniform4uiv(this.addr, e), ha(r, e))
        }

        function Ti(s, e, r) {
            const h = this.cache,
                c = r.allocateTextureUnit();
            h[0] !== c && (s.uniform1i(this.addr, c), h[0] = c), r.safeSetTexture2D(e || Po, c)
        }

        function jl(s, e, r) {
            const h = this.cache,
                c = r.allocateTextureUnit();
            h[0] !== c && (s.uniform1i(this.addr, c), h[0] = c), r.setTexture3D(e || oo, c)
        }

        function Ih(s, e, r) {
            const h = this.cache,
                c = r.allocateTextureUnit();
            h[0] !== c && (s.uniform1i(this.addr, c), h[0] = c), r.safeSetTextureCube(e || Uc, c)
        }

        function zh(s, e, r) {
            const h = this.cache,
                c = r.allocateTextureUnit();
            h[0] !== c && (s.uniform1i(this.addr, c), h[0] = c), r.setTexture2DArray(e || Dh, c)
        }

        function Yl(s, e) {
            s.uniform1fv(this.addr, e)
        }

        function ql(s, e) {
            const r = Ya(e, this.size, 2);
            s.uniform2fv(this.addr, r)
        }

        function Gc(s, e) {
            const r = Ya(e, this.size, 3);
            s.uniform3fv(this.addr, r)
        }

        function ku(s, e) {
            const r = Ya(e, this.size, 4);
            s.uniform4fv(this.addr, r)
        }

        function Nh(s, e) {
            const r = Ya(e, this.size, 4);
            s.uniformMatrix2fv(this.addr, !1, r)
        }

        function co(s, e) {
            const r = Ya(e, this.size, 9);
            s.uniformMatrix3fv(this.addr, !1, r)
        }

        function cr(s, e) {
            const r = Ya(e, this.size, 16);
            s.uniformMatrix4fv(this.addr, !1, r)
        }

        function _l(s, e) {
            s.uniform1iv(this.addr, e)
        }

        function $l(s, e) {
            s.uniform2iv(this.addr, e)
        }

        function Oh(s, e) {
            s.uniform3iv(this.addr, e)
        }

        function Vh(s, e) {
            s.uniform4iv(this.addr, e)
        }

        function Hc(s, e) {
            s.uniform1uiv(this.addr, e)
        }

        function Gh(s, e) {
            s.uniform2uiv(this.addr, e)
        }

        function qa(s, e) {
            s.uniform3uiv(this.addr, e)
        }

        function xl(s, e) {
            s.uniform4uiv(this.addr, e)
        }

        function Ji(s, e, r) {
            const h = e.length,
                c = Ha(r, h);
            s.uniform1iv(this.addr, c);
            for (let v = 0; v !== h; ++v) r.safeSetTexture2D(e[v] || Po, c[v])
        }

        function ln(s, e, r) {
            const h = e.length,
                c = Ha(r, h);
            s.uniform1iv(this.addr, c);
            for (let v = 0; v !== h; ++v) r.safeSetTextureCube(e[v] || Uc, c[v])
        }

        function Io(s, e, r) {
            this.id = s, this.addr = r, this.cache = [], this.setValue = function(h) {
                switch (h) {
                    case 5126:
                        return Fa;
                    case 35664:
                        return Nc;
                    case 35665:
                        return Wa;
                    case 35666:
                        return gl;
                    case 35674:
                        return Oc;
                    case 35675:
                        return Pu;
                    case 35676:
                        return yl;
                    case 5124:
                    case 35670:
                        return Uh;
                    case 35667:
                    case 35671:
                        return lo;
                    case 35668:
                    case 35672:
                        return Ss;
                    case 35669:
                    case 35673:
                        return Ii;
                    case 5125:
                        return Vc;
                    case 36294:
                        return Uo;
                    case 36295:
                        return vl;
                    case 36296:
                        return Xl;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return Ti;
                    case 35679:
                    case 36299:
                    case 36307:
                        return jl;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return Ih;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return zh
                }
            }(e.type)
        }

        function Kl(s, e, r) {
            this.id = s, this.addr = r, this.cache = [], this.size = e.size, this.setValue = function(h) {
                switch (h) {
                    case 5126:
                        return Yl;
                    case 35664:
                        return ql;
                    case 35665:
                        return Gc;
                    case 35666:
                        return ku;
                    case 35674:
                        return Nh;
                    case 35675:
                        return co;
                    case 35676:
                        return cr;
                    case 5124:
                    case 35670:
                        return _l;
                    case 35667:
                    case 35671:
                        return $l;
                    case 35668:
                    case 35672:
                        return Oh;
                    case 35669:
                    case 35673:
                        return Vh;
                    case 5125:
                        return Hc;
                    case 36294:
                        return Gh;
                    case 36295:
                        return qa;
                    case 36296:
                        return xl;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return Ji;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return ln
                }
            }(e.type)
        }

        function ec(s) {
            this.id = s, this.seq = [], this.map = {}
        }
        Kl.prototype.updateCache = function(s) {
            const e = this.cache;
            s instanceof Float32Array && e.length !== s.length && (this.cache = new Float32Array(s.length)), ha(e, s)
        }, ec.prototype.setValue = function(s, e, r) {
            const h = this.seq;
            for (let c = 0, v = h.length; c !== v; ++c) {
                const w = h[c];
                w.setValue(s, e[w.id], r)
            }
        };
        const ua = /(\w+)(\])?(\[|\.)?/g;

        function tc(s, e) {
            s.seq.push(e), s.map[e.id] = e
        }

        function $a(s, e, r) {
            const h = s.name,
                c = h.length;
            for (ua.lastIndex = 0;;) {
                const v = ua.exec(h),
                    w = ua.lastIndex;
                let E = v[1];
                const T = v[2] === "]",
                    B = v[3];
                if (T && (E |= 0), B === void 0 || B === "[" && w + 2 === c) {
                    tc(r, B === void 0 ? new Io(E, s, e) : new Kl(E, s, e));
                    break
                } {
                    let Q = r.map[E];
                    Q === void 0 && (Q = new ec(E), tc(r, Q)), r = Q
                }
            }
        }

        function Vs(s, e) {
            this.seq = [], this.map = {};
            const r = s.getProgramParameter(e, 35718);
            for (let h = 0; h < r; ++h) {
                const c = s.getActiveUniform(e, h);
                $a(c, s.getUniformLocation(e, c.name), this)
            }
        }

        function zo(s, e, r) {
            const h = s.createShader(e);
            return s.shaderSource(h, r), s.compileShader(h), h
        }
        Vs.prototype.setValue = function(s, e, r, h) {
            const c = this.map[e];
            c !== void 0 && c.setValue(s, r, h)
        }, Vs.prototype.setOptional = function(s, e, r) {
            const h = e[r];
            h !== void 0 && this.setValue(s, r, h)
        }, Vs.upload = function(s, e, r, h) {
            for (let c = 0, v = e.length; c !== v; ++c) {
                const w = e[c],
                    E = r[w.id];
                E.needsUpdate !== !1 && w.setValue(s, E.value, h)
            }
        }, Vs.seqWithValue = function(s, e) {
            const r = [];
            for (let h = 0, c = s.length; h !== c; ++h) {
                const v = s[h];
                v.id in e && r.push(v)
            }
            return r
        };
        let Ar = 0;

        function kr(s) {
            switch (s) {
                case 3e3:
                    return ["Linear", "( value )"];
                case 3001:
                    return ["sRGB", "( value )"];
                case 3002:
                    return ["RGBE", "( value )"];
                case 3004:
                    return ["RGBM", "( value, 7.0 )"];
                case 3005:
                    return ["RGBM", "( value, 16.0 )"];
                case 3006:
                    return ["RGBD", "( value, 256.0 )"];
                case 3007:
                    return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                case 3003:
                    return ["LogLuv", "( value )"];
                default:
                    return console.warn("THREE.WebGLProgram: Unsupported encoding:", s), ["Linear", "( value )"]
            }
        }

        function Wc(s, e, r) {
            const h = s.getShaderParameter(e, 35713),
                c = s.getShaderInfoLog(e).trim();
            return h && c === "" ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + r + `
` + c + function(v) {
                const w = v.split(`
`);
                for (let E = 0; E < w.length; E++) w[E] = E + 1 + ": " + w[E];
                return w.join(`
`)
            }(s.getShaderSource(e))
        }

        function La(s, e) {
            const r = kr(e);
            return "vec4 " + s + "( vec4 value ) { return " + r[0] + "ToLinear" + r[1] + "; }"
        }

        function ic(s, e) {
            const r = kr(e);
            return "vec4 " + s + "( vec4 value ) { return LinearTo" + r[0] + r[1] + "; }"
        }

        function Jc(s, e) {
            let r;
            switch (e) {
                case 1:
                    r = "Linear";
                    break;
                case 2:
                    r = "Reinhard";
                    break;
                case 3:
                    r = "OptimizedCineon";
                    break;
                case 4:
                    r = "ACESFilmic";
                    break;
                case 5:
                    r = "Custom";
                    break;
                default:
                    console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), r = "Linear"
            }
            return "vec3 " + s + "( vec3 color ) { return " + r + "ToneMapping( color ); }"
        }

        function ho(s) {
            return s !== ""
        }

        function nc(s, e) {
            return s.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
        }

        function uo(s, e) {
            return s.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
        }
        const Zc = /^[ \t]*#include +<([\w\d./]+)>/gm;

        function bl(s) {
            return s.replace(Zc, As)
        }

        function As(s, e) {
            const r = An[e];
            if (r === void 0) throw new Error("Can not resolve #include <" + e + ">");
            return bl(r)
        }
        const rc = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
            wl = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

        function El(s) {
            return s.replace(wl, ac).replace(rc, Sl)
        }

        function Sl(s, e, r, h) {
            return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), ac(s, e, r, h)
        }

        function ac(s, e, r, h) {
            let c = "";
            for (let v = parseInt(e); v < parseInt(r); v++) c += h.replace(/\[\s*i\s*\]/g, "[ " + v + " ]").replace(/UNROLLED_LOOP_INDEX/g, v);
            return c
        }

        function Gs(s) {
            let e = "precision " + s.precision + ` float;
precision ` + s.precision + " int;";
            return s.precision === "highp" ? e += `
#define HIGH_PRECISION` : s.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : s.precision === "lowp" && (e += `
#define LOW_PRECISION`), e
        }

        function po(s, e, r, h) {
            const c = s.getContext(),
                v = r.defines;
            let w = r.vertexShader,
                E = r.fragmentShader;
            const T = function(N) {
                    let H = "SHADOWMAP_TYPE_BASIC";
                    return N.shadowMapType === 1 ? H = "SHADOWMAP_TYPE_PCF" : N.shadowMapType === 2 ? H = "SHADOWMAP_TYPE_PCF_SOFT" : N.shadowMapType === 3 && (H = "SHADOWMAP_TYPE_VSM"), H
                }(r),
                B = function(N) {
                    let H = "ENVMAP_TYPE_CUBE";
                    if (N.envMap) switch (N.envMapMode) {
                        case 301:
                        case 302:
                            H = "ENVMAP_TYPE_CUBE";
                            break;
                        case 306:
                        case 307:
                            H = "ENVMAP_TYPE_CUBE_UV"
                    }
                    return H
                }(r),
                Q = function(N) {
                    let H = "ENVMAP_MODE_REFLECTION";
                    if (N.envMap) switch (N.envMapMode) {
                        case 302:
                        case 307:
                            H = "ENVMAP_MODE_REFRACTION"
                    }
                    return H
                }(r),
                k = function(N) {
                    let H = "ENVMAP_BLENDING_NONE";
                    if (N.envMap) switch (N.combine) {
                        case 0:
                            H = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case 1:
                            H = "ENVMAP_BLENDING_MIX";
                            break;
                        case 2:
                            H = "ENVMAP_BLENDING_ADD"
                    }
                    return H
                }(r),
                i = s.gammaFactor > 0 ? s.gammaFactor : 1,
                t = r.isWebGL2 ? "" : function(N) {
                    return [N.extensionDerivatives || N.envMapCubeUV || N.bumpMap || N.tangentSpaceNormalMap || N.clearcoatNormalMap || N.flatShading || N.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (N.extensionFragDepth || N.logarithmicDepthBuffer) && N.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", N.extensionDrawBuffers && N.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (N.extensionShaderTextureLOD || N.envMap) && N.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(ho).join(`
`)
                }(r),
                a = function(N) {
                    const H = [];
                    for (const X in N) {
                        const ne = N[X];
                        ne !== !1 && H.push("#define " + X + " " + ne)
                    }
                    return H.join(`
`)
                }(v),
                l = c.createProgram();
            let d, g, x = r.glslVersion ? "#version " + r.glslVersion + `
` : "";
            r.isRawShaderMaterial ? (d = [a].filter(ho).join(`
`), d.length > 0 && (d += `
`), g = [t, a].filter(ho).join(`
`), g.length > 0 && (g += `
`)) : (d = [Gs(r), "#define SHADER_NAME " + r.shaderName, a, r.instancing ? "#define USE_INSTANCING" : "", r.instancingColor ? "#define USE_INSTANCING_COLOR" : "", r.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + i, "#define MAX_BONES " + r.maxBones, r.useFog && r.fog ? "#define USE_FOG" : "", r.useFog && r.fogExp2 ? "#define FOG_EXP2" : "", r.map ? "#define USE_MAP" : "", r.envMap ? "#define USE_ENVMAP" : "", r.envMap ? "#define " + Q : "", r.lightMap ? "#define USE_LIGHTMAP" : "", r.aoMap ? "#define USE_AOMAP" : "", r.emissiveMap ? "#define USE_EMISSIVEMAP" : "", r.bumpMap ? "#define USE_BUMPMAP" : "", r.normalMap ? "#define USE_NORMALMAP" : "", r.normalMap && r.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", r.normalMap && r.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", r.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", r.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", r.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", r.displacementMap && r.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", r.specularMap ? "#define USE_SPECULARMAP" : "", r.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", r.metalnessMap ? "#define USE_METALNESSMAP" : "", r.alphaMap ? "#define USE_ALPHAMAP" : "", r.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", r.vertexTangents ? "#define USE_TANGENT" : "", r.vertexColors ? "#define USE_COLOR" : "", r.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", r.vertexUvs ? "#define USE_UV" : "", r.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", r.flatShading ? "#define FLAT_SHADED" : "", r.skinning ? "#define USE_SKINNING" : "", r.useVertexTexture ? "#define BONE_TEXTURE" : "", r.morphTargets ? "#define USE_MORPHTARGETS" : "", r.morphNormals && r.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", r.doubleSided ? "#define DOUBLE_SIDED" : "", r.flipSided ? "#define FLIP_SIDED" : "", r.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", r.shadowMapEnabled ? "#define " + T : "", r.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", r.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", r.logarithmicDepthBuffer && r.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(ho).join(`
`), g = [t, Gs(r), "#define SHADER_NAME " + r.shaderName, a, r.alphaTest ? "#define ALPHATEST " + r.alphaTest + (r.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + i, r.useFog && r.fog ? "#define USE_FOG" : "", r.useFog && r.fogExp2 ? "#define FOG_EXP2" : "", r.map ? "#define USE_MAP" : "", r.matcap ? "#define USE_MATCAP" : "", r.envMap ? "#define USE_ENVMAP" : "", r.envMap ? "#define " + B : "", r.envMap ? "#define " + Q : "", r.envMap ? "#define " + k : "", r.lightMap ? "#define USE_LIGHTMAP" : "", r.aoMap ? "#define USE_AOMAP" : "", r.emissiveMap ? "#define USE_EMISSIVEMAP" : "", r.bumpMap ? "#define USE_BUMPMAP" : "", r.normalMap ? "#define USE_NORMALMAP" : "", r.normalMap && r.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", r.normalMap && r.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", r.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", r.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", r.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", r.specularMap ? "#define USE_SPECULARMAP" : "", r.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", r.metalnessMap ? "#define USE_METALNESSMAP" : "", r.alphaMap ? "#define USE_ALPHAMAP" : "", r.sheen ? "#define USE_SHEEN" : "", r.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", r.vertexTangents ? "#define USE_TANGENT" : "", r.vertexColors || r.instancingColor ? "#define USE_COLOR" : "", r.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", r.vertexUvs ? "#define USE_UV" : "", r.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", r.gradientMap ? "#define USE_GRADIENTMAP" : "", r.flatShading ? "#define FLAT_SHADED" : "", r.doubleSided ? "#define DOUBLE_SIDED" : "", r.flipSided ? "#define FLIP_SIDED" : "", r.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", r.shadowMapEnabled ? "#define " + T : "", r.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", r.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", r.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", r.logarithmicDepthBuffer && r.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (r.extensionShaderTextureLOD || r.envMap) && r.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", r.toneMapping !== 0 ? "#define TONE_MAPPING" : "", r.toneMapping !== 0 ? An.tonemapping_pars_fragment : "", r.toneMapping !== 0 ? Jc("toneMapping", r.toneMapping) : "", r.dithering ? "#define DITHERING" : "", An.encodings_pars_fragment, r.map ? La("mapTexelToLinear", r.mapEncoding) : "", r.matcap ? La("matcapTexelToLinear", r.matcapEncoding) : "", r.envMap ? La("envMapTexelToLinear", r.envMapEncoding) : "", r.emissiveMap ? La("emissiveMapTexelToLinear", r.emissiveMapEncoding) : "", r.lightMap ? La("lightMapTexelToLinear", r.lightMapEncoding) : "", ic("linearToOutputTexel", r.outputEncoding), r.depthPacking ? "#define DEPTH_PACKING " + r.depthPacking : "", `
`].filter(ho).join(`
`)), w = bl(w), w = nc(w, r), w = uo(w, r), E = bl(E), E = nc(E, r), E = uo(E, r), w = El(w), E = El(E), r.isWebGL2 && r.isRawShaderMaterial !== !0 && (x = `#version 300 es
`, d = ["#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + d, g = ["#define varying in", r.glslVersion === sn ? "" : "out highp vec4 pc_fragColor;", r.glslVersion === sn ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + g);
            const A = x + g + E,
                M = zo(c, 35633, x + d + w),
                F = zo(c, 35632, A);
            if (c.attachShader(l, M), c.attachShader(l, F), r.index0AttributeName !== void 0 ? c.bindAttribLocation(l, 0, r.index0AttributeName) : r.morphTargets === !0 && c.bindAttribLocation(l, 0, "position"), c.linkProgram(l), s.debug.checkShaderErrors) {
                const N = c.getProgramInfoLog(l).trim(),
                    H = c.getShaderInfoLog(M).trim(),
                    X = c.getShaderInfoLog(F).trim();
                let ne = !0,
                    le = !0;
                if (c.getProgramParameter(l, 35714) === !1) {
                    ne = !1;
                    const ce = Wc(c, M, "vertex"),
                        Qe = Wc(c, F, "fragment");
                    console.error("THREE.WebGLProgram: shader error: ", c.getError(), "35715", c.getProgramParameter(l, 35715), "gl.getProgramInfoLog", N, ce, Qe)
                } else N !== "" ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", N) : H !== "" && X !== "" || (le = !1);
                le && (this.diagnostics = {
                    runnable: ne,
                    programLog: N,
                    vertexShader: {
                        log: H,
                        prefix: d
                    },
                    fragmentShader: {
                        log: X,
                        prefix: g
                    }
                })
            }
            let D, U;
            return c.deleteShader(M), c.deleteShader(F), this.getUniforms = function() {
                return D === void 0 && (D = new Vs(c, l)), D
            }, this.getAttributes = function() {
                return U === void 0 && (U = function(N, H) {
                    const X = {},
                        ne = N.getProgramParameter(H, 35721);
                    for (let le = 0; le < ne; le++) {
                        const ce = N.getActiveAttrib(H, le).name;
                        X[ce] = N.getAttribLocation(H, ce)
                    }
                    return X
                }(c, l)), U
            }, this.destroy = function() {
                h.releaseStatesOfProgram(this), c.deleteProgram(l), this.program = void 0
            }, this.name = r.shaderName, this.id = Ar++, this.cacheKey = e, this.usedTimes = 1, this.program = l, this.vertexShader = M, this.fragmentShader = F, this
        }

        function Xc(s, e, r, h, c, v) {
            const w = [],
                E = h.isWebGL2,
                T = h.logarithmicDepthBuffer,
                B = h.floatVertexTextures,
                Q = h.maxVertexUniforms,
                k = h.vertexTextures;
            let i = h.precision;
            const t = {
                    MeshDepthMaterial: "depth",
                    MeshDistanceMaterial: "distanceRGBA",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshToonMaterial: "toon",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    MeshMatcapMaterial: "matcap",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points",
                    ShadowMaterial: "shadow",
                    SpriteMaterial: "sprite"
                },
                a = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];

            function l(d) {
                let g;
                return d && d.isTexture ? g = d.encoding : d && d.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), g = d.texture.encoding) : g = 3e3, g
            }
            return {
                getParameters: function(d, g, x, A, M) {
                    const F = A.fog,
                        D = d.isMeshStandardMaterial ? A.environment : null,
                        U = e.get(d.envMap || D),
                        N = t[d.type],
                        H = M.isSkinnedMesh ? function(ce) {
                            const Qe = ce.skeleton.bones;
                            if (B) return 1024;
                            {
                                const Se = Q,
                                    Re = Math.floor((Se - 20) / 4),
                                    ot = Math.min(Re, Qe.length);
                                return ot < Qe.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + Qe.length + " bones. This GPU supports " + ot + "."), 0) : ot
                            }
                        }(M) : 0;
                    let X, ne;
                    if (d.precision !== null && (i = h.getMaxPrecision(d.precision), i !== d.precision && console.warn("THREE.WebGLProgram.getParameters:", d.precision, "not supported, using", i, "instead.")), N) {
                        const ce = Ga[N];
                        X = ce.vertexShader, ne = ce.fragmentShader
                    } else X = d.vertexShader, ne = d.fragmentShader;
                    const le = s.getRenderTarget();
                    return {
                        isWebGL2: E,
                        shaderID: N,
                        shaderName: d.type,
                        vertexShader: X,
                        fragmentShader: ne,
                        defines: d.defines,
                        isRawShaderMaterial: d.isRawShaderMaterial === !0,
                        glslVersion: d.glslVersion,
                        precision: i,
                        instancing: M.isInstancedMesh === !0,
                        instancingColor: M.isInstancedMesh === !0 && M.instanceColor !== null,
                        supportsVertexTextures: k,
                        outputEncoding: le !== null ? l(le.texture) : s.outputEncoding,
                        map: !!d.map,
                        mapEncoding: l(d.map),
                        matcap: !!d.matcap,
                        matcapEncoding: l(d.matcap),
                        envMap: !!U,
                        envMapMode: U && U.mapping,
                        envMapEncoding: l(U),
                        envMapCubeUV: !!U && (U.mapping === 306 || U.mapping === 307),
                        lightMap: !!d.lightMap,
                        lightMapEncoding: l(d.lightMap),
                        aoMap: !!d.aoMap,
                        emissiveMap: !!d.emissiveMap,
                        emissiveMapEncoding: l(d.emissiveMap),
                        bumpMap: !!d.bumpMap,
                        normalMap: !!d.normalMap,
                        objectSpaceNormalMap: d.normalMapType === 1,
                        tangentSpaceNormalMap: d.normalMapType === 0,
                        clearcoatMap: !!d.clearcoatMap,
                        clearcoatRoughnessMap: !!d.clearcoatRoughnessMap,
                        clearcoatNormalMap: !!d.clearcoatNormalMap,
                        displacementMap: !!d.displacementMap,
                        roughnessMap: !!d.roughnessMap,
                        metalnessMap: !!d.metalnessMap,
                        specularMap: !!d.specularMap,
                        alphaMap: !!d.alphaMap,
                        gradientMap: !!d.gradientMap,
                        sheen: !!d.sheen,
                        transmissionMap: !!d.transmissionMap,
                        combine: d.combine,
                        vertexTangents: d.normalMap && d.vertexTangents,
                        vertexColors: d.vertexColors,
                        vertexAlphas: d.vertexColors === !0 && M.geometry.attributes.color && M.geometry.attributes.color.itemSize === 4,
                        vertexUvs: !!(d.map || d.bumpMap || d.normalMap || d.specularMap || d.alphaMap || d.emissiveMap || d.roughnessMap || d.metalnessMap || d.clearcoatMap || d.clearcoatRoughnessMap || d.clearcoatNormalMap || d.displacementMap || d.transmissionMap),
                        uvsVertexOnly: !(d.map || d.bumpMap || d.normalMap || d.specularMap || d.alphaMap || d.emissiveMap || d.roughnessMap || d.metalnessMap || d.clearcoatNormalMap || d.transmissionMap || !d.displacementMap),
                        fog: !!F,
                        useFog: d.fog,
                        fogExp2: F && F.isFogExp2,
                        flatShading: !!d.flatShading,
                        sizeAttenuation: d.sizeAttenuation,
                        logarithmicDepthBuffer: T,
                        skinning: d.skinning && H > 0,
                        maxBones: H,
                        useVertexTexture: B,
                        morphTargets: d.morphTargets,
                        morphNormals: d.morphNormals,
                        numDirLights: g.directional.length,
                        numPointLights: g.point.length,
                        numSpotLights: g.spot.length,
                        numRectAreaLights: g.rectArea.length,
                        numHemiLights: g.hemi.length,
                        numDirLightShadows: g.directionalShadowMap.length,
                        numPointLightShadows: g.pointShadowMap.length,
                        numSpotLightShadows: g.spotShadowMap.length,
                        numClippingPlanes: v.numPlanes,
                        numClipIntersection: v.numIntersection,
                        dithering: d.dithering,
                        shadowMapEnabled: s.shadowMap.enabled && x.length > 0,
                        shadowMapType: s.shadowMap.type,
                        toneMapping: d.toneMapped ? s.toneMapping : 0,
                        physicallyCorrectLights: s.physicallyCorrectLights,
                        premultipliedAlpha: d.premultipliedAlpha,
                        alphaTest: d.alphaTest,
                        doubleSided: d.side === 2,
                        flipSided: d.side === 1,
                        depthPacking: d.depthPacking !== void 0 && d.depthPacking,
                        index0AttributeName: d.index0AttributeName,
                        extensionDerivatives: d.extensions && d.extensions.derivatives,
                        extensionFragDepth: d.extensions && d.extensions.fragDepth,
                        extensionDrawBuffers: d.extensions && d.extensions.drawBuffers,
                        extensionShaderTextureLOD: d.extensions && d.extensions.shaderTextureLOD,
                        rendererExtensionFragDepth: E || r.has("EXT_frag_depth"),
                        rendererExtensionDrawBuffers: E || r.has("WEBGL_draw_buffers"),
                        rendererExtensionShaderTextureLod: E || r.has("EXT_shader_texture_lod"),
                        customProgramCacheKey: d.customProgramCacheKey()
                    }
                },
                getProgramCacheKey: function(d) {
                    const g = [];
                    if (d.shaderID ? g.push(d.shaderID) : (g.push(d.fragmentShader), g.push(d.vertexShader)), d.defines !== void 0)
                        for (const x in d.defines) g.push(x), g.push(d.defines[x]);
                    if (d.isRawShaderMaterial === !1) {
                        for (let x = 0; x < a.length; x++) g.push(d[a[x]]);
                        g.push(s.outputEncoding), g.push(s.gammaFactor)
                    }
                    return g.push(d.customProgramCacheKey), g.join()
                },
                getUniforms: function(d) {
                    const g = t[d.type];
                    let x;
                    if (g) {
                        const A = Ga[g];
                        x = Gl.clone(A.uniforms)
                    } else x = d.uniforms;
                    return x
                },
                acquireProgram: function(d, g) {
                    let x;
                    for (let A = 0, M = w.length; A < M; A++) {
                        const F = w[A];
                        if (F.cacheKey === g) {
                            x = F, ++x.usedTimes;
                            break
                        }
                    }
                    return x === void 0 && (x = new po(s, g, d, c), w.push(x)), x
                },
                releaseProgram: function(d) {
                    if (--d.usedTimes == 0) {
                        const g = w.indexOf(d);
                        w[g] = w[w.length - 1], w.pop(), d.destroy()
                    }
                },
                programs: w
            }
        }

        function Al() {
            let s = new WeakMap;
            return {
                get: function(e) {
                    let r = s.get(e);
                    return r === void 0 && (r = {}, s.set(e, r)), r
                },
                remove: function(e) {
                    s.delete(e)
                },
                update: function(e, r, h) {
                    s.get(e)[r] = h
                },
                dispose: function() {
                    s = new WeakMap
                }
            }
        }

        function fo(s, e) {
            return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.program !== e.program ? s.program.id - e.program.id : s.material.id !== e.material.id ? s.material.id - e.material.id : s.z !== e.z ? s.z - e.z : s.id - e.id
        }

        function jc(s, e) {
            return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.z !== e.z ? e.z - s.z : s.id - e.id
        }

        function sc(s) {
            const e = [];
            let r = 0;
            const h = [],
                c = [],
                v = {
                    id: -1
                };

            function w(E, T, B, Q, k, i) {
                let t = e[r];
                const a = s.get(B);
                return t === void 0 ? (t = {
                    id: E.id,
                    object: E,
                    geometry: T,
                    material: B,
                    program: a.program || v,
                    groupOrder: Q,
                    renderOrder: E.renderOrder,
                    z: k,
                    group: i
                }, e[r] = t) : (t.id = E.id, t.object = E, t.geometry = T, t.material = B, t.program = a.program || v, t.groupOrder = Q, t.renderOrder = E.renderOrder, t.z = k, t.group = i), r++, t
            }
            return {
                opaque: h,
                transparent: c,
                init: function() {
                    r = 0, h.length = 0, c.length = 0
                },
                push: function(E, T, B, Q, k, i) {
                    const t = w(E, T, B, Q, k, i);
                    (B.transparent === !0 ? c : h).push(t)
                },
                unshift: function(E, T, B, Q, k, i) {
                    const t = w(E, T, B, Q, k, i);
                    (B.transparent === !0 ? c : h).unshift(t)
                },
                finish: function() {
                    for (let E = r, T = e.length; E < T; E++) {
                        const B = e[E];
                        if (B.id === null) break;
                        B.id = null, B.object = null, B.geometry = null, B.material = null, B.program = null, B.group = null
                    }
                },
                sort: function(E, T) {
                    h.length > 1 && h.sort(E || fo), c.length > 1 && c.sort(T || jc)
                }
            }
        }

        function oc(s) {
            let e = new WeakMap;
            return {
                get: function(r, h) {
                    let c;
                    return e.has(r) === !1 ? (c = new sc(s), e.set(r, [c])) : h >= e.get(r).length ? (c = new sc(s), e.get(r).push(c)) : c = e.get(r)[h], c
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }

        function Yc() {
            const s = {};
            return {
                get: function(e) {
                    if (s[e.id] !== void 0) return s[e.id];
                    let r;
                    switch (e.type) {
                        case "DirectionalLight":
                            r = {
                                direction: new ge,
                                color: new Rt
                            };
                            break;
                        case "SpotLight":
                            r = {
                                position: new ge,
                                direction: new ge,
                                color: new Rt,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0
                            };
                            break;
                        case "PointLight":
                            r = {
                                position: new ge,
                                color: new Rt,
                                distance: 0,
                                decay: 0
                            };
                            break;
                        case "HemisphereLight":
                            r = {
                                direction: new ge,
                                skyColor: new Rt,
                                groundColor: new Rt
                            };
                            break;
                        case "RectAreaLight":
                            r = {
                                color: new Rt,
                                position: new ge,
                                halfWidth: new ge,
                                halfHeight: new ge
                            }
                    }
                    return s[e.id] = r, r
                }
            }
        }
        let b = 0;

        function n(s, e) {
            return (e.castShadow ? 1 : 0) - (s.castShadow ? 1 : 0)
        }

        function u(s, e) {
            const r = new Yc,
                h = function() {
                    const T = {};
                    return {
                        get: function(B) {
                            if (T[B.id] !== void 0) return T[B.id];
                            let Q;
                            switch (B.type) {
                                case "DirectionalLight":
                                case "SpotLight":
                                    Q = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new Ht
                                    };
                                    break;
                                case "PointLight":
                                    Q = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new Ht,
                                        shadowCameraNear: 1,
                                        shadowCameraFar: 1e3
                                    }
                            }
                            return T[B.id] = Q, Q
                        }
                    }
                }(),
                c = {
                    version: 0,
                    hash: {
                        directionalLength: -1,
                        pointLength: -1,
                        spotLength: -1,
                        rectAreaLength: -1,
                        hemiLength: -1,
                        numDirectionalShadows: -1,
                        numPointShadows: -1,
                        numSpotShadows: -1
                    },
                    ambient: [0, 0, 0],
                    probe: [],
                    directional: [],
                    directionalShadow: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotShadow: [],
                    spotShadowMap: [],
                    spotShadowMatrix: [],
                    rectArea: [],
                    rectAreaLTC1: null,
                    rectAreaLTC2: null,
                    point: [],
                    pointShadow: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: []
                };
            for (let T = 0; T < 9; T++) c.probe.push(new ge);
            const v = new ge,
                w = new Ui,
                E = new Ui;
            return {
                setup: function(T) {
                    let B = 0,
                        Q = 0,
                        k = 0;
                    for (let F = 0; F < 9; F++) c.probe[F].set(0, 0, 0);
                    let i = 0,
                        t = 0,
                        a = 0,
                        l = 0,
                        d = 0,
                        g = 0,
                        x = 0,
                        A = 0;
                    T.sort(n);
                    for (let F = 0, D = T.length; F < D; F++) {
                        const U = T[F],
                            N = U.color,
                            H = U.intensity,
                            X = U.distance,
                            ne = U.shadow && U.shadow.map ? U.shadow.map.texture : null;
                        if (U.isAmbientLight) B += N.r * H, Q += N.g * H, k += N.b * H;
                        else if (U.isLightProbe)
                            for (let le = 0; le < 9; le++) c.probe[le].addScaledVector(U.sh.coefficients[le], H);
                        else if (U.isDirectionalLight) {
                            const le = r.get(U);
                            if (le.color.copy(U.color).multiplyScalar(U.intensity), U.castShadow) {
                                const ce = U.shadow,
                                    Qe = h.get(U);
                                Qe.shadowBias = ce.bias, Qe.shadowNormalBias = ce.normalBias, Qe.shadowRadius = ce.radius, Qe.shadowMapSize = ce.mapSize, c.directionalShadow[i] = Qe, c.directionalShadowMap[i] = ne, c.directionalShadowMatrix[i] = U.shadow.matrix, g++
                            }
                            c.directional[i] = le, i++
                        } else if (U.isSpotLight) {
                            const le = r.get(U);
                            if (le.position.setFromMatrixPosition(U.matrixWorld), le.color.copy(N).multiplyScalar(H), le.distance = X, le.coneCos = Math.cos(U.angle), le.penumbraCos = Math.cos(U.angle * (1 - U.penumbra)), le.decay = U.decay, U.castShadow) {
                                const ce = U.shadow,
                                    Qe = h.get(U);
                                Qe.shadowBias = ce.bias, Qe.shadowNormalBias = ce.normalBias, Qe.shadowRadius = ce.radius, Qe.shadowMapSize = ce.mapSize, c.spotShadow[a] = Qe, c.spotShadowMap[a] = ne, c.spotShadowMatrix[a] = U.shadow.matrix, A++
                            }
                            c.spot[a] = le, a++
                        } else if (U.isRectAreaLight) {
                            const le = r.get(U);
                            le.color.copy(N).multiplyScalar(H), le.halfWidth.set(.5 * U.width, 0, 0), le.halfHeight.set(0, .5 * U.height, 0), c.rectArea[l] = le, l++
                        } else if (U.isPointLight) {
                            const le = r.get(U);
                            if (le.color.copy(U.color).multiplyScalar(U.intensity), le.distance = U.distance, le.decay = U.decay, U.castShadow) {
                                const ce = U.shadow,
                                    Qe = h.get(U);
                                Qe.shadowBias = ce.bias, Qe.shadowNormalBias = ce.normalBias, Qe.shadowRadius = ce.radius, Qe.shadowMapSize = ce.mapSize, Qe.shadowCameraNear = ce.camera.near, Qe.shadowCameraFar = ce.camera.far, c.pointShadow[t] = Qe, c.pointShadowMap[t] = ne, c.pointShadowMatrix[t] = U.shadow.matrix, x++
                            }
                            c.point[t] = le, t++
                        } else if (U.isHemisphereLight) {
                            const le = r.get(U);
                            le.skyColor.copy(U.color).multiplyScalar(H), le.groundColor.copy(U.groundColor).multiplyScalar(H), c.hemi[d] = le, d++
                        }
                    }
                    l > 0 && (e.isWebGL2 || s.has("OES_texture_float_linear") === !0 ? (c.rectAreaLTC1 = Oi.LTC_FLOAT_1, c.rectAreaLTC2 = Oi.LTC_FLOAT_2) : s.has("OES_texture_half_float_linear") === !0 ? (c.rectAreaLTC1 = Oi.LTC_HALF_1, c.rectAreaLTC2 = Oi.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), c.ambient[0] = B, c.ambient[1] = Q, c.ambient[2] = k;
                    const M = c.hash;
                    M.directionalLength === i && M.pointLength === t && M.spotLength === a && M.rectAreaLength === l && M.hemiLength === d && M.numDirectionalShadows === g && M.numPointShadows === x && M.numSpotShadows === A || (c.directional.length = i, c.spot.length = a, c.rectArea.length = l, c.point.length = t, c.hemi.length = d, c.directionalShadow.length = g, c.directionalShadowMap.length = g, c.pointShadow.length = x, c.pointShadowMap.length = x, c.spotShadow.length = A, c.spotShadowMap.length = A, c.directionalShadowMatrix.length = g, c.pointShadowMatrix.length = x, c.spotShadowMatrix.length = A, M.directionalLength = i, M.pointLength = t, M.spotLength = a, M.rectAreaLength = l, M.hemiLength = d, M.numDirectionalShadows = g, M.numPointShadows = x, M.numSpotShadows = A, c.version = b++)
                },
                setupView: function(T, B) {
                    let Q = 0,
                        k = 0,
                        i = 0,
                        t = 0,
                        a = 0;
                    const l = B.matrixWorldInverse;
                    for (let d = 0, g = T.length; d < g; d++) {
                        const x = T[d];
                        if (x.isDirectionalLight) {
                            const A = c.directional[Q];
                            A.direction.setFromMatrixPosition(x.matrixWorld), v.setFromMatrixPosition(x.target.matrixWorld), A.direction.sub(v), A.direction.transformDirection(l), Q++
                        } else if (x.isSpotLight) {
                            const A = c.spot[i];
                            A.position.setFromMatrixPosition(x.matrixWorld), A.position.applyMatrix4(l), A.direction.setFromMatrixPosition(x.matrixWorld), v.setFromMatrixPosition(x.target.matrixWorld), A.direction.sub(v), A.direction.transformDirection(l), i++
                        } else if (x.isRectAreaLight) {
                            const A = c.rectArea[t];
                            A.position.setFromMatrixPosition(x.matrixWorld), A.position.applyMatrix4(l), E.identity(), w.copy(x.matrixWorld), w.premultiply(l), E.extractRotation(w), A.halfWidth.set(.5 * x.width, 0, 0), A.halfHeight.set(0, .5 * x.height, 0), A.halfWidth.applyMatrix4(E), A.halfHeight.applyMatrix4(E), t++
                        } else if (x.isPointLight) {
                            const A = c.point[k];
                            A.position.setFromMatrixPosition(x.matrixWorld), A.position.applyMatrix4(l), k++
                        } else if (x.isHemisphereLight) {
                            const A = c.hemi[a];
                            A.direction.setFromMatrixPosition(x.matrixWorld), A.direction.transformDirection(l), A.direction.normalize(), a++
                        }
                    }
                },
                state: c
            }
        }

        function f(s, e) {
            const r = new u(s, e),
                h = [],
                c = [];
            return {
                init: function() {
                    h.length = 0, c.length = 0
                },
                state: {
                    lightsArray: h,
                    shadowsArray: c,
                    lights: r
                },
                setupLights: function() {
                    r.setup(h)
                },
                setupLightsView: function(v) {
                    r.setupView(h, v)
                },
                pushLight: function(v) {
                    h.push(v)
                },
                pushShadow: function(v) {
                    c.push(v)
                }
            }
        }

        function _(s, e) {
            let r = new WeakMap;
            return {
                get: function(h, c = 0) {
                    let v;
                    return r.has(h) === !1 ? (v = new f(s, e), r.set(h, [v])) : c >= r.get(h).length ? (v = new f(s, e), r.get(h).push(v)) : v = r.get(h)[c], v
                },
                dispose: function() {
                    r = new WeakMap
                }
            }
        }
        class S extends ti {
            constructor(e) {
                super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
            }
        }
        S.prototype.isMeshDepthMaterial = !0;
        class L extends ti {
            constructor(e) {
                super(), this.type = "MeshDistanceMaterial", this.referencePosition = new ge, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
            }
        }
        L.prototype.isMeshDistanceMaterial = !0;

        function P(s, e, r) {
            let h = new Us;
            const c = new Ht,
                v = new Ht,
                w = new Si,
                E = [],
                T = [],
                B = {},
                Q = r.maxTextureSize,
                k = {
                    0: 1,
                    1: 0,
                    2: 2
                },
                i = new Cn({
                    defines: {
                        SAMPLE_RATE: 2 / 8,
                        HALF_SAMPLE_RATE: 1 / 8
                    },
                    uniforms: {
                        shadow_pass: {
                            value: null
                        },
                        resolution: {
                            value: new Ht
                        },
                        radius: {
                            value: 4
                        }
                    },
                    vertexShader: `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
                    fragmentShader: `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );
	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`
                }),
                t = i.clone();
            t.defines.HORIZONTAL_PASS = 1;
            const a = new an;
            a.setAttribute("position", new pi(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
            const l = new ar(a, i),
                d = this;

            function g(D, U) {
                const N = e.update(l);
                i.uniforms.shadow_pass.value = D.map.texture, i.uniforms.resolution.value = D.mapSize, i.uniforms.radius.value = D.radius, s.setRenderTarget(D.mapPass), s.clear(), s.renderBufferDirect(U, null, N, i, l, null), t.uniforms.shadow_pass.value = D.mapPass.texture, t.uniforms.resolution.value = D.mapSize, t.uniforms.radius.value = D.radius, s.setRenderTarget(D.map), s.clear(), s.renderBufferDirect(U, null, N, t, l, null)
            }

            function x(D, U, N) {
                const H = D << 0 | U << 1 | N << 2;
                let X = E[H];
                return X === void 0 && (X = new S({
                    depthPacking: 3201,
                    morphTargets: D,
                    skinning: U
                }), E[H] = X), X
            }

            function A(D, U, N) {
                const H = D << 0 | U << 1 | N << 2;
                let X = T[H];
                return X === void 0 && (X = new L({
                    morphTargets: D,
                    skinning: U
                }), T[H] = X), X
            }

            function M(D, U, N, H, X, ne, le) {
                let ce = null,
                    Qe = x,
                    Se = D.customDepthMaterial;
                if (H.isPointLight === !0 && (Qe = A, Se = D.customDistanceMaterial), Se === void 0) {
                    let Re = !1;
                    N.morphTargets === !0 && (Re = U.morphAttributes && U.morphAttributes.position && U.morphAttributes.position.length > 0);
                    let ot = !1;
                    D.isSkinnedMesh === !0 && (N.skinning === !0 ? ot = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", D)), ce = Qe(Re, ot, D.isInstancedMesh === !0)
                } else ce = Se;
                if (s.localClippingEnabled && N.clipShadows === !0 && N.clippingPlanes.length !== 0) {
                    const Re = ce.uuid,
                        ot = N.uuid;
                    let dt = B[Re];
                    dt === void 0 && (dt = {}, B[Re] = dt);
                    let Ct = dt[ot];
                    Ct === void 0 && (Ct = ce.clone(), dt[ot] = Ct), ce = Ct
                }
                return ce.visible = N.visible, ce.wireframe = N.wireframe, ce.side = le === 3 ? N.shadowSide !== null ? N.shadowSide : N.side : N.shadowSide !== null ? N.shadowSide : k[N.side], ce.clipShadows = N.clipShadows, ce.clippingPlanes = N.clippingPlanes, ce.clipIntersection = N.clipIntersection, ce.wireframeLinewidth = N.wireframeLinewidth, ce.linewidth = N.linewidth, H.isPointLight === !0 && ce.isMeshDistanceMaterial === !0 && (ce.referencePosition.setFromMatrixPosition(H.matrixWorld), ce.nearDistance = X, ce.farDistance = ne), ce
            }

            function F(D, U, N, H, X) {
                if (D.visible === !1) return;
                if (D.layers.test(U.layers) && (D.isMesh || D.isLine || D.isPoints) && (D.castShadow || D.receiveShadow && X === 3) && (!D.frustumCulled || h.intersectsObject(D))) {
                    D.modelViewMatrix.multiplyMatrices(N.matrixWorldInverse, D.matrixWorld);
                    const le = e.update(D),
                        ce = D.material;
                    if (Array.isArray(ce)) {
                        const Qe = le.groups;
                        for (let Se = 0, Re = Qe.length; Se < Re; Se++) {
                            const ot = Qe[Se],
                                dt = ce[ot.materialIndex];
                            if (dt && dt.visible) {
                                const Ct = M(D, le, dt, H, N.near, N.far, X);
                                s.renderBufferDirect(N, null, le, Ct, D, ot)
                            }
                        }
                    } else if (ce.visible) {
                        const Qe = M(D, le, ce, H, N.near, N.far, X);
                        s.renderBufferDirect(N, null, le, Qe, D, null)
                    }
                }
                const ne = D.children;
                for (let le = 0, ce = ne.length; le < ce; le++) F(ne[le], U, N, H, X)
            }
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(D, U, N) {
                if (d.enabled === !1 || d.autoUpdate === !1 && d.needsUpdate === !1 || D.length === 0) return;
                const H = s.getRenderTarget(),
                    X = s.getActiveCubeFace(),
                    ne = s.getActiveMipmapLevel(),
                    le = s.state;
                le.setBlending(0), le.buffers.color.setClear(1, 1, 1, 1), le.buffers.depth.setTest(!0), le.setScissorTest(!1);
                for (let ce = 0, Qe = D.length; ce < Qe; ce++) {
                    const Se = D[ce],
                        Re = Se.shadow;
                    if (Re === void 0) {
                        console.warn("THREE.WebGLShadowMap:", Se, "has no shadow.");
                        continue
                    }
                    if (Re.autoUpdate === !1 && Re.needsUpdate === !1) continue;
                    c.copy(Re.mapSize);
                    const ot = Re.getFrameExtents();
                    if (c.multiply(ot), v.copy(Re.mapSize), (c.x > Q || c.y > Q) && (c.x > Q && (v.x = Math.floor(Q / ot.x), c.x = v.x * ot.x, Re.mapSize.x = v.x), c.y > Q && (v.y = Math.floor(Q / ot.y), c.y = v.y * ot.y, Re.mapSize.y = v.y)), Re.map === null && !Re.isPointLightShadow && this.type === 3) {
                        const Ct = {
                            minFilter: 1006,
                            magFilter: 1006,
                            format: 1023
                        };
                        Re.map = new qi(c.x, c.y, Ct), Re.map.texture.name = Se.name + ".shadowMap", Re.mapPass = new qi(c.x, c.y, Ct), Re.camera.updateProjectionMatrix()
                    }
                    if (Re.map === null) {
                        const Ct = {
                            minFilter: 1003,
                            magFilter: 1003,
                            format: 1023
                        };
                        Re.map = new qi(c.x, c.y, Ct), Re.map.texture.name = Se.name + ".shadowMap", Re.camera.updateProjectionMatrix()
                    }
                    s.setRenderTarget(Re.map), s.clear();
                    const dt = Re.getViewportCount();
                    for (let Ct = 0; Ct < dt; Ct++) {
                        const Nt = Re.getViewport(Ct);
                        w.set(v.x * Nt.x, v.y * Nt.y, v.x * Nt.z, v.y * Nt.w), le.viewport(w), Re.updateMatrices(Se, Ct), h = Re.getFrustum(), F(U, N, Re.camera, Se, this.type)
                    }
                    Re.isPointLightShadow || this.type !== 3 || g(Re, N), Re.needsUpdate = !1
                }
                d.needsUpdate = !1, s.setRenderTarget(H, X, ne)
            }
        }

        function I(s, e, r) {
            const h = r.isWebGL2,
                c = new function() {
                    let Ie = !1;
                    const pt = new Si;
                    let xt = null;
                    const Gt = new Si(0, 0, 0, 0);
                    return {
                        setMask: function(Xt) {
                            xt === Xt || Ie || (s.colorMask(Xt, Xt, Xt, Xt), xt = Xt)
                        },
                        setLocked: function(Xt) {
                            Ie = Xt
                        },
                        setClear: function(Xt, hi, _i, Di, nn) {
                            nn === !0 && (Xt *= Di, hi *= Di, _i *= Di), pt.set(Xt, hi, _i, Di), Gt.equals(pt) === !1 && (s.clearColor(Xt, hi, _i, Di), Gt.copy(pt))
                        },
                        reset: function() {
                            Ie = !1, xt = null, Gt.set(-1, 0, 0, 0)
                        }
                    }
                },
                v = new function() {
                    let Ie = !1,
                        pt = null,
                        xt = null,
                        Gt = null;
                    return {
                        setTest: function(Xt) {
                            Xt ? Ct(2929) : Nt(2929)
                        },
                        setMask: function(Xt) {
                            pt === Xt || Ie || (s.depthMask(Xt), pt = Xt)
                        },
                        setFunc: function(Xt) {
                            if (xt !== Xt) {
                                if (Xt) switch (Xt) {
                                    case 0:
                                        s.depthFunc(512);
                                        break;
                                    case 1:
                                        s.depthFunc(519);
                                        break;
                                    case 2:
                                        s.depthFunc(513);
                                        break;
                                    case 3:
                                        s.depthFunc(515);
                                        break;
                                    case 4:
                                        s.depthFunc(514);
                                        break;
                                    case 5:
                                        s.depthFunc(518);
                                        break;
                                    case 6:
                                        s.depthFunc(516);
                                        break;
                                    case 7:
                                        s.depthFunc(517);
                                        break;
                                    default:
                                        s.depthFunc(515)
                                } else s.depthFunc(515);
                                xt = Xt
                            }
                        },
                        setLocked: function(Xt) {
                            Ie = Xt
                        },
                        setClear: function(Xt) {
                            Gt !== Xt && (s.clearDepth(Xt), Gt = Xt)
                        },
                        reset: function() {
                            Ie = !1, pt = null, xt = null, Gt = null
                        }
                    }
                },
                w = new function() {
                    let Ie = !1,
                        pt = null,
                        xt = null,
                        Gt = null,
                        Xt = null,
                        hi = null,
                        _i = null,
                        Di = null,
                        nn = null;
                    return {
                        setTest: function(Fi) {
                            Ie || (Fi ? Ct(2960) : Nt(2960))
                        },
                        setMask: function(Fi) {
                            pt === Fi || Ie || (s.stencilMask(Fi), pt = Fi)
                        },
                        setFunc: function(Fi, tn, gn) {
                            xt === Fi && Gt === tn && Xt === gn || (s.stencilFunc(Fi, tn, gn), xt = Fi, Gt = tn, Xt = gn)
                        },
                        setOp: function(Fi, tn, gn) {
                            hi === Fi && _i === tn && Di === gn || (s.stencilOp(Fi, tn, gn), hi = Fi, _i = tn, Di = gn)
                        },
                        setLocked: function(Fi) {
                            Ie = Fi
                        },
                        setClear: function(Fi) {
                            nn !== Fi && (s.clearStencil(Fi), nn = Fi)
                        },
                        reset: function() {
                            Ie = !1, pt = null, xt = null, Gt = null, Xt = null, hi = null, _i = null, Di = null, nn = null
                        }
                    }
                };
            let E = {},
                T = null,
                B = {},
                Q = null,
                k = !1,
                i = null,
                t = null,
                a = null,
                l = null,
                d = null,
                g = null,
                x = null,
                A = !1,
                M = null,
                F = null,
                D = null,
                U = null,
                N = null;
            const H = s.getParameter(35661);
            let X = !1,
                ne = 0;
            const le = s.getParameter(7938);
            le.indexOf("WebGL") !== -1 ? (ne = parseFloat(/^WebGL (\d)/.exec(le)[1]), X = ne >= 1) : le.indexOf("OpenGL ES") !== -1 && (ne = parseFloat(/^OpenGL ES (\d)/.exec(le)[1]), X = ne >= 2);
            let ce = null,
                Qe = {};
            const Se = new Si(0, 0, s.canvas.width, s.canvas.height),
                Re = new Si(0, 0, s.canvas.width, s.canvas.height);

            function ot(Ie, pt, xt) {
                const Gt = new Uint8Array(4),
                    Xt = s.createTexture();
                s.bindTexture(Ie, Xt), s.texParameteri(Ie, 10241, 9728), s.texParameteri(Ie, 10240, 9728);
                for (let hi = 0; hi < xt; hi++) s.texImage2D(pt + hi, 0, 6408, 1, 1, 0, 6408, 5121, Gt);
                return Xt
            }
            const dt = {};

            function Ct(Ie) {
                E[Ie] !== !0 && (s.enable(Ie), E[Ie] = !0)
            }

            function Nt(Ie) {
                E[Ie] !== !1 && (s.disable(Ie), E[Ie] = !1)
            }
            dt[3553] = ot(3553, 3553, 1), dt[34067] = ot(34067, 34069, 6), c.setClear(0, 0, 0, 1), v.setClear(1), w.setClear(0), Ct(2929), v.setFunc(3), mt(!1), lt(1), Ct(2884), Be(0);
            const qt = {
                100: 32774,
                101: 32778,
                102: 32779
            };
            if (h) qt[103] = 32775, qt[104] = 32776;
            else {
                const Ie = e.get("EXT_blend_minmax");
                Ie !== null && (qt[103] = Ie.MIN_EXT, qt[104] = Ie.MAX_EXT)
            }
            const Fe = {
                200: 0,
                201: 1,
                202: 768,
                204: 770,
                210: 776,
                208: 774,
                206: 772,
                203: 769,
                205: 771,
                209: 775,
                207: 773
            };

            function Be(Ie, pt, xt, Gt, Xt, hi, _i, Di) {
                if (Ie !== 0) {
                    if (k === !1 && (Ct(3042), k = !0), Ie === 5) Xt = Xt || pt, hi = hi || xt, _i = _i || Gt, pt === t && Xt === d || (s.blendEquationSeparate(qt[pt], qt[Xt]), t = pt, d = Xt), xt === a && Gt === l && hi === g && _i === x || (s.blendFuncSeparate(Fe[xt], Fe[Gt], Fe[hi], Fe[_i]), a = xt, l = Gt, g = hi, x = _i), i = Ie, A = null;
                    else if (Ie !== i || Di !== A) {
                        if (t === 100 && d === 100 || (s.blendEquation(32774), t = 100, d = 100), Di) switch (Ie) {
                            case 1:
                                s.blendFuncSeparate(1, 771, 1, 771);
                                break;
                            case 2:
                                s.blendFunc(1, 1);
                                break;
                            case 3:
                                s.blendFuncSeparate(0, 0, 769, 771);
                                break;
                            case 4:
                                s.blendFuncSeparate(0, 768, 0, 770);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", Ie)
                        } else switch (Ie) {
                            case 1:
                                s.blendFuncSeparate(770, 771, 1, 771);
                                break;
                            case 2:
                                s.blendFunc(770, 1);
                                break;
                            case 3:
                                s.blendFunc(0, 769);
                                break;
                            case 4:
                                s.blendFunc(0, 768);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", Ie)
                        }
                        a = null, l = null, g = null, x = null, i = Ie, A = Di
                    }
                } else k === !0 && (Nt(3042), k = !1)
            }

            function mt(Ie) {
                M !== Ie && (Ie ? s.frontFace(2304) : s.frontFace(2305), M = Ie)
            }

            function lt(Ie) {
                Ie !== 0 ? (Ct(2884), Ie !== F && (Ie === 1 ? s.cullFace(1029) : Ie === 2 ? s.cullFace(1028) : s.cullFace(1032))) : Nt(2884), F = Ie
            }

            function Xe(Ie, pt, xt) {
                Ie ? (Ct(32823), U === pt && N === xt || (s.polygonOffset(pt, xt), U = pt, N = xt)) : Nt(32823)
            }

            function Zt(Ie) {
                Ie === void 0 && (Ie = 33984 + H - 1), ce !== Ie && (s.activeTexture(Ie), ce = Ie)
            }
            return {
                buffers: {
                    color: c,
                    depth: v,
                    stencil: w
                },
                enable: Ct,
                disable: Nt,
                bindFramebuffer: function(Ie, pt) {
                    pt === null && T !== null && (pt = T), B[Ie] !== pt && (s.bindFramebuffer(Ie, pt), B[Ie] = pt)
                },
                bindXRFramebuffer: function(Ie) {
                    Ie !== T && (s.bindFramebuffer(36160, Ie), T = Ie)
                },
                useProgram: function(Ie) {
                    return Q !== Ie && (s.useProgram(Ie), Q = Ie, !0)
                },
                setBlending: Be,
                setMaterial: function(Ie, pt) {
                    Ie.side === 2 ? Nt(2884) : Ct(2884);
                    let xt = Ie.side === 1;
                    pt && (xt = !xt), mt(xt), Ie.blending === 1 && Ie.transparent === !1 ? Be(0) : Be(Ie.blending, Ie.blendEquation, Ie.blendSrc, Ie.blendDst, Ie.blendEquationAlpha, Ie.blendSrcAlpha, Ie.blendDstAlpha, Ie.premultipliedAlpha), v.setFunc(Ie.depthFunc), v.setTest(Ie.depthTest), v.setMask(Ie.depthWrite), c.setMask(Ie.colorWrite);
                    const Gt = Ie.stencilWrite;
                    w.setTest(Gt), Gt && (w.setMask(Ie.stencilWriteMask), w.setFunc(Ie.stencilFunc, Ie.stencilRef, Ie.stencilFuncMask), w.setOp(Ie.stencilFail, Ie.stencilZFail, Ie.stencilZPass)), Xe(Ie.polygonOffset, Ie.polygonOffsetFactor, Ie.polygonOffsetUnits), Ie.alphaToCoverage === !0 ? Ct(32926) : Nt(32926)
                },
                setFlipSided: mt,
                setCullFace: lt,
                setLineWidth: function(Ie) {
                    Ie !== D && (X && s.lineWidth(Ie), D = Ie)
                },
                setPolygonOffset: Xe,
                setScissorTest: function(Ie) {
                    Ie ? Ct(3089) : Nt(3089)
                },
                activeTexture: Zt,
                bindTexture: function(Ie, pt) {
                    ce === null && Zt();
                    let xt = Qe[ce];
                    xt === void 0 && (xt = {
                        type: void 0,
                        texture: void 0
                    }, Qe[ce] = xt), xt.type === Ie && xt.texture === pt || (s.bindTexture(Ie, pt || dt[Ie]), xt.type = Ie, xt.texture = pt)
                },
                unbindTexture: function() {
                    const Ie = Qe[ce];
                    Ie !== void 0 && Ie.type !== void 0 && (s.bindTexture(Ie.type, null), Ie.type = void 0, Ie.texture = void 0)
                },
                compressedTexImage2D: function() {
                    try {
                        s.compressedTexImage2D.apply(s, arguments)
                    } catch (Ie) {
                        console.error("THREE.WebGLState:", Ie)
                    }
                },
                texImage2D: function() {
                    try {
                        s.texImage2D.apply(s, arguments)
                    } catch (Ie) {
                        console.error("THREE.WebGLState:", Ie)
                    }
                },
                texImage3D: function() {
                    try {
                        s.texImage3D.apply(s, arguments)
                    } catch (Ie) {
                        console.error("THREE.WebGLState:", Ie)
                    }
                },
                scissor: function(Ie) {
                    Se.equals(Ie) === !1 && (s.scissor(Ie.x, Ie.y, Ie.z, Ie.w), Se.copy(Ie))
                },
                viewport: function(Ie) {
                    Re.equals(Ie) === !1 && (s.viewport(Ie.x, Ie.y, Ie.z, Ie.w), Re.copy(Ie))
                },
                reset: function() {
                    s.disable(3042), s.disable(2884), s.disable(2929), s.disable(32823), s.disable(3089), s.disable(2960), s.disable(32926), s.blendEquation(32774), s.blendFunc(1, 0), s.blendFuncSeparate(1, 0, 1, 0), s.colorMask(!0, !0, !0, !0), s.clearColor(0, 0, 0, 0), s.depthMask(!0), s.depthFunc(513), s.clearDepth(1), s.stencilMask(4294967295), s.stencilFunc(519, 0, 4294967295), s.stencilOp(7680, 7680, 7680), s.clearStencil(0), s.cullFace(1029), s.frontFace(2305), s.polygonOffset(0, 0), s.activeTexture(33984), s.bindFramebuffer(36160, null), h === !0 && (s.bindFramebuffer(36009, null), s.bindFramebuffer(36008, null)), s.useProgram(null), s.lineWidth(1), s.scissor(0, 0, s.canvas.width, s.canvas.height), s.viewport(0, 0, s.canvas.width, s.canvas.height), E = {}, ce = null, Qe = {}, T = null, B = {}, Q = null, k = !1, i = null, t = null, a = null, l = null, d = null, g = null, x = null, A = !1, M = null, F = null, D = null, U = null, N = null, Se.set(0, 0, s.canvas.width, s.canvas.height), Re.set(0, 0, s.canvas.width, s.canvas.height), c.reset(), v.reset(), w.reset()
                }
            }
        }

        function G(s, e, r, h, c, v, w) {
            const E = c.isWebGL2,
                T = c.maxTextures,
                B = c.maxCubemapSize,
                Q = c.maxTextureSize,
                k = c.maxSamples,
                i = new WeakMap;
            let t, a = !1;
            try {
                a = typeof OffscreenCanvas != "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null
            } catch (Fe) {}

            function l(Fe, Be) {
                return a ? new OffscreenCanvas(Fe, Be) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
            }

            function d(Fe, Be, mt, lt) {
                let Xe = 1;
                if ((Fe.width > lt || Fe.height > lt) && (Xe = lt / Math.max(Fe.width, Fe.height)), Xe < 1 || Be === !0) {
                    if (typeof HTMLImageElement != "undefined" && Fe instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && Fe instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && Fe instanceof ImageBitmap) {
                        const Zt = Be ? Mi.floorPowerOfTwo : Math.floor,
                            Ie = Zt(Xe * Fe.width),
                            pt = Zt(Xe * Fe.height);
                        t === void 0 && (t = l(Ie, pt));
                        const xt = mt ? l(Ie, pt) : t;
                        return xt.width = Ie, xt.height = pt, xt.getContext("2d").drawImage(Fe, 0, 0, Ie, pt), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + Fe.width + "x" + Fe.height + ") to (" + Ie + "x" + pt + ")."), xt
                    }
                    return "data" in Fe && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + Fe.width + "x" + Fe.height + ")."), Fe
                }
                return Fe
            }

            function g(Fe) {
                return Mi.isPowerOfTwo(Fe.width) && Mi.isPowerOfTwo(Fe.height)
            }

            function x(Fe, Be) {
                return Fe.generateMipmaps && Be && Fe.minFilter !== 1003 && Fe.minFilter !== 1006
            }

            function A(Fe, Be, mt, lt) {
                s.generateMipmap(Fe), h.get(Be).__maxMipLevel = Math.log2(Math.max(mt, lt))
            }

            function M(Fe, Be, mt) {
                if (E === !1) return Be;
                if (Fe !== null) {
                    if (s[Fe] !== void 0) return s[Fe];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + Fe + "'")
                }
                let lt = Be;
                return Be === 6403 && (mt === 5126 && (lt = 33326), mt === 5131 && (lt = 33325), mt === 5121 && (lt = 33321)), Be === 6407 && (mt === 5126 && (lt = 34837), mt === 5131 && (lt = 34843), mt === 5121 && (lt = 32849)), Be === 6408 && (mt === 5126 && (lt = 34836), mt === 5131 && (lt = 34842), mt === 5121 && (lt = 32856)), lt !== 33325 && lt !== 33326 && lt !== 34842 && lt !== 34836 || e.get("EXT_color_buffer_float"), lt
            }

            function F(Fe) {
                return Fe === 1003 || Fe === 1004 || Fe === 1005 ? 9728 : 9729
            }

            function D(Fe) {
                const Be = Fe.target;
                Be.removeEventListener("dispose", D),
                    function(mt) {
                        const lt = h.get(mt);
                        lt.__webglInit !== void 0 && (s.deleteTexture(lt.__webglTexture), h.remove(mt))
                    }(Be), Be.isVideoTexture && i.delete(Be), w.memory.textures--
            }

            function U(Fe) {
                const Be = Fe.target;
                Be.removeEventListener("dispose", U),
                    function(mt) {
                        const lt = mt.texture,
                            Xe = h.get(mt),
                            Zt = h.get(lt);
                        if (mt) {
                            if (Zt.__webglTexture !== void 0 && s.deleteTexture(Zt.__webglTexture), mt.depthTexture && mt.depthTexture.dispose(), mt.isWebGLCubeRenderTarget)
                                for (let Ie = 0; Ie < 6; Ie++) s.deleteFramebuffer(Xe.__webglFramebuffer[Ie]), Xe.__webglDepthbuffer && s.deleteRenderbuffer(Xe.__webglDepthbuffer[Ie]);
                            else s.deleteFramebuffer(Xe.__webglFramebuffer), Xe.__webglDepthbuffer && s.deleteRenderbuffer(Xe.__webglDepthbuffer), Xe.__webglMultisampledFramebuffer && s.deleteFramebuffer(Xe.__webglMultisampledFramebuffer), Xe.__webglColorRenderbuffer && s.deleteRenderbuffer(Xe.__webglColorRenderbuffer), Xe.__webglDepthRenderbuffer && s.deleteRenderbuffer(Xe.__webglDepthRenderbuffer);
                            h.remove(lt), h.remove(mt)
                        }
                    }(Be), w.memory.textures--
            }
            let N = 0;

            function H(Fe, Be) {
                const mt = h.get(Fe);
                if (Fe.isVideoTexture && function(lt) {
                        const Xe = w.render.frame;
                        i.get(lt) !== Xe && (i.set(lt, Xe), lt.update())
                    }(Fe), Fe.version > 0 && mt.__version !== Fe.version) {
                    const lt = Fe.image;
                    if (lt === void 0) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                    else {
                        if (lt.complete !== !1) return void Se(mt, Fe, Be);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                r.activeTexture(33984 + Be), r.bindTexture(3553, mt.__webglTexture)
            }

            function X(Fe, Be) {
                const mt = h.get(Fe);
                Fe.version > 0 && mt.__version !== Fe.version ? function(lt, Xe, Zt) {
                    if (Xe.image.length !== 6) return;
                    Qe(lt, Xe), r.activeTexture(33984 + Zt), r.bindTexture(34067, lt.__webglTexture), s.pixelStorei(37440, Xe.flipY), s.pixelStorei(37441, Xe.premultiplyAlpha), s.pixelStorei(3317, Xe.unpackAlignment), s.pixelStorei(37443, 0);
                    const Ie = Xe && (Xe.isCompressedTexture || Xe.image[0].isCompressedTexture),
                        pt = Xe.image[0] && Xe.image[0].isDataTexture,
                        xt = [];
                    for (let Fi = 0; Fi < 6; Fi++) xt[Fi] = Ie || pt ? pt ? Xe.image[Fi].image : Xe.image[Fi] : d(Xe.image[Fi], !1, !0, B);
                    const Gt = xt[0],
                        Xt = g(Gt) || E,
                        hi = v.convert(Xe.format),
                        _i = v.convert(Xe.type),
                        Di = M(Xe.internalFormat, hi, _i);
                    let nn;
                    if (ce(34067, Xe, Xt), Ie) {
                        for (let Fi = 0; Fi < 6; Fi++) {
                            nn = xt[Fi].mipmaps;
                            for (let tn = 0; tn < nn.length; tn++) {
                                const gn = nn[tn];
                                Xe.format !== 1023 && Xe.format !== 1022 ? hi !== null ? r.compressedTexImage2D(34069 + Fi, tn, Di, gn.width, gn.height, 0, gn.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : r.texImage2D(34069 + Fi, tn, Di, gn.width, gn.height, 0, hi, _i, gn.data)
                            }
                        }
                        lt.__maxMipLevel = nn.length - 1
                    } else {
                        nn = Xe.mipmaps;
                        for (let Fi = 0; Fi < 6; Fi++)
                            if (pt) {
                                r.texImage2D(34069 + Fi, 0, Di, xt[Fi].width, xt[Fi].height, 0, hi, _i, xt[Fi].data);
                                for (let tn = 0; tn < nn.length; tn++) {
                                    const gn = nn[tn].image[Fi].image;
                                    r.texImage2D(34069 + Fi, tn + 1, Di, gn.width, gn.height, 0, hi, _i, gn.data)
                                }
                            } else {
                                r.texImage2D(34069 + Fi, 0, Di, hi, _i, xt[Fi]);
                                for (let tn = 0; tn < nn.length; tn++) {
                                    const gn = nn[tn];
                                    r.texImage2D(34069 + Fi, tn + 1, Di, hi, _i, gn.image[Fi])
                                }
                            } lt.__maxMipLevel = nn.length
                    }
                    x(Xe, Xt) && A(34067, Xe, Gt.width, Gt.height), lt.__version = Xe.version, Xe.onUpdate && Xe.onUpdate(Xe)
                }(mt, Fe, Be) : (r.activeTexture(33984 + Be), r.bindTexture(34067, mt.__webglTexture))
            }
            const ne = {
                    1e3: 10497,
                    1001: 33071,
                    1002: 33648
                },
                le = {
                    1003: 9728,
                    1004: 9984,
                    1005: 9986,
                    1006: 9729,
                    1007: 9985,
                    1008: 9987
                };

            function ce(Fe, Be, mt) {
                if (mt ? (s.texParameteri(Fe, 10242, ne[Be.wrapS]), s.texParameteri(Fe, 10243, ne[Be.wrapT]), Fe !== 32879 && Fe !== 35866 || s.texParameteri(Fe, 32882, ne[Be.wrapR]), s.texParameteri(Fe, 10240, le[Be.magFilter]), s.texParameteri(Fe, 10241, le[Be.minFilter])) : (s.texParameteri(Fe, 10242, 33071), s.texParameteri(Fe, 10243, 33071), Fe !== 32879 && Fe !== 35866 || s.texParameteri(Fe, 32882, 33071), Be.wrapS === 1001 && Be.wrapT === 1001 || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), s.texParameteri(Fe, 10240, F(Be.magFilter)), s.texParameteri(Fe, 10241, F(Be.minFilter)), Be.minFilter !== 1003 && Be.minFilter !== 1006 && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), e.has("EXT_texture_filter_anisotropic") === !0) {
                    const lt = e.get("EXT_texture_filter_anisotropic");
                    if (Be.type === 1015 && e.has("OES_texture_float_linear") === !1 || E === !1 && Be.type === 1016 && e.has("OES_texture_half_float_linear") === !1) return;
                    (Be.anisotropy > 1 || h.get(Be).__currentAnisotropy) && (s.texParameterf(Fe, lt.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(Be.anisotropy, c.getMaxAnisotropy())), h.get(Be).__currentAnisotropy = Be.anisotropy)
                }
            }

            function Qe(Fe, Be) {
                Fe.__webglInit === void 0 && (Fe.__webglInit = !0, Be.addEventListener("dispose", D), Fe.__webglTexture = s.createTexture(), w.memory.textures++)
            }

            function Se(Fe, Be, mt) {
                let lt = 3553;
                Be.isDataTexture2DArray && (lt = 35866), Be.isDataTexture3D && (lt = 32879), Qe(Fe, Be), r.activeTexture(33984 + mt), r.bindTexture(lt, Fe.__webglTexture), s.pixelStorei(37440, Be.flipY), s.pixelStorei(37441, Be.premultiplyAlpha), s.pixelStorei(3317, Be.unpackAlignment), s.pixelStorei(37443, 0);
                const Xe = function(_i) {
                        return !E && (_i.wrapS !== 1001 || _i.wrapT !== 1001 || _i.minFilter !== 1003 && _i.minFilter !== 1006)
                    }(Be) && g(Be.image) === !1,
                    Zt = d(Be.image, Xe, !1, Q),
                    Ie = g(Zt) || E,
                    pt = v.convert(Be.format);
                let xt, Gt = v.convert(Be.type),
                    Xt = M(Be.internalFormat, pt, Gt);
                ce(lt, Be, Ie);
                const hi = Be.mipmaps;
                if (Be.isDepthTexture) Xt = 6402, E ? Xt = Be.type === 1015 ? 36012 : Be.type === 1014 ? 33190 : Be.type === 1020 ? 35056 : 33189 : Be.type === 1015 && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), Be.format === 1026 && Xt === 6402 && Be.type !== 1012 && Be.type !== 1014 && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), Be.type = 1012, Gt = v.convert(Be.type)), Be.format === 1027 && Xt === 6402 && (Xt = 34041, Be.type !== 1020 && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), Be.type = 1020, Gt = v.convert(Be.type))), r.texImage2D(3553, 0, Xt, Zt.width, Zt.height, 0, pt, Gt, null);
                else if (Be.isDataTexture)
                    if (hi.length > 0 && Ie) {
                        for (let _i = 0, Di = hi.length; _i < Di; _i++) xt = hi[_i], r.texImage2D(3553, _i, Xt, xt.width, xt.height, 0, pt, Gt, xt.data);
                        Be.generateMipmaps = !1, Fe.__maxMipLevel = hi.length - 1
                    } else r.texImage2D(3553, 0, Xt, Zt.width, Zt.height, 0, pt, Gt, Zt.data), Fe.__maxMipLevel = 0;
                else if (Be.isCompressedTexture) {
                    for (let _i = 0, Di = hi.length; _i < Di; _i++) xt = hi[_i], Be.format !== 1023 && Be.format !== 1022 ? pt !== null ? r.compressedTexImage2D(3553, _i, Xt, xt.width, xt.height, 0, xt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : r.texImage2D(3553, _i, Xt, xt.width, xt.height, 0, pt, Gt, xt.data);
                    Fe.__maxMipLevel = hi.length - 1
                } else if (Be.isDataTexture2DArray) r.texImage3D(35866, 0, Xt, Zt.width, Zt.height, Zt.depth, 0, pt, Gt, Zt.data), Fe.__maxMipLevel = 0;
                else if (Be.isDataTexture3D) r.texImage3D(32879, 0, Xt, Zt.width, Zt.height, Zt.depth, 0, pt, Gt, Zt.data), Fe.__maxMipLevel = 0;
                else if (hi.length > 0 && Ie) {
                    for (let _i = 0, Di = hi.length; _i < Di; _i++) xt = hi[_i], r.texImage2D(3553, _i, Xt, pt, Gt, xt);
                    Be.generateMipmaps = !1, Fe.__maxMipLevel = hi.length - 1
                } else r.texImage2D(3553, 0, Xt, pt, Gt, Zt), Fe.__maxMipLevel = 0;
                x(Be, Ie) && A(lt, Be, Zt.width, Zt.height), Fe.__version = Be.version, Be.onUpdate && Be.onUpdate(Be)
            }

            function Re(Fe, Be, mt, lt) {
                const Xe = Be.texture,
                    Zt = v.convert(Xe.format),
                    Ie = v.convert(Xe.type),
                    pt = M(Xe.internalFormat, Zt, Ie);
                lt === 32879 || lt === 35866 ? r.texImage3D(lt, 0, pt, Be.width, Be.height, Be.depth, 0, Zt, Ie, null) : r.texImage2D(lt, 0, pt, Be.width, Be.height, 0, Zt, Ie, null), r.bindFramebuffer(36160, Fe), s.framebufferTexture2D(36160, mt, lt, h.get(Xe).__webglTexture, 0), r.bindFramebuffer(36160, null)
            }

            function ot(Fe, Be, mt) {
                if (s.bindRenderbuffer(36161, Fe), Be.depthBuffer && !Be.stencilBuffer) {
                    let lt = 33189;
                    if (mt) {
                        const Xe = Be.depthTexture;
                        Xe && Xe.isDepthTexture && (Xe.type === 1015 ? lt = 36012 : Xe.type === 1014 && (lt = 33190));
                        const Zt = Ct(Be);
                        s.renderbufferStorageMultisample(36161, Zt, lt, Be.width, Be.height)
                    } else s.renderbufferStorage(36161, lt, Be.width, Be.height);
                    s.framebufferRenderbuffer(36160, 36096, 36161, Fe)
                } else if (Be.depthBuffer && Be.stencilBuffer) {
                    if (mt) {
                        const lt = Ct(Be);
                        s.renderbufferStorageMultisample(36161, lt, 35056, Be.width, Be.height)
                    } else s.renderbufferStorage(36161, 34041, Be.width, Be.height);
                    s.framebufferRenderbuffer(36160, 33306, 36161, Fe)
                } else {
                    const lt = Be.texture,
                        Xe = v.convert(lt.format),
                        Zt = v.convert(lt.type),
                        Ie = M(lt.internalFormat, Xe, Zt);
                    if (mt) {
                        const pt = Ct(Be);
                        s.renderbufferStorageMultisample(36161, pt, Ie, Be.width, Be.height)
                    } else s.renderbufferStorage(36161, Ie, Be.width, Be.height)
                }
                s.bindRenderbuffer(36161, null)
            }

            function dt(Fe) {
                const Be = h.get(Fe),
                    mt = Fe.isWebGLCubeRenderTarget === !0;
                if (Fe.depthTexture) {
                    if (mt) throw new Error("target.depthTexture not supported in Cube render targets");
                    (function(lt, Xe) {
                        if (Xe && Xe.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                        if (r.bindFramebuffer(36160, lt), !Xe.depthTexture || !Xe.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        h.get(Xe.depthTexture).__webglTexture && Xe.depthTexture.image.width === Xe.width && Xe.depthTexture.image.height === Xe.height || (Xe.depthTexture.image.width = Xe.width, Xe.depthTexture.image.height = Xe.height, Xe.depthTexture.needsUpdate = !0), H(Xe.depthTexture, 0);
                        const Zt = h.get(Xe.depthTexture).__webglTexture;
                        if (Xe.depthTexture.format === 1026) s.framebufferTexture2D(36160, 36096, 3553, Zt, 0);
                        else {
                            if (Xe.depthTexture.format !== 1027) throw new Error("Unknown depthTexture format");
                            s.framebufferTexture2D(36160, 33306, 3553, Zt, 0)
                        }
                    })(Be.__webglFramebuffer, Fe)
                } else if (mt) {
                    Be.__webglDepthbuffer = [];
                    for (let lt = 0; lt < 6; lt++) r.bindFramebuffer(36160, Be.__webglFramebuffer[lt]), Be.__webglDepthbuffer[lt] = s.createRenderbuffer(), ot(Be.__webglDepthbuffer[lt], Fe, !1)
                } else r.bindFramebuffer(36160, Be.__webglFramebuffer), Be.__webglDepthbuffer = s.createRenderbuffer(), ot(Be.__webglDepthbuffer, Fe, !1);
                r.bindFramebuffer(36160, null)
            }

            function Ct(Fe) {
                return E && Fe.isWebGLMultisampleRenderTarget ? Math.min(k, Fe.samples) : 0
            }
            let Nt = !1,
                qt = !1;
            this.allocateTextureUnit = function() {
                const Fe = N;
                return Fe >= T && console.warn("THREE.WebGLTextures: Trying to use " + Fe + " texture units while this GPU supports only " + T), N += 1, Fe
            }, this.resetTextureUnits = function() {
                N = 0
            }, this.setTexture2D = H, this.setTexture2DArray = function(Fe, Be) {
                const mt = h.get(Fe);
                Fe.version > 0 && mt.__version !== Fe.version ? Se(mt, Fe, Be) : (r.activeTexture(33984 + Be), r.bindTexture(35866, mt.__webglTexture))
            }, this.setTexture3D = function(Fe, Be) {
                const mt = h.get(Fe);
                Fe.version > 0 && mt.__version !== Fe.version ? Se(mt, Fe, Be) : (r.activeTexture(33984 + Be), r.bindTexture(32879, mt.__webglTexture))
            }, this.setTextureCube = X, this.setupRenderTarget = function(Fe) {
                const Be = Fe.texture,
                    mt = h.get(Fe),
                    lt = h.get(Be);
                Fe.addEventListener("dispose", U), lt.__webglTexture = s.createTexture(), lt.__version = Be.version, w.memory.textures++;
                const Xe = Fe.isWebGLCubeRenderTarget === !0,
                    Zt = Fe.isWebGLMultisampleRenderTarget === !0,
                    Ie = Be.isDataTexture3D || Be.isDataTexture2DArray,
                    pt = g(Fe) || E;
                if (!E || Be.format !== 1022 || Be.type !== 1015 && Be.type !== 1016 || (Be.format = 1023, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), Xe) {
                    mt.__webglFramebuffer = [];
                    for (let xt = 0; xt < 6; xt++) mt.__webglFramebuffer[xt] = s.createFramebuffer()
                } else if (mt.__webglFramebuffer = s.createFramebuffer(), Zt)
                    if (E) {
                        mt.__webglMultisampledFramebuffer = s.createFramebuffer(), mt.__webglColorRenderbuffer = s.createRenderbuffer(), s.bindRenderbuffer(36161, mt.__webglColorRenderbuffer);
                        const xt = v.convert(Be.format),
                            Gt = v.convert(Be.type),
                            Xt = M(Be.internalFormat, xt, Gt),
                            hi = Ct(Fe);
                        s.renderbufferStorageMultisample(36161, hi, Xt, Fe.width, Fe.height), r.bindFramebuffer(36160, mt.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(36160, 36064, 36161, mt.__webglColorRenderbuffer), s.bindRenderbuffer(36161, null), Fe.depthBuffer && (mt.__webglDepthRenderbuffer = s.createRenderbuffer(), ot(mt.__webglDepthRenderbuffer, Fe, !0)), r.bindFramebuffer(36160, null)
                    } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                if (Xe) {
                    r.bindTexture(34067, lt.__webglTexture), ce(34067, Be, pt);
                    for (let xt = 0; xt < 6; xt++) Re(mt.__webglFramebuffer[xt], Fe, 36064, 34069 + xt);
                    x(Be, pt) && A(34067, Be, Fe.width, Fe.height), r.bindTexture(34067, null)
                } else {
                    let xt = 3553;
                    Ie && (E ? xt = Be.isDataTexture3D ? 32879 : 35866 : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), r.bindTexture(xt, lt.__webglTexture), ce(xt, Be, pt), Re(mt.__webglFramebuffer, Fe, 36064, xt), x(Be, pt) && A(3553, Be, Fe.width, Fe.height), r.bindTexture(3553, null)
                }
                Fe.depthBuffer && dt(Fe)
            }, this.updateRenderTargetMipmap = function(Fe) {
                const Be = Fe.texture;
                if (x(Be, g(Fe) || E)) {
                    const mt = Fe.isWebGLCubeRenderTarget ? 34067 : 3553,
                        lt = h.get(Be).__webglTexture;
                    r.bindTexture(mt, lt), A(mt, Be, Fe.width, Fe.height), r.bindTexture(mt, null)
                }
            }, this.updateMultisampleRenderTarget = function(Fe) {
                if (Fe.isWebGLMultisampleRenderTarget)
                    if (E) {
                        const Be = h.get(Fe);
                        r.bindFramebuffer(36008, Be.__webglMultisampledFramebuffer), r.bindFramebuffer(36009, Be.__webglFramebuffer);
                        const mt = Fe.width,
                            lt = Fe.height;
                        let Xe = 16384;
                        Fe.depthBuffer && (Xe |= 256), Fe.stencilBuffer && (Xe |= 1024), s.blitFramebuffer(0, 0, mt, lt, 0, 0, mt, lt, Xe, 9728), r.bindFramebuffer(36160, Be.__webglMultisampledFramebuffer)
                    } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
            }, this.safeSetTexture2D = function(Fe, Be) {
                Fe && Fe.isWebGLRenderTarget && (Nt === !1 && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), Nt = !0), Fe = Fe.texture), H(Fe, Be)
            }, this.safeSetTextureCube = function(Fe, Be) {
                Fe && Fe.isWebGLCubeRenderTarget && (qt === !1 && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), qt = !0), Fe = Fe.texture), X(Fe, Be)
            }
        }

        function j(s, e, r) {
            const h = r.isWebGL2;
            return {
                convert: function(c) {
                    let v;
                    if (c === 1009) return 5121;
                    if (c === 1017) return 32819;
                    if (c === 1018) return 32820;
                    if (c === 1019) return 33635;
                    if (c === 1010) return 5120;
                    if (c === 1011) return 5122;
                    if (c === 1012) return 5123;
                    if (c === 1013) return 5124;
                    if (c === 1014) return 5125;
                    if (c === 1015) return 5126;
                    if (c === 1016) return h ? 5131 : (v = e.get("OES_texture_half_float"), v !== null ? v.HALF_FLOAT_OES : null);
                    if (c === 1021) return 6406;
                    if (c === 1022) return 6407;
                    if (c === 1023) return 6408;
                    if (c === 1024) return 6409;
                    if (c === 1025) return 6410;
                    if (c === 1026) return 6402;
                    if (c === 1027) return 34041;
                    if (c === 1028) return 6403;
                    if (c === 1029) return 36244;
                    if (c === 1030) return 33319;
                    if (c === 1031) return 33320;
                    if (c === 1032) return 36248;
                    if (c === 1033) return 36249;
                    if (c === 33776 || c === 33777 || c === 33778 || c === 33779) {
                        if (v = e.get("WEBGL_compressed_texture_s3tc"), v === null) return null;
                        if (c === 33776) return v.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (c === 33777) return v.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (c === 33778) return v.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (c === 33779) return v.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if (c === 35840 || c === 35841 || c === 35842 || c === 35843) {
                        if (v = e.get("WEBGL_compressed_texture_pvrtc"), v === null) return null;
                        if (c === 35840) return v.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (c === 35841) return v.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (c === 35842) return v.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (c === 35843) return v.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (c === 36196) return v = e.get("WEBGL_compressed_texture_etc1"), v !== null ? v.COMPRESSED_RGB_ETC1_WEBGL : null;
                    if ((c === 37492 || c === 37496) && (v = e.get("WEBGL_compressed_texture_etc"), v !== null)) {
                        if (c === 37492) return v.COMPRESSED_RGB8_ETC2;
                        if (c === 37496) return v.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    return c === 37808 || c === 37809 || c === 37810 || c === 37811 || c === 37812 || c === 37813 || c === 37814 || c === 37815 || c === 37816 || c === 37817 || c === 37818 || c === 37819 || c === 37820 || c === 37821 || c === 37840 || c === 37841 || c === 37842 || c === 37843 || c === 37844 || c === 37845 || c === 37846 || c === 37847 || c === 37848 || c === 37849 || c === 37850 || c === 37851 || c === 37852 || c === 37853 ? (v = e.get("WEBGL_compressed_texture_astc"), v !== null ? c : null) : c === 36492 ? (v = e.get("EXT_texture_compression_bptc"), v !== null ? c : null) : c === 1020 ? h ? 34042 : (v = e.get("WEBGL_depth_texture"), v !== null ? v.UNSIGNED_INT_24_8_WEBGL : null) : void 0
                }
            }
        }
        class ee extends dr {
            constructor(e = []) {
                super(), this.cameras = e
            }
        }
        ee.prototype.isArrayCamera = !0;
        class pe extends Z {
            constructor() {
                super(), this.type = "Group"
            }
        }

        function Ce() {
            this._targetRay = null, this._grip = null, this._hand = null
        }

        function Me(s, e) {
            const r = this,
                h = s.state;
            let c = null,
                v = 1,
                w = null,
                E = "local-floor",
                T = null;
            const B = [],
                Q = new Map,
                k = new dr;
            k.layers.enable(1), k.viewport = new Si;
            const i = new dr;
            i.layers.enable(2), i.viewport = new Si;
            const t = [k, i],
                a = new ee;
            a.layers.enable(1), a.layers.enable(2);
            let l = null,
                d = null;

            function g(H) {
                const X = Q.get(H.inputSource);
                X && X.dispatchEvent({
                    type: H.type,
                    data: H.inputSource
                })
            }

            function x() {
                Q.forEach(function(H, X) {
                    H.disconnect(X)
                }), Q.clear(), l = null, d = null, h.bindXRFramebuffer(null), s.setRenderTarget(s.getRenderTarget()), N.stop(), r.isPresenting = !1, r.dispatchEvent({
                    type: "sessionend"
                })
            }

            function A(H) {
                const X = c.inputSources;
                for (let ne = 0; ne < B.length; ne++) Q.set(X[ne], B[ne]);
                for (let ne = 0; ne < H.removed.length; ne++) {
                    const le = H.removed[ne],
                        ce = Q.get(le);
                    ce && (ce.dispatchEvent({
                        type: "disconnected",
                        data: le
                    }), Q.delete(le))
                }
                for (let ne = 0; ne < H.added.length; ne++) {
                    const le = H.added[ne],
                        ce = Q.get(le);
                    ce && ce.dispatchEvent({
                        type: "connected",
                        data: le
                    })
                }
            }
            this.enabled = !1, this.isPresenting = !1, this.getController = function(H) {
                let X = B[H];
                return X === void 0 && (X = new Ce, B[H] = X), X.getTargetRaySpace()
            }, this.getControllerGrip = function(H) {
                let X = B[H];
                return X === void 0 && (X = new Ce, B[H] = X), X.getGripSpace()
            }, this.getHand = function(H) {
                let X = B[H];
                return X === void 0 && (X = new Ce, B[H] = X), X.getHandSpace()
            }, this.setFramebufferScaleFactor = function(H) {
                v = H, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
            }, this.setReferenceSpaceType = function(H) {
                E = H, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
            }, this.getReferenceSpace = function() {
                return w
            }, this.getSession = function() {
                return c
            }, this.setSession = function(H) {
                return no(this, null, function*() {
                    if (c = H, c !== null) {
                        c.addEventListener("select", g), c.addEventListener("selectstart", g), c.addEventListener("selectend", g), c.addEventListener("squeeze", g), c.addEventListener("squeezestart", g), c.addEventListener("squeezeend", g), c.addEventListener("end", x), c.addEventListener("inputsourceschange", A);
                        const X = e.getContextAttributes();
                        X.xrCompatible !== !0 && (yield e.makeXRCompatible());
                        const ne = {
                                antialias: X.antialias,
                                alpha: X.alpha,
                                depth: X.depth,
                                stencil: X.stencil,
                                framebufferScaleFactor: v
                            },
                            le = new XRWebGLLayer(c, e, ne);
                        c.updateRenderState({
                            baseLayer: le
                        }), w = yield c.requestReferenceSpace(E), N.setContext(c), N.start(), r.isPresenting = !0, r.dispatchEvent({
                            type: "sessionstart"
                        })
                    }
                })
            };
            const M = new ge,
                F = new ge;

            function D(H, X) {
                X === null ? H.matrixWorld.copy(H.matrix) : H.matrixWorld.multiplyMatrices(X.matrixWorld, H.matrix), H.matrixWorldInverse.copy(H.matrixWorld).invert()
            }
            this.getCamera = function(H) {
                a.near = i.near = k.near = H.near, a.far = i.far = k.far = H.far, l === a.near && d === a.far || (c.updateRenderState({
                    depthNear: a.near,
                    depthFar: a.far
                }), l = a.near, d = a.far);
                const X = H.parent,
                    ne = a.cameras;
                D(a, X);
                for (let ce = 0; ce < ne.length; ce++) D(ne[ce], X);
                H.matrixWorld.copy(a.matrixWorld), H.matrix.copy(a.matrix), H.matrix.decompose(H.position, H.quaternion, H.scale);
                const le = H.children;
                for (let ce = 0, Qe = le.length; ce < Qe; ce++) le[ce].updateMatrixWorld(!0);
                return ne.length === 2 ? function(ce, Qe, Se) {
                    M.setFromMatrixPosition(Qe.matrixWorld), F.setFromMatrixPosition(Se.matrixWorld);
                    const Re = M.distanceTo(F),
                        ot = Qe.projectionMatrix.elements,
                        dt = Se.projectionMatrix.elements,
                        Ct = ot[14] / (ot[10] - 1),
                        Nt = ot[14] / (ot[10] + 1),
                        qt = (ot[9] + 1) / ot[5],
                        Fe = (ot[9] - 1) / ot[5],
                        Be = (ot[8] - 1) / ot[0],
                        mt = (dt[8] + 1) / dt[0],
                        lt = Ct * Be,
                        Xe = Ct * mt,
                        Zt = Re / (-Be + mt),
                        Ie = Zt * -Be;
                    Qe.matrixWorld.decompose(ce.position, ce.quaternion, ce.scale), ce.translateX(Ie), ce.translateZ(Zt), ce.matrixWorld.compose(ce.position, ce.quaternion, ce.scale), ce.matrixWorldInverse.copy(ce.matrixWorld).invert();
                    const pt = Ct + Zt,
                        xt = Nt + Zt,
                        Gt = lt - Ie,
                        Xt = Xe + (Re - Ie),
                        hi = qt * Nt / xt * pt,
                        _i = Fe * Nt / xt * pt;
                    ce.projectionMatrix.makePerspective(Gt, Xt, hi, _i, pt, xt)
                }(a, k, i) : a.projectionMatrix.copy(k.projectionMatrix), a
            };
            let U = null;
            const N = new Pc;
            N.setAnimationLoop(function(H, X) {
                if (T = X.getViewerPose(w), T !== null) {
                    const le = T.views,
                        ce = c.renderState.baseLayer;
                    h.bindXRFramebuffer(ce.framebuffer);
                    let Qe = !1;
                    le.length !== a.cameras.length && (a.cameras.length = 0, Qe = !0);
                    for (let Se = 0; Se < le.length; Se++) {
                        const Re = le[Se],
                            ot = ce.getViewport(Re),
                            dt = t[Se];
                        dt.matrix.fromArray(Re.transform.matrix), dt.projectionMatrix.fromArray(Re.projectionMatrix), dt.viewport.set(ot.x, ot.y, ot.width, ot.height), Se === 0 && a.matrix.copy(dt.matrix), Qe === !0 && a.cameras.push(dt)
                    }
                }
                const ne = c.inputSources;
                for (let le = 0; le < B.length; le++) {
                    const ce = B[le],
                        Qe = ne[le];
                    ce.update(Qe, X, w)
                }
                U && U(H, X)
            }), this.setAnimationLoop = function(H) {
                U = H
            }, this.dispose = function() {}
        }

        function ke(s) {
            function e(h, c) {
                h.opacity.value = c.opacity, c.color && h.diffuse.value.copy(c.color), c.emissive && h.emissive.value.copy(c.emissive).multiplyScalar(c.emissiveIntensity), c.map && (h.map.value = c.map), c.alphaMap && (h.alphaMap.value = c.alphaMap), c.specularMap && (h.specularMap.value = c.specularMap);
                const v = s.get(c).envMap;
                if (v) {
                    h.envMap.value = v, h.flipEnvMap.value = v.isCubeTexture && v._needsFlipEnvMap ? -1 : 1, h.reflectivity.value = c.reflectivity, h.refractionRatio.value = c.refractionRatio;
                    const T = s.get(v).__maxMipLevel;
                    T !== void 0 && (h.maxMipLevel.value = T)
                }
                let w, E;
                c.lightMap && (h.lightMap.value = c.lightMap, h.lightMapIntensity.value = c.lightMapIntensity), c.aoMap && (h.aoMap.value = c.aoMap, h.aoMapIntensity.value = c.aoMapIntensity), c.map ? w = c.map : c.specularMap ? w = c.specularMap : c.displacementMap ? w = c.displacementMap : c.normalMap ? w = c.normalMap : c.bumpMap ? w = c.bumpMap : c.roughnessMap ? w = c.roughnessMap : c.metalnessMap ? w = c.metalnessMap : c.alphaMap ? w = c.alphaMap : c.emissiveMap ? w = c.emissiveMap : c.clearcoatMap ? w = c.clearcoatMap : c.clearcoatNormalMap ? w = c.clearcoatNormalMap : c.clearcoatRoughnessMap && (w = c.clearcoatRoughnessMap), w !== void 0 && (w.isWebGLRenderTarget && (w = w.texture), w.matrixAutoUpdate === !0 && w.updateMatrix(), h.uvTransform.value.copy(w.matrix)), c.aoMap ? E = c.aoMap : c.lightMap && (E = c.lightMap), E !== void 0 && (E.isWebGLRenderTarget && (E = E.texture), E.matrixAutoUpdate === !0 && E.updateMatrix(), h.uv2Transform.value.copy(E.matrix))
            }

            function r(h, c) {
                h.roughness.value = c.roughness, h.metalness.value = c.metalness, c.roughnessMap && (h.roughnessMap.value = c.roughnessMap), c.metalnessMap && (h.metalnessMap.value = c.metalnessMap), c.emissiveMap && (h.emissiveMap.value = c.emissiveMap), c.bumpMap && (h.bumpMap.value = c.bumpMap, h.bumpScale.value = c.bumpScale, c.side === 1 && (h.bumpScale.value *= -1)), c.normalMap && (h.normalMap.value = c.normalMap, h.normalScale.value.copy(c.normalScale), c.side === 1 && h.normalScale.value.negate()), c.displacementMap && (h.displacementMap.value = c.displacementMap, h.displacementScale.value = c.displacementScale, h.displacementBias.value = c.displacementBias), s.get(c).envMap && (h.envMapIntensity.value = c.envMapIntensity)
            }
            return {
                refreshFogUniforms: function(h, c) {
                    h.fogColor.value.copy(c.color), c.isFog ? (h.fogNear.value = c.near, h.fogFar.value = c.far) : c.isFogExp2 && (h.fogDensity.value = c.density)
                },
                refreshMaterialUniforms: function(h, c, v, w) {
                    c.isMeshBasicMaterial ? e(h, c) : c.isMeshLambertMaterial ? (e(h, c), function(E, T) {
                        T.emissiveMap && (E.emissiveMap.value = T.emissiveMap)
                    }(h, c)) : c.isMeshToonMaterial ? (e(h, c), function(E, T) {
                        T.gradientMap && (E.gradientMap.value = T.gradientMap), T.emissiveMap && (E.emissiveMap.value = T.emissiveMap), T.bumpMap && (E.bumpMap.value = T.bumpMap, E.bumpScale.value = T.bumpScale, T.side === 1 && (E.bumpScale.value *= -1)), T.normalMap && (E.normalMap.value = T.normalMap, E.normalScale.value.copy(T.normalScale), T.side === 1 && E.normalScale.value.negate()), T.displacementMap && (E.displacementMap.value = T.displacementMap, E.displacementScale.value = T.displacementScale, E.displacementBias.value = T.displacementBias)
                    }(h, c)) : c.isMeshPhongMaterial ? (e(h, c), function(E, T) {
                        E.specular.value.copy(T.specular), E.shininess.value = Math.max(T.shininess, 1e-4), T.emissiveMap && (E.emissiveMap.value = T.emissiveMap), T.bumpMap && (E.bumpMap.value = T.bumpMap, E.bumpScale.value = T.bumpScale, T.side === 1 && (E.bumpScale.value *= -1)), T.normalMap && (E.normalMap.value = T.normalMap, E.normalScale.value.copy(T.normalScale), T.side === 1 && E.normalScale.value.negate()), T.displacementMap && (E.displacementMap.value = T.displacementMap, E.displacementScale.value = T.displacementScale, E.displacementBias.value = T.displacementBias)
                    }(h, c)) : c.isMeshStandardMaterial ? (e(h, c), c.isMeshPhysicalMaterial ? function(E, T) {
                        r(E, T), E.reflectivity.value = T.reflectivity, E.clearcoat.value = T.clearcoat, E.clearcoatRoughness.value = T.clearcoatRoughness, T.sheen && E.sheen.value.copy(T.sheen), T.clearcoatMap && (E.clearcoatMap.value = T.clearcoatMap), T.clearcoatRoughnessMap && (E.clearcoatRoughnessMap.value = T.clearcoatRoughnessMap), T.clearcoatNormalMap && (E.clearcoatNormalScale.value.copy(T.clearcoatNormalScale), E.clearcoatNormalMap.value = T.clearcoatNormalMap, T.side === 1 && E.clearcoatNormalScale.value.negate()), E.transmission.value = T.transmission, T.transmissionMap && (E.transmissionMap.value = T.transmissionMap)
                    }(h, c) : r(h, c)) : c.isMeshMatcapMaterial ? (e(h, c), function(E, T) {
                        T.matcap && (E.matcap.value = T.matcap), T.bumpMap && (E.bumpMap.value = T.bumpMap, E.bumpScale.value = T.bumpScale, T.side === 1 && (E.bumpScale.value *= -1)), T.normalMap && (E.normalMap.value = T.normalMap, E.normalScale.value.copy(T.normalScale), T.side === 1 && E.normalScale.value.negate()), T.displacementMap && (E.displacementMap.value = T.displacementMap, E.displacementScale.value = T.displacementScale, E.displacementBias.value = T.displacementBias)
                    }(h, c)) : c.isMeshDepthMaterial ? (e(h, c), function(E, T) {
                        T.displacementMap && (E.displacementMap.value = T.displacementMap, E.displacementScale.value = T.displacementScale, E.displacementBias.value = T.displacementBias)
                    }(h, c)) : c.isMeshDistanceMaterial ? (e(h, c), function(E, T) {
                        T.displacementMap && (E.displacementMap.value = T.displacementMap, E.displacementScale.value = T.displacementScale, E.displacementBias.value = T.displacementBias), E.referencePosition.value.copy(T.referencePosition), E.nearDistance.value = T.nearDistance, E.farDistance.value = T.farDistance
                    }(h, c)) : c.isMeshNormalMaterial ? (e(h, c), function(E, T) {
                        T.bumpMap && (E.bumpMap.value = T.bumpMap, E.bumpScale.value = T.bumpScale, T.side === 1 && (E.bumpScale.value *= -1)), T.normalMap && (E.normalMap.value = T.normalMap, E.normalScale.value.copy(T.normalScale), T.side === 1 && E.normalScale.value.negate()), T.displacementMap && (E.displacementMap.value = T.displacementMap, E.displacementScale.value = T.displacementScale, E.displacementBias.value = T.displacementBias)
                    }(h, c)) : c.isLineBasicMaterial ? (function(E, T) {
                        E.diffuse.value.copy(T.color), E.opacity.value = T.opacity
                    }(h, c), c.isLineDashedMaterial && function(E, T) {
                        E.dashSize.value = T.dashSize, E.totalSize.value = T.dashSize + T.gapSize, E.scale.value = T.scale
                    }(h, c)) : c.isPointsMaterial ? function(E, T, B, Q) {
                        E.diffuse.value.copy(T.color), E.opacity.value = T.opacity, E.size.value = T.size * B, E.scale.value = .5 * Q, T.map && (E.map.value = T.map), T.alphaMap && (E.alphaMap.value = T.alphaMap);
                        let k;
                        T.map ? k = T.map : T.alphaMap && (k = T.alphaMap), k !== void 0 && (k.matrixAutoUpdate === !0 && k.updateMatrix(), E.uvTransform.value.copy(k.matrix))
                    }(h, c, v, w) : c.isSpriteMaterial ? function(E, T) {
                        E.diffuse.value.copy(T.color), E.opacity.value = T.opacity, E.rotation.value = T.rotation, T.map && (E.map.value = T.map), T.alphaMap && (E.alphaMap.value = T.alphaMap);
                        let B;
                        T.map ? B = T.map : T.alphaMap && (B = T.alphaMap), B !== void 0 && (B.matrixAutoUpdate === !0 && B.updateMatrix(), E.uvTransform.value.copy(B.matrix))
                    }(h, c) : c.isShadowMaterial ? (h.color.value.copy(c.color), h.opacity.value = c.opacity) : c.isShaderMaterial && (c.uniformsNeedUpdate = !1)
                }
            }
        }

        function we(s) {
            const e = (s = s || {}).canvas !== void 0 ? s.canvas : function() {
                    const Ge = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                    return Ge.style.display = "block", Ge
                }(),
                r = s.context !== void 0 ? s.context : null,
                h = s.alpha !== void 0 && s.alpha,
                c = s.depth === void 0 || s.depth,
                v = s.stencil === void 0 || s.stencil,
                w = s.antialias !== void 0 && s.antialias,
                E = s.premultipliedAlpha === void 0 || s.premultipliedAlpha,
                T = s.preserveDrawingBuffer !== void 0 && s.preserveDrawingBuffer,
                B = s.powerPreference !== void 0 ? s.powerPreference : "default",
                Q = s.failIfMajorPerformanceCaveat !== void 0 && s.failIfMajorPerformanceCaveat;
            let k = null,
                i = null;
            const t = [],
                a = [];
            this.domElement = e, this.debug = {
                checkShaderErrors: !0
            }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = 3e3, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1;
            const l = this;
            let d = !1,
                g = 0,
                x = 0,
                A = null,
                M = -1,
                F = null;
            const D = new Si,
                U = new Si;
            let N = null,
                H = e.width,
                X = e.height,
                ne = 1,
                le = null,
                ce = null;
            const Qe = new Si(0, 0, H, X),
                Se = new Si(0, 0, H, X);
            let Re = !1;
            const ot = new Us;
            let dt = !1,
                Ct = !1;
            const Nt = new Ui,
                qt = new ge,
                Fe = {
                    background: null,
                    fog: null,
                    environment: null,
                    overrideMaterial: null,
                    isScene: !0
                };

            function Be() {
                return A === null ? ne : 1
            }
            let mt, lt, Xe, Zt, Ie, pt, xt, Gt, Xt, hi, _i, Di, nn, Fi, tn, gn, Kn, er, ia, oa, tr, jn, fi = r;

            function Yr(Ge, oi) {
                for (let kt = 0; kt < Ge.length; kt++) {
                    const ui = Ge[kt],
                        Ni = e.getContext(ui, oi);
                    if (Ni !== null) return Ni
                }
                return null
            }
            try {
                const Ge = {
                    alpha: h,
                    depth: c,
                    stencil: v,
                    antialias: w,
                    premultipliedAlpha: E,
                    preserveDrawingBuffer: T,
                    powerPreference: B,
                    failIfMajorPerformanceCaveat: Q
                };
                if (e.addEventListener("webglcontextlost", fa, !1), e.addEventListener("webglcontextrestored", qr, !1), fi === null) {
                    const oi = ["webgl2", "webgl", "experimental-webgl"];
                    if (l.isWebGL1Renderer === !0 && oi.shift(), fi = Yr(oi, Ge), fi === null) throw Yr(oi) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                }
                fi.getShaderPrecisionFormat === void 0 && (fi.getShaderPrecisionFormat = function() {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    }
                })
            } catch (Ge) {
                throw console.error("THREE.WebGLRenderer: " + Ge.message), Ge
            }

            function Tn() {
                mt = new Sa(fi), lt = new Ph(fi, mt, s), mt.init(lt), tr = new j(fi, mt, lt), Xe = new I(fi, mt, lt), Zt = new kh, Ie = new Al, pt = new G(fi, mt, Xe, Ie, lt, tr, Zt), xt = new zs(l), Gt = new Hl(fi, lt), jn = new kc(fi, mt, Gt, lt), Xt = new Dc(fi, Gt, Zt, jn), hi = new Zl(fi, Xt, Gt, Zt), er = new Qo(fi), tn = new Sr(Ie), _i = new Xc(l, xt, mt, lt, jn, tn), Di = new ke(Ie), nn = new oc(Ie), Fi = new _(mt, lt), Kn = new Wl(l, xt, Xe, hi, E), gn = new P(l, hi, lt), ia = new Qu(fi, mt, Zt, lt), oa = new Jl(fi, mt, Zt, lt), Zt.programs = _i.programs, l.capabilities = lt, l.extensions = mt, l.properties = Ie, l.renderLists = nn, l.shadowMap = gn, l.state = Xe, l.info = Zt
            }
            Tn();
            const mr = new Me(l, fi);

            function fa(Ge) {
                Ge.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), d = !0
            }

            function qr() {
                console.log("THREE.WebGLRenderer: Context Restored."), d = !1;
                const Ge = Zt.autoReset,
                    oi = gn.enabled,
                    kt = gn.autoUpdate,
                    ui = gn.needsUpdate,
                    Ni = gn.type;
                Tn(), Zt.autoReset = Ge, gn.enabled = oi, gn.autoUpdate = kt, gn.needsUpdate = ui, gn.type = Ni
            }

            function rs(Ge) {
                const oi = Ge.target;
                oi.removeEventListener("dispose", rs),
                    function(kt) {
                        (function(ui) {
                            const Ni = Ie.get(ui).programs;
                            Ni !== void 0 && Ni.forEach(function(Rn) {
                                _i.releaseProgram(Rn)
                            })
                        })(kt), Ie.remove(kt)
                    }(oi)
            }
            this.xr = mr, this.getContext = function() {
                return fi
            }, this.getContextAttributes = function() {
                return fi.getContextAttributes()
            }, this.forceContextLoss = function() {
                const Ge = mt.get("WEBGL_lose_context");
                Ge && Ge.loseContext()
            }, this.forceContextRestore = function() {
                const Ge = mt.get("WEBGL_lose_context");
                Ge && Ge.restoreContext()
            }, this.getPixelRatio = function() {
                return ne
            }, this.setPixelRatio = function(Ge) {
                Ge !== void 0 && (ne = Ge, this.setSize(H, X, !1))
            }, this.getSize = function(Ge) {
                return Ge === void 0 && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), Ge = new Ht), Ge.set(H, X)
            }, this.setSize = function(Ge, oi, kt) {
                mr.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (H = Ge, X = oi, e.width = Math.floor(Ge * ne), e.height = Math.floor(oi * ne), kt !== !1 && (e.style.width = Ge + "px", e.style.height = oi + "px"), this.setViewport(0, 0, Ge, oi))
            }, this.getDrawingBufferSize = function(Ge) {
                return Ge === void 0 && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), Ge = new Ht), Ge.set(H * ne, X * ne).floor()
            }, this.setDrawingBufferSize = function(Ge, oi, kt) {
                H = Ge, X = oi, ne = kt, e.width = Math.floor(Ge * kt), e.height = Math.floor(oi * kt), this.setViewport(0, 0, Ge, oi)
            }, this.getCurrentViewport = function(Ge) {
                return Ge === void 0 && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), Ge = new Si), Ge.copy(D)
            }, this.getViewport = function(Ge) {
                return Ge.copy(Qe)
            }, this.setViewport = function(Ge, oi, kt, ui) {
                Ge.isVector4 ? Qe.set(Ge.x, Ge.y, Ge.z, Ge.w) : Qe.set(Ge, oi, kt, ui), Xe.viewport(D.copy(Qe).multiplyScalar(ne).floor())
            }, this.getScissor = function(Ge) {
                return Ge.copy(Se)
            }, this.setScissor = function(Ge, oi, kt, ui) {
                Ge.isVector4 ? Se.set(Ge.x, Ge.y, Ge.z, Ge.w) : Se.set(Ge, oi, kt, ui), Xe.scissor(U.copy(Se).multiplyScalar(ne).floor())
            }, this.getScissorTest = function() {
                return Re
            }, this.setScissorTest = function(Ge) {
                Xe.setScissorTest(Re = Ge)
            }, this.setOpaqueSort = function(Ge) {
                le = Ge
            }, this.setTransparentSort = function(Ge) {
                ce = Ge
            }, this.getClearColor = function(Ge) {
                return Ge === void 0 && (console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"), Ge = new Rt), Ge.copy(Kn.getClearColor())
            }, this.setClearColor = function() {
                Kn.setClearColor.apply(Kn, arguments)
            }, this.getClearAlpha = function() {
                return Kn.getClearAlpha()
            }, this.setClearAlpha = function() {
                Kn.setClearAlpha.apply(Kn, arguments)
            }, this.clear = function(Ge, oi, kt) {
                let ui = 0;
                (Ge === void 0 || Ge) && (ui |= 16384), (oi === void 0 || oi) && (ui |= 256), (kt === void 0 || kt) && (ui |= 1024), fi.clear(ui)
            }, this.clearColor = function() {
                this.clear(!0, !1, !1)
            }, this.clearDepth = function() {
                this.clear(!1, !0, !1)
            }, this.clearStencil = function() {
                this.clear(!1, !1, !0)
            }, this.dispose = function() {
                e.removeEventListener("webglcontextlost", fa, !1), e.removeEventListener("webglcontextrestored", qr, !1), nn.dispose(), Fi.dispose(), Ie.dispose(), xt.dispose(), hi.dispose(), jn.dispose(), mr.dispose(), mr.removeEventListener("sessionstart", ps), mr.removeEventListener("sessionend", to), ba.stop()
            }, this.renderBufferImmediate = function(Ge, oi) {
                jn.initAttributes();
                const kt = Ie.get(Ge);
                Ge.hasPositions && !kt.position && (kt.position = fi.createBuffer()), Ge.hasNormals && !kt.normal && (kt.normal = fi.createBuffer()), Ge.hasUvs && !kt.uv && (kt.uv = fi.createBuffer()), Ge.hasColors && !kt.color && (kt.color = fi.createBuffer());
                const ui = oi.getAttributes();
                Ge.hasPositions && (fi.bindBuffer(34962, kt.position), fi.bufferData(34962, Ge.positionArray, 35048), jn.enableAttribute(ui.position), fi.vertexAttribPointer(ui.position, 3, 5126, !1, 0, 0)), Ge.hasNormals && (fi.bindBuffer(34962, kt.normal), fi.bufferData(34962, Ge.normalArray, 35048), jn.enableAttribute(ui.normal), fi.vertexAttribPointer(ui.normal, 3, 5126, !1, 0, 0)), Ge.hasUvs && (fi.bindBuffer(34962, kt.uv), fi.bufferData(34962, Ge.uvArray, 35048), jn.enableAttribute(ui.uv), fi.vertexAttribPointer(ui.uv, 2, 5126, !1, 0, 0)), Ge.hasColors && (fi.bindBuffer(34962, kt.color), fi.bufferData(34962, Ge.colorArray, 35048), jn.enableAttribute(ui.color), fi.vertexAttribPointer(ui.color, 3, 5126, !1, 0, 0)), jn.disableUnusedAttributes(), fi.drawArrays(4, 0, Ge.count), Ge.count = 0
            }, this.renderBufferDirect = function(Ge, oi, kt, ui, Ni, Rn) {
                oi === null && (oi = Fe);
                const En = Ni.isMesh && Ni.matrixWorld.determinant() < 0,
                    In = Bu(Ge, oi, ui, Ni);
                Xe.setMaterial(ui, En);
                let ir = kt.index;
                const Sn = kt.attributes.position;
                if (ir === null) {
                    if (Sn === void 0 || Sn.count === 0) return
                } else if (ir.count === 0) return;
                let nr, bn = 1;
                ui.wireframe === !0 && (ir = Xt.getWireframeAttribute(kt), bn = 2), (ui.morphTargets || ui.morphNormals) && er.update(Ni, kt, ui, In), jn.setup(Ni, ui, In, kt, ir);
                let zn = ia;
                ir !== null && (nr = Gt.get(ir), zn = oa, zn.setIndex(nr));
                const ss = ir !== null ? ir.count : Sn.count,
                    Ur = kt.drawRange.start * bn,
                    Ul = kt.drawRange.count * bn,
                    ma = Rn !== null ? Rn.start * bn : 0,
                    Il = Rn !== null ? Rn.count * bn : 1 / 0,
                    Yn = Math.max(Ur, ma),
                    Rr = Math.min(ss, Ur + Ul, ma + Il) - 1,
                    xr = Math.max(0, Rr - Yn + 1);
                if (xr !== 0) {
                    if (Ni.isMesh) ui.wireframe === !0 ? (Xe.setLineWidth(ui.wireframeLinewidth * Be()), zn.setMode(1)) : zn.setMode(4);
                    else if (Ni.isLine) {
                        let Ba = ui.linewidth;
                        Ba === void 0 && (Ba = 1), Xe.setLineWidth(Ba * Be()), Ni.isLineSegments ? zn.setMode(1) : Ni.isLineLoop ? zn.setMode(2) : zn.setMode(3)
                    } else Ni.isPoints ? zn.setMode(0) : Ni.isSprite && zn.setMode(4);
                    if (Ni.isInstancedMesh) zn.renderInstances(Yn, xr, Ni.count);
                    else if (kt.isInstancedBufferGeometry) {
                        const Ba = Math.min(kt.instanceCount, kt._maxInstanceCount);
                        zn.renderInstances(Yn, xr, Ba)
                    } else zn.render(Yn, xr)
                }
            }, this.compile = function(Ge, oi) {
                i = Fi.get(Ge), i.init(), Ge.traverseVisible(function(kt) {
                    kt.isLight && kt.layers.test(oi.layers) && (i.pushLight(kt), kt.castShadow && i.pushShadow(kt))
                }), i.setupLights(), Ge.traverse(function(kt) {
                    const ui = kt.material;
                    if (ui)
                        if (Array.isArray(ui))
                            for (let Ni = 0; Ni < ui.length; Ni++) Dl(ui[Ni], Ge, kt);
                        else Dl(ui, Ge, kt)
                })
            };
            let as = null;

            function ps() {
                ba.stop()
            }

            function to() {
                ba.start()
            }
            const ba = new Pc;

            function Za(Ge, oi, kt, ui) {
                if (Ge.visible === !1) return;
                if (Ge.layers.test(oi.layers)) {
                    if (Ge.isGroup) kt = Ge.renderOrder;
                    else if (Ge.isLOD) Ge.autoUpdate === !0 && Ge.update(oi);
                    else if (Ge.isLight) i.pushLight(Ge), Ge.castShadow && i.pushShadow(Ge);
                    else if (Ge.isSprite) {
                        if (!Ge.frustumCulled || ot.intersectsSprite(Ge)) {
                            ui && qt.setFromMatrixPosition(Ge.matrixWorld).applyMatrix4(Nt);
                            const Rn = hi.update(Ge),
                                En = Ge.material;
                            En.visible && k.push(Ge, Rn, En, kt, qt.z, null)
                        }
                    } else if (Ge.isImmediateRenderObject) ui && qt.setFromMatrixPosition(Ge.matrixWorld).applyMatrix4(Nt), k.push(Ge, null, Ge.material, kt, qt.z, null);
                    else if ((Ge.isMesh || Ge.isLine || Ge.isPoints) && (Ge.isSkinnedMesh && Ge.skeleton.frame !== Zt.render.frame && (Ge.skeleton.update(), Ge.skeleton.frame = Zt.render.frame), !Ge.frustumCulled || ot.intersectsObject(Ge))) {
                        ui && qt.setFromMatrixPosition(Ge.matrixWorld).applyMatrix4(Nt);
                        const Rn = hi.update(Ge),
                            En = Ge.material;
                        if (Array.isArray(En)) {
                            const In = Rn.groups;
                            for (let ir = 0, Sn = In.length; ir < Sn; ir++) {
                                const nr = In[ir],
                                    bn = En[nr.materialIndex];
                                bn && bn.visible && k.push(Ge, Rn, bn, kt, qt.z, nr)
                            }
                        } else En.visible && k.push(Ge, Rn, En, kt, qt.z, null)
                    }
                }
                const Ni = Ge.children;
                for (let Rn = 0, En = Ni.length; Rn < En; Rn++) Za(Ni[Rn], oi, kt, ui)
            }

            function Pa(Ge, oi, kt) {
                const ui = oi.isScene === !0 ? oi.overrideMaterial : null;
                for (let Ni = 0, Rn = Ge.length; Ni < Rn; Ni++) {
                    const En = Ge[Ni],
                        In = En.object,
                        ir = En.geometry,
                        Sn = ui === null ? En.material : ui,
                        nr = En.group;
                    if (kt.isArrayCamera) {
                        const bn = kt.cameras;
                        for (let zn = 0, ss = bn.length; zn < ss; zn++) {
                            const Ur = bn[zn];
                            In.layers.test(Ur.layers) && (Xe.viewport(D.copy(Ur.viewport)), i.setupLightsView(Ur), io(In, oi, Ur, ir, Sn, nr))
                        }
                    } else io(In, oi, kt, ir, Sn, nr)
                }
            }

            function io(Ge, oi, kt, ui, Ni, Rn) {
                if (Ge.onBeforeRender(l, oi, kt, ui, Ni, Rn), Ge.modelViewMatrix.multiplyMatrices(kt.matrixWorldInverse, Ge.matrixWorld), Ge.normalMatrix.getNormalMatrix(Ge.modelViewMatrix), Ge.isImmediateRenderObject) {
                    const En = Bu(kt, oi, Ni, Ge);
                    Xe.setMaterial(Ni), jn.reset(),
                        function(In, ir) {
                            In.render(function(Sn) {
                                l.renderBufferImmediate(Sn, ir)
                            })
                        }(Ge, En)
                } else l.renderBufferDirect(kt, oi, ui, Ni, Ge, Rn);
                Ge.onAfterRender(l, oi, kt, ui, Ni, Rn)
            }

            function Dl(Ge, oi, kt) {
                oi.isScene !== !0 && (oi = Fe);
                const ui = Ie.get(Ge),
                    Ni = i.state.lights,
                    Rn = i.state.shadowsArray,
                    En = Ni.state.version,
                    In = _i.getParameters(Ge, Ni.state, Rn, oi, kt),
                    ir = _i.getProgramCacheKey(In);
                let Sn = ui.programs;
                ui.environment = Ge.isMeshStandardMaterial ? oi.environment : null, ui.fog = oi.fog, ui.envMap = xt.get(Ge.envMap || ui.environment), Sn === void 0 && (Ge.addEventListener("dispose", rs), Sn = new Map, ui.programs = Sn);
                let nr = Sn.get(ir);
                if (nr !== void 0) {
                    if (ui.currentProgram === nr && ui.lightsStateVersion === En) return Ld(Ge, In), nr
                } else In.uniforms = _i.getUniforms(Ge), Ge.onBeforeCompile(In, l), nr = _i.acquireProgram(In, ir), Sn.set(ir, nr), ui.uniforms = In.uniforms;
                const bn = ui.uniforms;
                (Ge.isShaderMaterial || Ge.isRawShaderMaterial) && Ge.clipping !== !0 || (bn.clippingPlanes = tn.uniform), Ld(Ge, In), ui.needsLights = function(Ur) {
                    return Ur.isMeshLambertMaterial || Ur.isMeshToonMaterial || Ur.isMeshPhongMaterial || Ur.isMeshStandardMaterial || Ur.isShadowMaterial || Ur.isShaderMaterial && Ur.lights === !0
                }(Ge), ui.lightsStateVersion = En, ui.needsLights && (bn.ambientLightColor.value = Ni.state.ambient, bn.lightProbe.value = Ni.state.probe, bn.directionalLights.value = Ni.state.directional, bn.directionalLightShadows.value = Ni.state.directionalShadow, bn.spotLights.value = Ni.state.spot, bn.spotLightShadows.value = Ni.state.spotShadow, bn.rectAreaLights.value = Ni.state.rectArea, bn.ltc_1.value = Ni.state.rectAreaLTC1, bn.ltc_2.value = Ni.state.rectAreaLTC2, bn.pointLights.value = Ni.state.point, bn.pointLightShadows.value = Ni.state.pointShadow, bn.hemisphereLights.value = Ni.state.hemi, bn.directionalShadowMap.value = Ni.state.directionalShadowMap, bn.directionalShadowMatrix.value = Ni.state.directionalShadowMatrix, bn.spotShadowMap.value = Ni.state.spotShadowMap, bn.spotShadowMatrix.value = Ni.state.spotShadowMatrix, bn.pointShadowMap.value = Ni.state.pointShadowMap, bn.pointShadowMatrix.value = Ni.state.pointShadowMatrix);
                const zn = nr.getUniforms(),
                    ss = Vs.seqWithValue(zn.seq, bn);
                return ui.currentProgram = nr, ui.uniformsList = ss, nr
            }

            function Ld(Ge, oi) {
                const kt = Ie.get(Ge);
                kt.outputEncoding = oi.outputEncoding, kt.instancing = oi.instancing, kt.numClippingPlanes = oi.numClippingPlanes, kt.numIntersection = oi.numClipIntersection, kt.vertexAlphas = oi.vertexAlphas
            }

            function Bu(Ge, oi, kt, ui) {
                oi.isScene !== !0 && (oi = Fe), pt.resetTextureUnits();
                const Ni = oi.fog,
                    Rn = kt.isMeshStandardMaterial ? oi.environment : null,
                    En = A === null ? l.outputEncoding : A.texture.encoding,
                    In = xt.get(kt.envMap || Rn),
                    ir = kt.vertexColors === !0 && ui.geometry.attributes.color && ui.geometry.attributes.color.itemSize === 4,
                    Sn = Ie.get(kt),
                    nr = i.state.lights;
                if (dt === !0 && (Ct === !0 || Ge !== F)) {
                    const xr = Ge === F && kt.id === M;
                    tn.setState(kt, Ge, xr)
                }
                let bn = !1;
                kt.version === Sn.__version ? Sn.needsLights && Sn.lightsStateVersion !== nr.state.version || Sn.outputEncoding !== En || ui.isInstancedMesh && Sn.instancing === !1 ? bn = !0 : ui.isInstancedMesh || Sn.instancing !== !0 ? Sn.envMap !== In || kt.fog && Sn.fog !== Ni ? bn = !0 : Sn.numClippingPlanes === void 0 || Sn.numClippingPlanes === tn.numPlanes && Sn.numIntersection === tn.numIntersection ? Sn.vertexAlphas !== ir && (bn = !0) : bn = !0 : bn = !0 : (bn = !0, Sn.__version = kt.version);
                let zn = Sn.currentProgram;
                bn === !0 && (zn = Dl(kt, oi, ui));
                let ss = !1,
                    Ur = !1,
                    Ul = !1;
                const ma = zn.getUniforms(),
                    Il = Sn.uniforms;
                if (Xe.useProgram(zn.program) && (ss = !0, Ur = !0, Ul = !0), kt.id !== M && (M = kt.id, Ur = !0), ss || F !== Ge) {
                    if (ma.setValue(fi, "projectionMatrix", Ge.projectionMatrix), lt.logarithmicDepthBuffer && ma.setValue(fi, "logDepthBufFC", 2 / (Math.log(Ge.far + 1) / Math.LN2)), F !== Ge && (F = Ge, Ur = !0, Ul = !0), kt.isShaderMaterial || kt.isMeshPhongMaterial || kt.isMeshToonMaterial || kt.isMeshStandardMaterial || kt.envMap) {
                        const xr = ma.map.cameraPosition;
                        xr !== void 0 && xr.setValue(fi, qt.setFromMatrixPosition(Ge.matrixWorld))
                    }(kt.isMeshPhongMaterial || kt.isMeshToonMaterial || kt.isMeshLambertMaterial || kt.isMeshBasicMaterial || kt.isMeshStandardMaterial || kt.isShaderMaterial) && ma.setValue(fi, "isOrthographic", Ge.isOrthographicCamera === !0), (kt.isMeshPhongMaterial || kt.isMeshToonMaterial || kt.isMeshLambertMaterial || kt.isMeshBasicMaterial || kt.isMeshStandardMaterial || kt.isShaderMaterial || kt.isShadowMaterial || kt.skinning) && ma.setValue(fi, "viewMatrix", Ge.matrixWorldInverse)
                }
                if (kt.skinning) {
                    ma.setOptional(fi, ui, "bindMatrix"), ma.setOptional(fi, ui, "bindMatrixInverse");
                    const xr = ui.skeleton;
                    if (xr) {
                        const Ba = xr.bones;
                        if (lt.floatVertexTextures) {
                            if (xr.boneTexture === null) {
                                let Oa = Math.sqrt(4 * Ba.length);
                                Oa = Mi.ceilPowerOfTwo(Oa), Oa = Math.max(Oa, 4);
                                const fs = new Float32Array(Oa * Oa * 4);
                                fs.set(xr.boneMatrices);
                                const jf = new ws(fs, Oa, Oa, 1023, 1015);
                                xr.boneMatrices = fs, xr.boneTexture = jf, xr.boneTextureSize = Oa
                            }
                            ma.setValue(fi, "boneTexture", xr.boneTexture, pt), ma.setValue(fi, "boneTextureSize", xr.boneTextureSize)
                        } else ma.setOptional(fi, xr, "boneMatrices")
                    }
                }
                var Yn, Rr;
                return (Ur || Sn.receiveShadow !== ui.receiveShadow) && (Sn.receiveShadow = ui.receiveShadow, ma.setValue(fi, "receiveShadow", ui.receiveShadow)), Ur && (ma.setValue(fi, "toneMappingExposure", l.toneMappingExposure), Sn.needsLights && (Rr = Ul, (Yn = Il).ambientLightColor.needsUpdate = Rr, Yn.lightProbe.needsUpdate = Rr, Yn.directionalLights.needsUpdate = Rr, Yn.directionalLightShadows.needsUpdate = Rr, Yn.pointLights.needsUpdate = Rr, Yn.pointLightShadows.needsUpdate = Rr, Yn.spotLights.needsUpdate = Rr, Yn.spotLightShadows.needsUpdate = Rr, Yn.rectAreaLights.needsUpdate = Rr, Yn.hemisphereLights.needsUpdate = Rr), Ni && kt.fog && Di.refreshFogUniforms(Il, Ni), Di.refreshMaterialUniforms(Il, kt, ne, X), Vs.upload(fi, Sn.uniformsList, Il, pt)), kt.isShaderMaterial && kt.uniformsNeedUpdate === !0 && (Vs.upload(fi, Sn.uniformsList, Il, pt), kt.uniformsNeedUpdate = !1), kt.isSpriteMaterial && ma.setValue(fi, "center", ui.center), ma.setValue(fi, "modelViewMatrix", ui.modelViewMatrix), ma.setValue(fi, "normalMatrix", ui.normalMatrix), ma.setValue(fi, "modelMatrix", ui.matrixWorld), zn
            }
            ba.setAnimationLoop(function(Ge) {
                as && as(Ge)
            }), typeof window != "undefined" && ba.setContext(window), this.setAnimationLoop = function(Ge) {
                as = Ge, mr.setAnimationLoop(Ge), Ge === null ? ba.stop() : ba.start()
            }, mr.addEventListener("sessionstart", ps), mr.addEventListener("sessionend", to), this.render = function(Ge, oi) {
                let kt, ui;
                if (arguments[2] !== void 0 && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), kt = arguments[2]), arguments[3] !== void 0 && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), ui = arguments[3]), oi !== void 0 && oi.isCamera !== !0) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                if (d === !0) return;
                Ge.autoUpdate === !0 && Ge.updateMatrixWorld(), oi.parent === null && oi.updateMatrixWorld(), mr.enabled === !0 && mr.isPresenting === !0 && (oi = mr.getCamera(oi)), Ge.isScene === !0 && Ge.onBeforeRender(l, Ge, oi, kt || A), i = Fi.get(Ge, a.length), i.init(), a.push(i), Nt.multiplyMatrices(oi.projectionMatrix, oi.matrixWorldInverse), ot.setFromProjectionMatrix(Nt), Ct = this.localClippingEnabled, dt = tn.init(this.clippingPlanes, Ct, oi), k = nn.get(Ge, t.length), k.init(), t.push(k), Za(Ge, oi, 0, l.sortObjects), k.finish(), l.sortObjects === !0 && k.sort(le, ce), dt === !0 && tn.beginShadows();
                const Ni = i.state.shadowsArray;
                gn.render(Ni, Ge, oi), i.setupLights(), i.setupLightsView(oi), dt === !0 && tn.endShadows(), this.info.autoReset === !0 && this.info.reset(), kt !== void 0 && this.setRenderTarget(kt), Kn.render(k, Ge, oi, ui);
                const Rn = k.opaque,
                    En = k.transparent;
                Rn.length > 0 && Pa(Rn, Ge, oi), En.length > 0 && Pa(En, Ge, oi), A !== null && (pt.updateRenderTargetMipmap(A), pt.updateMultisampleRenderTarget(A)), Ge.isScene === !0 && Ge.onAfterRender(l, Ge, oi), Xe.buffers.depth.setTest(!0), Xe.buffers.depth.setMask(!0), Xe.buffers.color.setMask(!0), Xe.setPolygonOffset(!1), jn.resetDefaultState(), M = -1, F = null, a.pop(), i = a.length > 0 ? a[a.length - 1] : null, t.pop(), k = t.length > 0 ? t[t.length - 1] : null
            }, this.getActiveCubeFace = function() {
                return g
            }, this.getActiveMipmapLevel = function() {
                return x
            }, this.getRenderTarget = function() {
                return A
            }, this.setRenderTarget = function(Ge, oi = 0, kt = 0) {
                A = Ge, g = oi, x = kt, Ge && Ie.get(Ge).__webglFramebuffer === void 0 && pt.setupRenderTarget(Ge);
                let ui = null,
                    Ni = !1,
                    Rn = !1;
                if (Ge) {
                    const En = Ge.texture;
                    (En.isDataTexture3D || En.isDataTexture2DArray) && (Rn = !0);
                    const In = Ie.get(Ge).__webglFramebuffer;
                    Ge.isWebGLCubeRenderTarget ? (ui = In[oi], Ni = !0) : ui = Ge.isWebGLMultisampleRenderTarget ? Ie.get(Ge).__webglMultisampledFramebuffer : In, D.copy(Ge.viewport), U.copy(Ge.scissor), N = Ge.scissorTest
                } else D.copy(Qe).multiplyScalar(ne).floor(), U.copy(Se).multiplyScalar(ne).floor(), N = Re;
                if (Xe.bindFramebuffer(36160, ui), Xe.viewport(D), Xe.scissor(U), Xe.setScissorTest(N), Ni) {
                    const En = Ie.get(Ge.texture);
                    fi.framebufferTexture2D(36160, 36064, 34069 + oi, En.__webglTexture, kt)
                } else if (Rn) {
                    const En = Ie.get(Ge.texture),
                        In = oi || 0;
                    fi.framebufferTextureLayer(36160, 36064, En.__webglTexture, kt || 0, In)
                }
            }, this.readRenderTargetPixels = function(Ge, oi, kt, ui, Ni, Rn, En) {
                if (!Ge || !Ge.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                let In = Ie.get(Ge).__webglFramebuffer;
                if (Ge.isWebGLCubeRenderTarget && En !== void 0 && (In = In[En]), In) {
                    Xe.bindFramebuffer(36160, In);
                    try {
                        const ir = Ge.texture,
                            Sn = ir.format,
                            nr = ir.type;
                        if (Sn !== 1023 && tr.convert(Sn) !== fi.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        const bn = nr === 1016 && (mt.has("EXT_color_buffer_half_float") || lt.isWebGL2 && mt.has("EXT_color_buffer_float"));
                        if (!(nr === 1009 || tr.convert(nr) === fi.getParameter(35738) || nr === 1015 && (lt.isWebGL2 || mt.has("OES_texture_float") || mt.has("WEBGL_color_buffer_float")) || bn)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        fi.checkFramebufferStatus(36160) === 36053 ? oi >= 0 && oi <= Ge.width - ui && kt >= 0 && kt <= Ge.height - Ni && fi.readPixels(oi, kt, ui, Ni, tr.convert(Sn), tr.convert(nr), Rn) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                    } finally {
                        const ir = A !== null ? Ie.get(A).__webglFramebuffer : null;
                        Xe.bindFramebuffer(36160, ir)
                    }
                }
            }, this.copyFramebufferToTexture = function(Ge, oi, kt = 0) {
                const ui = Math.pow(2, -kt),
                    Ni = Math.floor(oi.image.width * ui),
                    Rn = Math.floor(oi.image.height * ui),
                    En = tr.convert(oi.format);
                pt.setTexture2D(oi, 0), fi.copyTexImage2D(3553, kt, En, Ge.x, Ge.y, Ni, Rn, 0), Xe.unbindTexture()
            }, this.copyTextureToTexture = function(Ge, oi, kt, ui = 0) {
                const Ni = oi.image.width,
                    Rn = oi.image.height,
                    En = tr.convert(kt.format),
                    In = tr.convert(kt.type);
                pt.setTexture2D(kt, 0), fi.pixelStorei(37440, kt.flipY), fi.pixelStorei(37441, kt.premultiplyAlpha), fi.pixelStorei(3317, kt.unpackAlignment), oi.isDataTexture ? fi.texSubImage2D(3553, ui, Ge.x, Ge.y, Ni, Rn, En, In, oi.image.data) : oi.isCompressedTexture ? fi.compressedTexSubImage2D(3553, ui, Ge.x, Ge.y, oi.mipmaps[0].width, oi.mipmaps[0].height, En, oi.mipmaps[0].data) : fi.texSubImage2D(3553, ui, Ge.x, Ge.y, En, In, oi.image), ui === 0 && kt.generateMipmaps && fi.generateMipmap(3553), Xe.unbindTexture()
            }, this.copyTextureToTexture3D = function(Ge, oi, kt, ui, Ni = 0) {
                if (l.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                const {
                    width: Rn,
                    height: En,
                    data: In
                } = kt.image, ir = tr.convert(ui.format), Sn = tr.convert(ui.type);
                let nr;
                if (ui.isDataTexture3D) pt.setTexture3D(ui, 0), nr = 32879;
                else {
                    if (!ui.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                    pt.setTexture2DArray(ui, 0), nr = 35866
                }
                fi.pixelStorei(37440, ui.flipY), fi.pixelStorei(37441, ui.premultiplyAlpha), fi.pixelStorei(3317, ui.unpackAlignment);
                const bn = fi.getParameter(3314),
                    zn = fi.getParameter(32878),
                    ss = fi.getParameter(3316),
                    Ur = fi.getParameter(3315),
                    Ul = fi.getParameter(32877);
                fi.pixelStorei(3314, Rn), fi.pixelStorei(32878, En), fi.pixelStorei(3316, Ge.min.x), fi.pixelStorei(3315, Ge.min.y), fi.pixelStorei(32877, Ge.min.z), fi.texSubImage3D(nr, Ni, oi.x, oi.y, oi.z, Ge.max.x - Ge.min.x + 1, Ge.max.y - Ge.min.y + 1, Ge.max.z - Ge.min.z + 1, ir, Sn, In), fi.pixelStorei(3314, bn), fi.pixelStorei(32878, zn), fi.pixelStorei(3316, ss), fi.pixelStorei(3315, Ur), fi.pixelStorei(32877, Ul), Ni === 0 && ui.generateMipmaps && fi.generateMipmap(nr), Xe.unbindTexture()
            }, this.initTexture = function(Ge) {
                pt.setTexture2D(Ge, 0), Xe.unbindTexture()
            }, this.resetState = function() {
                g = 0, x = 0, A = null, Xe.reset(), jn.reset()
            }, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }))
        }
        pe.prototype.isGroup = !0, Object.assign(Ce.prototype, {
            constructor: Ce,
            getHandSpace: function() {
                return this._hand === null && (this._hand = new pe, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                    pinching: !1
                }), this._hand
            },
            getTargetRaySpace: function() {
                return this._targetRay === null && (this._targetRay = new pe, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay
            },
            getGripSpace: function() {
                return this._grip === null && (this._grip = new pe, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip
            },
            dispatchEvent: function(s) {
                return this._targetRay !== null && this._targetRay.dispatchEvent(s), this._grip !== null && this._grip.dispatchEvent(s), this._hand !== null && this._hand.dispatchEvent(s), this
            },
            disconnect: function(s) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: s
                }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this
            },
            update: function(s, e, r) {
                let h = null,
                    c = null,
                    v = null;
                const w = this._targetRay,
                    E = this._grip,
                    T = this._hand;
                if (s && e.session.visibilityState !== "visible-blurred")
                    if (w !== null && (h = e.getPose(s.targetRaySpace, r), h !== null && (w.matrix.fromArray(h.transform.matrix), w.matrix.decompose(w.position, w.rotation, w.scale))), T && s.hand) {
                        v = !0;
                        for (const a of s.hand.values()) {
                            const l = e.getJointPose(a, r);
                            if (T.joints[a.jointName] === void 0) {
                                const g = new pe;
                                g.matrixAutoUpdate = !1, g.visible = !1, T.joints[a.jointName] = g, T.add(g)
                            }
                            const d = T.joints[a.jointName];
                            l !== null && (d.matrix.fromArray(l.transform.matrix), d.matrix.decompose(d.position, d.rotation, d.scale), d.jointRadius = l.radius), d.visible = l !== null
                        }
                        const B = T.joints["index-finger-tip"],
                            Q = T.joints["thumb-tip"],
                            k = B.position.distanceTo(Q.position),
                            i = .02,
                            t = .005;
                        T.inputState.pinching && k > i + t ? (T.inputState.pinching = !1, this.dispatchEvent({
                            type: "pinchend",
                            handedness: s.handedness,
                            target: this
                        })) : !T.inputState.pinching && k <= i - t && (T.inputState.pinching = !0, this.dispatchEvent({
                            type: "pinchstart",
                            handedness: s.handedness,
                            target: this
                        }))
                    } else E !== null && s.gripSpace && (c = e.getPose(s.gripSpace, r), c !== null && (E.matrix.fromArray(c.transform.matrix), E.matrix.decompose(E.position, E.rotation, E.scale)));
                return w !== null && (w.visible = h !== null), E !== null && (E.visible = c !== null), T !== null && (T.visible = v !== null), this
            }
        }), Object.assign(Me.prototype, yn.prototype);
        class nt extends we {}
        nt.prototype.isWebGL1Renderer = !0;
        class bt {
            constructor(e, r = 25e-5) {
                this.name = "", this.color = new Rt(e), this.density = r
            }
            clone() {
                return new bt(this.color, this.density)
            }
            toJSON() {
                return {
                    type: "FogExp2",
                    color: this.color.getHex(),
                    density: this.density
                }
            }
        }
        bt.prototype.isFogExp2 = !0;
        class ze {
            constructor(e, r = 1, h = 1e3) {
                this.name = "", this.color = new Rt(e), this.near = r, this.far = h
            }
            clone() {
                return new ze(this.color, this.near, this.far)
            }
            toJSON() {
                return {
                    type: "Fog",
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }
        }
        ze.prototype.isFog = !0;
        class ut extends Z {
            constructor() {
                super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            copy(e, r) {
                return super.copy(e, r), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
            }
            toJSON(e) {
                const r = super.toJSON(e);
                return this.background !== null && (r.object.background = this.background.toJSON(e)), this.environment !== null && (r.object.environment = this.environment.toJSON(e)), this.fog !== null && (r.object.fog = this.fog.toJSON()), r
            }
        }

        function St(s, e) {
            this.array = s, this.stride = e, this.count = s !== void 0 ? s.length / e : 0, this.usage = 35044, this.updateRange = {
                offset: 0,
                count: -1
            }, this.version = 0, this.uuid = Mi.generateUUID()
        }
        ut.prototype.isScene = !0, Object.defineProperty(St.prototype, "needsUpdate", {
            set: function(s) {
                s === !0 && this.version++
            }
        }), Object.assign(St.prototype, {
            isInterleavedBuffer: !0,
            onUploadCallback: function() {},
            setUsage: function(s) {
                return this.usage = s, this
            },
            copy: function(s) {
                return this.array = new s.array.constructor(s.array), this.count = s.count, this.stride = s.stride, this.usage = s.usage, this
            },
            copyAt: function(s, e, r) {
                s *= this.stride, r *= e.stride;
                for (let h = 0, c = this.stride; h < c; h++) this.array[s + h] = e.array[r + h];
                return this
            },
            set: function(s, e = 0) {
                return this.array.set(s, e), this
            },
            clone: function(s) {
                s.arrayBuffers === void 0 && (s.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Mi.generateUUID()), s.arrayBuffers[this.array.buffer._uuid] === void 0 && (s.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                const e = new St(new this.array.constructor(s.arrayBuffers[this.array.buffer._uuid]), this.stride);
                return e.setUsage(this.usage), e
            },
            onUpload: function(s) {
                return this.onUploadCallback = s, this
            },
            toJSON: function(s) {
                return s.arrayBuffers === void 0 && (s.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Mi.generateUUID()), s.arrayBuffers[this.array.buffer._uuid] === void 0 && (s.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                }
            }
        });
        const yt = new ge;

        function Vt(s, e, r, h) {
            this.name = "", this.data = s, this.itemSize = e, this.offset = r, this.normalized = h === !0
        }
        Object.defineProperties(Vt.prototype, {
            count: {
                get: function() {
                    return this.data.count
                }
            },
            array: {
                get: function() {
                    return this.data.array
                }
            },
            needsUpdate: {
                set: function(s) {
                    this.data.needsUpdate = s
                }
            }
        }), Object.assign(Vt.prototype, {
            isInterleavedBufferAttribute: !0,
            applyMatrix4: function(s) {
                for (let e = 0, r = this.data.count; e < r; e++) yt.x = this.getX(e), yt.y = this.getY(e), yt.z = this.getZ(e), yt.applyMatrix4(s), this.setXYZ(e, yt.x, yt.y, yt.z);
                return this
            },
            applyNormalMatrix: function(s) {
                for (let e = 0, r = this.count; e < r; e++) yt.x = this.getX(e), yt.y = this.getY(e), yt.z = this.getZ(e), yt.applyNormalMatrix(s), this.setXYZ(e, yt.x, yt.y, yt.z);
                return this
            },
            transformDirection: function(s) {
                for (let e = 0, r = this.count; e < r; e++) yt.x = this.getX(e), yt.y = this.getY(e), yt.z = this.getZ(e), yt.transformDirection(s), this.setXYZ(e, yt.x, yt.y, yt.z);
                return this
            },
            setX: function(s, e) {
                return this.data.array[s * this.data.stride + this.offset] = e, this
            },
            setY: function(s, e) {
                return this.data.array[s * this.data.stride + this.offset + 1] = e, this
            },
            setZ: function(s, e) {
                return this.data.array[s * this.data.stride + this.offset + 2] = e, this
            },
            setW: function(s, e) {
                return this.data.array[s * this.data.stride + this.offset + 3] = e, this
            },
            getX: function(s) {
                return this.data.array[s * this.data.stride + this.offset]
            },
            getY: function(s) {
                return this.data.array[s * this.data.stride + this.offset + 1]
            },
            getZ: function(s) {
                return this.data.array[s * this.data.stride + this.offset + 2]
            },
            getW: function(s) {
                return this.data.array[s * this.data.stride + this.offset + 3]
            },
            setXY: function(s, e, r) {
                return s = s * this.data.stride + this.offset, this.data.array[s + 0] = e, this.data.array[s + 1] = r, this
            },
            setXYZ: function(s, e, r, h) {
                return s = s * this.data.stride + this.offset, this.data.array[s + 0] = e, this.data.array[s + 1] = r, this.data.array[s + 2] = h, this
            },
            setXYZW: function(s, e, r, h, c) {
                return s = s * this.data.stride + this.offset, this.data.array[s + 0] = e, this.data.array[s + 1] = r, this.data.array[s + 2] = h, this.data.array[s + 3] = c, this
            },
            clone: function(s) {
                if (s === void 0) {
                    console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                    const e = [];
                    for (let r = 0; r < this.count; r++) {
                        const h = r * this.data.stride + this.offset;
                        for (let c = 0; c < this.itemSize; c++) e.push(this.data.array[h + c])
                    }
                    return new pi(new this.array.constructor(e), this.itemSize, this.normalized)
                }
                return s.interleavedBuffers === void 0 && (s.interleavedBuffers = {}), s.interleavedBuffers[this.data.uuid] === void 0 && (s.interleavedBuffers[this.data.uuid] = this.data.clone(s)), new Vt(s.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
            },
            toJSON: function(s) {
                if (s === void 0) {
                    console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                    const e = [];
                    for (let r = 0; r < this.count; r++) {
                        const h = r * this.data.stride + this.offset;
                        for (let c = 0; c < this.itemSize; c++) e.push(this.data.array[h + c])
                    }
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: e,
                        normalized: this.normalized
                    }
                }
                return s.interleavedBuffers === void 0 && (s.interleavedBuffers = {}), s.interleavedBuffers[this.data.uuid] === void 0 && (s.interleavedBuffers[this.data.uuid] = this.data.toJSON(s)), {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                }
            }
        });
        class ci extends ti {
            constructor(e) {
                super(), this.type = "SpriteMaterial", this.color = new Rt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this
            }
        }
        let $t;
        ci.prototype.isSpriteMaterial = !0;
        const gi = new ge,
            Ri = new ge,
            Ki = new ge,
            wi = new Ht,
            $i = new Ht,
            Vi = new Ui,
            Jn = new ge,
            xn = new ge,
            mn = new ge,
            wn = new Ht,
            Tr = new Ht,
            Hn = new Ht;
        class sa extends Z {
            constructor(e) {
                if (super(), this.type = "Sprite", $t === void 0) {
                    $t = new an;
                    const r = new St(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5);
                    $t.setIndex([0, 1, 2, 0, 2, 3]), $t.setAttribute("position", new Vt(r, 3, 0, !1)), $t.setAttribute("uv", new Vt(r, 2, 3, !1))
                }
                this.geometry = $t, this.material = e !== void 0 ? e : new ci, this.center = new Ht(.5, .5)
            }
            raycast(e, r) {
                e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Ri.setFromMatrixScale(this.matrixWorld), Vi.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Ki.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Ri.multiplyScalar(-Ki.z);
                const h = this.material.rotation;
                let c, v;
                h !== 0 && (v = Math.cos(h), c = Math.sin(h));
                const w = this.center;
                Gr(Jn.set(-.5, -.5, 0), Ki, w, Ri, c, v), Gr(xn.set(.5, -.5, 0), Ki, w, Ri, c, v), Gr(mn.set(.5, .5, 0), Ki, w, Ri, c, v), wn.set(0, 0), Tr.set(1, 0), Hn.set(1, 1);
                let E = e.ray.intersectTriangle(Jn, xn, mn, !1, gi);
                if (E === null && (Gr(xn.set(-.5, .5, 0), Ki, w, Ri, c, v), Tr.set(0, 1), E = e.ray.intersectTriangle(Jn, mn, xn, !1, gi), E === null)) return;
                const T = e.ray.origin.distanceTo(gi);
                T < e.near || T > e.far || r.push({
                    distance: T,
                    point: gi.clone(),
                    uv: Mt.getUV(gi, Jn, xn, mn, wn, Tr, Hn, new Ht),
                    face: null,
                    object: this
                })
            }
            copy(e) {
                return super.copy(e), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this
            }
        }

        function Gr(s, e, r, h, c, v) {
            wi.subVectors(s, r).addScalar(.5).multiply(h), c !== void 0 ? ($i.x = v * wi.x - c * wi.y, $i.y = c * wi.x + v * wi.y) : $i.copy(wi), s.copy(e), s.x += $i.x, s.y += $i.y, s.applyMatrix4(Vi)
        }
        sa.prototype.isSprite = !0;
        const hr = new ge,
            da = new ge;
        class pa extends Z {
            constructor() {
                super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    },
                    isLOD: {
                        value: !0
                    }
                }), this.autoUpdate = !0
            }
            copy(e) {
                super.copy(e, !1);
                const r = e.levels;
                for (let h = 0, c = r.length; h < c; h++) {
                    const v = r[h];
                    this.addLevel(v.object.clone(), v.distance)
                }
                return this.autoUpdate = e.autoUpdate, this
            }
            addLevel(e, r = 0) {
                r = Math.abs(r);
                const h = this.levels;
                let c;
                for (c = 0; c < h.length && !(r < h[c].distance); c++);
                return h.splice(c, 0, {
                    distance: r,
                    object: e
                }), this.add(e), this
            }
            getCurrentLevel() {
                return this._currentLevel
            }
            getObjectForDistance(e) {
                const r = this.levels;
                if (r.length > 0) {
                    let h, c;
                    for (h = 1, c = r.length; h < c && !(e < r[h].distance); h++);
                    return r[h - 1].object
                }
                return null
            }
            raycast(e, r) {
                if (this.levels.length > 0) {
                    hr.setFromMatrixPosition(this.matrixWorld);
                    const h = e.ray.origin.distanceTo(hr);
                    this.getObjectForDistance(h).raycast(e, r)
                }
            }
            update(e) {
                const r = this.levels;
                if (r.length > 1) {
                    hr.setFromMatrixPosition(e.matrixWorld), da.setFromMatrixPosition(this.matrixWorld);
                    const h = hr.distanceTo(da) / e.zoom;
                    let c, v;
                    for (r[0].object.visible = !0, c = 1, v = r.length; c < v && h >= r[c].distance; c++) r[c - 1].object.visible = !1, r[c].object.visible = !0;
                    for (this._currentLevel = c - 1; c < v; c++) r[c].object.visible = !1
                }
            }
            toJSON(e) {
                const r = super.toJSON(e);
                this.autoUpdate === !1 && (r.object.autoUpdate = !1), r.object.levels = [];
                const h = this.levels;
                for (let c = 0, v = h.length; c < v; c++) {
                    const w = h[c];
                    r.object.levels.push({
                        object: w.object.uuid,
                        distance: w.distance
                    })
                }
                return r
            }
        }
        const Ia = new ge,
            Ts = new Si,
            mo = new Si,
            No = new ge,
            Ms = new Ui;

        function Mr(s, e) {
            ar.call(this, s, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Ui, this.bindMatrixInverse = new Ui
        }

        function pr() {
            Z.call(this), this.type = "Bone"
        }
        Mr.prototype = Object.assign(Object.create(ar.prototype), {
            constructor: Mr,
            isSkinnedMesh: !0,
            copy: function(s) {
                return ar.prototype.copy.call(this, s), this.bindMode = s.bindMode, this.bindMatrix.copy(s.bindMatrix), this.bindMatrixInverse.copy(s.bindMatrixInverse), this.skeleton = s.skeleton, this
            },
            bind: function(s, e) {
                this.skeleton = s, e === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
            },
            pose: function() {
                this.skeleton.pose()
            },
            normalizeSkinWeights: function() {
                const s = new Si,
                    e = this.geometry.attributes.skinWeight;
                for (let r = 0, h = e.count; r < h; r++) {
                    s.x = e.getX(r), s.y = e.getY(r), s.z = e.getZ(r), s.w = e.getW(r);
                    const c = 1 / s.manhattanLength();
                    c !== 1 / 0 ? s.multiplyScalar(c) : s.set(1, 0, 0, 0), e.setXYZW(r, s.x, s.y, s.z, s.w)
                }
            },
            updateMatrixWorld: function(s) {
                ar.prototype.updateMatrixWorld.call(this, s), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            },
            boneTransform: function(s, e) {
                const r = this.skeleton,
                    h = this.geometry;
                Ts.fromBufferAttribute(h.attributes.skinIndex, s), mo.fromBufferAttribute(h.attributes.skinWeight, s), Ia.fromBufferAttribute(h.attributes.position, s).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                for (let c = 0; c < 4; c++) {
                    const v = mo.getComponent(c);
                    if (v !== 0) {
                        const w = Ts.getComponent(c);
                        Ms.multiplyMatrices(r.bones[w].matrixWorld, r.boneInverses[w]), e.addScaledVector(No.copy(Ia).applyMatrix4(Ms), v)
                    }
                }
                return e.applyMatrix4(this.bindMatrixInverse)
            }
        }), pr.prototype = Object.assign(Object.create(Z.prototype), {
            constructor: pr,
            isBone: !0
        });
        const yr = new Ui,
            Ta = new Ui;
        class Zn {
            constructor(e = [], r = []) {
                this.uuid = Mi.generateUUID(), this.bones = e.slice(0), this.boneInverses = r, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
            }
            init() {
                const e = this.bones,
                    r = this.boneInverses;
                if (this.boneMatrices = new Float32Array(16 * e.length), r.length === 0) this.calculateInverses();
                else if (e.length !== r.length) {
                    console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                    for (let h = 0, c = this.bones.length; h < c; h++) this.boneInverses.push(new Ui)
                }
            }
            calculateInverses() {
                this.boneInverses.length = 0;
                for (let e = 0, r = this.bones.length; e < r; e++) {
                    const h = new Ui;
                    this.bones[e] && h.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(h)
                }
            }
            pose() {
                for (let e = 0, r = this.bones.length; e < r; e++) {
                    const h = this.bones[e];
                    h && h.matrixWorld.copy(this.boneInverses[e]).invert()
                }
                for (let e = 0, r = this.bones.length; e < r; e++) {
                    const h = this.bones[e];
                    h && (h.parent && h.parent.isBone ? (h.matrix.copy(h.parent.matrixWorld).invert(), h.matrix.multiply(h.matrixWorld)) : h.matrix.copy(h.matrixWorld), h.matrix.decompose(h.position, h.quaternion, h.scale))
                }
            }
            update() {
                const e = this.bones,
                    r = this.boneInverses,
                    h = this.boneMatrices,
                    c = this.boneTexture;
                for (let v = 0, w = e.length; v < w; v++) {
                    const E = e[v] ? e[v].matrixWorld : Ta;
                    yr.multiplyMatrices(E, r[v]), yr.toArray(h, 16 * v)
                }
                c !== null && (c.needsUpdate = !0)
            }
            clone() {
                return new Zn(this.bones, this.boneInverses)
            }
            getBoneByName(e) {
                for (let r = 0, h = this.bones.length; r < h; r++) {
                    const c = this.bones[r];
                    if (c.name === e) return c
                }
            }
            dispose() {
                this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null)
            }
            fromJSON(e, r) {
                this.uuid = e.uuid;
                for (let h = 0, c = e.bones.length; h < c; h++) {
                    const v = e.bones[h];
                    let w = r[v];
                    w === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", v), w = new pr), this.bones.push(w), this.boneInverses.push(new Ui().fromArray(e.boneInverses[h]))
                }
                return this.init(), this
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.5,
                        type: "Skeleton",
                        generator: "Skeleton.toJSON"
                    },
                    bones: [],
                    boneInverses: []
                };
                e.uuid = this.uuid;
                const r = this.bones,
                    h = this.boneInverses;
                for (let c = 0, v = r.length; c < v; c++) {
                    const w = r[c];
                    e.bones.push(w.uuid);
                    const E = h[c];
                    e.boneInverses.push(E.toArray())
                }
                return e
            }
        }
        const Zr = new Ui,
            ea = new Ui,
            Dr = [],
            Oo = new ar;

        function fr(s, e, r) {
            ar.call(this, s, e), this.instanceMatrix = new pi(new Float32Array(16 * r), 16), this.instanceColor = null, this.count = r, this.frustumCulled = !1
        }
        fr.prototype = Object.assign(Object.create(ar.prototype), {
            constructor: fr,
            isInstancedMesh: !0,
            copy: function(s) {
                return ar.prototype.copy.call(this, s), this.instanceMatrix.copy(s.instanceMatrix), s.instanceColor !== null && (this.instanceColor = s.instanceColor.clone()), this.count = s.count, this
            },
            getColorAt: function(s, e) {
                e.fromArray(this.instanceColor.array, 3 * s)
            },
            getMatrixAt: function(s, e) {
                e.fromArray(this.instanceMatrix.array, 16 * s)
            },
            raycast: function(s, e) {
                const r = this.matrixWorld,
                    h = this.count;
                if (Oo.geometry = this.geometry, Oo.material = this.material, Oo.material !== void 0)
                    for (let c = 0; c < h; c++) {
                        this.getMatrixAt(c, Zr), ea.multiplyMatrices(r, Zr), Oo.matrixWorld = ea, Oo.raycast(s, Dr);
                        for (let v = 0, w = Dr.length; v < w; v++) {
                            const E = Dr[v];
                            E.instanceId = c, E.object = this, e.push(E)
                        }
                        Dr.length = 0
                    }
            },
            setColorAt: function(s, e) {
                this.instanceColor === null && (this.instanceColor = new pi(new Float32Array(3 * this.count), 3)), e.toArray(this.instanceColor.array, 3 * s)
            },
            setMatrixAt: function(s, e) {
                e.toArray(this.instanceMatrix.array, 16 * s)
            },
            updateMorphTargets: function() {},
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        });
        class Xr extends ti {
            constructor(e) {
                super(), this.type = "LineBasicMaterial", this.color = new Rt(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.morphTargets = e.morphTargets, this
            }
        }
        Xr.prototype.isLineBasicMaterial = !0;
        const qc = new ge,
            Hs = new ge,
            Ws = new Ui,
            Ka = new wr,
            go = new Fn;

        function za(s = new an, e = new Xr) {
            Z.call(this), this.type = "Line", this.geometry = s, this.material = e, this.updateMorphTargets()
        }
        za.prototype = Object.assign(Object.create(Z.prototype), {
            constructor: za,
            isLine: !0,
            copy: function(s) {
                return Z.prototype.copy.call(this, s), this.material = s.material, this.geometry = s.geometry, this
            },
            computeLineDistances: function() {
                const s = this.geometry;
                if (s.isBufferGeometry)
                    if (s.index === null) {
                        const e = s.attributes.position,
                            r = [0];
                        for (let h = 1, c = e.count; h < c; h++) qc.fromBufferAttribute(e, h - 1), Hs.fromBufferAttribute(e, h), r[h] = r[h - 1], r[h] += qc.distanceTo(Hs);
                        s.setAttribute("lineDistance", new Ai(r, 1))
                    } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else s.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                return this
            },
            raycast: function(s, e) {
                const r = this.geometry,
                    h = this.matrixWorld,
                    c = s.params.Line.threshold,
                    v = r.drawRange;
                if (r.boundingSphere === null && r.computeBoundingSphere(), go.copy(r.boundingSphere), go.applyMatrix4(h), go.radius += c, s.ray.intersectsSphere(go) === !1) return;
                Ws.copy(h).invert(), Ka.copy(s.ray).applyMatrix4(Ws);
                const w = c / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    E = w * w,
                    T = new ge,
                    B = new ge,
                    Q = new ge,
                    k = new ge,
                    i = this.isLineSegments ? 2 : 1;
                if (r.isBufferGeometry) {
                    const t = r.index,
                        a = r.attributes.position;
                    if (t !== null)
                        for (let l = Math.max(0, v.start), d = Math.min(t.count, v.start + v.count) - 1; l < d; l += i) {
                            const g = t.getX(l),
                                x = t.getX(l + 1);
                            if (T.fromBufferAttribute(a, g), B.fromBufferAttribute(a, x), Ka.distanceSqToSegment(T, B, k, Q) > E) continue;
                            k.applyMatrix4(this.matrixWorld);
                            const A = s.ray.origin.distanceTo(k);
                            A < s.near || A > s.far || e.push({
                                distance: A,
                                point: Q.clone().applyMatrix4(this.matrixWorld),
                                index: l,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        } else
                            for (let l = Math.max(0, v.start), d = Math.min(a.count, v.start + v.count) - 1; l < d; l += i) {
                                if (T.fromBufferAttribute(a, l), B.fromBufferAttribute(a, l + 1), Ka.distanceSqToSegment(T, B, k, Q) > E) continue;
                                k.applyMatrix4(this.matrixWorld);
                                const g = s.ray.origin.distanceTo(k);
                                g < s.near || g > s.far || e.push({
                                    distance: g,
                                    point: Q.clone().applyMatrix4(this.matrixWorld),
                                    index: l,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                } else r.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            },
            updateMorphTargets: function() {
                const s = this.geometry;
                if (s.isBufferGeometry) {
                    const e = s.morphAttributes,
                        r = Object.keys(e);
                    if (r.length > 0) {
                        const h = e[r[0]];
                        if (h !== void 0) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let c = 0, v = h.length; c < v; c++) {
                                const w = h[c].name || String(c);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[w] = c
                            }
                        }
                    }
                } else {
                    const e = s.morphTargets;
                    e !== void 0 && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
        });
        const $c = new ge,
            Tl = new ge;

        function xa(s, e) {
            za.call(this, s, e), this.type = "LineSegments"
        }
        xa.prototype = Object.assign(Object.create(za.prototype), {
            constructor: xa,
            isLineSegments: !0,
            computeLineDistances: function() {
                const s = this.geometry;
                if (s.isBufferGeometry)
                    if (s.index === null) {
                        const e = s.attributes.position,
                            r = [];
                        for (let h = 0, c = e.count; h < c; h += 2) $c.fromBufferAttribute(e, h), Tl.fromBufferAttribute(e, h + 1), r[h] = h === 0 ? 0 : r[h - 1], r[h + 1] = r[h] + $c.distanceTo(Tl);
                        s.setAttribute("lineDistance", new Ai(r, 1))
                    } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else s.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                return this
            }
        });
        class yo extends za {
            constructor(e, r) {
                super(e, r), this.type = "LineLoop"
            }
        }
        yo.prototype.isLineLoop = !0;
        class Ml extends ti {
            constructor(e) {
                super(), this.type = "PointsMaterial", this.color = new Rt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this
            }
        }
        Ml.prototype.isPointsMaterial = !0;
        const Hh = new Ui,
            Wh = new wr,
            Kc = new Fn,
            vo = new ge;

        function lc(s = new an, e = new Ml) {
            Z.call(this), this.type = "Points", this.geometry = s, this.material = e, this.updateMorphTargets()
        }

        function cc(s, e, r, h, c, v, w) {
            const E = Wh.distanceSqToPoint(s);
            if (E < r) {
                const T = new ge;
                Wh.closestPointToPoint(s, T), T.applyMatrix4(h);
                const B = c.ray.origin.distanceTo(T);
                if (B < c.near || B > c.far) return;
                v.push({
                    distance: B,
                    distanceToRay: Math.sqrt(E),
                    point: T,
                    index: e,
                    face: null,
                    object: w
                })
            }
        }
        lc.prototype = Object.assign(Object.create(Z.prototype), {
            constructor: lc,
            isPoints: !0,
            copy: function(s) {
                return Z.prototype.copy.call(this, s), this.material = s.material, this.geometry = s.geometry, this
            },
            raycast: function(s, e) {
                const r = this.geometry,
                    h = this.matrixWorld,
                    c = s.params.Points.threshold,
                    v = r.drawRange;
                if (r.boundingSphere === null && r.computeBoundingSphere(), Kc.copy(r.boundingSphere), Kc.applyMatrix4(h), Kc.radius += c, s.ray.intersectsSphere(Kc) === !1) return;
                Hh.copy(h).invert(), Wh.copy(s.ray).applyMatrix4(Hh);
                const w = c / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    E = w * w;
                if (r.isBufferGeometry) {
                    const T = r.index,
                        B = r.attributes.position;
                    if (T !== null)
                        for (let Q = Math.max(0, v.start), k = Math.min(T.count, v.start + v.count); Q < k; Q++) {
                            const i = T.getX(Q);
                            vo.fromBufferAttribute(B, i), cc(vo, i, E, h, s, e, this)
                        } else
                            for (let Q = Math.max(0, v.start), k = Math.min(B.count, v.start + v.count); Q < k; Q++) vo.fromBufferAttribute(B, Q), cc(vo, Q, E, h, s, e, this)
                } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            },
            updateMorphTargets: function() {
                const s = this.geometry;
                if (s.isBufferGeometry) {
                    const e = s.morphAttributes,
                        r = Object.keys(e);
                    if (r.length > 0) {
                        const h = e[r[0]];
                        if (h !== void 0) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let c = 0, v = h.length; c < v; c++) {
                                const w = h[c].name || String(c);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[w] = c
                            }
                        }
                    }
                } else {
                    const e = s.morphTargets;
                    e !== void 0 && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
        });
        class eh extends cn {
            constructor(e, r, h, c, v, w, E, T, B) {
                super(e, r, h, c, v, w, E, T, B), this.format = E !== void 0 ? E : 1022, this.minFilter = w !== void 0 ? w : 1006, this.magFilter = v !== void 0 ? v : 1006, this.generateMipmaps = !1;
                const Q = this;
                "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(function k() {
                    Q.needsUpdate = !0, e.requestVideoFrameCallback(k)
                })
            }
            clone() {
                return new this.constructor(this.image).copy(this)
            }
            update() {
                const e = this.image;
                !("requestVideoFrameCallback" in e) && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }
        eh.prototype.isVideoTexture = !0;
        class hc extends cn {
            constructor(e, r, h, c, v, w, E, T, B, Q, k, i) {
                super(null, w, E, T, B, Q, c, v, k, i), this.image = {
                    width: r,
                    height: h
                }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
            }
        }
        hc.prototype.isCompressedTexture = !0;
        class Du extends cn {
            constructor(e, r, h, c, v, w, E, T, B) {
                super(e, r, h, c, v, w, E, T, B), this.needsUpdate = !0
            }
        }
        Du.prototype.isCanvasTexture = !0;
        class Uu extends cn {
            constructor(e, r, h, c, v, w, E, T, B, Q) {
                if ((Q = Q !== void 0 ? Q : 1026) !== 1026 && Q !== 1027) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                h === void 0 && Q === 1026 && (h = 1012), h === void 0 && Q === 1027 && (h = 1020), super(null, c, v, w, E, T, Q, h, B), this.image = {
                    width: e,
                    height: r
                }, this.magFilter = E !== void 0 ? E : 1003, this.minFilter = T !== void 0 ? T : 1003, this.flipY = !1, this.generateMipmaps = !1
            }
        }
        Uu.prototype.isDepthTexture = !0;
        class Jh extends an {
            constructor(e = 1, r = 8, h = 0, c = 2 * Math.PI) {
                super(), this.type = "CircleGeometry", this.parameters = {
                    radius: e,
                    segments: r,
                    thetaStart: h,
                    thetaLength: c
                }, r = Math.max(3, r);
                const v = [],
                    w = [],
                    E = [],
                    T = [],
                    B = new ge,
                    Q = new Ht;
                w.push(0, 0, 0), E.push(0, 0, 1), T.push(.5, .5);
                for (let k = 0, i = 3; k <= r; k++, i += 3) {
                    const t = h + k / r * c;
                    B.x = e * Math.cos(t), B.y = e * Math.sin(t), w.push(B.x, B.y, B.z), E.push(0, 0, 1), Q.x = (w[i] / e + 1) / 2, Q.y = (w[i + 1] / e + 1) / 2, T.push(Q.x, Q.y)
                }
                for (let k = 1; k <= r; k++) v.push(k, k + 1, 0);
                this.setIndex(v), this.setAttribute("position", new Ai(w, 3)), this.setAttribute("normal", new Ai(E, 3)), this.setAttribute("uv", new Ai(T, 2))
            }
        }
        class ta extends an {
            constructor(e = 1, r = 1, h = 1, c = 8, v = 1, w = !1, E = 0, T = 2 * Math.PI) {
                super(), this.type = "CylinderGeometry", this.parameters = {
                    radiusTop: e,
                    radiusBottom: r,
                    height: h,
                    radialSegments: c,
                    heightSegments: v,
                    openEnded: w,
                    thetaStart: E,
                    thetaLength: T
                };
                const B = this;
                c = Math.floor(c), v = Math.floor(v);
                const Q = [],
                    k = [],
                    i = [],
                    t = [];
                let a = 0;
                const l = [],
                    d = h / 2;
                let g = 0;

                function x(A) {
                    const M = a,
                        F = new Ht,
                        D = new ge;
                    let U = 0;
                    const N = A === !0 ? e : r,
                        H = A === !0 ? 1 : -1;
                    for (let ne = 1; ne <= c; ne++) k.push(0, d * H, 0), i.push(0, H, 0), t.push(.5, .5), a++;
                    const X = a;
                    for (let ne = 0; ne <= c; ne++) {
                        const le = ne / c * T + E,
                            ce = Math.cos(le),
                            Qe = Math.sin(le);
                        D.x = N * Qe, D.y = d * H, D.z = N * ce, k.push(D.x, D.y, D.z), i.push(0, H, 0), F.x = .5 * ce + .5, F.y = .5 * Qe * H + .5, t.push(F.x, F.y), a++
                    }
                    for (let ne = 0; ne < c; ne++) {
                        const le = M + ne,
                            ce = X + ne;
                        A === !0 ? Q.push(ce, ce + 1, le) : Q.push(ce + 1, ce, le), U += 3
                    }
                    B.addGroup(g, U, A === !0 ? 1 : 2), g += U
                }(function() {
                    const A = new ge,
                        M = new ge;
                    let F = 0;
                    const D = (r - e) / h;
                    for (let U = 0; U <= v; U++) {
                        const N = [],
                            H = U / v,
                            X = H * (r - e) + e;
                        for (let ne = 0; ne <= c; ne++) {
                            const le = ne / c,
                                ce = le * T + E,
                                Qe = Math.sin(ce),
                                Se = Math.cos(ce);
                            M.x = X * Qe, M.y = -H * h + d, M.z = X * Se, k.push(M.x, M.y, M.z), A.set(Qe, D, Se).normalize(), i.push(A.x, A.y, A.z), t.push(le, 1 - H), N.push(a++)
                        }
                        l.push(N)
                    }
                    for (let U = 0; U < c; U++)
                        for (let N = 0; N < v; N++) {
                            const H = l[N][U],
                                X = l[N + 1][U],
                                ne = l[N + 1][U + 1],
                                le = l[N][U + 1];
                            Q.push(H, X, le), Q.push(X, ne, le), F += 6
                        }
                    B.addGroup(g, F, 0), g += F
                })(), w === !1 && (e > 0 && x(!0), r > 0 && x(!1)), this.setIndex(Q), this.setAttribute("position", new Ai(k, 3)), this.setAttribute("normal", new Ai(i, 3)), this.setAttribute("uv", new Ai(t, 2))
            }
        }
        class _o extends ta {
            constructor(e = 1, r = 1, h = 8, c = 1, v = !1, w = 0, E = 2 * Math.PI) {
                super(0, e, r, h, c, v, w, E), this.type = "ConeGeometry", this.parameters = {
                    radius: e,
                    height: r,
                    radialSegments: h,
                    heightSegments: c,
                    openEnded: v,
                    thetaStart: w,
                    thetaLength: E
                }
            }
        }
        class Js extends an {
            constructor(e, r, h = 1, c = 0) {
                super(), this.type = "PolyhedronGeometry", this.parameters = {
                    vertices: e,
                    indices: r,
                    radius: h,
                    detail: c
                };
                const v = [],
                    w = [];

                function E(i, t, a, l) {
                    const d = l + 1,
                        g = [];
                    for (let x = 0; x <= d; x++) {
                        g[x] = [];
                        const A = i.clone().lerp(a, x / d),
                            M = t.clone().lerp(a, x / d),
                            F = d - x;
                        for (let D = 0; D <= F; D++) g[x][D] = D === 0 && x === d ? A : A.clone().lerp(M, D / F)
                    }
                    for (let x = 0; x < d; x++)
                        for (let A = 0; A < 2 * (d - x) - 1; A++) {
                            const M = Math.floor(A / 2);
                            A % 2 == 0 ? (T(g[x][M + 1]), T(g[x + 1][M]), T(g[x][M])) : (T(g[x][M + 1]), T(g[x + 1][M + 1]), T(g[x + 1][M]))
                        }
                }

                function T(i) {
                    v.push(i.x, i.y, i.z)
                }

                function B(i, t) {
                    const a = 3 * i;
                    t.x = e[a + 0], t.y = e[a + 1], t.z = e[a + 2]
                }

                function Q(i, t, a, l) {
                    l < 0 && i.x === 1 && (w[t] = i.x - 1), a.x === 0 && a.z === 0 && (w[t] = l / 2 / Math.PI + .5)
                }

                function k(i) {
                    return Math.atan2(i.z, -i.x)
                }(function(i) {
                    const t = new ge,
                        a = new ge,
                        l = new ge;
                    for (let d = 0; d < r.length; d += 3) B(r[d + 0], t), B(r[d + 1], a), B(r[d + 2], l), E(t, a, l, i)
                })(c),
                function(i) {
                    const t = new ge;
                    for (let a = 0; a < v.length; a += 3) t.x = v[a + 0], t.y = v[a + 1], t.z = v[a + 2], t.normalize().multiplyScalar(i), v[a + 0] = t.x, v[a + 1] = t.y, v[a + 2] = t.z
                }(h),
                function() {
                    const i = new ge;
                    for (let a = 0; a < v.length; a += 3) {
                        i.x = v[a + 0], i.y = v[a + 1], i.z = v[a + 2];
                        const l = k(i) / 2 / Math.PI + .5,
                            d = (t = i, Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + .5);
                        w.push(l, 1 - d)
                    }
                    var t;
                    (function() {
                        const a = new ge,
                            l = new ge,
                            d = new ge,
                            g = new ge,
                            x = new Ht,
                            A = new Ht,
                            M = new Ht;
                        for (let F = 0, D = 0; F < v.length; F += 9, D += 6) {
                            a.set(v[F + 0], v[F + 1], v[F + 2]), l.set(v[F + 3], v[F + 4], v[F + 5]), d.set(v[F + 6], v[F + 7], v[F + 8]), x.set(w[D + 0], w[D + 1]), A.set(w[D + 2], w[D + 3]), M.set(w[D + 4], w[D + 5]), g.copy(a).add(l).add(d).divideScalar(3);
                            const U = k(g);
                            Q(x, D + 0, a, U), Q(A, D + 2, l, U), Q(M, D + 4, d, U)
                        }
                    })(),
                    function() {
                        for (let a = 0; a < w.length; a += 6) {
                            const l = w[a + 0],
                                d = w[a + 2],
                                g = w[a + 4],
                                x = Math.max(l, d, g),
                                A = Math.min(l, d, g);
                            x > .9 && A < .1 && (l < .2 && (w[a + 0] += 1), d < .2 && (w[a + 2] += 1), g < .2 && (w[a + 4] += 1))
                        }
                    }()
                }(), this.setAttribute("position", new Ai(v, 3)), this.setAttribute("normal", new Ai(v.slice(), 3)), this.setAttribute("uv", new Ai(w, 2)), c === 0 ? this.computeVertexNormals() : this.normalizeNormals()
            }
        }
        class th extends Js {
            constructor(e = 1, r = 0) {
                const h = (1 + Math.sqrt(5)) / 2,
                    c = 1 / h;
                super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -c, -h, 0, -c, h, 0, c, -h, 0, c, h, -c, -h, 0, -c, h, 0, c, -h, 0, c, h, 0, -h, 0, -c, h, 0, -c, -h, 0, c, h, 0, c], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, r), this.type = "DodecahedronGeometry", this.parameters = {
                    radius: e,
                    detail: r
                }
            }
        }
        const Vo = new ge,
            Zh = new ge,
            uc = new ge,
            Xh = new Mt;
        class jh extends an {
            constructor(e, r) {
                if (super(), this.type = "EdgesGeometry", this.parameters = {
                        thresholdAngle: r
                    }, r = r !== void 0 ? r : 1, e.isGeometry === !0) return void console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                const h = Math.pow(10, 4),
                    c = Math.cos(Mi.DEG2RAD * r),
                    v = e.getIndex(),
                    w = e.getAttribute("position"),
                    E = v ? v.count : w.count,
                    T = [0, 0, 0],
                    B = ["a", "b", "c"],
                    Q = new Array(3),
                    k = {},
                    i = [];
                for (let t = 0; t < E; t += 3) {
                    v ? (T[0] = v.getX(t), T[1] = v.getX(t + 1), T[2] = v.getX(t + 2)) : (T[0] = t, T[1] = t + 1, T[2] = t + 2);
                    const {
                        a,
                        b: l,
                        c: d
                    } = Xh;
                    if (a.fromBufferAttribute(w, T[0]), l.fromBufferAttribute(w, T[1]), d.fromBufferAttribute(w, T[2]), Xh.getNormal(uc), Q[0] = `${Math.round(a.x*h)},${Math.round(a.y*h)},${Math.round(a.z*h)}`, Q[1] = `${Math.round(l.x*h)},${Math.round(l.y*h)},${Math.round(l.z*h)}`, Q[2] = `${Math.round(d.x*h)},${Math.round(d.y*h)},${Math.round(d.z*h)}`, Q[0] !== Q[1] && Q[1] !== Q[2] && Q[2] !== Q[0])
                        for (let g = 0; g < 3; g++) {
                            const x = (g + 1) % 3,
                                A = Q[g],
                                M = Q[x],
                                F = Xh[B[g]],
                                D = Xh[B[x]],
                                U = `${A}_${M}`,
                                N = `${M}_${A}`;
                            N in k && k[N] ? (uc.dot(k[N].normal) <= c && (i.push(F.x, F.y, F.z), i.push(D.x, D.y, D.z)), k[N] = null) : U in k || (k[U] = {
                                index0: T[g],
                                index1: T[x],
                                normal: uc.clone()
                            })
                        }
                }
                for (const t in k)
                    if (k[t]) {
                        const {
                            index0: a,
                            index1: l
                        } = k[t];
                        Vo.fromBufferAttribute(w, a), Zh.fromBufferAttribute(w, l), i.push(Vo.x, Vo.y, Vo.z), i.push(Zh.x, Zh.y, Zh.z)
                    } this.setAttribute("position", new Ai(i, 3))
            }
        }
        const zd = function(s, e, r) {
            r = r || 2;
            const h = e && e.length,
                c = h ? e[0] * r : s.length;
            let v = Iu(s, 0, c, r, !0);
            const w = [];
            if (!v || v.next === v.prev) return w;
            let E, T, B, Q, k, i, t;
            if (h && (v = function(a, l, d, g) {
                    const x = [];
                    let A, M, F, D, U;
                    for (A = 0, M = l.length; A < M; A++) F = l[A] * g, D = A < M - 1 ? l[A + 1] * g : a.length, U = Iu(a, F, D, g, !1), U === U.next && (U.steiner = !0), x.push(bp(U));
                    for (x.sort(Od), A = 0; A < x.length; A++) xp(x[A], d), d = Go(d, d.next);
                    return d
                }(s, e, v, r)), s.length > 80 * r) {
                E = B = s[0], T = Q = s[1];
                for (let a = r; a < c; a += r) k = s[a], i = s[a + 1], k < E && (E = k), i < T && (T = i), k > B && (B = k), i > Q && (Q = i);
                t = Math.max(B - E, Q - T), t = t !== 0 ? 1 / t : 0
            }
            return Cl(v, w, r, E, T, t), w
        };

        function Iu(s, e, r, h, c) {
            let v, w;
            if (c === function(E, T, B, Q) {
                    let k = 0;
                    for (let i = T, t = B - Q; i < B; i += Q) k += (E[t] - E[i]) * (E[i + 1] + E[t + 1]), t = i;
                    return k
                }(s, e, r, h) > 0)
                for (v = e; v < r; v += h) w = Hd(v, s[v], s[v + 1], w);
            else
                for (v = r - h; v >= e; v -= h) w = Hd(v, s[v], s[v + 1], w);
            return w && Bl(w, w.next) && (rh(w), w = w.next), w
        }

        function Go(s, e) {
            if (!s) return s;
            e || (e = s);
            let r, h = s;
            do
                if (r = !1, h.steiner || !Bl(h, h.next) && Cr(h.prev, h, h.next) !== 0) h = h.next;
                else {
                    if (rh(h), h = e = h.prev, h === h.next) break;
                    r = !0
                } while (r || h !== e);
            return e
        }

        function Cl(s, e, r, h, c, v, w) {
            if (!s) return;
            !w && v && function(Q, k, i, t) {
                let a = Q;
                do a.z === null && (a.z = Nu(a.x, a.y, k, i, t)), a.prevZ = a.prev, a.nextZ = a.next, a = a.next; while (a !== Q);
                a.prevZ.nextZ = null, a.prevZ = null,
                    function(l) {
                        let d, g, x, A, M, F, D, U, N = 1;
                        do {
                            for (g = l, l = null, M = null, F = 0; g;) {
                                for (F++, x = g, D = 0, d = 0; d < N && (D++, x = x.nextZ, x); d++);
                                for (U = N; D > 0 || U > 0 && x;) D !== 0 && (U === 0 || !x || g.z <= x.z) ? (A = g, g = g.nextZ, D--) : (A = x, x = x.nextZ, U--), M ? M.nextZ = A : l = A, A.prevZ = M, M = A;
                                g = x
                            }
                            M.nextZ = null, N *= 2
                        } while (F > 1)
                    }(a)
            }(s, h, c, v);
            let E, T, B = s;
            for (; s.prev !== s.next;)
                if (E = s.prev, T = s.next, v ? zu(s, h, c, v) : Nd(s)) e.push(E.i / r), e.push(s.i / r), e.push(T.i / r), rh(s), s = T.next, B = T.next;
                else if ((s = T) === B) {
                w ? w === 1 ? Cl(s = ih(Go(s), e, r), e, r, h, c, v, 2) : w === 2 && es(s, e, r, h, c, v) : Cl(Go(s), e, r, h, c, v, 1);
                break
            }
        }

        function Nd(s) {
            const e = s.prev,
                r = s,
                h = s.next;
            if (Cr(e, r, h) >= 0) return !1;
            let c = s.next.next;
            for (; c !== s.prev;) {
                if (dc(e.x, e.y, r.x, r.y, h.x, h.y, c.x, c.y) && Cr(c.prev, c, c.next) >= 0) return !1;
                c = c.next
            }
            return !0
        }

        function zu(s, e, r, h) {
            const c = s.prev,
                v = s,
                w = s.next;
            if (Cr(c, v, w) >= 0) return !1;
            const E = c.x < v.x ? c.x < w.x ? c.x : w.x : v.x < w.x ? v.x : w.x,
                T = c.y < v.y ? c.y < w.y ? c.y : w.y : v.y < w.y ? v.y : w.y,
                B = c.x > v.x ? c.x > w.x ? c.x : w.x : v.x > w.x ? v.x : w.x,
                Q = c.y > v.y ? c.y > w.y ? c.y : w.y : v.y > w.y ? v.y : w.y,
                k = Nu(E, T, e, r, h),
                i = Nu(B, Q, e, r, h);
            let t = s.prevZ,
                a = s.nextZ;
            for (; t && t.z >= k && a && a.z <= i;) {
                if (t !== s.prev && t !== s.next && dc(c.x, c.y, v.x, v.y, w.x, w.y, t.x, t.y) && Cr(t.prev, t, t.next) >= 0 || (t = t.prevZ, a !== s.prev && a !== s.next && dc(c.x, c.y, v.x, v.y, w.x, w.y, a.x, a.y) && Cr(a.prev, a, a.next) >= 0)) return !1;
                a = a.nextZ
            }
            for (; t && t.z >= k;) {
                if (t !== s.prev && t !== s.next && dc(c.x, c.y, v.x, v.y, w.x, w.y, t.x, t.y) && Cr(t.prev, t, t.next) >= 0) return !1;
                t = t.prevZ
            }
            for (; a && a.z <= i;) {
                if (a !== s.prev && a !== s.next && dc(c.x, c.y, v.x, v.y, w.x, w.y, a.x, a.y) && Cr(a.prev, a, a.next) >= 0) return !1;
                a = a.nextZ
            }
            return !0
        }

        function ih(s, e, r) {
            let h = s;
            do {
                const c = h.prev,
                    v = h.next.next;
                !Bl(c, v) && Ou(c, h, h.next, v) && nh(c, v) && nh(v, c) && (e.push(c.i / r), e.push(h.i / r), e.push(v.i / r), rh(h), rh(h.next), h = s = v), h = h.next
            } while (h !== s);
            return Go(h)
        }

        function es(s, e, r, h, c, v) {
            let w = s;
            do {
                let E = w.next.next;
                for (; E !== w.prev;) {
                    if (w.i !== E.i && wp(w, E)) {
                        let T = Gd(w, E);
                        return w = Go(w, w.next), T = Go(T, T.next), Cl(w, e, r, h, c, v), void Cl(T, e, r, h, c, v)
                    }
                    E = E.next
                }
                w = w.next
            } while (w !== s)
        }

        function Od(s, e) {
            return s.x - e.x
        }

        function xp(s, e) {
            if (e = function(r, h) {
                    let c = h;
                    const v = r.x,
                        w = r.y;
                    let E, T = -1 / 0;
                    do {
                        if (w <= c.y && w >= c.next.y && c.next.y !== c.y) {
                            const a = c.x + (w - c.y) * (c.next.x - c.x) / (c.next.y - c.y);
                            if (a <= v && a > T) {
                                if (T = a, a === v) {
                                    if (w === c.y) return c;
                                    if (w === c.next.y) return c.next
                                }
                                E = c.x < c.next.x ? c : c.next
                            }
                        }
                        c = c.next
                    } while (c !== h);
                    if (!E) return null;
                    if (v === T) return E;
                    const B = E,
                        Q = E.x,
                        k = E.y;
                    let i, t = 1 / 0;
                    c = E;
                    do v >= c.x && c.x >= Q && v !== c.x && dc(w < k ? v : T, w, Q, k, w < k ? T : v, w, c.x, c.y) && (i = Math.abs(w - c.y) / (v - c.x), nh(c, r) && (i < t || i === t && (c.x > E.x || c.x === E.x && Vd(E, c))) && (E = c, t = i)), c = c.next; while (c !== B);
                    return E
                }(s, e)) {
                const r = Gd(e, s);
                Go(e, e.next), Go(r, r.next)
            }
        }

        function Vd(s, e) {
            return Cr(s.prev, s, e.prev) < 0 && Cr(e.next, s, s.next) < 0
        }

        function Nu(s, e, r, h, c) {
            return (s = 1431655765 & ((s = 858993459 & ((s = 252645135 & ((s = 16711935 & ((s = 32767 * (s - r) * c) | s << 8)) | s << 4)) | s << 2)) | s << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - h) * c) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
        }

        function bp(s) {
            let e = s,
                r = s;
            do(e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next; while (e !== s);
            return r
        }

        function dc(s, e, r, h, c, v, w, E) {
            return (c - w) * (e - E) - (s - w) * (v - E) >= 0 && (s - w) * (h - E) - (r - w) * (e - E) >= 0 && (r - w) * (v - E) - (c - w) * (h - E) >= 0
        }

        function wp(s, e) {
            return s.next.i !== e.i && s.prev.i !== e.i && ! function(r, h) {
                let c = r;
                do {
                    if (c.i !== r.i && c.next.i !== r.i && c.i !== h.i && c.next.i !== h.i && Ou(c, c.next, r, h)) return !0;
                    c = c.next
                } while (c !== r);
                return !1
            }(s, e) && (nh(s, e) && nh(e, s) && function(r, h) {
                let c = r,
                    v = !1;
                const w = (r.x + h.x) / 2,
                    E = (r.y + h.y) / 2;
                do c.y > E != c.next.y > E && c.next.y !== c.y && w < (c.next.x - c.x) * (E - c.y) / (c.next.y - c.y) + c.x && (v = !v), c = c.next; while (c !== r);
                return v
            }(s, e) && (Cr(s.prev, s, e.prev) || Cr(s, e.prev, e)) || Bl(s, e) && Cr(s.prev, s, s.next) > 0 && Cr(e.prev, e, e.next) > 0)
        }

        function Cr(s, e, r) {
            return (e.y - s.y) * (r.x - e.x) - (e.x - s.x) * (r.y - e.y)
        }

        function Bl(s, e) {
            return s.x === e.x && s.y === e.y
        }

        function Ou(s, e, r, h) {
            const c = Ho(Cr(s, e, r)),
                v = Ho(Cr(s, e, h)),
                w = Ho(Cr(r, h, s)),
                E = Ho(Cr(r, h, e));
            return c !== v && w !== E || !(c !== 0 || !Zs(s, r, e)) || !(v !== 0 || !Zs(s, h, e)) || !(w !== 0 || !Zs(r, s, h)) || !(E !== 0 || !Zs(r, e, h))
        }

        function Zs(s, e, r) {
            return e.x <= Math.max(s.x, r.x) && e.x >= Math.min(s.x, r.x) && e.y <= Math.max(s.y, r.y) && e.y >= Math.min(s.y, r.y)
        }

        function Ho(s) {
            return s > 0 ? 1 : s < 0 ? -1 : 0
        }

        function nh(s, e) {
            return Cr(s.prev, s, s.next) < 0 ? Cr(s, e, s.next) >= 0 && Cr(s, s.prev, e) >= 0 : Cr(s, e, s.prev) < 0 || Cr(s, s.next, e) < 0
        }

        function Gd(s, e) {
            const r = new Vu(s.i, s.x, s.y),
                h = new Vu(e.i, e.x, e.y),
                c = s.next,
                v = e.prev;
            return s.next = e, e.prev = s, r.next = c, c.prev = r, h.next = r, r.prev = h, v.next = h, h.prev = v, h
        }

        function Hd(s, e, r, h) {
            const c = new Vu(s, e, r);
            return h ? (c.next = h.next, c.prev = h, h.next.prev = c, h.next = c) : (c.prev = c, c.next = c), c
        }

        function rh(s) {
            s.next.prev = s.prev, s.prev.next = s.next, s.prevZ && (s.prevZ.nextZ = s.nextZ), s.nextZ && (s.nextZ.prevZ = s.prevZ)
        }

        function Vu(s, e, r) {
            this.i = s, this.x = e, this.y = r, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
        }
        const xo = {
            area: function(s) {
                const e = s.length;
                let r = 0;
                for (let h = e - 1, c = 0; c < e; h = c++) r += s[h].x * s[c].y - s[c].x * s[h].y;
                return .5 * r
            },
            isClockWise: function(s) {
                return xo.area(s) < 0
            },
            triangulateShape: function(s, e) {
                const r = [],
                    h = [],
                    c = [];
                Wd(s), Yh(r, s);
                let v = s.length;
                e.forEach(Wd);
                for (let E = 0; E < e.length; E++) h.push(v), v += e[E].length, Yh(r, e[E]);
                const w = zd(r, h);
                for (let E = 0; E < w.length; E += 3) c.push(w.slice(E, E + 3));
                return c
            }
        };

        function Wd(s) {
            const e = s.length;
            e > 2 && s[e - 1].equals(s[0]) && s.pop()
        }

        function Yh(s, e) {
            for (let r = 0; r < e.length; r++) s.push(e[r].x), s.push(e[r].y)
        }
        class bo extends an {
            constructor(e, r) {
                super(), this.type = "ExtrudeGeometry", this.parameters = {
                    shapes: e,
                    options: r
                }, e = Array.isArray(e) ? e : [e];
                const h = this,
                    c = [],
                    v = [];
                for (let E = 0, T = e.length; E < T; E++) w(e[E]);

                function w(E) {
                    const T = [],
                        B = r.curveSegments !== void 0 ? r.curveSegments : 12,
                        Q = r.steps !== void 0 ? r.steps : 1;
                    let k = r.depth !== void 0 ? r.depth : 100,
                        i = r.bevelEnabled === void 0 || r.bevelEnabled,
                        t = r.bevelThickness !== void 0 ? r.bevelThickness : 6,
                        a = r.bevelSize !== void 0 ? r.bevelSize : t - 2,
                        l = r.bevelOffset !== void 0 ? r.bevelOffset : 0,
                        d = r.bevelSegments !== void 0 ? r.bevelSegments : 3;
                    const g = r.extrudePath,
                        x = r.UVGenerator !== void 0 ? r.UVGenerator : pc;
                    r.amount !== void 0 && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), k = r.amount);
                    let A, M, F, D, U, N = !1;
                    g && (A = g.getSpacedPoints(Q), N = !0, i = !1, M = g.computeFrenetFrames(Q, !1), F = new ge, D = new ge, U = new ge), i || (d = 0, t = 0, a = 0, l = 0);
                    const H = E.extractPoints(B);
                    let X = H.shape;
                    const ne = H.holes;
                    if (!xo.isClockWise(X)) {
                        X = X.reverse();
                        for (let pt = 0, xt = ne.length; pt < xt; pt++) {
                            const Gt = ne[pt];
                            xo.isClockWise(Gt) && (ne[pt] = Gt.reverse())
                        }
                    }
                    const le = xo.triangulateShape(X, ne),
                        ce = X;
                    for (let pt = 0, xt = ne.length; pt < xt; pt++) {
                        const Gt = ne[pt];
                        X = X.concat(Gt)
                    }

                    function Qe(pt, xt, Gt) {
                        return xt || console.error("THREE.ExtrudeGeometry: vec does not exist"), xt.clone().multiplyScalar(Gt).add(pt)
                    }
                    const Se = X.length,
                        Re = le.length;

                    function ot(pt, xt, Gt) {
                        let Xt, hi, _i;
                        const Di = pt.x - xt.x,
                            nn = pt.y - xt.y,
                            Fi = Gt.x - pt.x,
                            tn = Gt.y - pt.y,
                            gn = Di * Di + nn * nn,
                            Kn = Di * tn - nn * Fi;
                        if (Math.abs(Kn) > Number.EPSILON) {
                            const er = Math.sqrt(gn),
                                ia = Math.sqrt(Fi * Fi + tn * tn),
                                oa = xt.x - nn / er,
                                tr = xt.y + Di / er,
                                jn = ((Gt.x - tn / ia - oa) * tn - (Gt.y + Fi / ia - tr) * Fi) / (Di * tn - nn * Fi);
                            Xt = oa + Di * jn - pt.x, hi = tr + nn * jn - pt.y;
                            const fi = Xt * Xt + hi * hi;
                            if (fi <= 2) return new Ht(Xt, hi);
                            _i = Math.sqrt(fi / 2)
                        } else {
                            let er = !1;
                            Di > Number.EPSILON ? Fi > Number.EPSILON && (er = !0) : Di < -Number.EPSILON ? Fi < -Number.EPSILON && (er = !0) : Math.sign(nn) === Math.sign(tn) && (er = !0), er ? (Xt = -nn, hi = Di, _i = Math.sqrt(gn)) : (Xt = Di, hi = nn, _i = Math.sqrt(gn / 2))
                        }
                        return new Ht(Xt / _i, hi / _i)
                    }
                    const dt = [];
                    for (let pt = 0, xt = ce.length, Gt = xt - 1, Xt = pt + 1; pt < xt; pt++, Gt++, Xt++) Gt === xt && (Gt = 0), Xt === xt && (Xt = 0), dt[pt] = ot(ce[pt], ce[Gt], ce[Xt]);
                    const Ct = [];
                    let Nt, qt = dt.concat();
                    for (let pt = 0, xt = ne.length; pt < xt; pt++) {
                        const Gt = ne[pt];
                        Nt = [];
                        for (let Xt = 0, hi = Gt.length, _i = hi - 1, Di = Xt + 1; Xt < hi; Xt++, _i++, Di++) _i === hi && (_i = 0), Di === hi && (Di = 0), Nt[Xt] = ot(Gt[Xt], Gt[_i], Gt[Di]);
                        Ct.push(Nt), qt = qt.concat(Nt)
                    }
                    for (let pt = 0; pt < d; pt++) {
                        const xt = pt / d,
                            Gt = t * Math.cos(xt * Math.PI / 2),
                            Xt = a * Math.sin(xt * Math.PI / 2) + l;
                        for (let hi = 0, _i = ce.length; hi < _i; hi++) {
                            const Di = Qe(ce[hi], dt[hi], Xt);
                            mt(Di.x, Di.y, -Gt)
                        }
                        for (let hi = 0, _i = ne.length; hi < _i; hi++) {
                            const Di = ne[hi];
                            Nt = Ct[hi];
                            for (let nn = 0, Fi = Di.length; nn < Fi; nn++) {
                                const tn = Qe(Di[nn], Nt[nn], Xt);
                                mt(tn.x, tn.y, -Gt)
                            }
                        }
                    }
                    const Fe = a + l;
                    for (let pt = 0; pt < Se; pt++) {
                        const xt = i ? Qe(X[pt], qt[pt], Fe) : X[pt];
                        N ? (D.copy(M.normals[0]).multiplyScalar(xt.x), F.copy(M.binormals[0]).multiplyScalar(xt.y), U.copy(A[0]).add(D).add(F), mt(U.x, U.y, U.z)) : mt(xt.x, xt.y, 0)
                    }
                    for (let pt = 1; pt <= Q; pt++)
                        for (let xt = 0; xt < Se; xt++) {
                            const Gt = i ? Qe(X[xt], qt[xt], Fe) : X[xt];
                            N ? (D.copy(M.normals[pt]).multiplyScalar(Gt.x), F.copy(M.binormals[pt]).multiplyScalar(Gt.y), U.copy(A[pt]).add(D).add(F), mt(U.x, U.y, U.z)) : mt(Gt.x, Gt.y, k / Q * pt)
                        }
                    for (let pt = d - 1; pt >= 0; pt--) {
                        const xt = pt / d,
                            Gt = t * Math.cos(xt * Math.PI / 2),
                            Xt = a * Math.sin(xt * Math.PI / 2) + l;
                        for (let hi = 0, _i = ce.length; hi < _i; hi++) {
                            const Di = Qe(ce[hi], dt[hi], Xt);
                            mt(Di.x, Di.y, k + Gt)
                        }
                        for (let hi = 0, _i = ne.length; hi < _i; hi++) {
                            const Di = ne[hi];
                            Nt = Ct[hi];
                            for (let nn = 0, Fi = Di.length; nn < Fi; nn++) {
                                const tn = Qe(Di[nn], Nt[nn], Xt);
                                N ? mt(tn.x, tn.y + A[Q - 1].y, A[Q - 1].x + Gt) : mt(tn.x, tn.y, k + Gt)
                            }
                        }
                    }

                    function Be(pt, xt) {
                        let Gt = pt.length;
                        for (; --Gt >= 0;) {
                            const Xt = Gt;
                            let hi = Gt - 1;
                            hi < 0 && (hi = pt.length - 1);
                            for (let _i = 0, Di = Q + 2 * d; _i < Di; _i++) {
                                const nn = Se * _i,
                                    Fi = Se * (_i + 1);
                                Xe(xt + Xt + nn, xt + hi + nn, xt + hi + Fi, xt + Xt + Fi)
                            }
                        }
                    }

                    function mt(pt, xt, Gt) {
                        T.push(pt), T.push(xt), T.push(Gt)
                    }

                    function lt(pt, xt, Gt) {
                        Zt(pt), Zt(xt), Zt(Gt);
                        const Xt = c.length / 3,
                            hi = x.generateTopUV(h, c, Xt - 3, Xt - 2, Xt - 1);
                        Ie(hi[0]), Ie(hi[1]), Ie(hi[2])
                    }

                    function Xe(pt, xt, Gt, Xt) {
                        Zt(pt), Zt(xt), Zt(Xt), Zt(xt), Zt(Gt), Zt(Xt);
                        const hi = c.length / 3,
                            _i = x.generateSideWallUV(h, c, hi - 6, hi - 3, hi - 2, hi - 1);
                        Ie(_i[0]), Ie(_i[1]), Ie(_i[3]), Ie(_i[1]), Ie(_i[2]), Ie(_i[3])
                    }

                    function Zt(pt) {
                        c.push(T[3 * pt + 0]), c.push(T[3 * pt + 1]), c.push(T[3 * pt + 2])
                    }

                    function Ie(pt) {
                        v.push(pt.x), v.push(pt.y)
                    }(function() {
                        const pt = c.length / 3;
                        if (i) {
                            let xt = 0,
                                Gt = Se * xt;
                            for (let Xt = 0; Xt < Re; Xt++) {
                                const hi = le[Xt];
                                lt(hi[2] + Gt, hi[1] + Gt, hi[0] + Gt)
                            }
                            xt = Q + 2 * d, Gt = Se * xt;
                            for (let Xt = 0; Xt < Re; Xt++) {
                                const hi = le[Xt];
                                lt(hi[0] + Gt, hi[1] + Gt, hi[2] + Gt)
                            }
                        } else {
                            for (let xt = 0; xt < Re; xt++) {
                                const Gt = le[xt];
                                lt(Gt[2], Gt[1], Gt[0])
                            }
                            for (let xt = 0; xt < Re; xt++) {
                                const Gt = le[xt];
                                lt(Gt[0] + Se * Q, Gt[1] + Se * Q, Gt[2] + Se * Q)
                            }
                        }
                        h.addGroup(pt, c.length / 3 - pt, 0)
                    })(),
                    function() {
                        const pt = c.length / 3;
                        let xt = 0;
                        Be(ce, xt), xt += ce.length;
                        for (let Gt = 0, Xt = ne.length; Gt < Xt; Gt++) {
                            const hi = ne[Gt];
                            Be(hi, xt), xt += hi.length
                        }
                        h.addGroup(pt, c.length / 3 - pt, 1)
                    }()
                }
                this.setAttribute("position", new Ai(c, 3)), this.setAttribute("uv", new Ai(v, 2)), this.computeVertexNormals()
            }
            toJSON() {
                const e = an.prototype.toJSON.call(this);
                return function(r, h, c) {
                    if (c.shapes = [], Array.isArray(r))
                        for (let v = 0, w = r.length; v < w; v++) {
                            const E = r[v];
                            c.shapes.push(E.uuid)
                        } else c.shapes.push(r.uuid);
                    return h.extrudePath !== void 0 && (c.options.extrudePath = h.extrudePath.toJSON()), c
                }(this.parameters.shapes, this.parameters.options, e)
            }
        }
        const pc = {
            generateTopUV: function(s, e, r, h, c) {
                const v = e[3 * r],
                    w = e[3 * r + 1],
                    E = e[3 * h],
                    T = e[3 * h + 1],
                    B = e[3 * c],
                    Q = e[3 * c + 1];
                return [new Ht(v, w), new Ht(E, T), new Ht(B, Q)]
            },
            generateSideWallUV: function(s, e, r, h, c, v) {
                const w = e[3 * r],
                    E = e[3 * r + 1],
                    T = e[3 * r + 2],
                    B = e[3 * h],
                    Q = e[3 * h + 1],
                    k = e[3 * h + 2],
                    i = e[3 * c],
                    t = e[3 * c + 1],
                    a = e[3 * c + 2],
                    l = e[3 * v],
                    d = e[3 * v + 1],
                    g = e[3 * v + 2];
                return Math.abs(E - Q) < .01 ? [new Ht(w, 1 - T), new Ht(B, 1 - k), new Ht(i, 1 - a), new Ht(l, 1 - g)] : [new Ht(E, 1 - T), new Ht(Q, 1 - k), new Ht(t, 1 - a), new Ht(d, 1 - g)]
            }
        };
        class qh extends Js {
            constructor(e = 1, r = 0) {
                const h = (1 + Math.sqrt(5)) / 2;
                super([-1, h, 0, 1, h, 0, -1, -h, 0, 1, -h, 0, 0, -1, h, 0, 1, h, 0, -1, -h, 0, 1, -h, h, 0, -1, h, 0, 1, -h, 0, -1, -h, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, r), this.type = "IcosahedronGeometry", this.parameters = {
                    radius: e,
                    detail: r
                }
            }
        }
        class vr extends an {
            constructor(e, r = 12, h = 0, c = 2 * Math.PI) {
                super(), this.type = "LatheGeometry", this.parameters = {
                    points: e,
                    segments: r,
                    phiStart: h,
                    phiLength: c
                }, r = Math.floor(r), c = Mi.clamp(c, 0, 2 * Math.PI);
                const v = [],
                    w = [],
                    E = [],
                    T = 1 / r,
                    B = new ge,
                    Q = new Ht;
                for (let k = 0; k <= r; k++) {
                    const i = h + k * T * c,
                        t = Math.sin(i),
                        a = Math.cos(i);
                    for (let l = 0; l <= e.length - 1; l++) B.x = e[l].x * t, B.y = e[l].y, B.z = e[l].x * a, w.push(B.x, B.y, B.z), Q.x = k / r, Q.y = l / (e.length - 1), E.push(Q.x, Q.y)
                }
                for (let k = 0; k < r; k++)
                    for (let i = 0; i < e.length - 1; i++) {
                        const t = i + k * e.length,
                            a = t,
                            l = t + e.length,
                            d = t + e.length + 1,
                            g = t + 1;
                        v.push(a, l, g), v.push(l, d, g)
                    }
                if (this.setIndex(v), this.setAttribute("position", new Ai(w, 3)), this.setAttribute("uv", new Ai(E, 2)), this.computeVertexNormals(), c === 2 * Math.PI) {
                    const k = this.attributes.normal.array,
                        i = new ge,
                        t = new ge,
                        a = new ge,
                        l = r * e.length * 3;
                    for (let d = 0, g = 0; d < e.length; d++, g += 3) i.x = k[g + 0], i.y = k[g + 1], i.z = k[g + 2], t.x = k[l + g + 0], t.y = k[l + g + 1], t.z = k[l + g + 2], a.addVectors(i, t).normalize(), k[g + 0] = k[l + g + 0] = a.x, k[g + 1] = k[l + g + 1] = a.y, k[g + 2] = k[l + g + 2] = a.z
                }
            }
        }
        class Wo extends Js {
            constructor(e = 1, r = 0) {
                super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, r), this.type = "OctahedronGeometry", this.parameters = {
                    radius: e,
                    detail: r
                }
            }
        }

        function Jo(s, e, r) {
            an.call(this), this.type = "ParametricGeometry", this.parameters = {
                func: s,
                slices: e,
                stacks: r
            };
            const h = [],
                c = [],
                v = [],
                w = [],
                E = 1e-5,
                T = new ge,
                B = new ge,
                Q = new ge,
                k = new ge,
                i = new ge;
            s.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
            const t = e + 1;
            for (let a = 0; a <= r; a++) {
                const l = a / r;
                for (let d = 0; d <= e; d++) {
                    const g = d / e;
                    s(g, l, B), c.push(B.x, B.y, B.z), g - E >= 0 ? (s(g - E, l, Q), k.subVectors(B, Q)) : (s(g + E, l, Q), k.subVectors(Q, B)), l - E >= 0 ? (s(g, l - E, Q), i.subVectors(B, Q)) : (s(g, l + E, Q), i.subVectors(Q, B)), T.crossVectors(k, i).normalize(), v.push(T.x, T.y, T.z), w.push(g, l)
                }
            }
            for (let a = 0; a < r; a++)
                for (let l = 0; l < e; l++) {
                    const d = a * t + l,
                        g = a * t + l + 1,
                        x = (a + 1) * t + l + 1,
                        A = (a + 1) * t + l;
                    h.push(d, g, A), h.push(g, x, A)
                }
            this.setIndex(h), this.setAttribute("position", new Ai(c, 3)), this.setAttribute("normal", new Ai(v, 3)), this.setAttribute("uv", new Ai(w, 2))
        }
        Jo.prototype = Object.create(an.prototype), Jo.prototype.constructor = Jo;
        class Rl extends an {
            constructor(e = .5, r = 1, h = 8, c = 1, v = 0, w = 2 * Math.PI) {
                super(), this.type = "RingGeometry", this.parameters = {
                    innerRadius: e,
                    outerRadius: r,
                    thetaSegments: h,
                    phiSegments: c,
                    thetaStart: v,
                    thetaLength: w
                }, h = Math.max(3, h);
                const E = [],
                    T = [],
                    B = [],
                    Q = [];
                let k = e;
                const i = (r - e) / (c = Math.max(1, c)),
                    t = new ge,
                    a = new Ht;
                for (let l = 0; l <= c; l++) {
                    for (let d = 0; d <= h; d++) {
                        const g = v + d / h * w;
                        t.x = k * Math.cos(g), t.y = k * Math.sin(g), T.push(t.x, t.y, t.z), B.push(0, 0, 1), a.x = (t.x / r + 1) / 2, a.y = (t.y / r + 1) / 2, Q.push(a.x, a.y)
                    }
                    k += i
                }
                for (let l = 0; l < c; l++) {
                    const d = l * (h + 1);
                    for (let g = 0; g < h; g++) {
                        const x = g + d,
                            A = x,
                            M = x + h + 1,
                            F = x + h + 2,
                            D = x + 1;
                        E.push(A, M, D), E.push(M, F, D)
                    }
                }
                this.setIndex(E), this.setAttribute("position", new Ai(T, 3)), this.setAttribute("normal", new Ai(B, 3)), this.setAttribute("uv", new Ai(Q, 2))
            }
        }
        class Zo extends an {
            constructor(e, r = 12) {
                super(), this.type = "ShapeGeometry", this.parameters = {
                    shapes: e,
                    curveSegments: r
                };
                const h = [],
                    c = [],
                    v = [],
                    w = [];
                let E = 0,
                    T = 0;
                if (Array.isArray(e) === !1) B(e);
                else
                    for (let Q = 0; Q < e.length; Q++) B(e[Q]), this.addGroup(E, T, Q), E += T, T = 0;

                function B(Q) {
                    const k = c.length / 3,
                        i = Q.extractPoints(r);
                    let t = i.shape;
                    const a = i.holes;
                    xo.isClockWise(t) === !1 && (t = t.reverse());
                    for (let d = 0, g = a.length; d < g; d++) {
                        const x = a[d];
                        xo.isClockWise(x) === !0 && (a[d] = x.reverse())
                    }
                    const l = xo.triangulateShape(t, a);
                    for (let d = 0, g = a.length; d < g; d++) {
                        const x = a[d];
                        t = t.concat(x)
                    }
                    for (let d = 0, g = t.length; d < g; d++) {
                        const x = t[d];
                        c.push(x.x, x.y, 0), v.push(0, 0, 1), w.push(x.x, x.y)
                    }
                    for (let d = 0, g = l.length; d < g; d++) {
                        const x = l[d],
                            A = x[0] + k,
                            M = x[1] + k,
                            F = x[2] + k;
                        h.push(A, M, F), T += 3
                    }
                }
                this.setIndex(h), this.setAttribute("position", new Ai(c, 3)), this.setAttribute("normal", new Ai(v, 3)), this.setAttribute("uv", new Ai(w, 2))
            }
            toJSON() {
                const e = an.prototype.toJSON.call(this);
                return function(r, h) {
                    if (h.shapes = [], Array.isArray(r))
                        for (let c = 0, v = r.length; c < v; c++) {
                            const w = r[c];
                            h.shapes.push(w.uuid)
                        } else h.shapes.push(r.uuid);
                    return h
                }(this.parameters.shapes, e)
            }
        }
        class wo extends an {
            constructor(e = 1, r = 8, h = 6, c = 0, v = 2 * Math.PI, w = 0, E = Math.PI) {
                super(), this.type = "SphereGeometry", this.parameters = {
                    radius: e,
                    widthSegments: r,
                    heightSegments: h,
                    phiStart: c,
                    phiLength: v,
                    thetaStart: w,
                    thetaLength: E
                }, r = Math.max(3, Math.floor(r)), h = Math.max(2, Math.floor(h));
                const T = Math.min(w + E, Math.PI);
                let B = 0;
                const Q = [],
                    k = new ge,
                    i = new ge,
                    t = [],
                    a = [],
                    l = [],
                    d = [];
                for (let g = 0; g <= h; g++) {
                    const x = [],
                        A = g / h;
                    let M = 0;
                    g == 0 && w == 0 ? M = .5 / r : g == h && T == Math.PI && (M = -.5 / r);
                    for (let F = 0; F <= r; F++) {
                        const D = F / r;
                        k.x = -e * Math.cos(c + D * v) * Math.sin(w + A * E), k.y = e * Math.cos(w + A * E), k.z = e * Math.sin(c + D * v) * Math.sin(w + A * E), a.push(k.x, k.y, k.z), i.copy(k).normalize(), l.push(i.x, i.y, i.z), d.push(D + M, 1 - A), x.push(B++)
                    }
                    Q.push(x)
                }
                for (let g = 0; g < h; g++)
                    for (let x = 0; x < r; x++) {
                        const A = Q[g][x + 1],
                            M = Q[g][x],
                            F = Q[g + 1][x],
                            D = Q[g + 1][x + 1];
                        (g !== 0 || w > 0) && t.push(A, M, D), (g !== h - 1 || T < Math.PI) && t.push(M, F, D)
                    }
                this.setIndex(t), this.setAttribute("position", new Ai(a, 3)), this.setAttribute("normal", new Ai(l, 3)), this.setAttribute("uv", new Ai(d, 2))
            }
        }
        class ah extends Js {
            constructor(e = 1, r = 0) {
                super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, r), this.type = "TetrahedronGeometry", this.parameters = {
                    radius: e,
                    detail: r
                }
            }
        }
        class sh extends bo {
            constructor(e, r = {}) {
                const h = r.font;
                if (!h || !h.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new an;
                const c = h.generateShapes(e, r.size);
                r.depth = r.height !== void 0 ? r.height : 50, r.bevelThickness === void 0 && (r.bevelThickness = 10), r.bevelSize === void 0 && (r.bevelSize = 8), r.bevelEnabled === void 0 && (r.bevelEnabled = !1), super(c, r), this.type = "TextGeometry"
            }
        }
        class Xo extends an {
            constructor(e = 1, r = .4, h = 8, c = 6, v = 2 * Math.PI) {
                super(), this.type = "TorusGeometry", this.parameters = {
                    radius: e,
                    tube: r,
                    radialSegments: h,
                    tubularSegments: c,
                    arc: v
                }, h = Math.floor(h), c = Math.floor(c);
                const w = [],
                    E = [],
                    T = [],
                    B = [],
                    Q = new ge,
                    k = new ge,
                    i = new ge;
                for (let t = 0; t <= h; t++)
                    for (let a = 0; a <= c; a++) {
                        const l = a / c * v,
                            d = t / h * Math.PI * 2;
                        k.x = (e + r * Math.cos(d)) * Math.cos(l), k.y = (e + r * Math.cos(d)) * Math.sin(l), k.z = r * Math.sin(d), E.push(k.x, k.y, k.z), Q.x = e * Math.cos(l), Q.y = e * Math.sin(l), i.subVectors(k, Q).normalize(), T.push(i.x, i.y, i.z), B.push(a / c), B.push(t / h)
                    }
                for (let t = 1; t <= h; t++)
                    for (let a = 1; a <= c; a++) {
                        const l = (c + 1) * t + a - 1,
                            d = (c + 1) * (t - 1) + a - 1,
                            g = (c + 1) * (t - 1) + a,
                            x = (c + 1) * t + a;
                        w.push(l, d, x), w.push(d, g, x)
                    }
                this.setIndex(w), this.setAttribute("position", new Ai(E, 3)), this.setAttribute("normal", new Ai(T, 3)), this.setAttribute("uv", new Ai(B, 2))
            }
        }
        class fc extends an {
            constructor(e = 1, r = .4, h = 64, c = 8, v = 2, w = 3) {
                super(), this.type = "TorusKnotGeometry", this.parameters = {
                    radius: e,
                    tube: r,
                    tubularSegments: h,
                    radialSegments: c,
                    p: v,
                    q: w
                }, h = Math.floor(h), c = Math.floor(c);
                const E = [],
                    T = [],
                    B = [],
                    Q = [],
                    k = new ge,
                    i = new ge,
                    t = new ge,
                    a = new ge,
                    l = new ge,
                    d = new ge,
                    g = new ge;
                for (let A = 0; A <= h; ++A) {
                    const M = A / h * v * Math.PI * 2;
                    x(M, v, w, e, t), x(M + .01, v, w, e, a), d.subVectors(a, t), g.addVectors(a, t), l.crossVectors(d, g), g.crossVectors(l, d), l.normalize(), g.normalize();
                    for (let F = 0; F <= c; ++F) {
                        const D = F / c * Math.PI * 2,
                            U = -r * Math.cos(D),
                            N = r * Math.sin(D);
                        k.x = t.x + (U * g.x + N * l.x), k.y = t.y + (U * g.y + N * l.y), k.z = t.z + (U * g.z + N * l.z), T.push(k.x, k.y, k.z), i.subVectors(k, t).normalize(), B.push(i.x, i.y, i.z), Q.push(A / h), Q.push(F / c)
                    }
                }
                for (let A = 1; A <= h; A++)
                    for (let M = 1; M <= c; M++) {
                        const F = (c + 1) * (A - 1) + (M - 1),
                            D = (c + 1) * A + (M - 1),
                            U = (c + 1) * A + M,
                            N = (c + 1) * (A - 1) + M;
                        E.push(F, D, N), E.push(D, U, N)
                    }

                function x(A, M, F, D, U) {
                    const N = Math.cos(A),
                        H = Math.sin(A),
                        X = F / M * A,
                        ne = Math.cos(X);
                    U.x = D * (2 + ne) * .5 * N, U.y = D * (2 + ne) * H * .5, U.z = D * Math.sin(X) * .5
                }
                this.setIndex(E), this.setAttribute("position", new Ai(T, 3)), this.setAttribute("normal", new Ai(B, 3)), this.setAttribute("uv", new Ai(Q, 2))
            }
        }
        class mc extends an {
            constructor(e, r = 64, h = 1, c = 8, v = !1) {
                super(), this.type = "TubeGeometry", this.parameters = {
                    path: e,
                    tubularSegments: r,
                    radius: h,
                    radialSegments: c,
                    closed: v
                };
                const w = e.computeFrenetFrames(r, v);
                this.tangents = w.tangents, this.normals = w.normals, this.binormals = w.binormals;
                const E = new ge,
                    T = new ge,
                    B = new Ht;
                let Q = new ge;
                const k = [],
                    i = [],
                    t = [],
                    a = [];

                function l(d) {
                    Q = e.getPointAt(d / r, Q);
                    const g = w.normals[d],
                        x = w.binormals[d];
                    for (let A = 0; A <= c; A++) {
                        const M = A / c * Math.PI * 2,
                            F = Math.sin(M),
                            D = -Math.cos(M);
                        T.x = D * g.x + F * x.x, T.y = D * g.y + F * x.y, T.z = D * g.z + F * x.z, T.normalize(), i.push(T.x, T.y, T.z), E.x = Q.x + h * T.x, E.y = Q.y + h * T.y, E.z = Q.z + h * T.z, k.push(E.x, E.y, E.z)
                    }
                }(function() {
                    for (let d = 0; d < r; d++) l(d);
                    l(v === !1 ? r : 0),
                        function() {
                            for (let d = 0; d <= r; d++)
                                for (let g = 0; g <= c; g++) B.x = d / r, B.y = g / c, t.push(B.x, B.y)
                        }(),
                        function() {
                            for (let d = 1; d <= r; d++)
                                for (let g = 1; g <= c; g++) {
                                    const x = (c + 1) * (d - 1) + (g - 1),
                                        A = (c + 1) * d + (g - 1),
                                        M = (c + 1) * d + g,
                                        F = (c + 1) * (d - 1) + g;
                                    a.push(x, A, F), a.push(A, M, F)
                                }
                        }()
                })(), this.setIndex(a), this.setAttribute("position", new Ai(k, 3)), this.setAttribute("normal", new Ai(i, 3)), this.setAttribute("uv", new Ai(t, 2))
            }
            toJSON() {
                const e = an.prototype.toJSON.call(this);
                return e.path = this.parameters.path.toJSON(), e
            }
        }
        class $h extends an {
            constructor(e) {
                if (super(), this.type = "WireframeGeometry", e.isGeometry === !0) return void console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                const r = [],
                    h = [0, 0],
                    c = {},
                    v = new ge;
                if (e.index !== null) {
                    const w = e.attributes.position,
                        E = e.index;
                    let T = e.groups;
                    T.length === 0 && (T = [{
                        start: 0,
                        count: E.count,
                        materialIndex: 0
                    }]);
                    for (let B = 0, Q = T.length; B < Q; ++B) {
                        const k = T[B],
                            i = k.start;
                        for (let t = i, a = i + k.count; t < a; t += 3)
                            for (let l = 0; l < 3; l++) {
                                const d = E.getX(t + l),
                                    g = E.getX(t + (l + 1) % 3);
                                h[0] = Math.min(d, g), h[1] = Math.max(d, g);
                                const x = h[0] + "," + h[1];
                                c[x] === void 0 && (c[x] = {
                                    index1: h[0],
                                    index2: h[1]
                                })
                            }
                    }
                    for (const B in c) {
                        const Q = c[B];
                        v.fromBufferAttribute(w, Q.index1), r.push(v.x, v.y, v.z), v.fromBufferAttribute(w, Q.index2), r.push(v.x, v.y, v.z)
                    }
                } else {
                    const w = e.attributes.position;
                    for (let E = 0, T = w.count / 3; E < T; E++)
                        for (let B = 0; B < 3; B++) {
                            const Q = 3 * E + B;
                            v.fromBufferAttribute(w, Q), r.push(v.x, v.y, v.z);
                            const k = 3 * E + (B + 1) % 3;
                            v.fromBufferAttribute(w, k), r.push(v.x, v.y, v.z)
                        }
                }
                this.setAttribute("position", new Ai(r, 3))
            }
        }
        var Na = Object.freeze({
            __proto__: null,
            BoxGeometry: sr,
            BoxBufferGeometry: sr,
            CircleGeometry: Jh,
            CircleBufferGeometry: Jh,
            ConeGeometry: _o,
            ConeBufferGeometry: _o,
            CylinderGeometry: ta,
            CylinderBufferGeometry: ta,
            DodecahedronGeometry: th,
            DodecahedronBufferGeometry: th,
            EdgesGeometry: jh,
            ExtrudeGeometry: bo,
            ExtrudeBufferGeometry: bo,
            IcosahedronGeometry: qh,
            IcosahedronBufferGeometry: qh,
            LatheGeometry: vr,
            LatheBufferGeometry: vr,
            OctahedronGeometry: Wo,
            OctahedronBufferGeometry: Wo,
            ParametricGeometry: Jo,
            ParametricBufferGeometry: Jo,
            PlaneGeometry: Is,
            PlaneBufferGeometry: Is,
            PolyhedronGeometry: Js,
            PolyhedronBufferGeometry: Js,
            RingGeometry: Rl,
            RingBufferGeometry: Rl,
            ShapeGeometry: Zo,
            ShapeBufferGeometry: Zo,
            SphereGeometry: wo,
            SphereBufferGeometry: wo,
            TetrahedronGeometry: ah,
            TetrahedronBufferGeometry: ah,
            TextGeometry: sh,
            TextBufferGeometry: sh,
            TorusGeometry: Xo,
            TorusBufferGeometry: Xo,
            TorusKnotGeometry: fc,
            TorusKnotBufferGeometry: fc,
            TubeGeometry: mc,
            TubeBufferGeometry: mc,
            WireframeGeometry: $h
        });
        class Kh extends ti {
            constructor(e) {
                super(), this.type = "ShadowMaterial", this.color = new Rt(0), this.transparent = !0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this
            }
        }
        Kh.prototype.isShadowMaterial = !0;
        class Xs extends Cn {
            constructor(e) {
                super(e), this.type = "RawShaderMaterial"
            }
        }

        function js(s) {
            ti.call(this), this.defines = {
                STANDARD: ""
            }, this.type = "MeshStandardMaterial", this.color = new Rt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Rt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Ht(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.vertexTangents = !1, this.setValues(s)
        }

        function Ys(s) {
            js.call(this), this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Ht(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, Object.defineProperty(this, "ior", {
                get: function() {
                    return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity)
                },
                set: function(e) {
                    this.reflectivity = Mi.clamp(2.5 * (e - 1) / (e + 1), 0, 1)
                }
            }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues(s)
        }
        Xs.prototype.isRawShaderMaterial = !0, js.prototype = Object.create(ti.prototype), js.prototype.constructor = js, js.prototype.isMeshStandardMaterial = !0, js.prototype.copy = function(s) {
            return ti.prototype.copy.call(this, s), this.defines = {
                STANDARD: ""
            }, this.color.copy(s.color), this.roughness = s.roughness, this.metalness = s.metalness, this.map = s.map, this.lightMap = s.lightMap, this.lightMapIntensity = s.lightMapIntensity, this.aoMap = s.aoMap, this.aoMapIntensity = s.aoMapIntensity, this.emissive.copy(s.emissive), this.emissiveMap = s.emissiveMap, this.emissiveIntensity = s.emissiveIntensity, this.bumpMap = s.bumpMap, this.bumpScale = s.bumpScale, this.normalMap = s.normalMap, this.normalMapType = s.normalMapType, this.normalScale.copy(s.normalScale), this.displacementMap = s.displacementMap, this.displacementScale = s.displacementScale, this.displacementBias = s.displacementBias, this.roughnessMap = s.roughnessMap, this.metalnessMap = s.metalnessMap, this.alphaMap = s.alphaMap, this.envMap = s.envMap, this.envMapIntensity = s.envMapIntensity, this.refractionRatio = s.refractionRatio, this.wireframe = s.wireframe, this.wireframeLinewidth = s.wireframeLinewidth, this.wireframeLinecap = s.wireframeLinecap, this.wireframeLinejoin = s.wireframeLinejoin, this.skinning = s.skinning, this.morphTargets = s.morphTargets, this.morphNormals = s.morphNormals, this.flatShading = s.flatShading, this.vertexTangents = s.vertexTangents, this
        }, Ys.prototype = Object.create(js.prototype), Ys.prototype.constructor = Ys, Ys.prototype.isMeshPhysicalMaterial = !0, Ys.prototype.copy = function(s) {
            return js.prototype.copy.call(this, s), this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.clearcoat = s.clearcoat, this.clearcoatMap = s.clearcoatMap, this.clearcoatRoughness = s.clearcoatRoughness, this.clearcoatRoughnessMap = s.clearcoatRoughnessMap, this.clearcoatNormalMap = s.clearcoatNormalMap, this.clearcoatNormalScale.copy(s.clearcoatNormalScale), this.reflectivity = s.reflectivity, s.sheen ? this.sheen = (this.sheen || new Rt).copy(s.sheen) : this.sheen = null, this.transmission = s.transmission, this.transmissionMap = s.transmissionMap, this
        };
        class Gu extends ti {
            constructor(e) {
                super(), this.type = "MeshPhongMaterial", this.color = new Rt(16777215), this.specular = new Rt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Rt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Ht(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.flatShading = e.flatShading, this
            }
        }
        Gu.prototype.isMeshPhongMaterial = !0;
        class oh extends ti {
            constructor(e) {
                super(), this.defines = {
                    TOON: ""
                }, this.type = "MeshToonMaterial", this.color = new Rt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Rt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Ht(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }
        }
        oh.prototype.isMeshToonMaterial = !0;
        class lh extends ti {
            constructor(e) {
                super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Ht(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.flatShading = e.flatShading, this
            }
        }
        lh.prototype.isMeshNormalMaterial = !0;
        class ch extends ti {
            constructor(e) {
                super(), this.type = "MeshLambertMaterial", this.color = new Rt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Rt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }
        }
        ch.prototype.isMeshLambertMaterial = !0;
        class eu extends ti {
            constructor(e) {
                super(), this.defines = {
                    MATCAP: ""
                }, this.type = "MeshMatcapMaterial", this.color = new Rt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Ht(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.defines = {
                    MATCAP: ""
                }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.flatShading = e.flatShading, this
            }
        }
        eu.prototype.isMeshMatcapMaterial = !0;
        class tu extends Xr {
            constructor(e) {
                super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
            }
        }
        tu.prototype.isLineDashedMaterial = !0;
        var Ep = Object.freeze({
            __proto__: null,
            ShadowMaterial: Kh,
            SpriteMaterial: ci,
            RawShaderMaterial: Xs,
            ShaderMaterial: Cn,
            PointsMaterial: Ml,
            MeshPhysicalMaterial: Ys,
            MeshStandardMaterial: js,
            MeshPhongMaterial: Gu,
            MeshToonMaterial: oh,
            MeshNormalMaterial: lh,
            MeshLambertMaterial: ch,
            MeshDepthMaterial: S,
            MeshDistanceMaterial: L,
            MeshBasicMaterial: Gi,
            MeshMatcapMaterial: eu,
            LineDashedMaterial: tu,
            LineBasicMaterial: Xr,
            Material: ti
        });
        const Br = {
            arraySlice: function(s, e, r) {
                return Br.isTypedArray(s) ? new s.constructor(s.subarray(e, r !== void 0 ? r : s.length)) : s.slice(e, r)
            },
            convertArray: function(s, e, r) {
                return !s || !r && s.constructor === e ? s : typeof e.BYTES_PER_ELEMENT == "number" ? new e(s) : Array.prototype.slice.call(s)
            },
            isTypedArray: function(s) {
                return ArrayBuffer.isView(s) && !(s instanceof DataView)
            },
            getKeyframeOrder: function(s) {
                const e = s.length,
                    r = new Array(e);
                for (let h = 0; h !== e; ++h) r[h] = h;
                return r.sort(function(h, c) {
                    return s[h] - s[c]
                }), r
            },
            sortedArray: function(s, e, r) {
                const h = s.length,
                    c = new s.constructor(h);
                for (let v = 0, w = 0; w !== h; ++v) {
                    const E = r[v] * e;
                    for (let T = 0; T !== e; ++T) c[w++] = s[E + T]
                }
                return c
            },
            flattenJSON: function(s, e, r, h) {
                let c = 1,
                    v = s[0];
                for (; v !== void 0 && v[h] === void 0;) v = s[c++];
                if (v === void 0) return;
                let w = v[h];
                if (w !== void 0)
                    if (Array.isArray(w))
                        do w = v[h], w !== void 0 && (e.push(v.time), r.push.apply(r, w)), v = s[c++]; while (v !== void 0);
                    else if (w.toArray !== void 0)
                    do w = v[h], w !== void 0 && (e.push(v.time), w.toArray(r, r.length)), v = s[c++]; while (v !== void 0);
                else
                    do w = v[h], w !== void 0 && (e.push(v.time), r.push(w)), v = s[c++]; while (v !== void 0)
            },
            subclip: function(s, e, r, h, c = 30) {
                const v = s.clone();
                v.name = e;
                const w = [];
                for (let T = 0; T < v.tracks.length; ++T) {
                    const B = v.tracks[T],
                        Q = B.getValueSize(),
                        k = [],
                        i = [];
                    for (let t = 0; t < B.times.length; ++t) {
                        const a = B.times[t] * c;
                        if (!(a < r || a >= h)) {
                            k.push(B.times[t]);
                            for (let l = 0; l < Q; ++l) i.push(B.values[t * Q + l])
                        }
                    }
                    k.length !== 0 && (B.times = Br.convertArray(k, B.times.constructor), B.values = Br.convertArray(i, B.values.constructor), w.push(B))
                }
                v.tracks = w;
                let E = 1 / 0;
                for (let T = 0; T < v.tracks.length; ++T) E > v.tracks[T].times[0] && (E = v.tracks[T].times[0]);
                for (let T = 0; T < v.tracks.length; ++T) v.tracks[T].shift(-1 * E);
                return v.resetDuration(), v
            },
            makeClipAdditive: function(s, e = 0, r = s, h = 30) {
                h <= 0 && (h = 30);
                const c = r.tracks.length,
                    v = e / h;
                for (let w = 0; w < c; ++w) {
                    const E = r.tracks[w],
                        T = E.ValueTypeName;
                    if (T === "bool" || T === "string") continue;
                    const B = s.tracks.find(function(g) {
                        return g.name === E.name && g.ValueTypeName === T
                    });
                    if (B === void 0) continue;
                    let Q = 0;
                    const k = E.getValueSize();
                    E.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (Q = k / 3);
                    let i = 0;
                    const t = B.getValueSize();
                    B.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (i = t / 3);
                    const a = E.times.length - 1;
                    let l;
                    if (v <= E.times[0]) {
                        const g = Q,
                            x = k - Q;
                        l = Br.arraySlice(E.values, g, x)
                    } else if (v >= E.times[a]) {
                        const g = a * k + Q,
                            x = g + k - Q;
                        l = Br.arraySlice(E.values, g, x)
                    } else {
                        const g = E.createInterpolant(),
                            x = Q,
                            A = k - Q;
                        g.evaluate(v), l = Br.arraySlice(g.resultBuffer, x, A)
                    }
                    T === "quaternion" && new Bn().fromArray(l).normalize().conjugate().toArray(l);
                    const d = B.times.length;
                    for (let g = 0; g < d; ++g) {
                        const x = g * t + i;
                        if (T === "quaternion") Bn.multiplyQuaternionsFlat(B.values, x, l, 0, B.values, x);
                        else {
                            const A = t - 2 * i;
                            for (let M = 0; M < A; ++M) B.values[x + M] -= l[M]
                        }
                    }
                }
                return s.blendMode = 2501, s
            }
        };

        function ts(s, e, r, h) {
            this.parameterPositions = s, this._cachedIndex = 0, this.resultBuffer = h !== void 0 ? h : new e.constructor(r), this.sampleValues = e, this.valueSize = r
        }

        function iu(s, e, r, h) {
            ts.call(this, s, e, r, h), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
        }

        function hh(s, e, r, h) {
            ts.call(this, s, e, r, h)
        }

        function Cs(s, e, r, h) {
            ts.call(this, s, e, r, h)
        }
        Object.assign(ts.prototype, {
            evaluate: function(s) {
                const e = this.parameterPositions;
                let r = this._cachedIndex,
                    h = e[r],
                    c = e[r - 1];
                e: {
                    t: {
                        let v;i: {
                            n: if (!(s < h)) {
                                for (let w = r + 2;;) {
                                    if (h === void 0) {
                                        if (s < c) break n;
                                        return r = e.length, this._cachedIndex = r, this.afterEnd_(r - 1, s, c)
                                    }
                                    if (r === w) break;
                                    if (c = h, h = e[++r], s < h) break t
                                }
                                v = e.length;
                                break i
                            }if (s >= c) break e;
                            {
                                const w = e[1];
                                s < w && (r = 2, c = w);
                                for (let E = r - 2;;) {
                                    if (c === void 0) return this._cachedIndex = 0, this.beforeStart_(0, s, h);
                                    if (r === E) break;
                                    if (h = c, c = e[--r - 1], s >= c) break t
                                }
                                v = r, r = 0
                            }
                        }
                        for (; r < v;) {
                            const w = r + v >>> 1;
                            s < e[w] ? v = w : r = w + 1
                        }
                        if (h = e[r], c = e[r - 1], c === void 0) return this._cachedIndex = 0,
                        this.beforeStart_(0, s, h);
                        if (h === void 0) return r = e.length,
                        this._cachedIndex = r,
                        this.afterEnd_(r - 1, c, s)
                    }
                    this._cachedIndex = r,
                    this.intervalChanged_(r, c, h)
                }
                return this.interpolate_(r, c, s, h)
            },
            settings: null,
            DefaultSettings_: {},
            getSettings_: function() {
                return this.settings || this.DefaultSettings_
            },
            copySampleValue_: function(s) {
                const e = this.resultBuffer,
                    r = this.sampleValues,
                    h = this.valueSize,
                    c = s * h;
                for (let v = 0; v !== h; ++v) e[v] = r[c + v];
                return e
            },
            interpolate_: function() {
                throw new Error("call to abstract method")
            },
            intervalChanged_: function() {}
        }), Object.assign(ts.prototype, {
            beforeStart_: ts.prototype.copySampleValue_,
            afterEnd_: ts.prototype.copySampleValue_
        }), iu.prototype = Object.assign(Object.create(ts.prototype), {
            constructor: iu,
            DefaultSettings_: {
                endingStart: 2400,
                endingEnd: 2400
            },
            intervalChanged_: function(s, e, r) {
                const h = this.parameterPositions;
                let c = s - 2,
                    v = s + 1,
                    w = h[c],
                    E = h[v];
                if (w === void 0) switch (this.getSettings_().endingStart) {
                    case 2401:
                        c = s, w = 2 * e - r;
                        break;
                    case 2402:
                        c = h.length - 2, w = e + h[c] - h[c + 1];
                        break;
                    default:
                        c = s, w = r
                }
                if (E === void 0) switch (this.getSettings_().endingEnd) {
                    case 2401:
                        v = s, E = 2 * r - e;
                        break;
                    case 2402:
                        v = 1, E = r + h[1] - h[0];
                        break;
                    default:
                        v = s - 1, E = e
                }
                const T = .5 * (r - e),
                    B = this.valueSize;
                this._weightPrev = T / (e - w), this._weightNext = T / (E - r), this._offsetPrev = c * B, this._offsetNext = v * B
            },
            interpolate_: function(s, e, r, h) {
                const c = this.resultBuffer,
                    v = this.sampleValues,
                    w = this.valueSize,
                    E = s * w,
                    T = E - w,
                    B = this._offsetPrev,
                    Q = this._offsetNext,
                    k = this._weightPrev,
                    i = this._weightNext,
                    t = (r - e) / (h - e),
                    a = t * t,
                    l = a * t,
                    d = -k * l + 2 * k * a - k * t,
                    g = (1 + k) * l + (-1.5 - 2 * k) * a + (-.5 + k) * t + 1,
                    x = (-1 - i) * l + (1.5 + i) * a + .5 * t,
                    A = i * l - i * a;
                for (let M = 0; M !== w; ++M) c[M] = d * v[B + M] + g * v[T + M] + x * v[E + M] + A * v[Q + M];
                return c
            }
        }), hh.prototype = Object.assign(Object.create(ts.prototype), {
            constructor: hh,
            interpolate_: function(s, e, r, h) {
                const c = this.resultBuffer,
                    v = this.sampleValues,
                    w = this.valueSize,
                    E = s * w,
                    T = E - w,
                    B = (r - e) / (h - e),
                    Q = 1 - B;
                for (let k = 0; k !== w; ++k) c[k] = v[T + k] * Q + v[E + k] * B;
                return c
            }
        }), Cs.prototype = Object.assign(Object.create(ts.prototype), {
            constructor: Cs,
            interpolate_: function(s) {
                return this.copySampleValue_(s - 1)
            }
        });
        class Bs {
            constructor(e, r, h, c) {
                if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (r === void 0 || r.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                this.name = e, this.times = Br.convertArray(r, this.TimeBufferType), this.values = Br.convertArray(h, this.ValueBufferType), this.setInterpolation(c || this.DefaultInterpolation)
            }
            static toJSON(e) {
                const r = e.constructor;
                let h;
                if (r.toJSON !== this.toJSON) h = r.toJSON(e);
                else {
                    h = {
                        name: e.name,
                        times: Br.convertArray(e.times, Array),
                        values: Br.convertArray(e.values, Array)
                    };
                    const c = e.getInterpolation();
                    c !== e.DefaultInterpolation && (h.interpolation = c)
                }
                return h.type = e.ValueTypeName, h
            }
            InterpolantFactoryMethodDiscrete(e) {
                return new Cs(this.times, this.values, this.getValueSize(), e)
            }
            InterpolantFactoryMethodLinear(e) {
                return new hh(this.times, this.values, this.getValueSize(), e)
            }
            InterpolantFactoryMethodSmooth(e) {
                return new iu(this.times, this.values, this.getValueSize(), e)
            }
            setInterpolation(e) {
                let r;
                switch (e) {
                    case 2300:
                        r = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case 2301:
                        r = this.InterpolantFactoryMethodLinear;
                        break;
                    case 2302:
                        r = this.InterpolantFactoryMethodSmooth
                }
                if (r === void 0) {
                    const h = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (this.createInterpolant === void 0) {
                        if (e === this.DefaultInterpolation) throw new Error(h);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", h), this
                }
                return this.createInterpolant = r, this
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return 2300;
                    case this.InterpolantFactoryMethodLinear:
                        return 2301;
                    case this.InterpolantFactoryMethodSmooth:
                        return 2302
                }
            }
            getValueSize() {
                return this.values.length / this.times.length
            }
            shift(e) {
                if (e !== 0) {
                    const r = this.times;
                    for (let h = 0, c = r.length; h !== c; ++h) r[h] += e
                }
                return this
            }
            scale(e) {
                if (e !== 1) {
                    const r = this.times;
                    for (let h = 0, c = r.length; h !== c; ++h) r[h] *= e
                }
                return this
            }
            trim(e, r) {
                const h = this.times,
                    c = h.length;
                let v = 0,
                    w = c - 1;
                for (; v !== c && h[v] < e;) ++v;
                for (; w !== -1 && h[w] > r;) --w;
                if (++w, v !== 0 || w !== c) {
                    v >= w && (w = Math.max(w, 1), v = w - 1);
                    const E = this.getValueSize();
                    this.times = Br.arraySlice(h, v, w), this.values = Br.arraySlice(this.values, v * E, w * E)
                }
                return this
            }
            validate() {
                let e = !0;
                const r = this.getValueSize();
                r - Math.floor(r) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
                const h = this.times,
                    c = this.values,
                    v = h.length;
                v === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
                let w = null;
                for (let E = 0; E !== v; E++) {
                    const T = h[E];
                    if (typeof T == "number" && isNaN(T)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, E, T), e = !1;
                        break
                    }
                    if (w !== null && w > T) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, E, T, w), e = !1;
                        break
                    }
                    w = T
                }
                if (c !== void 0 && Br.isTypedArray(c))
                    for (let E = 0, T = c.length; E !== T; ++E) {
                        const B = c[E];
                        if (isNaN(B)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, E, B), e = !1;
                            break
                        }
                    }
                return e
            }
            optimize() {
                const e = Br.arraySlice(this.times),
                    r = Br.arraySlice(this.values),
                    h = this.getValueSize(),
                    c = this.getInterpolation() === 2302,
                    v = e.length - 1;
                let w = 1;
                for (let E = 1; E < v; ++E) {
                    let T = !1;
                    const B = e[E];
                    if (B !== e[E + 1] && (E !== 1 || B !== e[0]))
                        if (c) T = !0;
                        else {
                            const Q = E * h,
                                k = Q - h,
                                i = Q + h;
                            for (let t = 0; t !== h; ++t) {
                                const a = r[Q + t];
                                if (a !== r[k + t] || a !== r[i + t]) {
                                    T = !0;
                                    break
                                }
                            }
                        } if (T) {
                        if (E !== w) {
                            e[w] = e[E];
                            const Q = E * h,
                                k = w * h;
                            for (let i = 0; i !== h; ++i) r[k + i] = r[Q + i]
                        }++w
                    }
                }
                if (v > 0) {
                    e[w] = e[v];
                    for (let E = v * h, T = w * h, B = 0; B !== h; ++B) r[T + B] = r[E + B];
                    ++w
                }
                return w !== e.length ? (this.times = Br.arraySlice(e, 0, w), this.values = Br.arraySlice(r, 0, w * h)) : (this.times = e, this.values = r), this
            }
            clone() {
                const e = Br.arraySlice(this.times, 0),
                    r = Br.arraySlice(this.values, 0),
                    h = new this.constructor(this.name, e, r);
                return h.createInterpolant = this.createInterpolant, h
            }
        }
        Bs.prototype.TimeBufferType = Float32Array, Bs.prototype.ValueBufferType = Float32Array, Bs.prototype.DefaultInterpolation = 2301;
        class jo extends Bs {}
        jo.prototype.ValueTypeName = "bool", jo.prototype.ValueBufferType = Array, jo.prototype.DefaultInterpolation = 2300, jo.prototype.InterpolantFactoryMethodLinear = void 0, jo.prototype.InterpolantFactoryMethodSmooth = void 0;
        class Yo extends Bs {}
        Yo.prototype.ValueTypeName = "color";
        class uh extends Bs {}

        function nu(s, e, r, h) {
            ts.call(this, s, e, r, h)
        }
        uh.prototype.ValueTypeName = "number", nu.prototype = Object.assign(Object.create(ts.prototype), {
            constructor: nu,
            interpolate_: function(s, e, r, h) {
                const c = this.resultBuffer,
                    v = this.sampleValues,
                    w = this.valueSize,
                    E = (r - e) / (h - e);
                let T = s * w;
                for (let B = T + w; T !== B; T += 4) Bn.slerpFlat(c, 0, v, T - w, v, T, E);
                return c
            }
        });
        class gc extends Bs {
            InterpolantFactoryMethodLinear(e) {
                return new nu(this.times, this.values, this.getValueSize(), e)
            }
        }
        gc.prototype.ValueTypeName = "quaternion", gc.prototype.DefaultInterpolation = 2301, gc.prototype.InterpolantFactoryMethodSmooth = void 0;
        class qo extends Bs {}
        qo.prototype.ValueTypeName = "string", qo.prototype.ValueBufferType = Array, qo.prototype.DefaultInterpolation = 2300, qo.prototype.InterpolantFactoryMethodLinear = void 0, qo.prototype.InterpolantFactoryMethodSmooth = void 0;
        class yc extends Bs {}
        yc.prototype.ValueTypeName = "vector";
        class dh {
            constructor(e, r = -1, h, c = 2500) {
                this.name = e, this.tracks = h, this.duration = r, this.blendMode = c, this.uuid = Mi.generateUUID(), this.duration < 0 && this.resetDuration()
            }
            static parse(e) {
                const r = [],
                    h = e.tracks,
                    c = 1 / (e.fps || 1);
                for (let w = 0, E = h.length; w !== E; ++w) r.push(Sp(h[w]).scale(c));
                const v = new this(e.name, e.duration, r, e.blendMode);
                return v.uuid = e.uuid, v
            }
            static toJSON(e) {
                const r = [],
                    h = e.tracks,
                    c = {
                        name: e.name,
                        duration: e.duration,
                        tracks: r,
                        uuid: e.uuid,
                        blendMode: e.blendMode
                    };
                for (let v = 0, w = h.length; v !== w; ++v) r.push(Bs.toJSON(h[v]));
                return c
            }
            static CreateFromMorphTargetSequence(e, r, h, c) {
                const v = r.length,
                    w = [];
                for (let E = 0; E < v; E++) {
                    let T = [],
                        B = [];
                    T.push((E + v - 1) % v, E, (E + 1) % v), B.push(0, 1, 0);
                    const Q = Br.getKeyframeOrder(T);
                    T = Br.sortedArray(T, 1, Q), B = Br.sortedArray(B, 1, Q), c || T[0] !== 0 || (T.push(v), B.push(B[0])), w.push(new uh(".morphTargetInfluences[" + r[E].name + "]", T, B).scale(1 / h))
                }
                return new this(e, -1, w)
            }
            static findByName(e, r) {
                let h = e;
                if (!Array.isArray(e)) {
                    const c = e;
                    h = c.geometry && c.geometry.animations || c.animations
                }
                for (let c = 0; c < h.length; c++)
                    if (h[c].name === r) return h[c];
                return null
            }
            static CreateClipsFromMorphTargetSequences(e, r, h) {
                const c = {},
                    v = /^([\w-]*?)([\d]+)$/;
                for (let E = 0, T = e.length; E < T; E++) {
                    const B = e[E],
                        Q = B.name.match(v);
                    if (Q && Q.length > 1) {
                        const k = Q[1];
                        let i = c[k];
                        i || (c[k] = i = []), i.push(B)
                    }
                }
                const w = [];
                for (const E in c) w.push(this.CreateFromMorphTargetSequence(E, c[E], r, h));
                return w
            }
            static parseAnimation(e, r) {
                if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                const h = function(Q, k, i, t, a) {
                        if (i.length !== 0) {
                            const l = [],
                                d = [];
                            Br.flattenJSON(i, l, d, t), l.length !== 0 && a.push(new Q(k, l, d))
                        }
                    },
                    c = [],
                    v = e.name || "default",
                    w = e.fps || 30,
                    E = e.blendMode;
                let T = e.length || -1;
                const B = e.hierarchy || [];
                for (let Q = 0; Q < B.length; Q++) {
                    const k = B[Q].keys;
                    if (k && k.length !== 0)
                        if (k[0].morphTargets) {
                            const i = {};
                            let t;
                            for (t = 0; t < k.length; t++)
                                if (k[t].morphTargets)
                                    for (let a = 0; a < k[t].morphTargets.length; a++) i[k[t].morphTargets[a]] = -1;
                            for (const a in i) {
                                const l = [],
                                    d = [];
                                for (let g = 0; g !== k[t].morphTargets.length; ++g) {
                                    const x = k[t];
                                    l.push(x.time), d.push(x.morphTarget === a ? 1 : 0)
                                }
                                c.push(new uh(".morphTargetInfluence[" + a + "]", l, d))
                            }
                            T = i.length * (w || 1)
                        } else {
                            const i = ".bones[" + r[Q].name + "]";
                            h(yc, i + ".position", k, "pos", c), h(gc, i + ".quaternion", k, "rot", c), h(yc, i + ".scale", k, "scl", c)
                        }
                }
                return c.length === 0 ? null : new this(v, T, c, E)
            }
            resetDuration() {
                let e = 0;
                for (let r = 0, h = this.tracks.length; r !== h; ++r) {
                    const c = this.tracks[r];
                    e = Math.max(e, c.times[c.times.length - 1])
                }
                return this.duration = e, this
            }
            trim() {
                for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
                return this
            }
            validate() {
                let e = !0;
                for (let r = 0; r < this.tracks.length; r++) e = e && this.tracks[r].validate();
                return e
            }
            optimize() {
                for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
                return this
            }
            clone() {
                const e = [];
                for (let r = 0; r < this.tracks.length; r++) e.push(this.tracks[r].clone());
                return new this.constructor(this.name, this.duration, e, this.blendMode)
            }
            toJSON() {
                return this.constructor.toJSON(this)
            }
        }

        function Sp(s) {
            if (s.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            const e = function(r) {
                switch (r.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return uh;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return yc;
                    case "color":
                        return Yo;
                    case "quaternion":
                        return gc;
                    case "bool":
                    case "boolean":
                        return jo;
                    case "string":
                        return qo
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + r)
            }(s.type);
            if (s.times === void 0) {
                const r = [],
                    h = [];
                Br.flattenJSON(s.keys, r, h, "value"), s.times = r, s.values = h
            }
            return e.parse !== void 0 ? e.parse(s) : new e(s.name, s.times, s.values, s.interpolation)
        }
        const Fl = {
            enabled: !1,
            files: {},
            add: function(s, e) {
                this.enabled !== !1 && (this.files[s] = e)
            },
            get: function(s) {
                if (this.enabled !== !1) return this.files[s]
            },
            remove: function(s) {
                delete this.files[s]
            },
            clear: function() {
                this.files = {}
            }
        };

        function Hu(s, e, r) {
            const h = this;
            let c, v = !1,
                w = 0,
                E = 0;
            const T = [];
            this.onStart = void 0, this.onLoad = s, this.onProgress = e, this.onError = r, this.itemStart = function(B) {
                E++, v === !1 && h.onStart !== void 0 && h.onStart(B, w, E), v = !0
            }, this.itemEnd = function(B) {
                w++, h.onProgress !== void 0 && h.onProgress(B, w, E), w === E && (v = !1, h.onLoad !== void 0 && h.onLoad())
            }, this.itemError = function(B) {
                h.onError !== void 0 && h.onError(B)
            }, this.resolveURL = function(B) {
                return c ? c(B) : B
            }, this.setURLModifier = function(B) {
                return c = B, this
            }, this.addHandler = function(B, Q) {
                return T.push(B, Q), this
            }, this.removeHandler = function(B) {
                const Q = T.indexOf(B);
                return Q !== -1 && T.splice(Q, 2), this
            }, this.getHandler = function(B) {
                for (let Q = 0, k = T.length; Q < k; Q += 2) {
                    const i = T[Q],
                        t = T[Q + 1];
                    if (i.global && (i.lastIndex = 0), i.test(B)) return t
                }
                return null
            }
        }
        const ru = new Hu;

        function _r(s) {
            this.manager = s !== void 0 ? s : ru, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
        }
        Object.assign(_r.prototype, {
            load: function() {},
            loadAsync: function(s, e) {
                const r = this;
                return new Promise(function(h, c) {
                    r.load(s, h, e, c)
                })
            },
            parse: function() {},
            setCrossOrigin: function(s) {
                return this.crossOrigin = s, this
            },
            setWithCredentials: function(s) {
                return this.withCredentials = s, this
            },
            setPath: function(s) {
                return this.path = s, this
            },
            setResourcePath: function(s) {
                return this.resourcePath = s, this
            },
            setRequestHeader: function(s) {
                return this.requestHeader = s, this
            }
        });
        const is = {};

        function hs(s) {
            _r.call(this, s)
        }
        hs.prototype = Object.assign(Object.create(_r.prototype), {
            constructor: hs,
            load: function(s, e, r, h) {
                s === void 0 && (s = ""), this.path !== void 0 && (s = this.path + s), s = this.manager.resolveURL(s);
                const c = this,
                    v = Fl.get(s);
                if (v !== void 0) return c.manager.itemStart(s), setTimeout(function() {
                    e && e(v), c.manager.itemEnd(s)
                }, 0), v;
                if (is[s] !== void 0) return void is[s].push({
                    onLoad: e,
                    onProgress: r,
                    onError: h
                });
                const w = s.match(/^data:(.*?)(;base64)?,(.*)$/);
                let E;
                if (w) {
                    const T = w[1],
                        B = !!w[2];
                    let Q = w[3];
                    Q = decodeURIComponent(Q), B && (Q = atob(Q));
                    try {
                        let k;
                        const i = (this.responseType || "").toLowerCase();
                        switch (i) {
                            case "arraybuffer":
                            case "blob":
                                const t = new Uint8Array(Q.length);
                                for (let l = 0; l < Q.length; l++) t[l] = Q.charCodeAt(l);
                                k = i === "blob" ? new Blob([t.buffer], {
                                    type: T
                                }) : t.buffer;
                                break;
                            case "document":
                                k = new DOMParser().parseFromString(Q, T);
                                break;
                            case "json":
                                k = JSON.parse(Q);
                                break;
                            default:
                                k = Q
                        }
                        setTimeout(function() {
                            e && e(k), c.manager.itemEnd(s)
                        }, 0)
                    } catch (k) {
                        setTimeout(function() {
                            h && h(k), c.manager.itemError(s), c.manager.itemEnd(s)
                        }, 0)
                    }
                } else {
                    is[s] = [], is[s].push({
                        onLoad: e,
                        onProgress: r,
                        onError: h
                    }), E = new XMLHttpRequest, E.open("GET", s, !0), E.addEventListener("load", function(T) {
                        const B = this.response,
                            Q = is[s];
                        if (delete is[s], this.status === 200 || this.status === 0) {
                            this.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), Fl.add(s, B);
                            for (let k = 0, i = Q.length; k < i; k++) {
                                const t = Q[k];
                                t.onLoad && t.onLoad(B)
                            }
                            c.manager.itemEnd(s)
                        } else {
                            for (let k = 0, i = Q.length; k < i; k++) {
                                const t = Q[k];
                                t.onError && t.onError(T)
                            }
                            c.manager.itemError(s), c.manager.itemEnd(s)
                        }
                    }, !1), E.addEventListener("progress", function(T) {
                        const B = is[s];
                        for (let Q = 0, k = B.length; Q < k; Q++) {
                            const i = B[Q];
                            i.onProgress && i.onProgress(T)
                        }
                    }, !1), E.addEventListener("error", function(T) {
                        const B = is[s];
                        delete is[s];
                        for (let Q = 0, k = B.length; Q < k; Q++) {
                            const i = B[Q];
                            i.onError && i.onError(T)
                        }
                        c.manager.itemError(s), c.manager.itemEnd(s)
                    }, !1), E.addEventListener("abort", function(T) {
                        const B = is[s];
                        delete is[s];
                        for (let Q = 0, k = B.length; Q < k; Q++) {
                            const i = B[Q];
                            i.onError && i.onError(T)
                        }
                        c.manager.itemError(s), c.manager.itemEnd(s)
                    }, !1), this.responseType !== void 0 && (E.responseType = this.responseType), this.withCredentials !== void 0 && (E.withCredentials = this.withCredentials), E.overrideMimeType && E.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
                    for (const T in this.requestHeader) E.setRequestHeader(T, this.requestHeader[T]);
                    E.send(null)
                }
                return c.manager.itemStart(s), E
            },
            setResponseType: function(s) {
                return this.responseType = s, this
            },
            setMimeType: function(s) {
                return this.mimeType = s, this
            }
        });

        function Wu(s) {
            _r.call(this, s)
        }
        Wu.prototype = Object.assign(Object.create(_r.prototype), {
            constructor: Wu,
            load: function(s, e, r, h) {
                const c = this,
                    v = [],
                    w = new hc,
                    E = new hs(this.manager);
                E.setPath(this.path), E.setResponseType("arraybuffer"), E.setRequestHeader(this.requestHeader), E.setWithCredentials(c.withCredentials);
                let T = 0;

                function B(Q) {
                    E.load(s[Q], function(k) {
                        const i = c.parse(k, !0);
                        v[Q] = {
                            width: i.width,
                            height: i.height,
                            format: i.format,
                            mipmaps: i.mipmaps
                        }, T += 1, T === 6 && (i.mipmapCount === 1 && (w.minFilter = 1006), w.image = v, w.format = i.format, w.needsUpdate = !0, e && e(w))
                    }, r, h)
                }
                if (Array.isArray(s))
                    for (let Q = 0, k = s.length; Q < k; ++Q) B(Q);
                else E.load(s, function(Q) {
                    const k = c.parse(Q, !0);
                    if (k.isCubemap) {
                        const i = k.mipmaps.length / k.mipmapCount;
                        for (let t = 0; t < i; t++) {
                            v[t] = {
                                mipmaps: []
                            };
                            for (let a = 0; a < k.mipmapCount; a++) v[t].mipmaps.push(k.mipmaps[t * k.mipmapCount + a]), v[t].format = k.format, v[t].width = k.width, v[t].height = k.height
                        }
                        w.image = v
                    } else w.image.width = k.width, w.image.height = k.height, w.mipmaps = k.mipmaps;
                    k.mipmapCount === 1 && (w.minFilter = 1006), w.format = k.format, w.needsUpdate = !0, e && e(w)
                }, r, h);
                return w
            }
        });
        class ph extends _r {
            constructor(e) {
                super(e)
            }
            load(e, r, h, c) {
                this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
                const v = this,
                    w = Fl.get(e);
                if (w !== void 0) return v.manager.itemStart(e), setTimeout(function() {
                    r && r(w), v.manager.itemEnd(e)
                }, 0), w;
                const E = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

                function T() {
                    E.removeEventListener("load", T, !1), E.removeEventListener("error", B, !1), Fl.add(e, this), r && r(this), v.manager.itemEnd(e)
                }

                function B(Q) {
                    E.removeEventListener("load", T, !1), E.removeEventListener("error", B, !1), c && c(Q), v.manager.itemError(e), v.manager.itemEnd(e)
                }
                return E.addEventListener("load", T, !1), E.addEventListener("error", B, !1), e.substr(0, 5) !== "data:" && this.crossOrigin !== void 0 && (E.crossOrigin = this.crossOrigin), v.manager.itemStart(e), E.src = e, E
            }
        }
        class Jd extends _r {
            constructor(e) {
                super(e)
            }
            load(e, r, h, c) {
                const v = new ao,
                    w = new ph(this.manager);
                w.setCrossOrigin(this.crossOrigin), w.setPath(this.path);
                let E = 0;

                function T(B) {
                    w.load(e[B], function(Q) {
                        v.images[B] = Q, E++, E === 6 && (v.needsUpdate = !0, r && r(v))
                    }, void 0, c)
                }
                for (let B = 0; B < e.length; ++B) T(B);
                return v
            }
        }

        function au(s) {
            _r.call(this, s)
        }

        function $o(s) {
            _r.call(this, s)
        }

        function Qa() {
            this.type = "Curve", this.arcLengthDivisions = 200
        }
        au.prototype = Object.assign(Object.create(_r.prototype), {
            constructor: au,
            load: function(s, e, r, h) {
                const c = this,
                    v = new ws,
                    w = new hs(this.manager);
                return w.setResponseType("arraybuffer"), w.setRequestHeader(this.requestHeader), w.setPath(this.path), w.setWithCredentials(c.withCredentials), w.load(s, function(E) {
                    const T = c.parse(E);
                    T && (T.image !== void 0 ? v.image = T.image : T.data !== void 0 && (v.image.width = T.width, v.image.height = T.height, v.image.data = T.data), v.wrapS = T.wrapS !== void 0 ? T.wrapS : 1001, v.wrapT = T.wrapT !== void 0 ? T.wrapT : 1001, v.magFilter = T.magFilter !== void 0 ? T.magFilter : 1006, v.minFilter = T.minFilter !== void 0 ? T.minFilter : 1006, v.anisotropy = T.anisotropy !== void 0 ? T.anisotropy : 1, T.encoding !== void 0 && (v.encoding = T.encoding), T.flipY !== void 0 && (v.flipY = T.flipY), T.format !== void 0 && (v.format = T.format), T.type !== void 0 && (v.type = T.type), T.mipmaps !== void 0 && (v.mipmaps = T.mipmaps, v.minFilter = 1008), T.mipmapCount === 1 && (v.minFilter = 1006), T.generateMipmaps !== void 0 && (v.generateMipmaps = T.generateMipmaps), v.needsUpdate = !0, e && e(v, T))
                }, r, h), v
            }
        }), $o.prototype = Object.assign(Object.create(_r.prototype), {
            constructor: $o,
            load: function(s, e, r, h) {
                const c = new cn,
                    v = new ph(this.manager);
                return v.setCrossOrigin(this.crossOrigin), v.setPath(this.path), v.load(s, function(w) {
                    c.image = w;
                    const E = s.search(/\.jpe?g($|\?)/i) > 0 || s.search(/^data\:image\/jpeg/) === 0;
                    c.format = E ? 1022 : 1023, c.needsUpdate = !0, e !== void 0 && e(c)
                }, r, h), c
            }
        }), Object.assign(Qa.prototype, {
            getPoint: function() {
                return console.warn("THREE.Curve: .getPoint() not implemented."), null
            },
            getPointAt: function(s, e) {
                const r = this.getUtoTmapping(s);
                return this.getPoint(r, e)
            },
            getPoints: function(s = 5) {
                const e = [];
                for (let r = 0; r <= s; r++) e.push(this.getPoint(r / s));
                return e
            },
            getSpacedPoints: function(s = 5) {
                const e = [];
                for (let r = 0; r <= s; r++) e.push(this.getPointAt(r / s));
                return e
            },
            getLength: function() {
                const s = this.getLengths();
                return s[s.length - 1]
            },
            getLengths: function(s) {
                if (s === void 0 && (s = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === s + 1 && !this.needsUpdate) return this.cacheArcLengths;
                this.needsUpdate = !1;
                const e = [];
                let r, h = this.getPoint(0),
                    c = 0;
                e.push(0);
                for (let v = 1; v <= s; v++) r = this.getPoint(v / s), c += r.distanceTo(h), e.push(c), h = r;
                return this.cacheArcLengths = e, e
            },
            updateArcLengths: function() {
                this.needsUpdate = !0, this.getLengths()
            },
            getUtoTmapping: function(s, e) {
                const r = this.getLengths();
                let h = 0;
                const c = r.length;
                let v;
                v = e || s * r[c - 1];
                let w, E = 0,
                    T = c - 1;
                for (; E <= T;)
                    if (h = Math.floor(E + (T - E) / 2), w = r[h] - v, w < 0) E = h + 1;
                    else {
                        if (!(w > 0)) {
                            T = h;
                            break
                        }
                        T = h - 1
                    } if (h = T, r[h] === v) return h / (c - 1);
                const B = r[h];
                return (h + (v - B) / (r[h + 1] - B)) / (c - 1)
            },
            getTangent: function(s, e) {
                let h = s - 1e-4,
                    c = s + 1e-4;
                h < 0 && (h = 0), c > 1 && (c = 1);
                const v = this.getPoint(h),
                    w = this.getPoint(c),
                    E = e || (v.isVector2 ? new Ht : new ge);
                return E.copy(w).sub(v).normalize(), E
            },
            getTangentAt: function(s, e) {
                const r = this.getUtoTmapping(s);
                return this.getTangent(r, e)
            },
            computeFrenetFrames: function(s, e) {
                const r = new ge,
                    h = [],
                    c = [],
                    v = [],
                    w = new ge,
                    E = new Ui;
                for (let i = 0; i <= s; i++) {
                    const t = i / s;
                    h[i] = this.getTangentAt(t, new ge), h[i].normalize()
                }
                c[0] = new ge, v[0] = new ge;
                let T = Number.MAX_VALUE;
                const B = Math.abs(h[0].x),
                    Q = Math.abs(h[0].y),
                    k = Math.abs(h[0].z);
                B <= T && (T = B, r.set(1, 0, 0)), Q <= T && (T = Q, r.set(0, 1, 0)), k <= T && r.set(0, 0, 1), w.crossVectors(h[0], r).normalize(), c[0].crossVectors(h[0], w), v[0].crossVectors(h[0], c[0]);
                for (let i = 1; i <= s; i++) {
                    if (c[i] = c[i - 1].clone(), v[i] = v[i - 1].clone(), w.crossVectors(h[i - 1], h[i]), w.length() > Number.EPSILON) {
                        w.normalize();
                        const t = Math.acos(Mi.clamp(h[i - 1].dot(h[i]), -1, 1));
                        c[i].applyMatrix4(E.makeRotationAxis(w, t))
                    }
                    v[i].crossVectors(h[i], c[i])
                }
                if (e === !0) {
                    let i = Math.acos(Mi.clamp(c[0].dot(c[s]), -1, 1));
                    i /= s, h[0].dot(w.crossVectors(c[0], c[s])) > 0 && (i = -i);
                    for (let t = 1; t <= s; t++) c[t].applyMatrix4(E.makeRotationAxis(h[t], i * t)), v[t].crossVectors(h[t], c[t])
                }
                return {
                    tangents: h,
                    normals: c,
                    binormals: v
                }
            },
            clone: function() {
                return new this.constructor().copy(this)
            },
            copy: function(s) {
                return this.arcLengthDivisions = s.arcLengthDivisions, this
            },
            toJSON: function() {
                const s = {
                    metadata: {
                        version: 4.5,
                        type: "Curve",
                        generator: "Curve.toJSON"
                    }
                };
                return s.arcLengthDivisions = this.arcLengthDivisions, s.type = this.type, s
            },
            fromJSON: function(s) {
                return this.arcLengthDivisions = s.arcLengthDivisions, this
            }
        });
        class fh extends Qa {
            constructor(e = 0, r = 0, h = 1, c = 1, v = 0, w = 2 * Math.PI, E = !1, T = 0) {
                super(), this.type = "EllipseCurve", this.aX = e, this.aY = r, this.xRadius = h, this.yRadius = c, this.aStartAngle = v, this.aEndAngle = w, this.aClockwise = E, this.aRotation = T
            }
            getPoint(e, r) {
                const h = r || new Ht,
                    c = 2 * Math.PI;
                let v = this.aEndAngle - this.aStartAngle;
                const w = Math.abs(v) < Number.EPSILON;
                for (; v < 0;) v += c;
                for (; v > c;) v -= c;
                v < Number.EPSILON && (v = w ? 0 : c), this.aClockwise !== !0 || w || (v === c ? v = -c : v -= c);
                const E = this.aStartAngle + e * v;
                let T = this.aX + this.xRadius * Math.cos(E),
                    B = this.aY + this.yRadius * Math.sin(E);
                if (this.aRotation !== 0) {
                    const Q = Math.cos(this.aRotation),
                        k = Math.sin(this.aRotation),
                        i = T - this.aX,
                        t = B - this.aY;
                    T = i * Q - t * k + this.aX, B = i * k + t * Q + this.aY
                }
                return h.set(T, B)
            }
            copy(e) {
                return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
            }
            toJSON() {
                const e = super.toJSON();
                return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
            }
            fromJSON(e) {
                return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
            }
        }
        fh.prototype.isEllipseCurve = !0;
        class Ju extends fh {
            constructor(e, r, h, c, v, w) {
                super(e, r, h, h, c, v, w), this.type = "ArcCurve"
            }
        }

        function Zu() {
            let s = 0,
                e = 0,
                r = 0,
                h = 0;

            function c(v, w, E, T) {
                s = v, e = E, r = -3 * v + 3 * w - 2 * E - T, h = 2 * v - 2 * w + E + T
            }
            return {
                initCatmullRom: function(v, w, E, T, B) {
                    c(w, E, B * (E - v), B * (T - w))
                },
                initNonuniformCatmullRom: function(v, w, E, T, B, Q, k) {
                    let i = (w - v) / B - (E - v) / (B + Q) + (E - w) / Q,
                        t = (E - w) / Q - (T - w) / (Q + k) + (T - E) / k;
                    i *= Q, t *= Q, c(w, E, i, t)
                },
                calc: function(v) {
                    const w = v * v;
                    return s + e * v + r * w + h * (w * v)
                }
            }
        }
        Ju.prototype.isArcCurve = !0;
        const su = new ge,
            Xu = new Zu,
            ju = new Zu,
            ou = new Zu;
        class mh extends Qa {
            constructor(e = [], r = !1, h = "centripetal", c = .5) {
                super(), this.type = "CatmullRomCurve3", this.points = e, this.closed = r, this.curveType = h, this.tension = c
            }
            getPoint(e, r = new ge) {
                const h = r,
                    c = this.points,
                    v = c.length,
                    w = (v - (this.closed ? 0 : 1)) * e;
                let E, T, B = Math.floor(w),
                    Q = w - B;
                this.closed ? B += B > 0 ? 0 : (Math.floor(Math.abs(B) / v) + 1) * v : Q === 0 && B === v - 1 && (B = v - 2, Q = 1), this.closed || B > 0 ? E = c[(B - 1) % v] : (su.subVectors(c[0], c[1]).add(c[0]), E = su);
                const k = c[B % v],
                    i = c[(B + 1) % v];
                if (this.closed || B + 2 < v ? T = c[(B + 2) % v] : (su.subVectors(c[v - 1], c[v - 2]).add(c[v - 1]), T = su), this.curveType === "centripetal" || this.curveType === "chordal") {
                    const t = this.curveType === "chordal" ? .5 : .25;
                    let a = Math.pow(E.distanceToSquared(k), t),
                        l = Math.pow(k.distanceToSquared(i), t),
                        d = Math.pow(i.distanceToSquared(T), t);
                    l < 1e-4 && (l = 1), a < 1e-4 && (a = l), d < 1e-4 && (d = l), Xu.initNonuniformCatmullRom(E.x, k.x, i.x, T.x, a, l, d), ju.initNonuniformCatmullRom(E.y, k.y, i.y, T.y, a, l, d), ou.initNonuniformCatmullRom(E.z, k.z, i.z, T.z, a, l, d)
                } else this.curveType === "catmullrom" && (Xu.initCatmullRom(E.x, k.x, i.x, T.x, this.tension), ju.initCatmullRom(E.y, k.y, i.y, T.y, this.tension), ou.initCatmullRom(E.z, k.z, i.z, T.z, this.tension));
                return h.set(Xu.calc(Q), ju.calc(Q), ou.calc(Q)), h
            }
            copy(e) {
                super.copy(e), this.points = [];
                for (let r = 0, h = e.points.length; r < h; r++) {
                    const c = e.points[r];
                    this.points.push(c.clone())
                }
                return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
            }
            toJSON() {
                const e = super.toJSON();
                e.points = [];
                for (let r = 0, h = this.points.length; r < h; r++) {
                    const c = this.points[r];
                    e.points.push(c.toArray())
                }
                return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
            }
            fromJSON(e) {
                super.fromJSON(e), this.points = [];
                for (let r = 0, h = e.points.length; r < h; r++) {
                    const c = e.points[r];
                    this.points.push(new ge().fromArray(c))
                }
                return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
            }
        }

        function Yu(s, e, r, h, c) {
            const v = .5 * (h - e),
                w = .5 * (c - r),
                E = s * s;
            return (2 * r - 2 * h + v + w) * (s * E) + (-3 * r + 3 * h - 2 * v - w) * E + v * s + r
        }

        function vc(s, e, r, h) {
            return function(c, v) {
                const w = 1 - c;
                return w * w * v
            }(s, e) + function(c, v) {
                return 2 * (1 - c) * c * v
            }(s, r) + function(c, v) {
                return c * c * v
            }(s, h)
        }

        function _c(s, e, r, h, c) {
            return function(v, w) {
                const E = 1 - v;
                return E * E * E * w
            }(s, e) + function(v, w) {
                const E = 1 - v;
                return 3 * E * E * v * w
            }(s, r) + function(v, w) {
                return 3 * (1 - v) * v * v * w
            }(s, h) + function(v, w) {
                return v * v * v * w
            }(s, c)
        }
        mh.prototype.isCatmullRomCurve3 = !0;
        class lu extends Qa {
            constructor(e = new Ht, r = new Ht, h = new Ht, c = new Ht) {
                super(), this.type = "CubicBezierCurve", this.v0 = e, this.v1 = r, this.v2 = h, this.v3 = c
            }
            getPoint(e, r = new Ht) {
                const h = r,
                    c = this.v0,
                    v = this.v1,
                    w = this.v2,
                    E = this.v3;
                return h.set(_c(e, c.x, v.x, w.x, E.x), _c(e, c.y, v.y, w.y, E.y)), h
            }
            copy(e) {
                return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
            }
            fromJSON(e) {
                return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
            }
        }
        lu.prototype.isCubicBezierCurve = !0;
        class xc extends Qa {
            constructor(e = new ge, r = new ge, h = new ge, c = new ge) {
                super(), this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = r, this.v2 = h, this.v3 = c
            }
            getPoint(e, r = new ge) {
                const h = r,
                    c = this.v0,
                    v = this.v1,
                    w = this.v2,
                    E = this.v3;
                return h.set(_c(e, c.x, v.x, w.x, E.x), _c(e, c.y, v.y, w.y, E.y), _c(e, c.z, v.z, w.z, E.z)), h
            }
            copy(e) {
                return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
            }
            fromJSON(e) {
                return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
            }
        }
        xc.prototype.isCubicBezierCurve3 = !0;
        class gh extends Qa {
            constructor(e = new Ht, r = new Ht) {
                super(), this.type = "LineCurve", this.v1 = e, this.v2 = r
            }
            getPoint(e, r = new Ht) {
                const h = r;
                return e === 1 ? h.copy(this.v2) : (h.copy(this.v2).sub(this.v1), h.multiplyScalar(e).add(this.v1)), h
            }
            getPointAt(e, r) {
                return this.getPoint(e, r)
            }
            getTangent(e, r) {
                const h = r || new Ht;
                return h.copy(this.v2).sub(this.v1).normalize(), h
            }
            copy(e) {
                return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }
            fromJSON(e) {
                return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }
        }
        gh.prototype.isLineCurve = !0;
        class qu extends Qa {
            constructor(e = new ge, r = new ge) {
                super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = e, this.v2 = r
            }
            getPoint(e, r = new ge) {
                const h = r;
                return e === 1 ? h.copy(this.v2) : (h.copy(this.v2).sub(this.v1), h.multiplyScalar(e).add(this.v1)), h
            }
            getPointAt(e, r) {
                return this.getPoint(e, r)
            }
            copy(e) {
                return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }
            fromJSON(e) {
                return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }
        }
        class cu extends Qa {
            constructor(e = new Ht, r = new Ht, h = new Ht) {
                super(), this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = r, this.v2 = h
            }
            getPoint(e, r = new Ht) {
                const h = r,
                    c = this.v0,
                    v = this.v1,
                    w = this.v2;
                return h.set(vc(e, c.x, v.x, w.x), vc(e, c.y, v.y, w.y)), h
            }
            copy(e) {
                return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }
            fromJSON(e) {
                return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }
        }
        cu.prototype.isQuadraticBezierCurve = !0;
        class $u extends Qa {
            constructor(e = new ge, r = new ge, h = new ge) {
                super(), this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = r, this.v2 = h
            }
            getPoint(e, r = new ge) {
                const h = r,
                    c = this.v0,
                    v = this.v1,
                    w = this.v2;
                return h.set(vc(e, c.x, v.x, w.x), vc(e, c.y, v.y, w.y), vc(e, c.z, v.z, w.z)), h
            }
            copy(e) {
                return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }
            fromJSON(e) {
                return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }
        }
        $u.prototype.isQuadraticBezierCurve3 = !0;
        class hu extends Qa {
            constructor(e = []) {
                super(), this.type = "SplineCurve", this.points = e
            }
            getPoint(e, r = new Ht) {
                const h = r,
                    c = this.points,
                    v = (c.length - 1) * e,
                    w = Math.floor(v),
                    E = v - w,
                    T = c[w === 0 ? w : w - 1],
                    B = c[w],
                    Q = c[w > c.length - 2 ? c.length - 1 : w + 1],
                    k = c[w > c.length - 3 ? c.length - 1 : w + 2];
                return h.set(Yu(E, T.x, B.x, Q.x, k.x), Yu(E, T.y, B.y, Q.y, k.y)), h
            }
            copy(e) {
                super.copy(e), this.points = [];
                for (let r = 0, h = e.points.length; r < h; r++) {
                    const c = e.points[r];
                    this.points.push(c.clone())
                }
                return this
            }
            toJSON() {
                const e = super.toJSON();
                e.points = [];
                for (let r = 0, h = this.points.length; r < h; r++) {
                    const c = this.points[r];
                    e.points.push(c.toArray())
                }
                return e
            }
            fromJSON(e) {
                super.fromJSON(e), this.points = [];
                for (let r = 0, h = e.points.length; r < h; r++) {
                    const c = e.points[r];
                    this.points.push(new Ht().fromArray(c))
                }
                return this
            }
        }
        hu.prototype.isSplineCurve = !0;
        var uu = Object.freeze({
            __proto__: null,
            ArcCurve: Ju,
            CatmullRomCurve3: mh,
            CubicBezierCurve: lu,
            CubicBezierCurve3: xc,
            EllipseCurve: fh,
            LineCurve: gh,
            LineCurve3: qu,
            QuadraticBezierCurve: cu,
            QuadraticBezierCurve3: $u,
            SplineCurve: hu
        });
        class Zd extends Qa {
            constructor() {
                super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
            }
            add(e) {
                this.curves.push(e)
            }
            closePath() {
                const e = this.curves[0].getPoint(0),
                    r = this.curves[this.curves.length - 1].getPoint(1);
                e.equals(r) || this.curves.push(new gh(r, e))
            }
            getPoint(e) {
                const r = e * this.getLength(),
                    h = this.getCurveLengths();
                let c = 0;
                for (; c < h.length;) {
                    if (h[c] >= r) {
                        const v = h[c] - r,
                            w = this.curves[c],
                            E = w.getLength(),
                            T = E === 0 ? 0 : 1 - v / E;
                        return w.getPointAt(T)
                    }
                    c++
                }
                return null
            }
            getLength() {
                const e = this.getCurveLengths();
                return e[e.length - 1]
            }
            updateArcLengths() {
                this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
            }
            getCurveLengths() {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                const e = [];
                let r = 0;
                for (let h = 0, c = this.curves.length; h < c; h++) r += this.curves[h].getLength(), e.push(r);
                return this.cacheLengths = e, e
            }
            getSpacedPoints(e = 40) {
                const r = [];
                for (let h = 0; h <= e; h++) r.push(this.getPoint(h / e));
                return this.autoClose && r.push(r[0]), r
            }
            getPoints(e = 12) {
                const r = [];
                let h;
                for (let c = 0, v = this.curves; c < v.length; c++) {
                    const w = v[c],
                        E = w && w.isEllipseCurve ? 2 * e : w && (w.isLineCurve || w.isLineCurve3) ? 1 : w && w.isSplineCurve ? e * w.points.length : e,
                        T = w.getPoints(E);
                    for (let B = 0; B < T.length; B++) {
                        const Q = T[B];
                        h && h.equals(Q) || (r.push(Q), h = Q)
                    }
                }
                return this.autoClose && r.length > 1 && !r[r.length - 1].equals(r[0]) && r.push(r[0]), r
            }
            copy(e) {
                super.copy(e), this.curves = [];
                for (let r = 0, h = e.curves.length; r < h; r++) {
                    const c = e.curves[r];
                    this.curves.push(c.clone())
                }
                return this.autoClose = e.autoClose, this
            }
            toJSON() {
                const e = super.toJSON();
                e.autoClose = this.autoClose, e.curves = [];
                for (let r = 0, h = this.curves.length; r < h; r++) {
                    const c = this.curves[r];
                    e.curves.push(c.toJSON())
                }
                return e
            }
            fromJSON(e) {
                super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
                for (let r = 0, h = e.curves.length; r < h; r++) {
                    const c = e.curves[r];
                    this.curves.push(new uu[c.type]().fromJSON(c))
                }
                return this
            }
        }
        class yh extends Zd {
            constructor(e) {
                super(), this.type = "Path", this.currentPoint = new Ht, e && this.setFromPoints(e)
            }
            setFromPoints(e) {
                this.moveTo(e[0].x, e[0].y);
                for (let r = 1, h = e.length; r < h; r++) this.lineTo(e[r].x, e[r].y);
                return this
            }
            moveTo(e, r) {
                return this.currentPoint.set(e, r), this
            }
            lineTo(e, r) {
                const h = new gh(this.currentPoint.clone(), new Ht(e, r));
                return this.curves.push(h), this.currentPoint.set(e, r), this
            }
            quadraticCurveTo(e, r, h, c) {
                const v = new cu(this.currentPoint.clone(), new Ht(e, r), new Ht(h, c));
                return this.curves.push(v), this.currentPoint.set(h, c), this
            }
            bezierCurveTo(e, r, h, c, v, w) {
                const E = new lu(this.currentPoint.clone(), new Ht(e, r), new Ht(h, c), new Ht(v, w));
                return this.curves.push(E), this.currentPoint.set(v, w), this
            }
            splineThru(e) {
                const r = [this.currentPoint.clone()].concat(e),
                    h = new hu(r);
                return this.curves.push(h), this.currentPoint.copy(e[e.length - 1]), this
            }
            arc(e, r, h, c, v, w) {
                const E = this.currentPoint.x,
                    T = this.currentPoint.y;
                return this.absarc(e + E, r + T, h, c, v, w), this
            }
            absarc(e, r, h, c, v, w) {
                return this.absellipse(e, r, h, h, c, v, w), this
            }
            ellipse(e, r, h, c, v, w, E, T) {
                const B = this.currentPoint.x,
                    Q = this.currentPoint.y;
                return this.absellipse(e + B, r + Q, h, c, v, w, E, T), this
            }
            absellipse(e, r, h, c, v, w, E, T) {
                const B = new fh(e, r, h, c, v, w, E, T);
                if (this.curves.length > 0) {
                    const k = B.getPoint(0);
                    k.equals(this.currentPoint) || this.lineTo(k.x, k.y)
                }
                this.curves.push(B);
                const Q = B.getPoint(1);
                return this.currentPoint.copy(Q), this
            }
            copy(e) {
                return super.copy(e), this.currentPoint.copy(e.currentPoint), this
            }
            toJSON() {
                const e = super.toJSON();
                return e.currentPoint = this.currentPoint.toArray(), e
            }
            fromJSON(e) {
                return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
            }
        }
        class us extends yh {
            constructor(e) {
                super(e), this.uuid = Mi.generateUUID(), this.type = "Shape", this.holes = []
            }
            getPointsHoles(e) {
                const r = [];
                for (let h = 0, c = this.holes.length; h < c; h++) r[h] = this.holes[h].getPoints(e);
                return r
            }
            extractPoints(e) {
                return {
                    shape: this.getPoints(e),
                    holes: this.getPointsHoles(e)
                }
            }
            copy(e) {
                super.copy(e), this.holes = [];
                for (let r = 0, h = e.holes.length; r < h; r++) {
                    const c = e.holes[r];
                    this.holes.push(c.clone())
                }
                return this
            }
            toJSON() {
                const e = super.toJSON();
                e.uuid = this.uuid, e.holes = [];
                for (let r = 0, h = this.holes.length; r < h; r++) {
                    const c = this.holes[r];
                    e.holes.push(c.toJSON())
                }
                return e
            }
            fromJSON(e) {
                super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
                for (let r = 0, h = e.holes.length; r < h; r++) {
                    const c = e.holes[r];
                    this.holes.push(new yh().fromJSON(c))
                }
                return this
            }
        }
        class Xn extends Z {
            constructor(e, r = 1) {
                super(), this.type = "Light", this.color = new Rt(e), this.intensity = r
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.intensity = e.intensity, this
            }
            toJSON(e) {
                const r = super.toJSON(e);
                return r.object.color = this.color.getHex(), r.object.intensity = this.intensity, this.groundColor !== void 0 && (r.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (r.object.distance = this.distance), this.angle !== void 0 && (r.object.angle = this.angle), this.decay !== void 0 && (r.object.decay = this.decay), this.penumbra !== void 0 && (r.object.penumbra = this.penumbra), this.shadow !== void 0 && (r.object.shadow = this.shadow.toJSON()), r
            }
        }
        Xn.prototype.isLight = !0;
        class du extends Xn {
            constructor(e, r, h) {
                super(e, h), this.type = "HemisphereLight", this.position.copy(Z.DefaultUp), this.updateMatrix(), this.groundColor = new Rt(r)
            }
            copy(e) {
                return Xn.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this
            }
        }
        du.prototype.isHemisphereLight = !0;
        const Ku = new Ui,
            ed = new ge,
            Wn = new ge;
        class vh {
            constructor(e) {
                this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new Ht(512, 512), this.map = null, this.mapPass = null, this.matrix = new Ui, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Us, this._frameExtents = new Ht(1, 1), this._viewportCount = 1, this._viewports = [new Si(0, 0, 1, 1)]
            }
            getViewportCount() {
                return this._viewportCount
            }
            getFrustum() {
                return this._frustum
            }
            updateMatrices(e) {
                const r = this.camera,
                    h = this.matrix;
                ed.setFromMatrixPosition(e.matrixWorld), r.position.copy(ed), Wn.setFromMatrixPosition(e.target.matrixWorld), r.lookAt(Wn), r.updateMatrixWorld(), Ku.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ku), h.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), h.multiply(r.projectionMatrix), h.multiply(r.matrixWorldInverse)
            }
            getViewport(e) {
                return this._viewports[e]
            }
            getFrameExtents() {
                return this._frameExtents
            }
            copy(e) {
                return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
            }
            clone() {
                return new this.constructor().copy(this)
            }
            toJSON() {
                const e = {};
                return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), this.mapSize.x === 512 && this.mapSize.y === 512 || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
            }
        }
        class td extends vh {
            constructor() {
                super(new dr(50, 1, .5, 500)), this.focus = 1
            }
            updateMatrices(e) {
                const r = this.camera,
                    h = 2 * Mi.RAD2DEG * e.angle * this.focus,
                    c = this.mapSize.width / this.mapSize.height,
                    v = e.distance || r.far;
                h === r.fov && c === r.aspect && v === r.far || (r.fov = h, r.aspect = c, r.far = v, r.updateProjectionMatrix()), super.updateMatrices(e)
            }
            copy(e) {
                return super.copy(e), this.focus = e.focus, this
            }
        }
        td.prototype.isSpotLightShadow = !0;
        class pu extends Xn {
            constructor(e, r, h = 0, c = Math.PI / 3, v = 0, w = 1) {
                super(e, r), this.type = "SpotLight", this.position.copy(Z.DefaultUp), this.updateMatrix(), this.target = new Z, this.distance = h, this.angle = c, this.penumbra = v, this.decay = w, this.shadow = new td
            }
            get power() {
                return this.intensity * Math.PI
            }
            set power(e) {
                this.intensity = e / Math.PI
            }
            copy(e) {
                return super.copy(e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
            }
        }
        pu.prototype.isSpotLight = !0;
        const qs = new Ui,
            $s = new ge,
            fu = new ge;
        class Xd extends vh {
            constructor() {
                super(new dr(90, 1, .5, 500)), this._frameExtents = new Ht(4, 2), this._viewportCount = 6, this._viewports = [new Si(2, 1, 1, 1), new Si(0, 1, 1, 1), new Si(3, 1, 1, 1), new Si(1, 1, 1, 1), new Si(3, 0, 1, 1), new Si(1, 0, 1, 1)], this._cubeDirections = [new ge(1, 0, 0), new ge(-1, 0, 0), new ge(0, 0, 1), new ge(0, 0, -1), new ge(0, 1, 0), new ge(0, -1, 0)], this._cubeUps = [new ge(0, 1, 0), new ge(0, 1, 0), new ge(0, 1, 0), new ge(0, 1, 0), new ge(0, 0, 1), new ge(0, 0, -1)]
            }
            updateMatrices(e, r = 0) {
                const h = this.camera,
                    c = this.matrix,
                    v = e.distance || h.far;
                v !== h.far && (h.far = v, h.updateProjectionMatrix()), $s.setFromMatrixPosition(e.matrixWorld), h.position.copy($s), fu.copy(h.position), fu.add(this._cubeDirections[r]), h.up.copy(this._cubeUps[r]), h.lookAt(fu), h.updateMatrixWorld(), c.makeTranslation(-$s.x, -$s.y, -$s.z), qs.multiplyMatrices(h.projectionMatrix, h.matrixWorldInverse), this._frustum.setFromProjectionMatrix(qs)
            }
        }
        Xd.prototype.isPointLightShadow = !0;
        class id extends Xn {
            constructor(e, r, h = 0, c = 1) {
                super(e, r), this.type = "PointLight", this.distance = h, this.decay = c, this.shadow = new Xd
            }
            get power() {
                return 4 * this.intensity * Math.PI
            }
            set power(e) {
                this.intensity = e / (4 * Math.PI)
            }
            copy(e) {
                return super.copy(e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
            }
        }
        id.prototype.isPointLight = !0;
        class _h extends Dn {
            constructor(e = -1, r = 1, h = 1, c = -1, v = .1, w = 2e3) {
                super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = r, this.top = h, this.bottom = c, this.near = v, this.far = w, this.updateProjectionMatrix()
            }
            copy(e, r) {
                return super.copy(e, r), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this
            }
            setViewOffset(e, r, h, c, v, w) {
                this.view === null && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = r, this.view.offsetX = h, this.view.offsetY = c, this.view.width = v, this.view.height = w, this.updateProjectionMatrix()
            }
            clearViewOffset() {
                this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const e = (this.right - this.left) / (2 * this.zoom),
                    r = (this.top - this.bottom) / (2 * this.zoom),
                    h = (this.right + this.left) / 2,
                    c = (this.top + this.bottom) / 2;
                let v = h - e,
                    w = h + e,
                    E = c + r,
                    T = c - r;
                if (this.view !== null && this.view.enabled) {
                    const B = (this.right - this.left) / this.view.fullWidth / this.zoom,
                        Q = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    v += B * this.view.offsetX, w = v + B * this.view.width, E -= Q * this.view.offsetY, T = E - Q * this.view.height
                }
                this.projectionMatrix.makeOrthographic(v, w, E, T, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(e) {
                const r = Z.prototype.toJSON.call(this, e);
                return r.object.zoom = this.zoom, r.object.left = this.left, r.object.right = this.right, r.object.top = this.top, r.object.bottom = this.bottom, r.object.near = this.near, r.object.far = this.far, this.view !== null && (r.object.view = Object.assign({}, this.view)), r
            }
        }
        _h.prototype.isOrthographicCamera = !0;
        class jd extends vh {
            constructor() {
                super(new _h(-5, 5, 5, -5, .5, 500))
            }
        }
        jd.prototype.isDirectionalLightShadow = !0;
        class nd extends Xn {
            constructor(e, r) {
                super(e, r), this.type = "DirectionalLight", this.position.copy(Z.DefaultUp), this.updateMatrix(), this.target = new Z, this.shadow = new jd
            }
            copy(e) {
                return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
            }
        }
        nd.prototype.isDirectionalLight = !0;
        class rd extends Xn {
            constructor(e, r) {
                super(e, r), this.type = "AmbientLight"
            }
        }
        rd.prototype.isAmbientLight = !0;
        class ad extends Xn {
            constructor(e, r, h = 10, c = 10) {
                super(e, r), this.type = "RectAreaLight", this.width = h, this.height = c
            }
            copy(e) {
                return super.copy(e), this.width = e.width, this.height = e.height, this
            }
            toJSON(e) {
                const r = super.toJSON(e);
                return r.object.width = this.width, r.object.height = this.height, r
            }
        }
        ad.prototype.isRectAreaLight = !0;
        class sd {
            constructor() {
                this.coefficients = [];
                for (let e = 0; e < 9; e++) this.coefficients.push(new ge)
            }
            set(e) {
                for (let r = 0; r < 9; r++) this.coefficients[r].copy(e[r]);
                return this
            }
            zero() {
                for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
                return this
            }
            getAt(e, r) {
                const h = e.x,
                    c = e.y,
                    v = e.z,
                    w = this.coefficients;
                return r.copy(w[0]).multiplyScalar(.282095), r.addScaledVector(w[1], .488603 * c), r.addScaledVector(w[2], .488603 * v), r.addScaledVector(w[3], .488603 * h), r.addScaledVector(w[4], h * c * 1.092548), r.addScaledVector(w[5], c * v * 1.092548), r.addScaledVector(w[6], .315392 * (3 * v * v - 1)), r.addScaledVector(w[7], h * v * 1.092548), r.addScaledVector(w[8], .546274 * (h * h - c * c)), r
            }
            getIrradianceAt(e, r) {
                const h = e.x,
                    c = e.y,
                    v = e.z,
                    w = this.coefficients;
                return r.copy(w[0]).multiplyScalar(.886227), r.addScaledVector(w[1], 1.023328 * c), r.addScaledVector(w[2], 1.023328 * v), r.addScaledVector(w[3], 1.023328 * h), r.addScaledVector(w[4], .858086 * h * c), r.addScaledVector(w[5], .858086 * c * v), r.addScaledVector(w[6], .743125 * v * v - .247708), r.addScaledVector(w[7], .858086 * h * v), r.addScaledVector(w[8], .429043 * (h * h - c * c)), r
            }
            add(e) {
                for (let r = 0; r < 9; r++) this.coefficients[r].add(e.coefficients[r]);
                return this
            }
            addScaledSH(e, r) {
                for (let h = 0; h < 9; h++) this.coefficients[h].addScaledVector(e.coefficients[h], r);
                return this
            }
            scale(e) {
                for (let r = 0; r < 9; r++) this.coefficients[r].multiplyScalar(e);
                return this
            }
            lerp(e, r) {
                for (let h = 0; h < 9; h++) this.coefficients[h].lerp(e.coefficients[h], r);
                return this
            }
            equals(e) {
                for (let r = 0; r < 9; r++)
                    if (!this.coefficients[r].equals(e.coefficients[r])) return !1;
                return !0
            }
            copy(e) {
                return this.set(e.coefficients)
            }
            clone() {
                return new this.constructor().copy(this)
            }
            fromArray(e, r = 0) {
                const h = this.coefficients;
                for (let c = 0; c < 9; c++) h[c].fromArray(e, r + 3 * c);
                return this
            }
            toArray(e = [], r = 0) {
                const h = this.coefficients;
                for (let c = 0; c < 9; c++) h[c].toArray(e, r + 3 * c);
                return e
            }
            static getBasisAt(e, r) {
                const h = e.x,
                    c = e.y,
                    v = e.z;
                r[0] = .282095, r[1] = .488603 * c, r[2] = .488603 * v, r[3] = .488603 * h, r[4] = 1.092548 * h * c, r[5] = 1.092548 * c * v, r[6] = .315392 * (3 * v * v - 1), r[7] = 1.092548 * h * v, r[8] = .546274 * (h * h - c * c)
            }
        }
        sd.prototype.isSphericalHarmonics3 = !0;
        class xh extends Xn {
            constructor(e = new sd, r = 1) {
                super(void 0, r), this.sh = e
            }
            copy(e) {
                return super.copy(e), this.sh.copy(e.sh), this
            }
            fromJSON(e) {
                return this.intensity = e.intensity, this.sh.fromArray(e.sh), this
            }
            toJSON(e) {
                const r = super.toJSON(e);
                return r.object.sh = this.sh.toArray(), r
            }
        }
        xh.prototype.isLightProbe = !0;
        class bh extends _r {
            constructor(e) {
                super(e), this.textures = {}
            }
            load(e, r, h, c) {
                const v = this,
                    w = new hs(v.manager);
                w.setPath(v.path), w.setRequestHeader(v.requestHeader), w.setWithCredentials(v.withCredentials), w.load(e, function(E) {
                    try {
                        r(v.parse(JSON.parse(E)))
                    } catch (T) {
                        c ? c(T) : console.error(T), v.manager.itemError(e)
                    }
                }, h, c)
            }
            parse(e) {
                const r = this.textures;

                function h(v) {
                    return r[v] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", v), r[v]
                }
                const c = new Ep[e.type];
                if (e.uuid !== void 0 && (c.uuid = e.uuid), e.name !== void 0 && (c.name = e.name), e.color !== void 0 && c.color !== void 0 && c.color.setHex(e.color), e.roughness !== void 0 && (c.roughness = e.roughness), e.metalness !== void 0 && (c.metalness = e.metalness), e.sheen !== void 0 && (c.sheen = new Rt().setHex(e.sheen)), e.emissive !== void 0 && c.emissive !== void 0 && c.emissive.setHex(e.emissive), e.specular !== void 0 && c.specular !== void 0 && c.specular.setHex(e.specular), e.shininess !== void 0 && (c.shininess = e.shininess), e.clearcoat !== void 0 && (c.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (c.clearcoatRoughness = e.clearcoatRoughness), e.fog !== void 0 && (c.fog = e.fog), e.flatShading !== void 0 && (c.flatShading = e.flatShading), e.blending !== void 0 && (c.blending = e.blending), e.combine !== void 0 && (c.combine = e.combine), e.side !== void 0 && (c.side = e.side), e.shadowSide !== void 0 && (c.shadowSide = e.shadowSide), e.opacity !== void 0 && (c.opacity = e.opacity), e.transparent !== void 0 && (c.transparent = e.transparent), e.alphaTest !== void 0 && (c.alphaTest = e.alphaTest), e.depthTest !== void 0 && (c.depthTest = e.depthTest), e.depthWrite !== void 0 && (c.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (c.colorWrite = e.colorWrite), e.stencilWrite !== void 0 && (c.stencilWrite = e.stencilWrite), e.stencilWriteMask !== void 0 && (c.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (c.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (c.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (c.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (c.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (c.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (c.stencilZPass = e.stencilZPass), e.wireframe !== void 0 && (c.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (c.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (c.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (c.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (c.rotation = e.rotation), e.linewidth !== 1 && (c.linewidth = e.linewidth), e.dashSize !== void 0 && (c.dashSize = e.dashSize), e.gapSize !== void 0 && (c.gapSize = e.gapSize), e.scale !== void 0 && (c.scale = e.scale), e.polygonOffset !== void 0 && (c.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (c.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (c.polygonOffsetUnits = e.polygonOffsetUnits), e.skinning !== void 0 && (c.skinning = e.skinning), e.morphTargets !== void 0 && (c.morphTargets = e.morphTargets), e.morphNormals !== void 0 && (c.morphNormals = e.morphNormals), e.dithering !== void 0 && (c.dithering = e.dithering), e.alphaToCoverage !== void 0 && (c.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (c.premultipliedAlpha = e.premultipliedAlpha), e.vertexTangents !== void 0 && (c.vertexTangents = e.vertexTangents), e.visible !== void 0 && (c.visible = e.visible), e.toneMapped !== void 0 && (c.toneMapped = e.toneMapped), e.userData !== void 0 && (c.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? c.vertexColors = e.vertexColors > 0 : c.vertexColors = e.vertexColors), e.uniforms !== void 0)
                    for (const v in e.uniforms) {
                        const w = e.uniforms[v];
                        switch (c.uniforms[v] = {}, w.type) {
                            case "t":
                                c.uniforms[v].value = h(w.value);
                                break;
                            case "c":
                                c.uniforms[v].value = new Rt().setHex(w.value);
                                break;
                            case "v2":
                                c.uniforms[v].value = new Ht().fromArray(w.value);
                                break;
                            case "v3":
                                c.uniforms[v].value = new ge().fromArray(w.value);
                                break;
                            case "v4":
                                c.uniforms[v].value = new Si().fromArray(w.value);
                                break;
                            case "m3":
                                c.uniforms[v].value = new Pt().fromArray(w.value);
                                break;
                            case "m4":
                                c.uniforms[v].value = new Ui().fromArray(w.value);
                                break;
                            default:
                                c.uniforms[v].value = w.value
                        }
                    }
                if (e.defines !== void 0 && (c.defines = e.defines), e.vertexShader !== void 0 && (c.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (c.fragmentShader = e.fragmentShader), e.extensions !== void 0)
                    for (const v in e.extensions) c.extensions[v] = e.extensions[v];
                if (e.shading !== void 0 && (c.flatShading = e.shading === 1), e.size !== void 0 && (c.size = e.size), e.sizeAttenuation !== void 0 && (c.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (c.map = h(e.map)), e.matcap !== void 0 && (c.matcap = h(e.matcap)), e.alphaMap !== void 0 && (c.alphaMap = h(e.alphaMap)), e.bumpMap !== void 0 && (c.bumpMap = h(e.bumpMap)), e.bumpScale !== void 0 && (c.bumpScale = e.bumpScale), e.normalMap !== void 0 && (c.normalMap = h(e.normalMap)), e.normalMapType !== void 0 && (c.normalMapType = e.normalMapType), e.normalScale !== void 0) {
                    let v = e.normalScale;
                    Array.isArray(v) === !1 && (v = [v, v]), c.normalScale = new Ht().fromArray(v)
                }
                return e.displacementMap !== void 0 && (c.displacementMap = h(e.displacementMap)), e.displacementScale !== void 0 && (c.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (c.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (c.roughnessMap = h(e.roughnessMap)), e.metalnessMap !== void 0 && (c.metalnessMap = h(e.metalnessMap)), e.emissiveMap !== void 0 && (c.emissiveMap = h(e.emissiveMap)), e.emissiveIntensity !== void 0 && (c.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (c.specularMap = h(e.specularMap)), e.envMap !== void 0 && (c.envMap = h(e.envMap)), e.envMapIntensity !== void 0 && (c.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (c.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (c.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (c.lightMap = h(e.lightMap)), e.lightMapIntensity !== void 0 && (c.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (c.aoMap = h(e.aoMap)), e.aoMapIntensity !== void 0 && (c.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (c.gradientMap = h(e.gradientMap)), e.clearcoatMap !== void 0 && (c.clearcoatMap = h(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (c.clearcoatRoughnessMap = h(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (c.clearcoatNormalMap = h(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (c.clearcoatNormalScale = new Ht().fromArray(e.clearcoatNormalScale)), e.transmission !== void 0 && (c.transmission = e.transmission), e.transmissionMap !== void 0 && (c.transmissionMap = h(e.transmissionMap)), c
            }
            setTextures(e) {
                return this.textures = e, this
            }
        }
        const Ko = {
            decodeText: function(s) {
                if (typeof TextDecoder != "undefined") return new TextDecoder().decode(s);
                let e = "";
                for (let r = 0, h = s.length; r < h; r++) e += String.fromCharCode(s[r]);
                try {
                    return decodeURIComponent(escape(e))
                } catch (r) {
                    return e
                }
            },
            extractUrlBase: function(s) {
                const e = s.lastIndexOf("/");
                return e === -1 ? "./" : s.substr(0, e + 1)
            }
        };

        function bc() {
            an.call(this), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
        }

        function wc(s, e, r, h) {
            typeof r == "number" && (h = r, r = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), pi.call(this, s, e, r), this.meshPerAttribute = h || 1
        }
        bc.prototype = Object.assign(Object.create(an.prototype), {
            constructor: bc,
            isInstancedBufferGeometry: !0,
            copy: function(s) {
                return an.prototype.copy.call(this, s), this.instanceCount = s.instanceCount, this
            },
            clone: function() {
                return new this.constructor().copy(this)
            },
            toJSON: function() {
                const s = an.prototype.toJSON.call(this);
                return s.instanceCount = this.instanceCount, s.isInstancedBufferGeometry = !0, s
            }
        }), wc.prototype = Object.assign(Object.create(pi.prototype), {
            constructor: wc,
            isInstancedBufferAttribute: !0,
            copy: function(s) {
                return pi.prototype.copy.call(this, s), this.meshPerAttribute = s.meshPerAttribute, this
            },
            toJSON: function() {
                const s = pi.prototype.toJSON.call(this);
                return s.meshPerAttribute = this.meshPerAttribute, s.isInstancedBufferAttribute = !0, s
            }
        });
        class mu extends _r {
            constructor(e) {
                super(e)
            }
            load(e, r, h, c) {
                const v = this,
                    w = new hs(v.manager);
                w.setPath(v.path), w.setRequestHeader(v.requestHeader), w.setWithCredentials(v.withCredentials), w.load(e, function(E) {
                    try {
                        r(v.parse(JSON.parse(E)))
                    } catch (T) {
                        c ? c(T) : console.error(T), v.manager.itemError(e)
                    }
                }, h, c)
            }
            parse(e) {
                const r = {},
                    h = {};

                function c(k, i) {
                    if (r[i] !== void 0) return r[i];
                    const t = k.interleavedBuffers[i],
                        a = function(d, g) {
                            if (h[g] !== void 0) return h[g];
                            const x = d.arrayBuffers[g],
                                A = new Uint32Array(x).buffer;
                            return h[g] = A, A
                        }(k, t.buffer),
                        l = new St(Er(t.type, a), t.stride);
                    return l.uuid = t.uuid, r[i] = l, l
                }
                const v = e.isInstancedBufferGeometry ? new bc : new an,
                    w = e.data.index;
                if (w !== void 0) {
                    const k = Er(w.type, w.array);
                    v.setIndex(new pi(k, 1))
                }
                const E = e.data.attributes;
                for (const k in E) {
                    const i = E[k];
                    let t;
                    if (i.isInterleavedBufferAttribute) t = new Vt(c(e.data, i.data), i.itemSize, i.offset, i.normalized);
                    else {
                        const a = Er(i.type, i.array);
                        t = new(i.isInstancedBufferAttribute ? wc : pi)(a, i.itemSize, i.normalized)
                    }
                    i.name !== void 0 && (t.name = i.name), i.usage !== void 0 && t.setUsage(i.usage), i.updateRange !== void 0 && (t.updateRange.offset = i.updateRange.offset, t.updateRange.count = i.updateRange.count), v.setAttribute(k, t)
                }
                const T = e.data.morphAttributes;
                if (T)
                    for (const k in T) {
                        const i = T[k],
                            t = [];
                        for (let a = 0, l = i.length; a < l; a++) {
                            const d = i[a];
                            let g;
                            d.isInterleavedBufferAttribute ? g = new Vt(c(e.data, d.data), d.itemSize, d.offset, d.normalized) : g = new pi(Er(d.type, d.array), d.itemSize, d.normalized), d.name !== void 0 && (g.name = d.name), t.push(g)
                        }
                        v.morphAttributes[k] = t
                    }
                e.data.morphTargetsRelative && (v.morphTargetsRelative = !0);
                const B = e.data.groups || e.data.drawcalls || e.data.offsets;
                if (B !== void 0)
                    for (let k = 0, i = B.length; k !== i; ++k) {
                        const t = B[k];
                        v.addGroup(t.start, t.count, t.materialIndex)
                    }
                const Q = e.data.boundingSphere;
                if (Q !== void 0) {
                    const k = new ge;
                    Q.center !== void 0 && k.fromArray(Q.center), v.boundingSphere = new Fn(k, Q.radius)
                }
                return e.name && (v.name = e.name), e.userData && (v.userData = e.userData), v
            }
        }
        const Ap = {
                UVMapping: 300,
                CubeReflectionMapping: 301,
                CubeRefractionMapping: 302,
                EquirectangularReflectionMapping: 303,
                EquirectangularRefractionMapping: 304,
                CubeUVReflectionMapping: 306,
                CubeUVRefractionMapping: 307
            },
            Yd = {
                RepeatWrapping: 1e3,
                ClampToEdgeWrapping: 1001,
                MirroredRepeatWrapping: 1002
            },
            qd = {
                NearestFilter: 1003,
                NearestMipmapNearestFilter: 1004,
                NearestMipmapLinearFilter: 1005,
                LinearFilter: 1006,
                LinearMipmapNearestFilter: 1007,
                LinearMipmapLinearFilter: 1008
            };

        function gu(s) {
            typeof createImageBitmap == "undefined" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch == "undefined" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), _r.call(this, s), this.options = {
                premultiplyAlpha: "none"
            }
        }
        gu.prototype = Object.assign(Object.create(_r.prototype), {
            constructor: gu,
            isImageBitmapLoader: !0,
            setOptions: function(s) {
                return this.options = s, this
            },
            load: function(s, e, r, h) {
                s === void 0 && (s = ""), this.path !== void 0 && (s = this.path + s), s = this.manager.resolveURL(s);
                const c = this,
                    v = Fl.get(s);
                if (v !== void 0) return c.manager.itemStart(s), setTimeout(function() {
                    e && e(v), c.manager.itemEnd(s)
                }, 0), v;
                const w = {};
                w.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", w.headers = this.requestHeader, fetch(s, w).then(function(E) {
                    return E.blob()
                }).then(function(E) {
                    return createImageBitmap(E, Object.assign(c.options, {
                        colorSpaceConversion: "none"
                    }))
                }).then(function(E) {
                    Fl.add(s, E), e && e(E), c.manager.itemEnd(s)
                }).catch(function(E) {
                    h && h(E), c.manager.itemError(s), c.manager.itemEnd(s)
                }), c.manager.itemStart(s)
            }
        });
        class od {
            constructor() {
                this.type = "ShapePath", this.color = new Rt, this.subPaths = [], this.currentPath = null
            }
            moveTo(e, r) {
                return this.currentPath = new yh, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, r), this
            }
            lineTo(e, r) {
                return this.currentPath.lineTo(e, r), this
            }
            quadraticCurveTo(e, r, h, c) {
                return this.currentPath.quadraticCurveTo(e, r, h, c), this
            }
            bezierCurveTo(e, r, h, c, v, w) {
                return this.currentPath.bezierCurveTo(e, r, h, c, v, w), this
            }
            splineThru(e) {
                return this.currentPath.splineThru(e), this
            }
            toShapes(e, r) {
                function h(x) {
                    const A = [];
                    for (let M = 0, F = x.length; M < F; M++) {
                        const D = x[M],
                            U = new us;
                        U.curves = D.curves, A.push(U)
                    }
                    return A
                }

                function c(x, A) {
                    const M = A.length;
                    let F = !1;
                    for (let D = M - 1, U = 0; U < M; D = U++) {
                        let N = A[D],
                            H = A[U],
                            X = H.x - N.x,
                            ne = H.y - N.y;
                        if (Math.abs(ne) > Number.EPSILON) {
                            if (ne < 0 && (N = A[U], X = -X, H = A[D], ne = -ne), x.y < N.y || x.y > H.y) continue;
                            if (x.y === N.y) {
                                if (x.x === N.x) return !0
                            } else {
                                const le = ne * (x.x - N.x) - X * (x.y - N.y);
                                if (le === 0) return !0;
                                if (le < 0) continue;
                                F = !F
                            }
                        } else {
                            if (x.y !== N.y) continue;
                            if (H.x <= x.x && x.x <= N.x || N.x <= x.x && x.x <= H.x) return !0
                        }
                    }
                    return F
                }
                const v = xo.isClockWise,
                    w = this.subPaths;
                if (w.length === 0) return [];
                if (r === !0) return h(w);
                let E, T, B;
                const Q = [];
                if (w.length === 1) return T = w[0], B = new us, B.curves = T.curves, Q.push(B), Q;
                let k = !v(w[0].getPoints());
                k = e ? !k : k;
                const i = [],
                    t = [];
                let a, l, d = [],
                    g = 0;
                t[g] = void 0, d[g] = [];
                for (let x = 0, A = w.length; x < A; x++) T = w[x], a = T.getPoints(), E = v(a), E = e ? !E : E, E ? (!k && t[g] && g++, t[g] = {
                    s: new us,
                    p: a
                }, t[g].s.curves = T.curves, k && g++, d[g] = []) : d[g].push({
                    h: T,
                    p: a[0]
                });
                if (!t[0]) return h(w);
                if (t.length > 1) {
                    let x = !1;
                    const A = [];
                    for (let M = 0, F = t.length; M < F; M++) i[M] = [];
                    for (let M = 0, F = t.length; M < F; M++) {
                        const D = d[M];
                        for (let U = 0; U < D.length; U++) {
                            const N = D[U];
                            let H = !0;
                            for (let X = 0; X < t.length; X++) c(N.p, t[X].p) && (M !== X && A.push({
                                froms: M,
                                tos: X,
                                hole: U
                            }), H ? (H = !1, i[X].push(N)) : x = !0);
                            H && i[M].push(N)
                        }
                    }
                    A.length > 0 && (x || (d = i))
                }
                for (let x = 0, A = t.length; x < A; x++) {
                    B = t[x].s, Q.push(B), l = d[x];
                    for (let M = 0, F = l.length; M < F; M++) B.holes.push(l[M].h)
                }
                return Q
            }
        }
        class Ma {
            constructor(e) {
                this.type = "Font", this.data = e
            }
            generateShapes(e, r = 100) {
                const h = [],
                    c = function(v, w, E) {
                        const T = Array.from(v),
                            B = w / E.resolution,
                            Q = (E.boundingBox.yMax - E.boundingBox.yMin + E.underlineThickness) * B,
                            k = [];
                        let i = 0,
                            t = 0;
                        for (let a = 0; a < T.length; a++) {
                            const l = T[a];
                            if (l === `
`) i = 0, t -= Q;
                            else {
                                const d = ld(l, B, i, t, E);
                                i += d.offsetX, k.push(d.path)
                            }
                        }
                        return k
                    }(e, r, this.data);
                for (let v = 0, w = c.length; v < w; v++) Array.prototype.push.apply(h, c[v].toShapes());
                return h
            }
        }

        function ld(s, e, r, h, c) {
            const v = c.glyphs[s] || c.glyphs["?"];
            if (!v) return void console.error('THREE.Font: character "' + s + '" does not exists in font family ' + c.familyName + ".");
            const w = new od;
            let E, T, B, Q, k, i, t, a;
            if (v.o) {
                const l = v._cachedOutline || (v._cachedOutline = v.o.split(" "));
                for (let d = 0, g = l.length; d < g;) switch (l[d++]) {
                    case "m":
                        E = l[d++] * e + r, T = l[d++] * e + h, w.moveTo(E, T);
                        break;
                    case "l":
                        E = l[d++] * e + r, T = l[d++] * e + h, w.lineTo(E, T);
                        break;
                    case "q":
                        B = l[d++] * e + r, Q = l[d++] * e + h, k = l[d++] * e + r, i = l[d++] * e + h, w.quadraticCurveTo(k, i, B, Q);
                        break;
                    case "b":
                        B = l[d++] * e + r, Q = l[d++] * e + h, k = l[d++] * e + r, i = l[d++] * e + h, t = l[d++] * e + r, a = l[d++] * e + h, w.bezierCurveTo(k, i, t, a, B, Q)
                }
            }
            return {
                offsetX: v.ha * e,
                path: w
            }
        }
        Ma.prototype.isFont = !0;
        let wh;
        const Ks = {
            getContext: function() {
                return wh === void 0 && (wh = new(window.AudioContext || window.webkitAudioContext)), wh
            },
            setContext: function(s) {
                wh = s
            }
        };
        class Ec extends _r {
            constructor(e) {
                super(e)
            }
            load(e, r, h, c) {
                const v = this,
                    w = new hs(this.manager);
                w.setResponseType("arraybuffer"), w.setPath(this.path), w.setRequestHeader(this.requestHeader), w.setWithCredentials(this.withCredentials), w.load(e, function(E) {
                    try {
                        const T = E.slice(0);
                        Ks.getContext().decodeAudioData(T, function(B) {
                            r(B)
                        })
                    } catch (T) {
                        c ? c(T) : console.error(T), v.manager.itemError(e)
                    }
                }, h, c)
            }
        }
        class Sc extends xh {
            constructor(e, r, h = 1) {
                super(void 0, h);
                const c = new Rt().set(e),
                    v = new Rt().set(r),
                    w = new ge(c.r, c.g, c.b),
                    E = new ge(v.r, v.g, v.b),
                    T = Math.sqrt(Math.PI),
                    B = T * Math.sqrt(.75);
                this.sh.coefficients[0].copy(w).add(E).multiplyScalar(T), this.sh.coefficients[1].copy(w).sub(E).multiplyScalar(B)
            }
        }
        Sc.prototype.isHemisphereLightProbe = !0;
        class Ll extends xh {
            constructor(e, r = 1) {
                super(void 0, r);
                const h = new Rt().set(e);
                this.sh.coefficients[0].set(h.r, h.g, h.b).multiplyScalar(2 * Math.sqrt(Math.PI))
            }
        }
        Ll.prototype.isAmbientLightProbe = !0;
        const Eh = new Ui,
            Sh = new Ui;
        class $d {
            constructor(e) {
                this.autoStart = e === void 0 || e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
            }
            start() {
                this.startTime = cd(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
            }
            stop() {
                this.getElapsedTime(), this.running = !1, this.autoStart = !1
            }
            getElapsedTime() {
                return this.getDelta(), this.elapsedTime
            }
            getDelta() {
                let e = 0;
                if (this.autoStart && !this.running) return this.start(), 0;
                if (this.running) {
                    const r = cd();
                    e = (r - this.oldTime) / 1e3, this.oldTime = r, this.elapsedTime += e
                }
                return e
            }
        }

        function cd() {
            return (typeof performance == "undefined" ? Date : performance).now()
        }
        const el = new ge,
            Kd = new Bn,
            ep = new ge,
            tl = new ge;
        class Ah extends Z {
            constructor(e) {
                super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
            }
            getOutput() {
                return this.gain
            }
            setNodeSource(e) {
                return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
            }
            setMediaElementSource(e) {
                return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
            }
            setMediaStreamSource(e) {
                return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
            }
            setBuffer(e) {
                return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
            }
            play(e = 0) {
                if (this.isPlaying === !0) return void console.warn("THREE.Audio: Audio is already playing.");
                if (this.hasPlaybackControl === !1) return void console.warn("THREE.Audio: this Audio has no playback control.");
                this._startedAt = this.context.currentTime + e;
                const r = this.context.createBufferSource();
                return r.buffer = this.buffer, r.loop = this.loop, r.loopStart = this.loopStart, r.loopEnd = this.loopEnd, r.onended = this.onEnded.bind(this), r.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = r, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
            }
            pause() {
                if (this.hasPlaybackControl !== !1) return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            stop() {
                if (this.hasPlaybackControl !== !1) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            connect() {
                if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (let e = 1, r = this.filters.length; e < r; e++) this.filters[e - 1].connect(this.filters[e]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else this.source.connect(this.getOutput());
                return this._connected = !0, this
            }
            disconnect() {
                if (this.filters.length > 0) {
                    this.source.disconnect(this.filters[0]);
                    for (let e = 1, r = this.filters.length; e < r; e++) this.filters[e - 1].disconnect(this.filters[e]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else this.source.disconnect(this.getOutput());
                return this._connected = !1, this
            }
            getFilters() {
                return this.filters
            }
            setFilters(e) {
                return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this
            }
            setDetune(e) {
                if (this.detune = e, this.source.detune !== void 0) return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
            }
            getDetune() {
                return this.detune
            }
            getFilter() {
                return this.getFilters()[0]
            }
            setFilter(e) {
                return this.setFilters(e ? [e] : [])
            }
            setPlaybackRate(e) {
                if (this.hasPlaybackControl !== !1) return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            getPlaybackRate() {
                return this.playbackRate
            }
            onEnded() {
                this.isPlaying = !1
            }
            getLoop() {
                return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
            }
            setLoop(e) {
                if (this.hasPlaybackControl !== !1) return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            setLoopStart(e) {
                return this.loopStart = e, this
            }
            setLoopEnd(e) {
                return this.loopEnd = e, this
            }
            getVolume() {
                return this.gain.gain.value
            }
            setVolume(e) {
                return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
            }
        }
        const Eo = new ge,
            tp = new Bn,
            Tp = new ge,
            il = new ge;
        class Ac {
            constructor(e, r = 2048) {
                this.analyser = e.context.createAnalyser(), this.analyser.fftSize = r, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
            }
            getFrequencyData() {
                return this.analyser.getByteFrequencyData(this.data), this.data
            }
            getAverageFrequency() {
                let e = 0;
                const r = this.getFrequencyData();
                for (let h = 0; h < r.length; h++) e += r[h];
                return e / r.length
            }
        }
        class Rs {
            constructor(e, r, h) {
                let c, v, w;
                switch (this.binding = e, this.valueSize = h, r) {
                    case "quaternion":
                        c = this._slerp, v = this._slerpAdditive, w = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * h), this._workIndex = 5;
                        break;
                    case "string":
                    case "bool":
                        c = this._select, v = this._select, w = this._setAdditiveIdentityOther, this.buffer = new Array(5 * h);
                        break;
                    default:
                        c = this._lerp, v = this._lerpAdditive, w = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * h)
                }
                this._mixBufferRegion = c, this._mixBufferRegionAdditive = v, this._setIdentity = w, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
            }
            accumulate(e, r) {
                const h = this.buffer,
                    c = this.valueSize,
                    v = e * c + c;
                let w = this.cumulativeWeight;
                if (w === 0) {
                    for (let E = 0; E !== c; ++E) h[v + E] = h[E];
                    w = r
                } else {
                    w += r;
                    const E = r / w;
                    this._mixBufferRegion(h, v, 0, E, c)
                }
                this.cumulativeWeight = w
            }
            accumulateAdditive(e) {
                const r = this.buffer,
                    h = this.valueSize,
                    c = h * this._addIndex;
                this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(r, c, 0, e, h), this.cumulativeWeightAdditive += e
            }
            apply(e) {
                const r = this.valueSize,
                    h = this.buffer,
                    c = e * r + r,
                    v = this.cumulativeWeight,
                    w = this.cumulativeWeightAdditive,
                    E = this.binding;
                if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, v < 1) {
                    const T = r * this._origIndex;
                    this._mixBufferRegion(h, c, T, 1 - v, r)
                }
                w > 0 && this._mixBufferRegionAdditive(h, c, this._addIndex * r, 1, r);
                for (let T = r, B = r + r; T !== B; ++T)
                    if (h[T] !== h[T + r]) {
                        E.setValue(h, c);
                        break
                    }
            }
            saveOriginalState() {
                const e = this.binding,
                    r = this.buffer,
                    h = this.valueSize,
                    c = h * this._origIndex;
                e.getValue(r, c);
                for (let v = h, w = c; v !== w; ++v) r[v] = r[c + v % h];
                this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
            }
            restoreOriginalState() {
                const e = 3 * this.valueSize;
                this.binding.setValue(this.buffer, e)
            }
            _setAdditiveIdentityNumeric() {
                const e = this._addIndex * this.valueSize,
                    r = e + this.valueSize;
                for (let h = e; h < r; h++) this.buffer[h] = 0
            }
            _setAdditiveIdentityQuaternion() {
                this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
            }
            _setAdditiveIdentityOther() {
                const e = this._origIndex * this.valueSize,
                    r = this._addIndex * this.valueSize;
                for (let h = 0; h < this.valueSize; h++) this.buffer[r + h] = this.buffer[e + h]
            }
            _select(e, r, h, c, v) {
                if (c >= .5)
                    for (let w = 0; w !== v; ++w) e[r + w] = e[h + w]
            }
            _slerp(e, r, h, c) {
                Bn.slerpFlat(e, r, e, r, e, h, c)
            }
            _slerpAdditive(e, r, h, c, v) {
                const w = this._workIndex * v;
                Bn.multiplyQuaternionsFlat(e, w, e, r, e, h), Bn.slerpFlat(e, r, e, r, e, w, c)
            }
            _lerp(e, r, h, c, v) {
                const w = 1 - c;
                for (let E = 0; E !== v; ++E) {
                    const T = r + E;
                    e[T] = e[T] * w + e[h + E] * c
                }
            }
            _lerpAdditive(e, r, h, c, v) {
                for (let w = 0; w !== v; ++w) {
                    const E = r + w;
                    e[E] = e[E] + e[h + w] * c
                }
            }
        }
        const nl = "\\[\\]\\.:\\/",
            ip = new RegExp("[\\[\\]\\.:\\/]", "g"),
            Th = "[^\\[\\]\\.:\\/]",
            Mp = "[^" + nl.replace("\\.", "") + "]",
            Cp = /((?:WC+[\/:])*)/.source.replace("WC", Th),
            yu = /(WCOD+)?/.source.replace("WCOD", Mp),
            hd = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Th),
            Bp = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Th),
            ud = new RegExp("^" + Cp + yu + hd + Bp + "$"),
            dd = ["material", "materials", "bones"];

        function Ql(s, e, r) {
            const h = r || Ca.parseTrackName(e);
            this._targetGroup = s, this._bindings = s.subscribe_(e, h)
        }

        function Ca(s, e, r) {
            this.path = e, this.parsedPath = r || Ca.parseTrackName(e), this.node = Ca.findNode(s, this.parsedPath.nodeName) || s, this.rootNode = s
        }
        Object.assign(Ql.prototype, {
            getValue: function(s, e) {
                this.bind();
                const r = this._targetGroup.nCachedObjects_,
                    h = this._bindings[r];
                h !== void 0 && h.getValue(s, e)
            },
            setValue: function(s, e) {
                const r = this._bindings;
                for (let h = this._targetGroup.nCachedObjects_, c = r.length; h !== c; ++h) r[h].setValue(s, e)
            },
            bind: function() {
                const s = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, r = s.length; e !== r; ++e) s[e].bind()
            },
            unbind: function() {
                const s = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, r = s.length; e !== r; ++e) s[e].unbind()
            }
        }), Object.assign(Ca, {
            Composite: Ql,
            create: function(s, e, r) {
                return s && s.isAnimationObjectGroup ? new Ca.Composite(s, e, r) : new Ca(s, e, r)
            },
            sanitizeNodeName: function(s) {
                return s.replace(/\s/g, "_").replace(ip, "")
            },
            parseTrackName: function(s) {
                const e = ud.exec(s);
                if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + s);
                const r = {
                        nodeName: e[2],
                        objectName: e[3],
                        objectIndex: e[4],
                        propertyName: e[5],
                        propertyIndex: e[6]
                    },
                    h = r.nodeName && r.nodeName.lastIndexOf(".");
                if (h !== void 0 && h !== -1) {
                    const c = r.nodeName.substring(h + 1);
                    dd.indexOf(c) !== -1 && (r.nodeName = r.nodeName.substring(0, h), r.objectName = c)
                }
                if (r.propertyName === null || r.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + s);
                return r
            },
            findNode: function(s, e) {
                if (!e || e === "" || e === "." || e === -1 || e === s.name || e === s.uuid) return s;
                if (s.skeleton) {
                    const r = s.skeleton.getBoneByName(e);
                    if (r !== void 0) return r
                }
                if (s.children) {
                    const r = function(c) {
                            for (let v = 0; v < c.length; v++) {
                                const w = c[v];
                                if (w.name === e || w.uuid === e) return w;
                                const E = r(w.children);
                                if (E) return E
                            }
                            return null
                        },
                        h = r(s.children);
                    if (h) return h
                }
                return null
            }
        }), Object.assign(Ca.prototype, {
            _getValue_unavailable: function() {},
            _setValue_unavailable: function() {},
            BindingType: {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            },
            Versioning: {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            },
            GetterByBindingType: [function(s, e) {
                s[e] = this.node[this.propertyName]
            }, function(s, e) {
                const r = this.resolvedProperty;
                for (let h = 0, c = r.length; h !== c; ++h) s[e++] = r[h]
            }, function(s, e) {
                s[e] = this.resolvedProperty[this.propertyIndex]
            }, function(s, e) {
                this.resolvedProperty.toArray(s, e)
            }],
            SetterByBindingTypeAndVersioning: [
                [function(s, e) {
                    this.targetObject[this.propertyName] = s[e]
                }, function(s, e) {
                    this.targetObject[this.propertyName] = s[e], this.targetObject.needsUpdate = !0
                }, function(s, e) {
                    this.targetObject[this.propertyName] = s[e], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(s, e) {
                    const r = this.resolvedProperty;
                    for (let h = 0, c = r.length; h !== c; ++h) r[h] = s[e++]
                }, function(s, e) {
                    const r = this.resolvedProperty;
                    for (let h = 0, c = r.length; h !== c; ++h) r[h] = s[e++];
                    this.targetObject.needsUpdate = !0
                }, function(s, e) {
                    const r = this.resolvedProperty;
                    for (let h = 0, c = r.length; h !== c; ++h) r[h] = s[e++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(s, e) {
                    this.resolvedProperty[this.propertyIndex] = s[e]
                }, function(s, e) {
                    this.resolvedProperty[this.propertyIndex] = s[e], this.targetObject.needsUpdate = !0
                }, function(s, e) {
                    this.resolvedProperty[this.propertyIndex] = s[e], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(s, e) {
                    this.resolvedProperty.fromArray(s, e)
                }, function(s, e) {
                    this.resolvedProperty.fromArray(s, e), this.targetObject.needsUpdate = !0
                }, function(s, e) {
                    this.resolvedProperty.fromArray(s, e), this.targetObject.matrixWorldNeedsUpdate = !0
                }]
            ],
            getValue: function(s, e) {
                this.bind(), this.getValue(s, e)
            },
            setValue: function(s, e) {
                this.bind(), this.setValue(s, e)
            },
            bind: function() {
                let s = this.node;
                const e = this.parsedPath,
                    r = e.objectName,
                    h = e.propertyName;
                let c = e.propertyIndex;
                if (s || (s = Ca.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = s), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !s) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                if (r) {
                    let T = e.objectIndex;
                    switch (r) {
                        case "materials":
                            if (!s.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!s.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            s = s.material.materials;
                            break;
                        case "bones":
                            if (!s.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            s = s.skeleton.bones;
                            for (let B = 0; B < s.length; B++)
                                if (s[B].name === T) {
                                    T = B;
                                    break
                                } break;
                        default:
                            if (s[r] === void 0) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            s = s[r]
                    }
                    if (T !== void 0) {
                        if (s[T] === void 0) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, s);
                        s = s[T]
                    }
                }
                const v = s[h];
                if (v === void 0) {
                    const T = e.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + T + "." + h + " but it wasn't found.", s)
                }
                let w = this.Versioning.None;
                this.targetObject = s, s.needsUpdate !== void 0 ? w = this.Versioning.NeedsUpdate : s.matrixWorldNeedsUpdate !== void 0 && (w = this.Versioning.MatrixWorldNeedsUpdate);
                let E = this.BindingType.Direct;
                if (c !== void 0) {
                    if (h === "morphTargetInfluences") {
                        if (!s.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (!s.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                        if (!s.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        s.morphTargetDictionary[c] !== void 0 && (c = s.morphTargetDictionary[c])
                    }
                    E = this.BindingType.ArrayElement, this.resolvedProperty = v, this.propertyIndex = c
                } else v.fromArray !== void 0 && v.toArray !== void 0 ? (E = this.BindingType.HasFromToArray, this.resolvedProperty = v) : Array.isArray(v) ? (E = this.BindingType.EntireArray, this.resolvedProperty = v) : this.propertyName = h;
                this.getValue = this.GetterByBindingType[E], this.setValue = this.SetterByBindingTypeAndVersioning[E][w]
            },
            unbind: function() {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }), Object.assign(Ca.prototype, {
            _getValue_unbound: Ca.prototype.getValue,
            _setValue_unbound: Ca.prototype.setValue
        });
        class pd {
            constructor() {
                this.uuid = Mi.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                const e = {};
                this._indicesByUUID = e;
                for (let h = 0, c = arguments.length; h !== c; ++h) e[arguments[h].uuid] = h;
                this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                const r = this;
                this.stats = {
                    objects: {
                        get total() {
                            return r._objects.length
                        },
                        get inUse() {
                            return this.total - r.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return r._bindings.length
                    }
                }
            }
            add() {
                const e = this._objects,
                    r = this._indicesByUUID,
                    h = this._paths,
                    c = this._parsedPaths,
                    v = this._bindings,
                    w = v.length;
                let E, T = e.length,
                    B = this.nCachedObjects_;
                for (let Q = 0, k = arguments.length; Q !== k; ++Q) {
                    const i = arguments[Q],
                        t = i.uuid;
                    let a = r[t];
                    if (a === void 0) {
                        a = T++, r[t] = a, e.push(i);
                        for (let l = 0, d = w; l !== d; ++l) v[l].push(new Ca(i, h[l], c[l]))
                    } else if (a < B) {
                        E = e[a];
                        const l = --B,
                            d = e[l];
                        r[d.uuid] = a, e[a] = d, r[t] = l, e[l] = i;
                        for (let g = 0, x = w; g !== x; ++g) {
                            const A = v[g],
                                M = A[l];
                            let F = A[a];
                            A[a] = M, F === void 0 && (F = new Ca(i, h[g], c[g])), A[l] = F
                        }
                    } else e[a] !== E && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                }
                this.nCachedObjects_ = B
            }
            remove() {
                const e = this._objects,
                    r = this._indicesByUUID,
                    h = this._bindings,
                    c = h.length;
                let v = this.nCachedObjects_;
                for (let w = 0, E = arguments.length; w !== E; ++w) {
                    const T = arguments[w],
                        B = T.uuid,
                        Q = r[B];
                    if (Q !== void 0 && Q >= v) {
                        const k = v++,
                            i = e[k];
                        r[i.uuid] = Q, e[Q] = i, r[B] = k, e[k] = T;
                        for (let t = 0, a = c; t !== a; ++t) {
                            const l = h[t],
                                d = l[k],
                                g = l[Q];
                            l[Q] = d, l[k] = g
                        }
                    }
                }
                this.nCachedObjects_ = v
            }
            uncache() {
                const e = this._objects,
                    r = this._indicesByUUID,
                    h = this._bindings,
                    c = h.length;
                let v = this.nCachedObjects_,
                    w = e.length;
                for (let E = 0, T = arguments.length; E !== T; ++E) {
                    const B = arguments[E].uuid,
                        Q = r[B];
                    if (Q !== void 0)
                        if (delete r[B], Q < v) {
                            const k = --v,
                                i = e[k],
                                t = --w,
                                a = e[t];
                            r[i.uuid] = Q, e[Q] = i, r[a.uuid] = k, e[k] = a, e.pop();
                            for (let l = 0, d = c; l !== d; ++l) {
                                const g = h[l],
                                    x = g[k],
                                    A = g[t];
                                g[Q] = x, g[k] = A, g.pop()
                            }
                        } else {
                            const k = --w,
                                i = e[k];
                            k > 0 && (r[i.uuid] = Q), e[Q] = i, e.pop();
                            for (let t = 0, a = c; t !== a; ++t) {
                                const l = h[t];
                                l[Q] = l[k], l.pop()
                            }
                        }
                }
                this.nCachedObjects_ = v
            }
            subscribe_(e, r) {
                const h = this._bindingsIndicesByPath;
                let c = h[e];
                const v = this._bindings;
                if (c !== void 0) return v[c];
                const w = this._paths,
                    E = this._parsedPaths,
                    T = this._objects,
                    B = T.length,
                    Q = this.nCachedObjects_,
                    k = new Array(B);
                c = v.length, h[e] = c, w.push(e), E.push(r), v.push(k);
                for (let i = Q, t = T.length; i !== t; ++i) {
                    const a = T[i];
                    k[i] = new Ca(a, e, r)
                }
                return k
            }
            unsubscribe_(e) {
                const r = this._bindingsIndicesByPath,
                    h = r[e];
                if (h !== void 0) {
                    const c = this._paths,
                        v = this._parsedPaths,
                        w = this._bindings,
                        E = w.length - 1,
                        T = w[E];
                    r[e[E]] = h, w[h] = T, w.pop(), v[h] = v[E], v.pop(), c[h] = c[E], c.pop()
                }
            }
        }
        pd.prototype.isAnimationObjectGroup = !0;
        class fd {
            constructor(e, r, h = null, c = r.blendMode) {
                this._mixer = e, this._clip = r, this._localRoot = h, this.blendMode = c;
                const v = r.tracks,
                    w = v.length,
                    E = new Array(w),
                    T = {
                        endingStart: 2400,
                        endingEnd: 2400
                    };
                for (let B = 0; B !== w; ++B) {
                    const Q = v[B].createInterpolant(null);
                    E[B] = Q, Q.settings = T
                }
                this._interpolantSettings = T, this._interpolants = E, this._propertyBindings = new Array(w), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
            }
            play() {
                return this._mixer._activateAction(this), this
            }
            stop() {
                return this._mixer._deactivateAction(this), this.reset()
            }
            reset() {
                return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
            }
            isRunning() {
                return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
            }
            isScheduled() {
                return this._mixer._isActiveAction(this)
            }
            startAt(e) {
                return this._startTime = e, this
            }
            setLoop(e, r) {
                return this.loop = e, this.repetitions = r, this
            }
            setEffectiveWeight(e) {
                return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
            }
            getEffectiveWeight() {
                return this._effectiveWeight
            }
            fadeIn(e) {
                return this._scheduleFading(e, 0, 1)
            }
            fadeOut(e) {
                return this._scheduleFading(e, 1, 0)
            }
            crossFadeFrom(e, r, h) {
                if (e.fadeOut(r), this.fadeIn(r), h) {
                    const c = this._clip.duration,
                        v = e._clip.duration,
                        w = v / c,
                        E = c / v;
                    e.warp(1, w, r), this.warp(E, 1, r)
                }
                return this
            }
            crossFadeTo(e, r, h) {
                return e.crossFadeFrom(this, r, h)
            }
            stopFading() {
                const e = this._weightInterpolant;
                return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
            }
            setEffectiveTimeScale(e) {
                return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
            }
            getEffectiveTimeScale() {
                return this._effectiveTimeScale
            }
            setDuration(e) {
                return this.timeScale = this._clip.duration / e, this.stopWarping()
            }
            syncWith(e) {
                return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
            }
            halt(e) {
                return this.warp(this._effectiveTimeScale, 0, e)
            }
            warp(e, r, h) {
                const c = this._mixer,
                    v = c.time,
                    w = this.timeScale;
                let E = this._timeScaleInterpolant;
                E === null && (E = c._lendControlInterpolant(), this._timeScaleInterpolant = E);
                const T = E.parameterPositions,
                    B = E.sampleValues;
                return T[0] = v, T[1] = v + h, B[0] = e / w, B[1] = r / w, this
            }
            stopWarping() {
                const e = this._timeScaleInterpolant;
                return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
            }
            getMixer() {
                return this._mixer
            }
            getClip() {
                return this._clip
            }
            getRoot() {
                return this._localRoot || this._mixer._root
            }
            _update(e, r, h, c) {
                if (!this.enabled) return void this._updateWeight(e);
                const v = this._startTime;
                if (v !== null) {
                    const T = (e - v) * h;
                    if (T < 0 || h === 0) return;
                    this._startTime = null, r = h * T
                }
                r *= this._updateTimeScale(e);
                const w = this._updateTime(r),
                    E = this._updateWeight(e);
                if (E > 0) {
                    const T = this._interpolants,
                        B = this._propertyBindings;
                    switch (this.blendMode) {
                        case 2501:
                            for (let Q = 0, k = T.length; Q !== k; ++Q) T[Q].evaluate(w), B[Q].accumulateAdditive(E);
                            break;
                        case 2500:
                        default:
                            for (let Q = 0, k = T.length; Q !== k; ++Q) T[Q].evaluate(w), B[Q].accumulate(c, E)
                    }
                }
            }
            _updateWeight(e) {
                let r = 0;
                if (this.enabled) {
                    r = this.weight;
                    const h = this._weightInterpolant;
                    if (h !== null) {
                        const c = h.evaluate(e)[0];
                        r *= c, e > h.parameterPositions[1] && (this.stopFading(), c === 0 && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = r, r
            }
            _updateTimeScale(e) {
                let r = 0;
                if (!this.paused) {
                    r = this.timeScale;
                    const h = this._timeScaleInterpolant;
                    h !== null && (r *= h.evaluate(e)[0], e > h.parameterPositions[1] && (this.stopWarping(), r === 0 ? this.paused = !0 : this.timeScale = r))
                }
                return this._effectiveTimeScale = r, r
            }
            _updateTime(e) {
                const r = this._clip.duration,
                    h = this.loop;
                let c = this.time + e,
                    v = this._loopCount;
                const w = h === 2202;
                if (e === 0) return v === -1 ? c : w && (1 & v) == 1 ? r - c : c;
                if (h === 2200) {
                    v === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                    e: {
                        if (c >= r) c = r;
                        else {
                            if (!(c < 0)) {
                                this.time = c;
                                break e
                            }
                            c = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        this.time = c,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: e < 0 ? -1 : 1
                        })
                    }
                } else {
                    if (v === -1 && (e >= 0 ? (v = 0, this._setEndings(!0, this.repetitions === 0, w)) : this._setEndings(this.repetitions === 0, !0, w)), c >= r || c < 0) {
                        const E = Math.floor(c / r);
                        c -= r * E, v += Math.abs(E);
                        const T = this.repetitions - v;
                        if (T <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, c = e > 0 ? r : 0, this.time = c, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: e > 0 ? 1 : -1
                        });
                        else {
                            if (T === 1) {
                                const B = e < 0;
                                this._setEndings(B, !B, w)
                            } else this._setEndings(!1, !1, w);
                            this._loopCount = v, this.time = c, this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: E
                            })
                        }
                    } else this.time = c;
                    if (w && (1 & v) == 1) return r - c
                }
                return c
            }
            _setEndings(e, r, h) {
                const c = this._interpolantSettings;
                h ? (c.endingStart = 2401, c.endingEnd = 2401) : (c.endingStart = e ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, c.endingEnd = r ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
            }
            _scheduleFading(e, r, h) {
                const c = this._mixer,
                    v = c.time;
                let w = this._weightInterpolant;
                w === null && (w = c._lendControlInterpolant(), this._weightInterpolant = w);
                const E = w.parameterPositions,
                    T = w.sampleValues;
                return E[0] = v, T[0] = r, E[1] = v + e, T[1] = h, this
            }
        }
        class md extends yn {
            constructor(e) {
                super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
            }
            _bindAction(e, r) {
                const h = e._localRoot || this._root,
                    c = e._clip.tracks,
                    v = c.length,
                    w = e._propertyBindings,
                    E = e._interpolants,
                    T = h.uuid,
                    B = this._bindingsByRootAndName;
                let Q = B[T];
                Q === void 0 && (Q = {}, B[T] = Q);
                for (let k = 0; k !== v; ++k) {
                    const i = c[k],
                        t = i.name;
                    let a = Q[t];
                    if (a !== void 0) w[k] = a;
                    else {
                        if (a = w[k], a !== void 0) {
                            a._cacheIndex === null && (++a.referenceCount, this._addInactiveBinding(a, T, t));
                            continue
                        }
                        const l = r && r._propertyBindings[k].binding.parsedPath;
                        a = new Rs(Ca.create(h, t, l), i.ValueTypeName, i.getValueSize()), ++a.referenceCount, this._addInactiveBinding(a, T, t), w[k] = a
                    }
                    E[k].resultBuffer = a.buffer
                }
            }
            _activateAction(e) {
                if (!this._isActiveAction(e)) {
                    if (e._cacheIndex === null) {
                        const h = (e._localRoot || this._root).uuid,
                            c = e._clip.uuid,
                            v = this._actionsByClip[c];
                        this._bindAction(e, v && v.knownActions[0]), this._addInactiveAction(e, c, h)
                    }
                    const r = e._propertyBindings;
                    for (let h = 0, c = r.length; h !== c; ++h) {
                        const v = r[h];
                        v.useCount++ == 0 && (this._lendBinding(v), v.saveOriginalState())
                    }
                    this._lendAction(e)
                }
            }
            _deactivateAction(e) {
                if (this._isActiveAction(e)) {
                    const r = e._propertyBindings;
                    for (let h = 0, c = r.length; h !== c; ++h) {
                        const v = r[h];
                        --v.useCount == 0 && (v.restoreOriginalState(), this._takeBackBinding(v))
                    }
                    this._takeBackAction(e)
                }
            }
            _initMemoryManager() {
                this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                const e = this;
                this.stats = {
                    actions: {
                        get total() {
                            return e._actions.length
                        },
                        get inUse() {
                            return e._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return e._bindings.length
                        },
                        get inUse() {
                            return e._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return e._controlInterpolants.length
                        },
                        get inUse() {
                            return e._nActiveControlInterpolants
                        }
                    }
                }
            }
            _isActiveAction(e) {
                const r = e._cacheIndex;
                return r !== null && r < this._nActiveActions
            }
            _addInactiveAction(e, r, h) {
                const c = this._actions,
                    v = this._actionsByClip;
                let w = v[r];
                if (w === void 0) w = {
                    knownActions: [e],
                    actionByRoot: {}
                }, e._byClipCacheIndex = 0, v[r] = w;
                else {
                    const E = w.knownActions;
                    e._byClipCacheIndex = E.length, E.push(e)
                }
                e._cacheIndex = c.length, c.push(e), w.actionByRoot[h] = e
            }
            _removeInactiveAction(e) {
                const r = this._actions,
                    h = r[r.length - 1],
                    c = e._cacheIndex;
                h._cacheIndex = c, r[c] = h, r.pop(), e._cacheIndex = null;
                const v = e._clip.uuid,
                    w = this._actionsByClip,
                    E = w[v],
                    T = E.knownActions,
                    B = T[T.length - 1],
                    Q = e._byClipCacheIndex;
                B._byClipCacheIndex = Q, T[Q] = B, T.pop(), e._byClipCacheIndex = null, delete E.actionByRoot[(e._localRoot || this._root).uuid], T.length === 0 && delete w[v], this._removeInactiveBindingsForAction(e)
            }
            _removeInactiveBindingsForAction(e) {
                const r = e._propertyBindings;
                for (let h = 0, c = r.length; h !== c; ++h) {
                    const v = r[h];
                    --v.referenceCount == 0 && this._removeInactiveBinding(v)
                }
            }
            _lendAction(e) {
                const r = this._actions,
                    h = e._cacheIndex,
                    c = this._nActiveActions++,
                    v = r[c];
                e._cacheIndex = c, r[c] = e, v._cacheIndex = h, r[h] = v
            }
            _takeBackAction(e) {
                const r = this._actions,
                    h = e._cacheIndex,
                    c = --this._nActiveActions,
                    v = r[c];
                e._cacheIndex = c, r[c] = e, v._cacheIndex = h, r[h] = v
            }
            _addInactiveBinding(e, r, h) {
                const c = this._bindingsByRootAndName,
                    v = this._bindings;
                let w = c[r];
                w === void 0 && (w = {}, c[r] = w), w[h] = e, e._cacheIndex = v.length, v.push(e)
            }
            _removeInactiveBinding(e) {
                const r = this._bindings,
                    h = e.binding,
                    c = h.rootNode.uuid,
                    v = h.path,
                    w = this._bindingsByRootAndName,
                    E = w[c],
                    T = r[r.length - 1],
                    B = e._cacheIndex;
                T._cacheIndex = B, r[B] = T, r.pop(), delete E[v], Object.keys(E).length === 0 && delete w[c]
            }
            _lendBinding(e) {
                const r = this._bindings,
                    h = e._cacheIndex,
                    c = this._nActiveBindings++,
                    v = r[c];
                e._cacheIndex = c, r[c] = e, v._cacheIndex = h, r[h] = v
            }
            _takeBackBinding(e) {
                const r = this._bindings,
                    h = e._cacheIndex,
                    c = --this._nActiveBindings,
                    v = r[c];
                e._cacheIndex = c, r[c] = e, v._cacheIndex = h, r[h] = v
            }
            _lendControlInterpolant() {
                const e = this._controlInterpolants,
                    r = this._nActiveControlInterpolants++;
                let h = e[r];
                return h === void 0 && (h = new hh(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), h.__cacheIndex = r, e[r] = h), h
            }
            _takeBackControlInterpolant(e) {
                const r = this._controlInterpolants,
                    h = e.__cacheIndex,
                    c = --this._nActiveControlInterpolants,
                    v = r[c];
                e.__cacheIndex = c, r[c] = e, v.__cacheIndex = h, r[h] = v
            }
            clipAction(e, r, h) {
                const c = r || this._root,
                    v = c.uuid;
                let w = typeof e == "string" ? dh.findByName(c, e) : e;
                const E = w !== null ? w.uuid : e,
                    T = this._actionsByClip[E];
                let B = null;
                if (h === void 0 && (h = w !== null ? w.blendMode : 2500), T !== void 0) {
                    const k = T.actionByRoot[v];
                    if (k !== void 0 && k.blendMode === h) return k;
                    B = T.knownActions[0], w === null && (w = B._clip)
                }
                if (w === null) return null;
                const Q = new fd(this, w, r, h);
                return this._bindAction(Q, B), this._addInactiveAction(Q, E, v), Q
            }
            existingAction(e, r) {
                const h = r || this._root,
                    c = h.uuid,
                    v = typeof e == "string" ? dh.findByName(h, e) : e,
                    w = v ? v.uuid : e,
                    E = this._actionsByClip[w];
                return E !== void 0 && E.actionByRoot[c] || null
            }
            stopAllAction() {
                const e = this._actions;
                for (let r = this._nActiveActions - 1; r >= 0; --r) e[r].stop();
                return this
            }
            update(e) {
                e *= this.timeScale;
                const r = this._actions,
                    h = this._nActiveActions,
                    c = this.time += e,
                    v = Math.sign(e),
                    w = this._accuIndex ^= 1;
                for (let B = 0; B !== h; ++B) r[B]._update(c, e, v, w);
                const E = this._bindings,
                    T = this._nActiveBindings;
                for (let B = 0; B !== T; ++B) E[B].apply(w);
                return this
            }
            setTime(e) {
                this.time = 0;
                for (let r = 0; r < this._actions.length; r++) this._actions[r].time = 0;
                return this.update(e)
            }
            getRoot() {
                return this._root
            }
            uncacheClip(e) {
                const r = this._actions,
                    h = e.uuid,
                    c = this._actionsByClip,
                    v = c[h];
                if (v !== void 0) {
                    const w = v.knownActions;
                    for (let E = 0, T = w.length; E !== T; ++E) {
                        const B = w[E];
                        this._deactivateAction(B);
                        const Q = B._cacheIndex,
                            k = r[r.length - 1];
                        B._cacheIndex = null, B._byClipCacheIndex = null, k._cacheIndex = Q, r[Q] = k, r.pop(), this._removeInactiveBindingsForAction(B)
                    }
                    delete c[h]
                }
            }
            uncacheRoot(e) {
                const r = e.uuid,
                    h = this._actionsByClip;
                for (const v in h) {
                    const w = h[v].actionByRoot[r];
                    w !== void 0 && (this._deactivateAction(w), this._removeInactiveAction(w))
                }
                const c = this._bindingsByRootAndName[r];
                if (c !== void 0)
                    for (const v in c) {
                        const w = c[v];
                        w.restoreOriginalState(), this._removeInactiveBinding(w)
                    }
            }
            uncacheAction(e, r) {
                const h = this.existingAction(e, r);
                h !== null && (this._deactivateAction(h), this._removeInactiveAction(h))
            }
        }
        md.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
        class Pl {
            constructor(e) {
                typeof e == "string" && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e
            }
            clone() {
                return new Pl(this.value.clone === void 0 ? this.value : this.value.clone())
            }
        }

        function vu(s, e, r) {
            St.call(this, s, e), this.meshPerAttribute = r || 1
        }

        function gd(s, e, r, h, c) {
            this.buffer = s, this.type = e, this.itemSize = r, this.elementSize = h, this.count = c, this.version = 0
        }

        function yd(s, e, r = 0, h = 1 / 0) {
            this.ray = new wr(s, e), this.near = r, this.far = h, this.camera = null, this.layers = new Jr, this.params = {
                Mesh: {},
                Line: {
                    threshold: 1
                },
                LOD: {},
                Points: {
                    threshold: 1
                },
                Sprite: {}
            }, Object.defineProperties(this.params, {
                PointCloud: {
                    get: function() {
                        return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                    }
                }
            })
        }

        function vd(s, e) {
            return s.distance - e.distance
        }

        function _d(s, e, r, h) {
            if (s.layers.test(e.layers) && s.raycast(e, r), h === !0) {
                const c = s.children;
                for (let v = 0, w = c.length; v < w; v++) _d(c[v], e, r, !0)
            }
        }
        vu.prototype = Object.assign(Object.create(St.prototype), {
            constructor: vu,
            isInstancedInterleavedBuffer: !0,
            copy: function(s) {
                return St.prototype.copy.call(this, s), this.meshPerAttribute = s.meshPerAttribute, this
            },
            clone: function(s) {
                const e = St.prototype.clone.call(this, s);
                return e.meshPerAttribute = this.meshPerAttribute, e
            },
            toJSON: function(s) {
                const e = St.prototype.toJSON.call(this, s);
                return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
            }
        }), Object.defineProperty(gd.prototype, "needsUpdate", {
            set: function(s) {
                s === !0 && this.version++
            }
        }), Object.assign(gd.prototype, {
            isGLBufferAttribute: !0,
            setBuffer: function(s) {
                return this.buffer = s, this
            },
            setType: function(s, e) {
                return this.type = s, this.elementSize = e, this
            },
            setItemSize: function(s) {
                return this.itemSize = s, this
            },
            setCount: function(s) {
                return this.count = s, this
            }
        }), Object.assign(yd.prototype, {
            set: function(s, e) {
                this.ray.set(s, e)
            },
            setFromCamera: function(s, e) {
                e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(s.x, s.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(s.x, s.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type)
            },
            intersectObject: function(s, e = !1, r = []) {
                return _d(s, this, r, e), r.sort(vd), r
            },
            intersectObjects: function(s, e = !1, r = []) {
                for (let h = 0, c = s.length; h < c; h++) _d(s[h], this, r, e);
                return r.sort(vd), r
            }
        });
        const np = new Ht;
        class Tc {
            constructor(e = new Ht(1 / 0, 1 / 0), r = new Ht(-1 / 0, -1 / 0)) {
                this.min = e, this.max = r
            }
            set(e, r) {
                return this.min.copy(e), this.max.copy(r), this
            }
            setFromPoints(e) {
                this.makeEmpty();
                for (let r = 0, h = e.length; r < h; r++) this.expandByPoint(e[r]);
                return this
            }
            setFromCenterAndSize(e, r) {
                const h = np.copy(r).multiplyScalar(.5);
                return this.min.copy(e).sub(h), this.max.copy(e).add(h), this
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(e) {
                return this.min.copy(e.min), this.max.copy(e.max), this
            }
            makeEmpty() {
                return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y
            }
            getCenter(e) {
                return e === void 0 && (console.warn("THREE.Box2: .getCenter() target is now required"), e = new Ht), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(e) {
                return e === void 0 && (console.warn("THREE.Box2: .getSize() target is now required"), e = new Ht), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
            }
            expandByPoint(e) {
                return this.min.min(e), this.max.max(e), this
            }
            expandByVector(e) {
                return this.min.sub(e), this.max.add(e), this
            }
            expandByScalar(e) {
                return this.min.addScalar(-e), this.max.addScalar(e), this
            }
            containsPoint(e) {
                return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
            }
            containsBox(e) {
                return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
            }
            getParameter(e, r) {
                return r === void 0 && (console.warn("THREE.Box2: .getParameter() target is now required"), r = new Ht), r.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
            }
            intersectsBox(e) {
                return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
            }
            clampPoint(e, r) {
                return r === void 0 && (console.warn("THREE.Box2: .clampPoint() target is now required"), r = new Ht), r.copy(e).clamp(this.min, this.max)
            }
            distanceToPoint(e) {
                return np.copy(e).clamp(this.min, this.max).sub(e).length()
            }
            intersect(e) {
                return this.min.max(e.min), this.max.min(e.max), this
            }
            union(e) {
                return this.min.min(e.min), this.max.max(e.max), this
            }
            translate(e) {
                return this.min.add(e), this.max.add(e), this
            }
            equals(e) {
                return e.min.equals(this.min) && e.max.equals(this.max)
            }
        }
        Tc.prototype.isBox2 = !0;
        const rp = new ge,
            Mc = new ge;
        class So {
            constructor(e = new ge, r = new ge) {
                this.start = e, this.end = r
            }
            set(e, r) {
                return this.start.copy(e), this.end.copy(r), this
            }
            copy(e) {
                return this.start.copy(e.start), this.end.copy(e.end), this
            }
            getCenter(e) {
                return e === void 0 && (console.warn("THREE.Line3: .getCenter() target is now required"), e = new ge), e.addVectors(this.start, this.end).multiplyScalar(.5)
            }
            delta(e) {
                return e === void 0 && (console.warn("THREE.Line3: .delta() target is now required"), e = new ge), e.subVectors(this.end, this.start)
            }
            distanceSq() {
                return this.start.distanceToSquared(this.end)
            }
            distance() {
                return this.start.distanceTo(this.end)
            }
            at(e, r) {
                return r === void 0 && (console.warn("THREE.Line3: .at() target is now required"), r = new ge), this.delta(r).multiplyScalar(e).add(this.start)
            }
            closestPointToPointParameter(e, r) {
                rp.subVectors(e, this.start), Mc.subVectors(this.end, this.start);
                const h = Mc.dot(Mc);
                let c = Mc.dot(rp) / h;
                return r && (c = Mi.clamp(c, 0, 1)), c
            }
            closestPointToPoint(e, r, h) {
                const c = this.closestPointToPointParameter(e, r);
                return h === void 0 && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), h = new ge), this.delta(h).multiplyScalar(c).add(this.start)
            }
            applyMatrix4(e) {
                return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
            }
            equals(e) {
                return e.start.equals(this.start) && e.end.equals(this.end)
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }

        function Cc(s) {
            Z.call(this), this.material = s, this.render = function() {}, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0
        }
        Cc.prototype = Object.create(Z.prototype), Cc.prototype.constructor = Cc, Cc.prototype.isImmediateRenderObject = !0;
        const xd = new ge,
            Ao = new ge,
            Mh = new Ui,
            _u = new Ui;
        class xu extends xa {
            constructor(e) {
                const r = Ch(e),
                    h = new an,
                    c = [],
                    v = [],
                    w = new Rt(0, 0, 1),
                    E = new Rt(0, 1, 0);
                for (let T = 0; T < r.length; T++) {
                    const B = r[T];
                    B.parent && B.parent.isBone && (c.push(0, 0, 0), c.push(0, 0, 0), v.push(w.r, w.g, w.b), v.push(E.r, E.g, E.b))
                }
                h.setAttribute("position", new Ai(c, 3)), h.setAttribute("color", new Ai(v, 3)), super(h, new Xr({
                    vertexColors: !0,
                    depthTest: !1,
                    depthWrite: !1,
                    toneMapped: !1,
                    transparent: !0
                })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = e, this.bones = r, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
            }
            updateMatrixWorld(e) {
                const r = this.bones,
                    h = this.geometry,
                    c = h.getAttribute("position");
                _u.copy(this.root.matrixWorld).invert();
                for (let v = 0, w = 0; v < r.length; v++) {
                    const E = r[v];
                    E.parent && E.parent.isBone && (Mh.multiplyMatrices(_u, E.matrixWorld), Ao.setFromMatrixPosition(Mh), c.setXYZ(w, Ao.x, Ao.y, Ao.z), Mh.multiplyMatrices(_u, E.parent.matrixWorld), Ao.setFromMatrixPosition(Mh), c.setXYZ(w + 1, Ao.x, Ao.y, Ao.z), w += 2)
                }
                h.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e)
            }
        }

        function Ch(s) {
            const e = [];
            s && s.isBone && e.push(s);
            for (let r = 0; r < s.children.length; r++) e.push.apply(e, Ch(s.children[r]));
            return e
        }
        const ap = new ge,
            bu = new Rt,
            bd = new Rt;
        class Ja extends xa {
            constructor(e = 10, r = 10, h = 4473924, c = 8947848) {
                h = new Rt(h), c = new Rt(c);
                const v = r / 2,
                    w = e / r,
                    E = e / 2,
                    T = [],
                    B = [];
                for (let k = 0, i = 0, t = -E; k <= r; k++, t += w) {
                    T.push(-E, 0, t, E, 0, t), T.push(t, 0, -E, t, 0, E);
                    const a = k === v ? h : c;
                    a.toArray(B, i), i += 3, a.toArray(B, i), i += 3, a.toArray(B, i), i += 3, a.toArray(B, i), i += 3
                }
                const Q = new an;
                Q.setAttribute("position", new Ai(T, 3)), Q.setAttribute("color", new Ai(B, 3)), super(Q, new Xr({
                    vertexColors: !0,
                    toneMapped: !1
                })), this.type = "GridHelper"
            }
        }
        const Bc = new ge,
            Bh = new ge,
            wd = new ge,
            Rh = new ge,
            Hr = new Dn;

        function jr(s, e, r, h, c, v, w) {
            Rh.set(c, v, w).unproject(h);
            const E = e[s];
            if (E !== void 0) {
                const T = r.getAttribute("position");
                for (let B = 0, Q = E.length; B < Q; B++) T.setXYZ(E[B], Rh.x, Rh.y, Rh.z)
            }
        }
        const Fh = new Te;
        class sp extends xa {
            constructor(e, r = 16776960) {
                const h = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    c = new Float32Array(24),
                    v = new an;
                v.setIndex(new pi(h, 1)), v.setAttribute("position", new pi(c, 3)), super(v, new Xr({
                    color: r,
                    toneMapped: !1
                })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
            }
            update(e) {
                if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && Fh.setFromObject(this.object), Fh.isEmpty()) return;
                const r = Fh.min,
                    h = Fh.max,
                    c = this.geometry.attributes.position,
                    v = c.array;
                v[0] = h.x, v[1] = h.y, v[2] = h.z, v[3] = r.x, v[4] = h.y, v[5] = h.z, v[6] = r.x, v[7] = r.y, v[8] = h.z, v[9] = h.x, v[10] = r.y, v[11] = h.z, v[12] = h.x, v[13] = h.y, v[14] = r.z, v[15] = r.x, v[16] = h.y, v[17] = r.z, v[18] = r.x, v[19] = r.y, v[20] = r.z, v[21] = h.x, v[22] = r.y, v[23] = r.z, c.needsUpdate = !0, this.geometry.computeBoundingSphere()
            }
            setFromObject(e) {
                return this.object = e, this.update(), this
            }
            copy(e) {
                return xa.prototype.copy.call(this, e), this.object = e.object, this
            }
        }
        const Ed = new ge;
        let Fs, wu;
        class Sd extends xa {
            constructor(e = 1) {
                const r = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
                    h = new an;
                h.setAttribute("position", new Ai(r, 3)), h.setAttribute("color", new Ai([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), super(h, new Xr({
                    vertexColors: !0,
                    toneMapped: !1
                })), this.type = "AxesHelper"
            }
        }
        const Ad = new Float32Array(1),
            op = new Int32Array(Ad.buffer),
            Rp = {
                toHalfFloat: function(s) {
                    Ad[0] = s;
                    const e = op[0];
                    let r = e >> 16 & 32768,
                        h = e >> 12 & 2047;
                    const c = e >> 23 & 255;
                    return c < 103 ? r : c > 142 ? (r |= 31744, r |= (c == 255 ? 0 : 1) && 8388607 & e, r) : c < 113 ? (h |= 2048, r |= (h >> 114 - c) + (h >> 113 - c & 1), r) : (r |= c - 112 << 10 | h >> 1, r += 1 & h, r)
                }
            },
            eo = Math.pow(2, 8),
            Td = [.125, .215, .35, .446, .526, .582],
            kl = 5 + Td.length,
            Lh = 20,
            ns = {
                3e3: 0,
                3001: 1,
                3002: 2,
                3004: 3,
                3005: 4,
                3006: 5,
                3007: 6
            },
            rl = new Gi({
                side: 1,
                depthWrite: !1,
                depthTest: !1
            }),
            Eu = new ar(new sr, rl),
            Rc = new _h,
            {
                _lodPlanes: al,
                _sizeLods: lp,
                _sigmas: Su
            } = up(),
            cp = new Rt;
        let Md = null;
        const ds = (1 + Math.sqrt(5)) / 2,
            Wr = 1 / ds,
            To = [new ge(1, 1, 1), new ge(-1, 1, 1), new ge(1, 1, -1), new ge(-1, 1, -1), new ge(0, ds, Wr), new ge(0, ds, -Wr), new ge(Wr, 0, ds), new ge(-Wr, 0, ds), new ge(ds, Wr, 0), new ge(-ds, Wr, 0)];

        function Au(s) {
            const e = Math.max(s.r, s.g, s.b),
                r = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127);
            return s.multiplyScalar(Math.pow(2, -r)), (r + 128) / 255
        }

        function hp(s) {
            return s !== void 0 && s.type === 1009 && (s.encoding === 3e3 || s.encoding === 3001 || s.encoding === 3007)
        }

        function up() {
            const s = [],
                e = [],
                r = [];
            let h = 8;
            for (let c = 0; c < kl; c++) {
                const v = Math.pow(2, h);
                e.push(v);
                let w = 1 / v;
                c > 4 ? w = Td[c - 8 + 4 - 1] : c == 0 && (w = 0), r.push(w);
                const E = 1 / (v - 1),
                    T = -E / 2,
                    B = 1 + E / 2,
                    Q = [T, T, B, T, B, B, T, T, B, B, T, B],
                    k = 6,
                    i = 6,
                    t = 3,
                    a = 2,
                    l = 1,
                    d = new Float32Array(t * i * k),
                    g = new Float32Array(a * i * k),
                    x = new Float32Array(l * i * k);
                for (let M = 0; M < k; M++) {
                    const F = M % 3 * 2 / 3 - 1,
                        D = M > 2 ? 0 : -1,
                        U = [F, D, 0, F + 2 / 3, D, 0, F + 2 / 3, D + 1, 0, F, D, 0, F + 2 / 3, D + 1, 0, F, D + 1, 0];
                    d.set(U, t * i * M), g.set(Q, a * i * M);
                    const N = [M, M, M, M, M, M];
                    x.set(N, l * i * M)
                }
                const A = new an;
                A.setAttribute("position", new pi(d, t)), A.setAttribute("uv", new pi(g, a)), A.setAttribute("faceIndex", new pi(x, l)), s.push(A), h > 4 && h--
            }
            return {
                _lodPlanes: s,
                _sizeLods: e,
                _sigmas: r
            }
        }

        function Tu(s) {
            const e = new qi(3 * eo, 3 * eo, s);
            return e.texture.mapping = 306, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e
        }

        function Mu(s, e, r, h, c) {
            s.viewport.set(e, r, h, c), s.scissor.set(e, r, h, c)
        }

        function Cd() {
            const s = new Ht(1, 1);
            return new Xs({
                name: "EquirectangularToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    texelSize: {
                        value: s
                    },
                    inputEncoding: {
                        value: ns[3e3]
                    },
                    outputEncoding: {
                        value: ns[3e3]
                    }
                },
                vertexShader: Rd(),
                fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${Cu()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function Bd() {
            return new Xs({
                name: "CubemapToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    inputEncoding: {
                        value: ns[3e3]
                    },
                    outputEncoding: {
                        value: ns[3e3]
                    }
                },
                vertexShader: Rd(),
                fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${Cu()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function Rd() {
            return `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
        }

        function Cu() {
            return `

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`
        }
        Qa.create = function(s, e) {
            return console.log("THREE.Curve.create() has been deprecated"), s.prototype = Object.create(Qa.prototype), s.prototype.constructor = s, s.prototype.getPoint = e, s
        }, yh.prototype.fromPoints = function(s) {
            return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(s)
        }, Ja.prototype.setColors = function() {
            console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
        }, xu.prototype.update = function() {
            console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
        }, _r.prototype.extractUrlBase = function(s) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Ko.extractUrlBase(s)
        }, _r.Handlers = {
            add: function() {
                console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
            },
            get: function() {
                console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
            }
        }, Tc.prototype.center = function(s) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(s)
        }, Tc.prototype.empty = function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        }, Tc.prototype.isIntersectionBox = function(s) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(s)
        }, Tc.prototype.size = function(s) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(s)
        }, Te.prototype.center = function(s) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(s)
        }, Te.prototype.empty = function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        }, Te.prototype.isIntersectionBox = function(s) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(s)
        }, Te.prototype.isIntersectionSphere = function(s) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(s)
        }, Te.prototype.size = function(s) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(s)
        }, Fn.prototype.empty = function() {
            return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        }, Us.prototype.setFromMatrix = function(s) {
            return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(s)
        }, So.prototype.center = function(s) {
            return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(s)
        }, Mi.random16 = function() {
            return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
        }, Mi.nearestPowerOfTwo = function(s) {
            return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Mi.floorPowerOfTwo(s)
        }, Mi.nextPowerOfTwo = function(s) {
            return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Mi.ceilPowerOfTwo(s)
        }, Pt.prototype.flattenToArrayOffset = function(s, e) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(s, e)
        }, Pt.prototype.multiplyVector3 = function(s) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), s.applyMatrix3(this)
        }, Pt.prototype.multiplyVector3Array = function() {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        }, Pt.prototype.applyToBufferAttribute = function(s) {
            return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), s.applyMatrix3(this)
        }, Pt.prototype.applyToVector3Array = function() {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }, Pt.prototype.getInverse = function(s) {
            return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(s).invert()
        }, Ui.prototype.extractPosition = function(s) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(s)
        }, Ui.prototype.flattenToArrayOffset = function(s, e) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(s, e)
        }, Ui.prototype.getPosition = function() {
            return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), new ge().setFromMatrixColumn(this, 3)
        }, Ui.prototype.setRotationFromQuaternion = function(s) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(s)
        }, Ui.prototype.multiplyToArray = function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        }, Ui.prototype.multiplyVector3 = function(s) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), s.applyMatrix4(this)
        }, Ui.prototype.multiplyVector4 = function(s) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), s.applyMatrix4(this)
        }, Ui.prototype.multiplyVector3Array = function() {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        }, Ui.prototype.rotateAxis = function(s) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), s.transformDirection(this)
        }, Ui.prototype.crossVector = function(s) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), s.applyMatrix4(this)
        }, Ui.prototype.translate = function() {
            console.error("THREE.Matrix4: .translate() has been removed.")
        }, Ui.prototype.rotateX = function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        }, Ui.prototype.rotateY = function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        }, Ui.prototype.rotateZ = function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        }, Ui.prototype.rotateByAxis = function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        }, Ui.prototype.applyToBufferAttribute = function(s) {
            return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), s.applyMatrix4(this)
        }, Ui.prototype.applyToVector3Array = function() {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        }, Ui.prototype.makeFrustum = function(s, e, r, h, c, v) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(s, e, h, r, c, v)
        }, Ui.prototype.getInverse = function(s) {
            return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(s).invert()
        }, Et.prototype.isIntersectionLine = function(s) {
            return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(s)
        }, Bn.prototype.multiplyVector3 = function(s) {
            return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), s.applyQuaternion(this)
        }, Bn.prototype.inverse = function() {
            return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert()
        }, wr.prototype.isIntersectionBox = function(s) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(s)
        }, wr.prototype.isIntersectionPlane = function(s) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(s)
        }, wr.prototype.isIntersectionSphere = function(s) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(s)
        }, Mt.prototype.area = function() {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
        }, Mt.prototype.barycoordFromPoint = function(s, e) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(s, e)
        }, Mt.prototype.midpoint = function(s) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(s)
        }, Mt.prototypenormal = function(s) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(s)
        }, Mt.prototype.plane = function(s) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(s)
        }, Mt.barycoordFromPoint = function(s, e, r, h, c) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Mt.getBarycoord(s, e, r, h, c)
        }, Mt.normal = function(s, e, r, h) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Mt.getNormal(s, e, r, h)
        }, us.prototype.extractAllPoints = function(s) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(s)
        }, us.prototype.extrude = function(s) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new bo(this, s)
        }, us.prototype.makeGeometry = function(s) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Zo(this, s)
        }, Ht.prototype.fromAttribute = function(s, e, r) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(s, e, r)
        }, Ht.prototype.distanceToManhattan = function(s) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(s)
        }, Ht.prototype.lengthManhattan = function() {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }, ge.prototype.setEulerFromRotationMatrix = function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        }, ge.prototype.setEulerFromQuaternion = function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        }, ge.prototype.getPositionFromMatrix = function(s) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(s)
        }, ge.prototype.getScaleFromMatrix = function(s) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(s)
        }, ge.prototype.getColumnFromMatrix = function(s, e) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, s)
        }, ge.prototype.applyProjection = function(s) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(s)
        }, ge.prototype.fromAttribute = function(s, e, r) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(s, e, r)
        }, ge.prototype.distanceToManhattan = function(s) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(s)
        }, ge.prototype.lengthManhattan = function() {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }, Si.prototype.fromAttribute = function(s, e, r) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(s, e, r)
        }, Si.prototype.lengthManhattan = function() {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }, Z.prototype.getChildByName = function(s) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(s)
        }, Z.prototype.renderDepth = function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        }, Z.prototype.translate = function(s, e) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, s)
        }, Z.prototype.getWorldRotation = function() {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        }, Z.prototype.applyMatrix = function(s) {
            return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(s)
        }, Object.defineProperties(Z.prototype, {
            eulerOrder: {
                get: function() {
                    return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                },
                set: function(s) {
                    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = s
                }
            },
            useQuaternion: {
                get: function() {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                },
                set: function() {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                }
            }
        }), ar.prototype.setDrawMode = function() {
            console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
        }, Object.defineProperties(ar.prototype, {
            drawMode: {
                get: function() {
                    return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
                },
                set: function() {
                    console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                }
            }
        }), Mr.prototype.initBones = function() {
            console.error("THREE.SkinnedMesh: initBones() has been removed.")
        }, Object.defineProperty(Qa.prototype, "__arcLengthDivisions", {
            get: function() {
                return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
            },
            set: function(s) {
                console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = s
            }
        }), dr.prototype.setLens = function(s, e) {
            console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), e !== void 0 && (this.filmGauge = e), this.setFocalLength(s)
        }, Object.defineProperties(Xn.prototype, {
            onlyShadow: {
                set: function() {
                    console.warn("THREE.Light: .onlyShadow has been removed.")
                }
            },
            shadowCameraFov: {
                set: function(s) {
                    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = s
                }
            },
            shadowCameraLeft: {
                set: function(s) {
                    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = s
                }
            },
            shadowCameraRight: {
                set: function(s) {
                    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = s
                }
            },
            shadowCameraTop: {
                set: function(s) {
                    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = s
                }
            },
            shadowCameraBottom: {
                set: function(s) {
                    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = s
                }
            },
            shadowCameraNear: {
                set: function(s) {
                    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = s
                }
            },
            shadowCameraFar: {
                set: function(s) {
                    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = s
                }
            },
            shadowCameraVisible: {
                set: function() {
                    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                }
            },
            shadowBias: {
                set: function(s) {
                    console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = s
                }
            },
            shadowDarkness: {
                set: function() {
                    console.warn("THREE.Light: .shadowDarkness has been removed.")
                }
            },
            shadowMapWidth: {
                set: function(s) {
                    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = s
                }
            },
            shadowMapHeight: {
                set: function(s) {
                    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = s
                }
            }
        }), Object.defineProperties(pi.prototype, {
            length: {
                get: function() {
                    return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                }
            },
            dynamic: {
                get: function() {
                    return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === 35048
                },
                set: function() {
                    console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(35048)
                }
            }
        }), pi.prototype.setDynamic = function(s) {
            return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(s === !0 ? 35048 : 35044), this
        }, pi.prototype.copyIndicesArray = function() {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        }, pi.prototype.setArray = function() {
            console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }, an.prototype.addIndex = function(s) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(s)
        }, an.prototype.addAttribute = function(s, e) {
            return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? s === "index" ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(s, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(s, new pi(arguments[1], arguments[2])))
        }, an.prototype.addDrawCall = function(s, e, r) {
            r !== void 0 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(s, e)
        }, an.prototype.clearDrawCalls = function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
        }, an.prototype.computeOffsets = function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }, an.prototype.removeAttribute = function(s) {
            return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(s)
        }, an.prototype.applyMatrix = function(s) {
            return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(s)
        }, Object.defineProperties(an.prototype, {
            drawcalls: {
                get: function() {
                    return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                }
            },
            offsets: {
                get: function() {
                    return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                }
            }
        }), Object.defineProperties(bc.prototype, {
            maxInstancedCount: {
                get: function() {
                    return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount
                },
                set: function(s) {
                    console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount = s
                }
            }
        }), Object.defineProperties(yd.prototype, {
            linePrecision: {
                get: function() {
                    return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold
                },
                set: function(s) {
                    console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold = s
                }
            }
        }), Object.defineProperties(St.prototype, {
            dynamic: {
                get: function() {
                    return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.usage === 35048
                },
                set: function(s) {
                    console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(s)
                }
            }
        }), St.prototype.setDynamic = function(s) {
            return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(s === !0 ? 35048 : 35044), this
        }, St.prototype.setArray = function() {
            console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }, bo.prototype.getArrays = function() {
            console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
        }, bo.prototype.addShapeList = function() {
            console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
        }, bo.prototype.addShape = function() {
            console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
        }, ut.prototype.dispose = function() {
            console.error("THREE.Scene: .dispose() has been removed.")
        }, Pl.prototype.onUpdate = function() {
            return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
        }, Object.defineProperties(ti.prototype, {
            wrapAround: {
                get: function() {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                },
                set: function() {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                }
            },
            overdraw: {
                get: function() {
                    console.warn("THREE.Material: .overdraw has been removed.")
                },
                set: function() {
                    console.warn("THREE.Material: .overdraw has been removed.")
                }
            },
            wrapRGB: {
                get: function() {
                    return console.warn("THREE.Material: .wrapRGB has been removed."), new Rt
                }
            },
            shading: {
                get: function() {
                    console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                },
                set: function(s) {
                    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = s === 1
                }
            },
            stencilMask: {
                get: function() {
                    return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
                },
                set: function(s) {
                    console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = s
                }
            }
        }), Object.defineProperties(Ys.prototype, {
            transparency: {
                get: function() {
                    return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission
                },
                set: function(s) {
                    console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission = s
                }
            }
        }), Object.defineProperties(Cn.prototype, {
            derivatives: {
                get: function() {
                    return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                },
                set: function(s) {
                    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = s
                }
            }
        }), we.prototype.clearTarget = function(s, e, r, h) {
            console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(s), this.clear(e, r, h)
        }, we.prototype.animate = function(s) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(s)
        }, we.prototype.getCurrentRenderTarget = function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
        }, we.prototype.getMaxAnisotropy = function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
        }, we.prototype.getPrecision = function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
        }, we.prototype.resetGLState = function() {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
        }, we.prototype.supportsFloatTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
        }, we.prototype.supportsHalfFloatTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
        }, we.prototype.supportsStandardDerivatives = function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
        }, we.prototype.supportsCompressedTextureS3TC = function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
        }, we.prototype.supportsCompressedTexturePVRTC = function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
        }, we.prototype.supportsBlendMinMax = function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
        }, we.prototype.supportsVertexTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
        }, we.prototype.supportsInstancedArrays = function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
        }, we.prototype.enableScissorTest = function(s) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(s)
        }, we.prototype.initMaterial = function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        }, we.prototype.addPrePlugin = function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        }, we.prototype.addPostPlugin = function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        }, we.prototype.updateShadowMap = function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        }, we.prototype.setFaceCulling = function() {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        }, we.prototype.allocTextureUnit = function() {
            console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
        }, we.prototype.setTexture = function() {
            console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
        }, we.prototype.setTexture2D = function() {
            console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
        }, we.prototype.setTextureCube = function() {
            console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
        }, we.prototype.getActiveMipMapLevel = function() {
            return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
        }, Object.defineProperties(we.prototype, {
            shadowMapEnabled: {
                get: function() {
                    return this.shadowMap.enabled
                },
                set: function(s) {
                    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = s
                }
            },
            shadowMapType: {
                get: function() {
                    return this.shadowMap.type
                },
                set: function(s) {
                    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = s
                }
            },
            shadowMapCullFace: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                }
            },
            context: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
                }
            },
            vr: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
                }
            },
            gammaInput: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
                }
            },
            gammaOutput: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
                },
                set: function(s) {
                    console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = s === !0 ? 3001 : 3e3
                }
            },
            toneMappingWhitePoint: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
                }
            }
        }), Object.defineProperties(P.prototype, {
            cullFace: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                }
            },
            renderReverseSided: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                }
            },
            renderSingleSided: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                }
            }
        }), Object.defineProperties(qi.prototype, {
            wrapS: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                },
                set: function(s) {
                    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = s
                }
            },
            wrapT: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                },
                set: function(s) {
                    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = s
                }
            },
            magFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                },
                set: function(s) {
                    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = s
                }
            },
            minFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                },
                set: function(s) {
                    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = s
                }
            },
            anisotropy: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                },
                set: function(s) {
                    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = s
                }
            },
            offset: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                },
                set: function(s) {
                    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = s
                }
            },
            repeat: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                },
                set: function(s) {
                    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = s
                }
            },
            format: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                },
                set: function(s) {
                    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = s
                }
            },
            type: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                },
                set: function(s) {
                    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = s
                }
            },
            generateMipmaps: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                },
                set: function(s) {
                    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = s
                }
            }
        }), Ah.prototype.load = function(s) {
            console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
            const e = this;
            return new Ec().load(s, function(r) {
                e.setBuffer(r)
            }), this
        }, Ac.prototype.getData = function() {
            return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
        }, Lo.prototype.updateCubeMap = function(s, e) {
            return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(s, e)
        }, Lo.prototype.clear = function(s, e, r, h) {
            return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(s, e, r, h)
        }, ji.crossOrigin = void 0, ji.loadTexture = function(s, e, r, h) {
            console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
            const c = new $o;
            c.setCrossOrigin(this.crossOrigin);
            const v = c.load(s, r, void 0, h);
            return e && (v.mapping = e), v
        }, ji.loadTextureCube = function(s, e, r, h) {
            console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
            const c = new Jd;
            c.setCrossOrigin(this.crossOrigin);
            const v = c.load(s, r, void 0, h);
            return e && (v.mapping = e), v
        }, ji.loadCompressedTexture = function() {
            console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
        }, ji.loadCompressedTextureCube = function() {
            console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
        };
        const Fd = {
            createMultiMaterialObject: function() {
                console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
            },
            detach: function() {
                console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
            },
            attach: function() {
                console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
            }
        };
        typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
            detail: {
                revision: z
            }
        })), typeof window != "undefined" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = z), y.ACESFilmicToneMapping = 4, y.AddEquation = 100, y.AddOperation = 2, y.AdditiveAnimationBlendMode = 2501, y.AdditiveBlending = 2, y.AlphaFormat = 1021, y.AlwaysDepth = 1, y.AlwaysStencilFunc = 519, y.AmbientLight = rd, y.AmbientLightProbe = Ll, y.AnimationClip = dh, y.AnimationLoader = class extends _r {
            constructor(s) {
                super(s)
            }
            load(s, e, r, h) {
                const c = this,
                    v = new hs(this.manager);
                v.setPath(this.path), v.setRequestHeader(this.requestHeader), v.setWithCredentials(this.withCredentials), v.load(s, function(w) {
                    try {
                        e(c.parse(JSON.parse(w)))
                    } catch (E) {
                        h ? h(E) : console.error(E), c.manager.itemError(s)
                    }
                }, r, h)
            }
            parse(s) {
                const e = [];
                for (let r = 0; r < s.length; r++) {
                    const h = dh.parse(s[r]);
                    e.push(h)
                }
                return e
            }
        }, y.AnimationMixer = md, y.AnimationObjectGroup = pd, y.AnimationUtils = Br, y.ArcCurve = Ju, y.ArrayCamera = ee, y.ArrowHelper = class extends Z {
            constructor(s = new ge(0, 0, 1), e = new ge(0, 0, 0), r = 1, h = 16776960, c = .2 * r, v = .2 * c) {
                super(), this.type = "ArrowHelper", Fs === void 0 && (Fs = new an, Fs.setAttribute("position", new Ai([0, 0, 0, 0, 1, 0], 3)), wu = new ta(0, .5, 1, 5, 1), wu.translate(0, -.5, 0)), this.position.copy(e), this.line = new za(Fs, new Xr({
                    color: h,
                    toneMapped: !1
                })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new ar(wu, new Gi({
                    color: h,
                    toneMapped: !1
                })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(s), this.setLength(r, c, v)
            }
            setDirection(s) {
                if (s.y > .99999) this.quaternion.set(0, 0, 0, 1);
                else if (s.y < -.99999) this.quaternion.set(1, 0, 0, 0);
                else {
                    Ed.set(s.z, 0, -s.x).normalize();
                    const e = Math.acos(s.y);
                    this.quaternion.setFromAxisAngle(Ed, e)
                }
            }
            setLength(s, e = .2 * s, r = .2 * e) {
                this.line.scale.set(1, Math.max(1e-4, s - e), 1), this.line.updateMatrix(), this.cone.scale.set(r, e, r), this.cone.position.y = s, this.cone.updateMatrix()
            }
            setColor(s) {
                this.line.material.color.set(s), this.cone.material.color.set(s)
            }
            copy(s) {
                return super.copy(s, !1), this.line.copy(s.line), this.cone.copy(s.cone), this
            }
        }, y.Audio = Ah, y.AudioAnalyser = Ac, y.AudioContext = Ks, y.AudioListener = class extends Z {
            constructor() {
                super(), this.type = "AudioListener", this.context = Ks.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new $d
            }
            getInput() {
                return this.gain
            }
            removeFilter() {
                return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
            }
            getFilter() {
                return this.filter
            }
            setFilter(s) {
                return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = s, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
            }
            getMasterVolume() {
                return this.gain.gain.value
            }
            setMasterVolume(s) {
                return this.gain.gain.setTargetAtTime(s, this.context.currentTime, .01), this
            }
            updateMatrixWorld(s) {
                super.updateMatrixWorld(s);
                const e = this.context.listener,
                    r = this.up;
                if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(el, Kd, ep), tl.set(0, 0, -1).applyQuaternion(Kd), e.positionX) {
                    const h = this.context.currentTime + this.timeDelta;
                    e.positionX.linearRampToValueAtTime(el.x, h), e.positionY.linearRampToValueAtTime(el.y, h), e.positionZ.linearRampToValueAtTime(el.z, h), e.forwardX.linearRampToValueAtTime(tl.x, h), e.forwardY.linearRampToValueAtTime(tl.y, h), e.forwardZ.linearRampToValueAtTime(tl.z, h), e.upX.linearRampToValueAtTime(r.x, h), e.upY.linearRampToValueAtTime(r.y, h), e.upZ.linearRampToValueAtTime(r.z, h)
                } else e.setPosition(el.x, el.y, el.z), e.setOrientation(tl.x, tl.y, tl.z, r.x, r.y, r.z)
            }
        }, y.AudioLoader = Ec, y.AxesHelper = Sd, y.AxisHelper = function(s) {
            return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Sd(s)
        }, y.BackSide = 1, y.BasicDepthPacking = 3200, y.BasicShadowMap = 0, y.BinaryTextureLoader = function(s) {
            return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new au(s)
        }, y.Bone = pr, y.BooleanKeyframeTrack = jo, y.BoundingBoxHelper = function(s, e) {
            return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new sp(s, e)
        }, y.Box2 = Tc, y.Box3 = Te, y.Box3Helper = class extends xa {
            constructor(s, e = 16776960) {
                const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    h = new an;
                h.setIndex(new pi(r, 1)), h.setAttribute("position", new Ai([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(h, new Xr({
                    color: e,
                    toneMapped: !1
                })), this.box = s, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
            }
            updateMatrixWorld(s) {
                const e = this.box;
                e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(s))
            }
        }, y.BoxBufferGeometry = sr, y.BoxGeometry = sr, y.BoxHelper = sp, y.BufferAttribute = pi, y.BufferGeometry = an, y.BufferGeometryLoader = mu, y.ByteType = 1010, y.Cache = Fl, y.Camera = Dn, y.CameraHelper = class extends xa {
            constructor(s) {
                const e = new an,
                    r = new Xr({
                        color: 16777215,
                        vertexColors: !0,
                        toneMapped: !1
                    }),
                    h = [],
                    c = [],
                    v = {},
                    w = new Rt(16755200),
                    E = new Rt(16711680),
                    T = new Rt(43775),
                    B = new Rt(16777215),
                    Q = new Rt(3355443);

                function k(t, a, l) {
                    i(t, l), i(a, l)
                }

                function i(t, a) {
                    h.push(0, 0, 0), c.push(a.r, a.g, a.b), v[t] === void 0 && (v[t] = []), v[t].push(h.length / 3 - 1)
                }
                k("n1", "n2", w), k("n2", "n4", w), k("n4", "n3", w), k("n3", "n1", w), k("f1", "f2", w), k("f2", "f4", w), k("f4", "f3", w), k("f3", "f1", w), k("n1", "f1", w), k("n2", "f2", w), k("n3", "f3", w), k("n4", "f4", w), k("p", "n1", E), k("p", "n2", E), k("p", "n3", E), k("p", "n4", E), k("u1", "u2", T), k("u2", "u3", T), k("u3", "u1", T), k("c", "t", B), k("p", "c", Q), k("cn1", "cn2", Q), k("cn3", "cn4", Q), k("cf1", "cf2", Q), k("cf3", "cf4", Q), e.setAttribute("position", new Ai(h, 3)), e.setAttribute("color", new Ai(c, 3)), super(e, r), this.type = "CameraHelper", this.camera = s, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = s.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = v, this.update()
            }
            update() {
                const s = this.geometry,
                    e = this.pointMap;
                Hr.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), jr("c", e, s, Hr, 0, 0, -1), jr("t", e, s, Hr, 0, 0, 1), jr("n1", e, s, Hr, -1, -1, -1), jr("n2", e, s, Hr, 1, -1, -1), jr("n3", e, s, Hr, -1, 1, -1), jr("n4", e, s, Hr, 1, 1, -1), jr("f1", e, s, Hr, -1, -1, 1), jr("f2", e, s, Hr, 1, -1, 1), jr("f3", e, s, Hr, -1, 1, 1), jr("f4", e, s, Hr, 1, 1, 1), jr("u1", e, s, Hr, .7, 1.1, -1), jr("u2", e, s, Hr, -.7, 1.1, -1), jr("u3", e, s, Hr, 0, 2, -1), jr("cf1", e, s, Hr, -1, 0, 1), jr("cf2", e, s, Hr, 1, 0, 1), jr("cf3", e, s, Hr, 0, -1, 1), jr("cf4", e, s, Hr, 0, 1, 1), jr("cn1", e, s, Hr, -1, 0, -1), jr("cn2", e, s, Hr, 1, 0, -1), jr("cn3", e, s, Hr, 0, -1, -1), jr("cn4", e, s, Hr, 0, 1, -1), s.getAttribute("position").needsUpdate = !0
            }
        }, y.CanvasRenderer = function() {
            console.error("THREE.CanvasRenderer has been removed")
        }, y.CanvasTexture = Du, y.CatmullRomCurve3 = mh, y.CineonToneMapping = 3, y.CircleBufferGeometry = Jh, y.CircleGeometry = Jh, y.ClampToEdgeWrapping = 1001, y.Clock = $d, y.Color = Rt, y.ColorKeyframeTrack = Yo, y.CompressedTexture = hc, y.CompressedTextureLoader = Wu, y.ConeBufferGeometry = _o, y.ConeGeometry = _o, y.CubeCamera = Lo, y.CubeReflectionMapping = 301, y.CubeRefractionMapping = 302, y.CubeTexture = ao, y.CubeTextureLoader = Jd, y.CubeUVReflectionMapping = 306, y.CubeUVRefractionMapping = 307, y.CubicBezierCurve = lu, y.CubicBezierCurve3 = xc, y.CubicInterpolant = iu, y.CullFaceBack = 1, y.CullFaceFront = 2, y.CullFaceFrontBack = 3, y.CullFaceNone = 0, y.Curve = Qa, y.CurvePath = Zd, y.CustomBlending = 5, y.CustomToneMapping = 5, y.CylinderBufferGeometry = ta, y.CylinderGeometry = ta, y.Cylindrical = class {
            constructor(s = 1, e = 0, r = 0) {
                return this.radius = s, this.theta = e, this.y = r, this
            }
            set(s, e, r) {
                return this.radius = s, this.theta = e, this.y = r, this
            }
            copy(s) {
                return this.radius = s.radius, this.theta = s.theta, this.y = s.y, this
            }
            setFromVector3(s) {
                return this.setFromCartesianCoords(s.x, s.y, s.z)
            }
            setFromCartesianCoords(s, e, r) {
                return this.radius = Math.sqrt(s * s + r * r), this.theta = Math.atan2(s, r), this.y = e, this
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }, y.DataTexture = ws, y.DataTexture2DArray = fl, y.DataTexture3D = ml, y.DataTextureLoader = au, y.DataUtils = Rp, y.DecrementStencilOp = 7683, y.DecrementWrapStencilOp = 34056, y.DefaultLoadingManager = ru, y.DepthFormat = 1026, y.DepthStencilFormat = 1027, y.DepthTexture = Uu, y.DirectionalLight = nd, y.DirectionalLightHelper = class extends Z {
            constructor(s, e, r) {
                super(), this.light = s, this.light.updateMatrixWorld(), this.matrix = s.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, e === void 0 && (e = 1);
                let h = new an;
                h.setAttribute("position", new Ai([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
                const c = new Xr({
                    fog: !1,
                    toneMapped: !1
                });
                this.lightPlane = new za(h, c), this.add(this.lightPlane), h = new an, h.setAttribute("position", new Ai([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new za(h, c), this.add(this.targetLine), this.update()
            }
            dispose() {
                this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
            }
            update() {
                Bc.setFromMatrixPosition(this.light.matrixWorld), Bh.setFromMatrixPosition(this.light.target.matrixWorld), wd.subVectors(Bh, Bc), this.lightPlane.lookAt(Bh), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Bh), this.targetLine.scale.z = wd.length()
            }
        }, y.DiscreteInterpolant = Cs, y.DodecahedronBufferGeometry = th, y.DodecahedronGeometry = th, y.DoubleSide = 2, y.DstAlphaFactor = 206, y.DstColorFactor = 208, y.DynamicBufferAttribute = function(s, e) {
            return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new pi(s, e).setUsage(35048)
        }, y.DynamicCopyUsage = 35050, y.DynamicDrawUsage = 35048, y.DynamicReadUsage = 35049, y.EdgesGeometry = jh, y.EdgesHelper = function(s, e) {
            return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new xa(new jh(s.geometry), new Xr({
                color: e !== void 0 ? e : 16777215
            }))
        }, y.EllipseCurve = fh, y.EqualDepth = 4, y.EqualStencilFunc = 514, y.EquirectangularReflectionMapping = 303, y.EquirectangularRefractionMapping = 304, y.Euler = gr, y.EventDispatcher = yn, y.ExtrudeBufferGeometry = bo, y.ExtrudeGeometry = bo, y.FaceColors = 1, y.FileLoader = hs, y.FlatShading = 1, y.Float16BufferAttribute = aa, y.Float32Attribute = function(s, e) {
            return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Ai(s, e)
        }, y.Float32BufferAttribute = Ai, y.Float64Attribute = function(s, e) {
            return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new ca(s, e)
        }, y.Float64BufferAttribute = ca, y.FloatType = 1015, y.Fog = ze, y.FogExp2 = bt, y.Font = Ma, y.FontLoader = class extends _r {
            constructor(s) {
                super(s)
            }
            load(s, e, r, h) {
                const c = this,
                    v = new hs(this.manager);
                v.setPath(this.path), v.setRequestHeader(this.requestHeader), v.setWithCredentials(c.withCredentials), v.load(s, function(w) {
                    let E;
                    try {
                        E = JSON.parse(w)
                    } catch (B) {
                        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), E = JSON.parse(w.substring(65, w.length - 2))
                    }
                    const T = c.parse(E);
                    e && e(T)
                }, r, h)
            }
            parse(s) {
                return new Ma(s)
            }
        }, y.FrontSide = 0, y.Frustum = Us, y.GLBufferAttribute = gd, y.GLSL1 = "100", y.GLSL3 = sn, y.GammaEncoding = 3007, y.GreaterDepth = 6, y.GreaterEqualDepth = 5, y.GreaterEqualStencilFunc = 518, y.GreaterStencilFunc = 516, y.GridHelper = Ja, y.Group = pe, y.HalfFloatType = 1016, y.HemisphereLight = du, y.HemisphereLightHelper = class extends Z {
            constructor(s, e, r) {
                super(), this.light = s, this.light.updateMatrixWorld(), this.matrix = s.matrixWorld, this.matrixAutoUpdate = !1, this.color = r;
                const h = new Wo(e);
                h.rotateY(.5 * Math.PI), this.material = new Gi({
                    wireframe: !0,
                    fog: !1,
                    toneMapped: !1
                }), this.color === void 0 && (this.material.vertexColors = !0);
                const c = h.getAttribute("position"),
                    v = new Float32Array(3 * c.count);
                h.setAttribute("color", new pi(v, 3)), this.add(new ar(h, this.material)), this.update()
            }
            dispose() {
                this.children[0].geometry.dispose(), this.children[0].material.dispose()
            }
            update() {
                const s = this.children[0];
                if (this.color !== void 0) this.material.color.set(this.color);
                else {
                    const e = s.geometry.getAttribute("color");
                    bu.copy(this.light.color), bd.copy(this.light.groundColor);
                    for (let r = 0, h = e.count; r < h; r++) {
                        const c = r < h / 2 ? bu : bd;
                        e.setXYZ(r, c.r, c.g, c.b)
                    }
                    e.needsUpdate = !0
                }
                s.lookAt(ap.setFromMatrixPosition(this.light.matrixWorld).negate())
            }
        }, y.HemisphereLightProbe = Sc, y.IcosahedronBufferGeometry = qh, y.IcosahedronGeometry = qh, y.ImageBitmapLoader = gu, y.ImageLoader = ph, y.ImageUtils = ji, y.ImmediateRenderObject = Cc, y.IncrementStencilOp = 7682, y.IncrementWrapStencilOp = 34055, y.InstancedBufferAttribute = wc, y.InstancedBufferGeometry = bc, y.InstancedInterleavedBuffer = vu, y.InstancedMesh = fr, y.Int16Attribute = function(s, e) {
            return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new Xi(s, e)
        }, y.Int16BufferAttribute = Xi, y.Int32Attribute = function(s, e) {
            return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new lr(s, e)
        }, y.Int32BufferAttribute = lr, y.Int8Attribute = function(s, e) {
            return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new Hi(s, e)
        }, y.Int8BufferAttribute = Hi, y.IntType = 1013, y.InterleavedBuffer = St, y.InterleavedBufferAttribute = Vt, y.Interpolant = ts, y.InterpolateDiscrete = 2300, y.InterpolateLinear = 2301, y.InterpolateSmooth = 2302, y.InvertStencilOp = 5386, y.JSONLoader = function() {
            console.error("THREE.JSONLoader has been removed.")
        }, y.KeepStencilOp = 7680, y.KeyframeTrack = Bs, y.LOD = pa, y.LatheBufferGeometry = vr, y.LatheGeometry = vr, y.Layers = Jr, y.LensFlare = function() {
            console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")
        }, y.LessDepth = 2, y.LessEqualDepth = 3, y.LessEqualStencilFunc = 515, y.LessStencilFunc = 513, y.Light = Xn, y.LightProbe = xh, y.Line = za, y.Line3 = So, y.LineBasicMaterial = Xr, y.LineCurve = gh, y.LineCurve3 = qu, y.LineDashedMaterial = tu, y.LineLoop = yo, y.LinePieces = 1, y.LineSegments = xa, y.LineStrip = 0, y.LinearEncoding = 3e3, y.LinearFilter = 1006, y.LinearInterpolant = hh, y.LinearMipMapLinearFilter = 1008, y.LinearMipMapNearestFilter = 1007, y.LinearMipmapLinearFilter = 1008, y.LinearMipmapNearestFilter = 1007, y.LinearToneMapping = 1, y.Loader = _r, y.LoaderUtils = Ko, y.LoadingManager = Hu, y.LogLuvEncoding = 3003, y.LoopOnce = 2200, y.LoopPingPong = 2202, y.LoopRepeat = 2201, y.LuminanceAlphaFormat = 1025, y.LuminanceFormat = 1024, y.MOUSE = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2
        }, y.Material = ti, y.MaterialLoader = bh, y.Math = Mi, y.MathUtils = Mi, y.Matrix3 = Pt, y.Matrix4 = Ui, y.MaxEquation = 104, y.Mesh = ar, y.MeshBasicMaterial = Gi, y.MeshDepthMaterial = S, y.MeshDistanceMaterial = L, y.MeshFaceMaterial = function(s) {
            return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), s
        }, y.MeshLambertMaterial = ch, y.MeshMatcapMaterial = eu, y.MeshNormalMaterial = lh, y.MeshPhongMaterial = Gu, y.MeshPhysicalMaterial = Ys, y.MeshStandardMaterial = js, y.MeshToonMaterial = oh, y.MinEquation = 103, y.MirroredRepeatWrapping = 1002, y.MixOperation = 1, y.MultiMaterial = function(s = []) {
            return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), s.isMultiMaterial = !0, s.materials = s, s.clone = function() {
                return s.slice()
            }, s
        }, y.MultiplyBlending = 4, y.MultiplyOperation = 0, y.NearestFilter = 1003, y.NearestMipMapLinearFilter = 1005, y.NearestMipMapNearestFilter = 1004, y.NearestMipmapLinearFilter = 1005, y.NearestMipmapNearestFilter = 1004, y.NeverDepth = 0, y.NeverStencilFunc = 512, y.NoBlending = 0, y.NoColors = 0, y.NoToneMapping = 0, y.NormalAnimationBlendMode = 2500, y.NormalBlending = 1, y.NotEqualDepth = 7, y.NotEqualStencilFunc = 517, y.NumberKeyframeTrack = uh, y.Object3D = Z, y.ObjectLoader = class extends _r {
            constructor(s) {
                super(s)
            }
            load(s, e, r, h) {
                const c = this,
                    v = this.path === "" ? Ko.extractUrlBase(s) : this.path;
                this.resourcePath = this.resourcePath || v;
                const w = new hs(this.manager);
                w.setPath(this.path), w.setRequestHeader(this.requestHeader), w.setWithCredentials(this.withCredentials), w.load(s, function(E) {
                    let T = null;
                    try {
                        T = JSON.parse(E)
                    } catch (Q) {
                        return h !== void 0 && h(Q), void console.error("THREE:ObjectLoader: Can't parse " + s + ".", Q.message)
                    }
                    const B = T.metadata;
                    B !== void 0 && B.type !== void 0 && B.type.toLowerCase() !== "geometry" ? c.parse(T, e) : console.error("THREE.ObjectLoader: Can't load " + s)
                }, r, h)
            }
            parse(s, e) {
                const r = this.parseAnimations(s.animations),
                    h = this.parseShapes(s.shapes),
                    c = this.parseGeometries(s.geometries, h),
                    v = this.parseImages(s.images, function() {
                        e !== void 0 && e(T)
                    }),
                    w = this.parseTextures(s.textures, v),
                    E = this.parseMaterials(s.materials, w),
                    T = this.parseObject(s.object, c, E, r),
                    B = this.parseSkeletons(s.skeletons, T);
                if (this.bindSkeletons(T, B), e !== void 0) {
                    let Q = !1;
                    for (const k in v)
                        if (v[k] instanceof HTMLImageElement) {
                            Q = !0;
                            break
                        } Q === !1 && e(T)
                }
                return T
            }
            parseShapes(s) {
                const e = {};
                if (s !== void 0)
                    for (let r = 0, h = s.length; r < h; r++) {
                        const c = new us().fromJSON(s[r]);
                        e[c.uuid] = c
                    }
                return e
            }
            parseSkeletons(s, e) {
                const r = {},
                    h = {};
                if (e.traverse(function(c) {
                        c.isBone && (h[c.uuid] = c)
                    }), s !== void 0)
                    for (let c = 0, v = s.length; c < v; c++) {
                        const w = new Zn().fromJSON(s[c], h);
                        r[w.uuid] = w
                    }
                return r
            }
            parseGeometries(s, e) {
                const r = {};
                let h;
                if (s !== void 0) {
                    const c = new mu;
                    for (let v = 0, w = s.length; v < w; v++) {
                        let E;
                        const T = s[v];
                        switch (T.type) {
                            case "PlaneGeometry":
                            case "PlaneBufferGeometry":
                                E = new Na[T.type](T.width, T.height, T.widthSegments, T.heightSegments);
                                break;
                            case "BoxGeometry":
                            case "BoxBufferGeometry":
                                E = new Na[T.type](T.width, T.height, T.depth, T.widthSegments, T.heightSegments, T.depthSegments);
                                break;
                            case "CircleGeometry":
                            case "CircleBufferGeometry":
                                E = new Na[T.type](T.radius, T.segments, T.thetaStart, T.thetaLength);
                                break;
                            case "CylinderGeometry":
                            case "CylinderBufferGeometry":
                                E = new Na[T.type](T.radiusTop, T.radiusBottom, T.height, T.radialSegments, T.heightSegments, T.openEnded, T.thetaStart, T.thetaLength);
                                break;
                            case "ConeGeometry":
                            case "ConeBufferGeometry":
                                E = new Na[T.type](T.radius, T.height, T.radialSegments, T.heightSegments, T.openEnded, T.thetaStart, T.thetaLength);
                                break;
                            case "SphereGeometry":
                            case "SphereBufferGeometry":
                                E = new Na[T.type](T.radius, T.widthSegments, T.heightSegments, T.phiStart, T.phiLength, T.thetaStart, T.thetaLength);
                                break;
                            case "DodecahedronGeometry":
                            case "DodecahedronBufferGeometry":
                            case "IcosahedronGeometry":
                            case "IcosahedronBufferGeometry":
                            case "OctahedronGeometry":
                            case "OctahedronBufferGeometry":
                            case "TetrahedronGeometry":
                            case "TetrahedronBufferGeometry":
                                E = new Na[T.type](T.radius, T.detail);
                                break;
                            case "RingGeometry":
                            case "RingBufferGeometry":
                                E = new Na[T.type](T.innerRadius, T.outerRadius, T.thetaSegments, T.phiSegments, T.thetaStart, T.thetaLength);
                                break;
                            case "TorusGeometry":
                            case "TorusBufferGeometry":
                                E = new Na[T.type](T.radius, T.tube, T.radialSegments, T.tubularSegments, T.arc);
                                break;
                            case "TorusKnotGeometry":
                            case "TorusKnotBufferGeometry":
                                E = new Na[T.type](T.radius, T.tube, T.tubularSegments, T.radialSegments, T.p, T.q);
                                break;
                            case "TubeGeometry":
                            case "TubeBufferGeometry":
                                E = new Na[T.type](new uu[T.path.type]().fromJSON(T.path), T.tubularSegments, T.radius, T.radialSegments, T.closed);
                                break;
                            case "LatheGeometry":
                            case "LatheBufferGeometry":
                                E = new Na[T.type](T.points, T.segments, T.phiStart, T.phiLength);
                                break;
                            case "PolyhedronGeometry":
                            case "PolyhedronBufferGeometry":
                                E = new Na[T.type](T.vertices, T.indices, T.radius, T.details);
                                break;
                            case "ShapeGeometry":
                            case "ShapeBufferGeometry":
                                h = [];
                                for (let Q = 0, k = T.shapes.length; Q < k; Q++) {
                                    const i = e[T.shapes[Q]];
                                    h.push(i)
                                }
                                E = new Na[T.type](h, T.curveSegments);
                                break;
                            case "ExtrudeGeometry":
                            case "ExtrudeBufferGeometry":
                                h = [];
                                for (let Q = 0, k = T.shapes.length; Q < k; Q++) {
                                    const i = e[T.shapes[Q]];
                                    h.push(i)
                                }
                                const B = T.options.extrudePath;
                                B !== void 0 && (T.options.extrudePath = new uu[B.type]().fromJSON(B)), E = new Na[T.type](h, T.options);
                                break;
                            case "BufferGeometry":
                            case "InstancedBufferGeometry":
                                E = c.parse(T);
                                break;
                            case "Geometry":
                                console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
                                break;
                            default:
                                console.warn('THREE.ObjectLoader: Unsupported geometry type "' + T.type + '"');
                                continue
                        }
                        E.uuid = T.uuid, T.name !== void 0 && (E.name = T.name), E.isBufferGeometry === !0 && T.userData !== void 0 && (E.userData = T.userData), r[T.uuid] = E
                    }
                }
                return r
            }
            parseMaterials(s, e) {
                const r = {},
                    h = {};
                if (s !== void 0) {
                    const c = new bh;
                    c.setTextures(e);
                    for (let v = 0, w = s.length; v < w; v++) {
                        const E = s[v];
                        if (E.type === "MultiMaterial") {
                            const T = [];
                            for (let B = 0; B < E.materials.length; B++) {
                                const Q = E.materials[B];
                                r[Q.uuid] === void 0 && (r[Q.uuid] = c.parse(Q)), T.push(r[Q.uuid])
                            }
                            h[E.uuid] = T
                        } else r[E.uuid] === void 0 && (r[E.uuid] = c.parse(E)), h[E.uuid] = r[E.uuid]
                    }
                }
                return h
            }
            parseAnimations(s) {
                const e = {};
                if (s !== void 0)
                    for (let r = 0; r < s.length; r++) {
                        const h = s[r],
                            c = dh.parse(h);
                        e[c.uuid] = c
                    }
                return e
            }
            parseImages(s, e) {
                const r = this,
                    h = {};
                let c;

                function v(w) {
                    if (typeof w == "string") {
                        const E = w;
                        return function(T) {
                            return r.manager.itemStart(T), c.load(T, function() {
                                r.manager.itemEnd(T)
                            }, void 0, function() {
                                r.manager.itemError(T), r.manager.itemEnd(T)
                            })
                        }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(E) ? E : r.resourcePath + E)
                    }
                    return w.data ? {
                        data: Er(w.type, w.data),
                        width: w.width,
                        height: w.height
                    } : null
                }
                if (s !== void 0 && s.length > 0) {
                    const w = new Hu(e);
                    c = new ph(w), c.setCrossOrigin(this.crossOrigin);
                    for (let E = 0, T = s.length; E < T; E++) {
                        const B = s[E],
                            Q = B.url;
                        if (Array.isArray(Q)) {
                            h[B.uuid] = [];
                            for (let k = 0, i = Q.length; k < i; k++) {
                                const t = v(Q[k]);
                                t !== null && (t instanceof HTMLImageElement ? h[B.uuid].push(t) : h[B.uuid].push(new ws(t.data, t.width, t.height)))
                            }
                        } else {
                            const k = v(B.url);
                            k !== null && (h[B.uuid] = k)
                        }
                    }
                }
                return h
            }
            parseTextures(s, e) {
                function r(c, v) {
                    return typeof c == "number" ? c : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", c), v[c])
                }
                const h = {};
                if (s !== void 0)
                    for (let c = 0, v = s.length; c < v; c++) {
                        const w = s[c];
                        let E;
                        w.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', w.uuid), e[w.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", w.image);
                        const T = e[w.image];
                        Array.isArray(T) ? (E = new ao(T), T.length === 6 && (E.needsUpdate = !0)) : (E = T && T.data ? new ws(T.data, T.width, T.height) : new cn(T), T && (E.needsUpdate = !0)), E.uuid = w.uuid, w.name !== void 0 && (E.name = w.name), w.mapping !== void 0 && (E.mapping = r(w.mapping, Ap)), w.offset !== void 0 && E.offset.fromArray(w.offset), w.repeat !== void 0 && E.repeat.fromArray(w.repeat), w.center !== void 0 && E.center.fromArray(w.center), w.rotation !== void 0 && (E.rotation = w.rotation), w.wrap !== void 0 && (E.wrapS = r(w.wrap[0], Yd), E.wrapT = r(w.wrap[1], Yd)), w.format !== void 0 && (E.format = w.format), w.type !== void 0 && (E.type = w.type), w.encoding !== void 0 && (E.encoding = w.encoding), w.minFilter !== void 0 && (E.minFilter = r(w.minFilter, qd)), w.magFilter !== void 0 && (E.magFilter = r(w.magFilter, qd)), w.anisotropy !== void 0 && (E.anisotropy = w.anisotropy), w.flipY !== void 0 && (E.flipY = w.flipY), w.premultiplyAlpha !== void 0 && (E.premultiplyAlpha = w.premultiplyAlpha), w.unpackAlignment !== void 0 && (E.unpackAlignment = w.unpackAlignment), h[w.uuid] = E
                    }
                return h
            }
            parseObject(s, e, r, h) {
                let c, v, w;

                function E(B) {
                    return e[B] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", B), e[B]
                }

                function T(B) {
                    if (B !== void 0) {
                        if (Array.isArray(B)) {
                            const Q = [];
                            for (let k = 0, i = B.length; k < i; k++) {
                                const t = B[k];
                                r[t] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", t), Q.push(r[t])
                            }
                            return Q
                        }
                        return r[B] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", B), r[B]
                    }
                }
                switch (s.type) {
                    case "Scene":
                        c = new ut, s.background !== void 0 && Number.isInteger(s.background) && (c.background = new Rt(s.background)), s.fog !== void 0 && (s.fog.type === "Fog" ? c.fog = new ze(s.fog.color, s.fog.near, s.fog.far) : s.fog.type === "FogExp2" && (c.fog = new bt(s.fog.color, s.fog.density)));
                        break;
                    case "PerspectiveCamera":
                        c = new dr(s.fov, s.aspect, s.near, s.far), s.focus !== void 0 && (c.focus = s.focus), s.zoom !== void 0 && (c.zoom = s.zoom), s.filmGauge !== void 0 && (c.filmGauge = s.filmGauge), s.filmOffset !== void 0 && (c.filmOffset = s.filmOffset), s.view !== void 0 && (c.view = Object.assign({}, s.view));
                        break;
                    case "OrthographicCamera":
                        c = new _h(s.left, s.right, s.top, s.bottom, s.near, s.far), s.zoom !== void 0 && (c.zoom = s.zoom), s.view !== void 0 && (c.view = Object.assign({}, s.view));
                        break;
                    case "AmbientLight":
                        c = new rd(s.color, s.intensity);
                        break;
                    case "DirectionalLight":
                        c = new nd(s.color, s.intensity);
                        break;
                    case "PointLight":
                        c = new id(s.color, s.intensity, s.distance, s.decay);
                        break;
                    case "RectAreaLight":
                        c = new ad(s.color, s.intensity, s.width, s.height);
                        break;
                    case "SpotLight":
                        c = new pu(s.color, s.intensity, s.distance, s.angle, s.penumbra, s.decay);
                        break;
                    case "HemisphereLight":
                        c = new du(s.color, s.groundColor, s.intensity);
                        break;
                    case "LightProbe":
                        c = new xh().fromJSON(s);
                        break;
                    case "SkinnedMesh":
                        v = E(s.geometry), w = T(s.material), c = new Mr(v, w), s.bindMode !== void 0 && (c.bindMode = s.bindMode), s.bindMatrix !== void 0 && c.bindMatrix.fromArray(s.bindMatrix), s.skeleton !== void 0 && (c.skeleton = s.skeleton);
                        break;
                    case "Mesh":
                        v = E(s.geometry), w = T(s.material), c = new ar(v, w);
                        break;
                    case "InstancedMesh":
                        v = E(s.geometry), w = T(s.material);
                        const B = s.count,
                            Q = s.instanceMatrix,
                            k = s.instanceColor;
                        c = new fr(v, w, B), c.instanceMatrix = new pi(new Float32Array(Q.array), 16), k !== void 0 && (c.instanceColor = new pi(new Float32Array(k.array), k.itemSize));
                        break;
                    case "LOD":
                        c = new pa;
                        break;
                    case "Line":
                        c = new za(E(s.geometry), T(s.material));
                        break;
                    case "LineLoop":
                        c = new yo(E(s.geometry), T(s.material));
                        break;
                    case "LineSegments":
                        c = new xa(E(s.geometry), T(s.material));
                        break;
                    case "PointCloud":
                    case "Points":
                        c = new lc(E(s.geometry), T(s.material));
                        break;
                    case "Sprite":
                        c = new sa(T(s.material));
                        break;
                    case "Group":
                        c = new pe;
                        break;
                    case "Bone":
                        c = new pr;
                        break;
                    default:
                        c = new Z
                }
                if (c.uuid = s.uuid, s.name !== void 0 && (c.name = s.name), s.matrix !== void 0 ? (c.matrix.fromArray(s.matrix), s.matrixAutoUpdate !== void 0 && (c.matrixAutoUpdate = s.matrixAutoUpdate), c.matrixAutoUpdate && c.matrix.decompose(c.position, c.quaternion, c.scale)) : (s.position !== void 0 && c.position.fromArray(s.position), s.rotation !== void 0 && c.rotation.fromArray(s.rotation), s.quaternion !== void 0 && c.quaternion.fromArray(s.quaternion), s.scale !== void 0 && c.scale.fromArray(s.scale)), s.castShadow !== void 0 && (c.castShadow = s.castShadow), s.receiveShadow !== void 0 && (c.receiveShadow = s.receiveShadow), s.shadow && (s.shadow.bias !== void 0 && (c.shadow.bias = s.shadow.bias), s.shadow.normalBias !== void 0 && (c.shadow.normalBias = s.shadow.normalBias), s.shadow.radius !== void 0 && (c.shadow.radius = s.shadow.radius), s.shadow.mapSize !== void 0 && c.shadow.mapSize.fromArray(s.shadow.mapSize), s.shadow.camera !== void 0 && (c.shadow.camera = this.parseObject(s.shadow.camera))), s.visible !== void 0 && (c.visible = s.visible), s.frustumCulled !== void 0 && (c.frustumCulled = s.frustumCulled), s.renderOrder !== void 0 && (c.renderOrder = s.renderOrder), s.userData !== void 0 && (c.userData = s.userData), s.layers !== void 0 && (c.layers.mask = s.layers), s.children !== void 0) {
                    const B = s.children;
                    for (let Q = 0; Q < B.length; Q++) c.add(this.parseObject(B[Q], e, r, h))
                }
                if (s.animations !== void 0) {
                    const B = s.animations;
                    for (let Q = 0; Q < B.length; Q++) {
                        const k = B[Q];
                        c.animations.push(h[k])
                    }
                }
                if (s.type === "LOD") {
                    s.autoUpdate !== void 0 && (c.autoUpdate = s.autoUpdate);
                    const B = s.levels;
                    for (let Q = 0; Q < B.length; Q++) {
                        const k = B[Q],
                            i = c.getObjectByProperty("uuid", k.object);
                        i !== void 0 && c.addLevel(i, k.distance)
                    }
                }
                return c
            }
            bindSkeletons(s, e) {
                Object.keys(e).length !== 0 && s.traverse(function(r) {
                    if (r.isSkinnedMesh === !0 && r.skeleton !== void 0) {
                        const h = e[r.skeleton];
                        h === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", r.skeleton) : r.bind(h, r.bindMatrix)
                    }
                })
            }
            setTexturePath(s) {
                return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(s)
            }
        }, y.ObjectSpaceNormalMap = 1, y.OctahedronBufferGeometry = Wo, y.OctahedronGeometry = Wo, y.OneFactor = 201, y.OneMinusDstAlphaFactor = 207, y.OneMinusDstColorFactor = 209, y.OneMinusSrcAlphaFactor = 205, y.OneMinusSrcColorFactor = 203, y.OrthographicCamera = _h, y.PCFShadowMap = 1, y.PCFSoftShadowMap = 2, y.PMREMGenerator = class {
            constructor(s) {
                this._renderer = s, this._pingPongRenderTarget = null, this._blurMaterial = function(e) {
                    const r = new Float32Array(e),
                        h = new ge(0, 1, 0);
                    return new Xs({
                        name: "SphericalGaussianBlur",
                        defines: {
                            n: e
                        },
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            samples: {
                                value: 1
                            },
                            weights: {
                                value: r
                            },
                            latitudinal: {
                                value: !1
                            },
                            dTheta: {
                                value: 0
                            },
                            mipInt: {
                                value: 0
                            },
                            poleAxis: {
                                value: h
                            },
                            inputEncoding: {
                                value: ns[3e3]
                            },
                            outputEncoding: {
                                value: ns[3e3]
                            }
                        },
                        vertexShader: Rd(),
                        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${Cu()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
                        blending: 0,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }(Lh), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
            }
            fromScene(s, e = 0, r = .1, h = 100) {
                Md = this._renderer.getRenderTarget();
                const c = this._allocateTargets();
                return this._sceneToCubeUV(s, r, h, c), e > 0 && this._blur(c, 0, 0, e), this._applyPMREM(c), this._cleanup(c), c
            }
            fromEquirectangular(s) {
                return this._fromTexture(s)
            }
            fromCubemap(s) {
                return this._fromTexture(s)
            }
            compileCubemapShader() {
                this._cubemapShader === null && (this._cubemapShader = Bd(), this._compileMaterial(this._cubemapShader))
            }
            compileEquirectangularShader() {
                this._equirectShader === null && (this._equirectShader = Cd(), this._compileMaterial(this._equirectShader))
            }
            dispose() {
                this._blurMaterial.dispose(), this._cubemapShader !== null && this._cubemapShader.dispose(), this._equirectShader !== null && this._equirectShader.dispose();
                for (let s = 0; s < al.length; s++) al[s].dispose()
            }
            _cleanup(s) {
                this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(Md), s.scissorTest = !1, Mu(s, 0, 0, s.width, s.height)
            }
            _fromTexture(s) {
                Md = this._renderer.getRenderTarget();
                const e = this._allocateTargets(s);
                return this._textureToCubeUV(s, e), this._applyPMREM(e), this._cleanup(e), e
            }
            _allocateTargets(s) {
                const e = {
                        magFilter: 1003,
                        minFilter: 1003,
                        generateMipmaps: !1,
                        type: 1009,
                        format: 1023,
                        encoding: hp(s) ? s.encoding : 3002,
                        depthBuffer: !1
                    },
                    r = Tu(e);
                return r.depthBuffer = !s, this._pingPongRenderTarget = Tu(e), r
            }
            _compileMaterial(s) {
                const e = new ar(al[0], s);
                this._renderer.compile(e, Rc)
            }
            _sceneToCubeUV(s, e, r, h) {
                const c = new dr(90, 1, e, r),
                    v = [1, -1, 1, 1, 1, 1],
                    w = [1, 1, 1, -1, -1, -1],
                    E = this._renderer,
                    T = E.autoClear,
                    B = E.outputEncoding,
                    Q = E.toneMapping;
                E.getClearColor(cp), E.toneMapping = 0, E.outputEncoding = 3e3, E.autoClear = !1;
                let k = !1;
                const i = s.background;
                if (i) {
                    if (i.isColor) {
                        rl.color.copy(i).convertSRGBToLinear(), s.background = null;
                        const t = Au(rl.color);
                        rl.opacity = t, k = !0
                    }
                } else {
                    rl.color.copy(cp).convertSRGBToLinear();
                    const t = Au(rl.color);
                    rl.opacity = t, k = !0
                }
                for (let t = 0; t < 6; t++) {
                    const a = t % 3;
                    a == 0 ? (c.up.set(0, v[t], 0), c.lookAt(w[t], 0, 0)) : a == 1 ? (c.up.set(0, 0, v[t]), c.lookAt(0, w[t], 0)) : (c.up.set(0, v[t], 0), c.lookAt(0, 0, w[t])), Mu(h, a * eo, t > 2 ? eo : 0, eo, eo), E.setRenderTarget(h), k && E.render(Eu, c), E.render(s, c)
                }
                E.toneMapping = Q, E.outputEncoding = B, E.autoClear = T
            }
            _textureToCubeUV(s, e) {
                const r = this._renderer;
                s.isCubeTexture ? this._cubemapShader == null && (this._cubemapShader = Bd()) : this._equirectShader == null && (this._equirectShader = Cd());
                const h = s.isCubeTexture ? this._cubemapShader : this._equirectShader,
                    c = new ar(al[0], h),
                    v = h.uniforms;
                v.envMap.value = s, s.isCubeTexture || v.texelSize.value.set(1 / s.image.width, 1 / s.image.height), v.inputEncoding.value = ns[s.encoding], v.outputEncoding.value = ns[e.texture.encoding], Mu(e, 0, 0, 3 * eo, 2 * eo), r.setRenderTarget(e), r.render(c, Rc)
            }
            _applyPMREM(s) {
                const e = this._renderer,
                    r = e.autoClear;
                e.autoClear = !1;
                for (let h = 1; h < kl; h++) {
                    const c = Math.sqrt(Su[h] * Su[h] - Su[h - 1] * Su[h - 1]),
                        v = To[(h - 1) % To.length];
                    this._blur(s, h - 1, h, c, v)
                }
                e.autoClear = r
            }
            _blur(s, e, r, h, c) {
                const v = this._pingPongRenderTarget;
                this._halfBlur(s, v, e, r, h, "latitudinal", c), this._halfBlur(v, s, r, r, h, "longitudinal", c)
            }
            _halfBlur(s, e, r, h, c, v, w) {
                const E = this._renderer,
                    T = this._blurMaterial;
                v !== "latitudinal" && v !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
                const B = new ar(al[h], T),
                    Q = T.uniforms,
                    k = lp[r] - 1,
                    i = isFinite(c) ? Math.PI / (2 * k) : 2 * Math.PI / 39,
                    t = c / i,
                    a = isFinite(c) ? 1 + Math.floor(3 * t) : Lh;
                a > Lh && console.warn(`sigmaRadians, ${c}, is too large and will clip, as it requested ${a} samples when the maximum is set to 20`);
                const l = [];
                let d = 0;
                for (let x = 0; x < Lh; ++x) {
                    const A = x / t,
                        M = Math.exp(-A * A / 2);
                    l.push(M), x == 0 ? d += M : x < a && (d += 2 * M)
                }
                for (let x = 0; x < l.length; x++) l[x] = l[x] / d;
                Q.envMap.value = s.texture, Q.samples.value = a, Q.weights.value = l, Q.latitudinal.value = v === "latitudinal", w && (Q.poleAxis.value = w), Q.dTheta.value = i, Q.mipInt.value = 8 - r, Q.inputEncoding.value = ns[s.texture.encoding], Q.outputEncoding.value = ns[s.texture.encoding];
                const g = lp[h];
                Mu(e, 3 * Math.max(0, eo - 2 * g), (h === 0 ? 0 : 2 * eo) + 2 * g * (h > 4 ? h - 8 + 4 : 0), 3 * g, 2 * g), E.setRenderTarget(e), E.render(B, Rc)
            }
        }, y.ParametricBufferGeometry = Jo, y.ParametricGeometry = Jo, y.Particle = function(s) {
            return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new sa(s)
        }, y.ParticleBasicMaterial = function(s) {
            return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Ml(s)
        }, y.ParticleSystem = function(s, e) {
            return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new lc(s, e)
        }, y.ParticleSystemMaterial = function(s) {
            return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Ml(s)
        }, y.Path = yh, y.PerspectiveCamera = dr, y.Plane = Et, y.PlaneBufferGeometry = Is, y.PlaneGeometry = Is, y.PlaneHelper = class extends za {
            constructor(s, e = 1, r = 16776960) {
                const h = r,
                    c = new an;
                c.setAttribute("position", new Ai([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), c.computeBoundingSphere(), super(c, new Xr({
                    color: h,
                    toneMapped: !1
                })), this.type = "PlaneHelper", this.plane = s, this.size = e;
                const v = new an;
                v.setAttribute("position", new Ai([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), v.computeBoundingSphere(), this.add(new ar(v, new Gi({
                    color: h,
                    opacity: .2,
                    transparent: !0,
                    depthWrite: !1,
                    toneMapped: !1
                })))
            }
            updateMatrixWorld(s) {
                let e = -this.plane.constant;
                Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? 1 : 0, this.lookAt(this.plane.normal), super.updateMatrixWorld(s)
            }
        }, y.PointCloud = function(s, e) {
            return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new lc(s, e)
        }, y.PointCloudMaterial = function(s) {
            return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Ml(s)
        }, y.PointLight = id, y.PointLightHelper = class extends ar {
            constructor(s, e, r) {
                super(new wo(e, 4, 2), new Gi({
                    wireframe: !0,
                    fog: !1,
                    toneMapped: !1
                })), this.light = s, this.light.updateMatrixWorld(), this.color = r, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
            }
            dispose() {
                this.geometry.dispose(), this.material.dispose()
            }
            update() {
                this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
            }
        }, y.Points = lc, y.PointsMaterial = Ml, y.PolarGridHelper = class extends xa {
            constructor(s = 10, e = 16, r = 8, h = 64, c = 4473924, v = 8947848) {
                c = new Rt(c), v = new Rt(v);
                const w = [],
                    E = [];
                for (let B = 0; B <= e; B++) {
                    const Q = B / e * (2 * Math.PI),
                        k = Math.sin(Q) * s,
                        i = Math.cos(Q) * s;
                    w.push(0, 0, 0), w.push(k, 0, i);
                    const t = 1 & B ? c : v;
                    E.push(t.r, t.g, t.b), E.push(t.r, t.g, t.b)
                }
                for (let B = 0; B <= r; B++) {
                    const Q = 1 & B ? c : v,
                        k = s - s / r * B;
                    for (let i = 0; i < h; i++) {
                        let t = i / h * (2 * Math.PI),
                            a = Math.sin(t) * k,
                            l = Math.cos(t) * k;
                        w.push(a, 0, l), E.push(Q.r, Q.g, Q.b), t = (i + 1) / h * (2 * Math.PI), a = Math.sin(t) * k, l = Math.cos(t) * k, w.push(a, 0, l), E.push(Q.r, Q.g, Q.b)
                    }
                }
                const T = new an;
                T.setAttribute("position", new Ai(w, 3)), T.setAttribute("color", new Ai(E, 3)), super(T, new Xr({
                    vertexColors: !0,
                    toneMapped: !1
                })), this.type = "PolarGridHelper"
            }
        }, y.PolyhedronBufferGeometry = Js, y.PolyhedronGeometry = Js, y.PositionalAudio = class extends Ah {
            constructor(s) {
                super(s), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
            }
            getOutput() {
                return this.panner
            }
            getRefDistance() {
                return this.panner.refDistance
            }
            setRefDistance(s) {
                return this.panner.refDistance = s, this
            }
            getRolloffFactor() {
                return this.panner.rolloffFactor
            }
            setRolloffFactor(s) {
                return this.panner.rolloffFactor = s, this
            }
            getDistanceModel() {
                return this.panner.distanceModel
            }
            setDistanceModel(s) {
                return this.panner.distanceModel = s, this
            }
            getMaxDistance() {
                return this.panner.maxDistance
            }
            setMaxDistance(s) {
                return this.panner.maxDistance = s, this
            }
            setDirectionalCone(s, e, r) {
                return this.panner.coneInnerAngle = s, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = r, this
            }
            updateMatrixWorld(s) {
                if (super.updateMatrixWorld(s), this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
                this.matrixWorld.decompose(Eo, tp, Tp), il.set(0, 0, 1).applyQuaternion(tp);
                const e = this.panner;
                if (e.positionX) {
                    const r = this.context.currentTime + this.listener.timeDelta;
                    e.positionX.linearRampToValueAtTime(Eo.x, r), e.positionY.linearRampToValueAtTime(Eo.y, r), e.positionZ.linearRampToValueAtTime(Eo.z, r), e.orientationX.linearRampToValueAtTime(il.x, r), e.orientationY.linearRampToValueAtTime(il.y, r), e.orientationZ.linearRampToValueAtTime(il.z, r)
                } else e.setPosition(Eo.x, Eo.y, Eo.z), e.setOrientation(il.x, il.y, il.z)
            }
        }, y.PropertyBinding = Ca, y.PropertyMixer = Rs, y.QuadraticBezierCurve = cu, y.QuadraticBezierCurve3 = $u, y.Quaternion = Bn, y.QuaternionKeyframeTrack = gc, y.QuaternionLinearInterpolant = nu, y.REVISION = z, y.RGBADepthPacking = 3201, y.RGBAFormat = 1023, y.RGBAIntegerFormat = 1033, y.RGBA_ASTC_10x10_Format = 37819, y.RGBA_ASTC_10x5_Format = 37816, y.RGBA_ASTC_10x6_Format = 37817, y.RGBA_ASTC_10x8_Format = 37818, y.RGBA_ASTC_12x10_Format = 37820, y.RGBA_ASTC_12x12_Format = 37821, y.RGBA_ASTC_4x4_Format = 37808, y.RGBA_ASTC_5x4_Format = 37809, y.RGBA_ASTC_5x5_Format = 37810, y.RGBA_ASTC_6x5_Format = 37811, y.RGBA_ASTC_6x6_Format = 37812, y.RGBA_ASTC_8x5_Format = 37813, y.RGBA_ASTC_8x6_Format = 37814, y.RGBA_ASTC_8x8_Format = 37815, y.RGBA_BPTC_Format = 36492, y.RGBA_ETC2_EAC_Format = 37496, y.RGBA_PVRTC_2BPPV1_Format = 35843, y.RGBA_PVRTC_4BPPV1_Format = 35842, y.RGBA_S3TC_DXT1_Format = 33777, y.RGBA_S3TC_DXT3_Format = 33778, y.RGBA_S3TC_DXT5_Format = 33779, y.RGBDEncoding = 3006, y.RGBEEncoding = 3002, y.RGBEFormat = 1023, y.RGBFormat = 1022, y.RGBIntegerFormat = 1032, y.RGBM16Encoding = 3005, y.RGBM7Encoding = 3004, y.RGB_ETC1_Format = 36196, y.RGB_ETC2_Format = 37492, y.RGB_PVRTC_2BPPV1_Format = 35841, y.RGB_PVRTC_4BPPV1_Format = 35840, y.RGB_S3TC_DXT1_Format = 33776, y.RGFormat = 1030, y.RGIntegerFormat = 1031, y.RawShaderMaterial = Xs, y.Ray = wr, y.Raycaster = yd, y.RectAreaLight = ad, y.RedFormat = 1028, y.RedIntegerFormat = 1029, y.ReinhardToneMapping = 2, y.RepeatWrapping = 1e3, y.ReplaceStencilOp = 7681, y.ReverseSubtractEquation = 102, y.RingBufferGeometry = Rl, y.RingGeometry = Rl, y.SRGB8_ALPHA8_ASTC_10x10_Format = 37851, y.SRGB8_ALPHA8_ASTC_10x5_Format = 37848, y.SRGB8_ALPHA8_ASTC_10x6_Format = 37849, y.SRGB8_ALPHA8_ASTC_10x8_Format = 37850, y.SRGB8_ALPHA8_ASTC_12x10_Format = 37852, y.SRGB8_ALPHA8_ASTC_12x12_Format = 37853, y.SRGB8_ALPHA8_ASTC_4x4_Format = 37840, y.SRGB8_ALPHA8_ASTC_5x4_Format = 37841, y.SRGB8_ALPHA8_ASTC_5x5_Format = 37842, y.SRGB8_ALPHA8_ASTC_6x5_Format = 37843, y.SRGB8_ALPHA8_ASTC_6x6_Format = 37844, y.SRGB8_ALPHA8_ASTC_8x5_Format = 37845, y.SRGB8_ALPHA8_ASTC_8x6_Format = 37846, y.SRGB8_ALPHA8_ASTC_8x8_Format = 37847, y.Scene = ut, y.SceneUtils = Fd, y.ShaderChunk = An, y.ShaderLib = Ga, y.ShaderMaterial = Cn, y.ShadowMaterial = Kh, y.Shape = us, y.ShapeBufferGeometry = Zo, y.ShapeGeometry = Zo, y.ShapePath = od, y.ShapeUtils = xo, y.ShortType = 1011, y.Skeleton = Zn, y.SkeletonHelper = xu, y.SkinnedMesh = Mr, y.SmoothShading = 2, y.Sphere = Fn, y.SphereBufferGeometry = wo, y.SphereGeometry = wo, y.Spherical = class {
            constructor(s = 1, e = 0, r = 0) {
                return this.radius = s, this.phi = e, this.theta = r, this
            }
            set(s, e, r) {
                return this.radius = s, this.phi = e, this.theta = r, this
            }
            copy(s) {
                return this.radius = s.radius, this.phi = s.phi, this.theta = s.theta, this
            }
            makeSafe() {
                return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
            }
            setFromVector3(s) {
                return this.setFromCartesianCoords(s.x, s.y, s.z)
            }
            setFromCartesianCoords(s, e, r) {
                return this.radius = Math.sqrt(s * s + e * e + r * r), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(s, r), this.phi = Math.acos(Mi.clamp(e / this.radius, -1, 1))), this
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }, y.SphericalHarmonics3 = sd, y.SplineCurve = hu, y.SpotLight = pu, y.SpotLightHelper = class extends Z {
            constructor(s, e) {
                super(), this.light = s, this.light.updateMatrixWorld(), this.matrix = s.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
                const r = new an,
                    h = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                for (let v = 0, w = 1, E = 32; v < E; v++, w++) {
                    const T = v / E * Math.PI * 2,
                        B = w / E * Math.PI * 2;
                    h.push(Math.cos(T), Math.sin(T), 1, Math.cos(B), Math.sin(B), 1)
                }
                r.setAttribute("position", new Ai(h, 3));
                const c = new Xr({
                    fog: !1,
                    toneMapped: !1
                });
                this.cone = new xa(r, c), this.add(this.cone), this.update()
            }
            dispose() {
                this.cone.geometry.dispose(), this.cone.material.dispose()
            }
            update() {
                this.light.updateMatrixWorld();
                const s = this.light.distance ? this.light.distance : 1e3,
                    e = s * Math.tan(this.light.angle);
                this.cone.scale.set(e, e, s), xd.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(xd), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
            }
        }, y.Sprite = sa, y.SpriteMaterial = ci, y.SrcAlphaFactor = 204, y.SrcAlphaSaturateFactor = 210, y.SrcColorFactor = 202, y.StaticCopyUsage = 35046, y.StaticDrawUsage = 35044, y.StaticReadUsage = 35045, y.StereoCamera = class {
            constructor() {
                this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new dr, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new dr, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
                    focus: null,
                    fov: null,
                    aspect: null,
                    near: null,
                    far: null,
                    zoom: null,
                    eyeSep: null
                }
            }
            update(s) {
                const e = this._cache;
                if (e.focus !== s.focus || e.fov !== s.fov || e.aspect !== s.aspect * this.aspect || e.near !== s.near || e.far !== s.far || e.zoom !== s.zoom || e.eyeSep !== this.eyeSep) {
                    e.focus = s.focus, e.fov = s.fov, e.aspect = s.aspect * this.aspect, e.near = s.near, e.far = s.far, e.zoom = s.zoom, e.eyeSep = this.eyeSep;
                    const r = s.projectionMatrix.clone(),
                        h = e.eyeSep / 2,
                        c = h * e.near / e.focus,
                        v = e.near * Math.tan(Mi.DEG2RAD * e.fov * .5) / e.zoom;
                    let w, E;
                    Sh.elements[12] = -h, Eh.elements[12] = h, w = -v * e.aspect + c, E = v * e.aspect + c, r.elements[0] = 2 * e.near / (E - w), r.elements[8] = (E + w) / (E - w), this.cameraL.projectionMatrix.copy(r), w = -v * e.aspect - c, E = v * e.aspect - c, r.elements[0] = 2 * e.near / (E - w), r.elements[8] = (E + w) / (E - w), this.cameraR.projectionMatrix.copy(r)
                }
                this.cameraL.matrixWorld.copy(s.matrixWorld).multiply(Sh), this.cameraR.matrixWorld.copy(s.matrixWorld).multiply(Eh)
            }
        }, y.StreamCopyUsage = 35042, y.StreamDrawUsage = 35040, y.StreamReadUsage = 35041, y.StringKeyframeTrack = qo, y.SubtractEquation = 101, y.SubtractiveBlending = 3, y.TOUCH = {
            ROTATE: 0,
            PAN: 1,
            DOLLY_PAN: 2,
            DOLLY_ROTATE: 3
        }, y.TangentSpaceNormalMap = 0, y.TetrahedronBufferGeometry = ah, y.TetrahedronGeometry = ah, y.TextBufferGeometry = sh, y.TextGeometry = sh, y.Texture = cn, y.TextureLoader = $o, y.TorusBufferGeometry = Xo, y.TorusGeometry = Xo, y.TorusKnotBufferGeometry = fc, y.TorusKnotGeometry = fc, y.Triangle = Mt, y.TriangleFanDrawMode = 2, y.TriangleStripDrawMode = 1, y.TrianglesDrawMode = 0, y.TubeBufferGeometry = mc, y.TubeGeometry = mc, y.UVMapping = 300, y.Uint16Attribute = function(s, e) {
            return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Un(s, e)
        }, y.Uint16BufferAttribute = Un, y.Uint32Attribute = function(s, e) {
            return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Qr(s, e)
        }, y.Uint32BufferAttribute = Qr, y.Uint8Attribute = function(s, e) {
            return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new en(s, e)
        }, y.Uint8BufferAttribute = en, y.Uint8ClampedAttribute = function(s, e) {
            return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new Bi(s, e)
        }, y.Uint8ClampedBufferAttribute = Bi, y.Uniform = Pl, y.UniformsLib = Oi, y.UniformsUtils = Gl, y.UnsignedByteType = 1009, y.UnsignedInt248Type = 1020, y.UnsignedIntType = 1014, y.UnsignedShort4444Type = 1017, y.UnsignedShort5551Type = 1018, y.UnsignedShort565Type = 1019, y.UnsignedShortType = 1012, y.VSMShadowMap = 3, y.Vector2 = Ht, y.Vector3 = ge, y.Vector4 = Si, y.VectorKeyframeTrack = yc, y.Vertex = function(s, e, r) {
            return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new ge(s, e, r)
        }, y.VertexColors = 2, y.VideoTexture = eh, y.WebGL1Renderer = nt, y.WebGLCubeRenderTarget = so, y.WebGLMultisampleRenderTarget = Nn, y.WebGLRenderTarget = qi, y.WebGLRenderTargetCube = function(s, e, r) {
            return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new so(s, r)
        }, y.WebGLRenderer = we, y.WebGLUtils = j, y.WireframeGeometry = $h, y.WireframeHelper = function(s, e) {
            return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new xa(new $h(s.geometry), new Xr({
                color: e !== void 0 ? e : 16777215
            }))
        }, y.WrapAroundEnding = 2402, y.XHRLoader = function(s) {
            return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new hs(s)
        }, y.ZeroCurvatureEnding = 2400, y.ZeroFactor = 200, y.ZeroSlopeEnding = 2401, y.ZeroStencilOp = 0, y.sRGBEncoding = 3001, Object.defineProperty(y, "__esModule", {
            value: !0
        })
    })
})(Qp, Qp.exports);
var Xa = Qp.exports,
    gf = {
        exports: {}
    },
    yf = {
        exports: {}
    },
    vf = {
        exports: {}
    };
(function(ue, R) {
    const z = .0005555555555555556 * Math.PI,
        V = Math.atan(3 / 4),
        Y = 63710088e-1,
        C = 40075017;
    ue.exports = {
        WORLD_SIZE: 1024e3,
        PROJECTION_WORLD_SIZE: 1024e3 / (Y * Math.PI * 2),
        MERCATOR_A: Y,
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        EARTH_RADIUS: Y,
        EARTH_CIRCUMFERENCE: 2 * Math.PI * Y,
        EARTH_CIRCUMFERENCE_EQUATOR: C,
        FOV_ORTHO: z,
        FOV: V,
        FOV_DEGREES: V * 180 / Math.PI,
        TILE_SIZE: 512
    }
})(vf);
var Op = vf.exports,
    _f = {
        exports: {}
    };
(function(ue, R) {
    function y() {}
    y.prototype = {
        Coords: function(z) {
            if (z.constructor !== Array) {
                console.error("Coords must be an array");
                return
            }
            if (z.length < 2) {
                console.error("Coords length must be at least 2");
                return
            }
            for (const V of z)
                if (V.constructor !== Number) {
                    console.error("Coords values must be numbers");
                    return
                } if (Math.abs(z[1]) > 90) {
                console.error("Latitude must be between -90 and 90");
                return
            }
            return z
        },
        Line: function(z) {
            var V = this;
            if (z.constructor !== Array) {
                console.error("Line must be an array");
                return
            }
            for (const Y of z)
                if (!V.Coords(Y)) {
                    console.error("Each coordinate in a line must be a valid Coords type");
                    return
                } return z
        },
        Rotation: function(z) {
            if (z.constructor === Number) z = {
                z
            };
            else if (z.constructor === Object)
                for (const V of Object.keys(z)) {
                    if (!["x", "y", "z"].includes(V)) {
                        console.error("Rotation parameters must be x, y, or z");
                        return
                    }
                    if (z[V].constructor !== Number) {
                        console.error("Individual rotation values must be numbers");
                        return
                    }
                } else {
                    console.error("Rotation must be an object or a number");
                    return
                }
            return z
        },
        Scale: function(z) {
            if (z.constructor === Number) z = {
                x: z,
                y: z,
                z
            };
            else if (z.constructor === Object)
                for (const V of Object.keys(z)) {
                    if (!["x", "y", "z"].includes(V)) {
                        console.error("Scale parameters must be x, y, or z");
                        return
                    }
                    if (z[V].constructor !== Number) {
                        console.error("Individual scale values must be numbers");
                        return
                    }
                } else {
                    console.error("Scale must be an object or a number");
                    return
                }
            return z
        }
    }, ue.exports = y
})(_f);
var im = _f.exports;
(function(ue, R) {
    var y = Xa,
        z = Op,
        V = im,
        Y = {
            prettyPrintMatrix: function(C) {
                for (var p = 0; p < 4; p++) {
                    var se = [C[p], C[p + 4], C[p + 8], C[p + 12]];
                    console.log(se.map(function(ie) {
                        return ie.toFixed(4)
                    }))
                }
            },
            makePerspectiveMatrix: function(C, p, se, ie) {
                var He = new y.Matrix4,
                    be = 1 / Math.tan(C / 2),
                    Ee = 1 / (se - ie),
                    Lt = [be / p, 0, 0, 0, 0, be, 0, 0, 0, 0, (ie + se) * Ee, -1, 0, 0, 2 * ie * se * Ee, 0];
                return He.elements = Lt, He
            },
            makeOrthographicMatrix: function(C, p, se, ie, He, be) {
                var Ee = new y.Matrix4;
                const Lt = 1 / (p - C),
                    Tt = 1 / (se - ie),
                    Je = 1 / (be - He),
                    wt = (p + C) * Lt,
                    Ke = (se + ie) * Tt,
                    Ye = He * Je;
                var jt = [2 * Lt, 0, 0, 0, 0, 2 * Tt, 0, 0, 0, 0, -1 * Je, 0, -wt, -Ke, -Ye, 1];
                return Ee.elements = jt, Ee
            },
            radify: function(C) {
                function p(se) {
                    return se = se || 0, Math.PI * 2 * se / 360
                }
                return typeof C == "object" ? C.length > 0 ? C.map(function(se) {
                    return p(se)
                }) : [p(C.x), p(C.y), p(C.z)] : p(C)
            },
            degreeify: function(C) {
                function p(se) {
                    return se = se || 0, se * 360 / (Math.PI * 2)
                }
                return typeof C == "object" ? [p(C.x), p(C.y), p(C.z)] : p(C)
            },
            projectToWorld: function(C) {
                var p = [-z.MERCATOR_A * z.DEG2RAD * C[0] * z.PROJECTION_WORLD_SIZE, -z.MERCATOR_A * Math.log(Math.tan(Math.PI * .25 + .5 * z.DEG2RAD * C[1])) * z.PROJECTION_WORLD_SIZE];
                if (!C[2]) p.push(0);
                else {
                    var se = this.projectedUnitsPerMeter(C[1]);
                    p.push(C[2] * se)
                }
                var ie = new y.Vector3(p[0], p[1], p[2]);
                return ie
            },
            projectedUnitsPerMeter: function(C) {
                return Math.abs(z.WORLD_SIZE / Math.cos(z.DEG2RAD * C) / z.EARTH_CIRCUMFERENCE)
            },
            _circumferenceAtLatitude: function(C) {
                return z.EARTH_CIRCUMFERENCE * Math.cos(C * Math.PI / 180)
            },
            mercatorZfromAltitude: function(C, p) {
                return C / this._circumferenceAtLatitude(p)
            },
            _scaleVerticesToMeters: function(C, p) {
                var se = this.projectedUnitsPerMeter(C[1]);
                this.projectToWorld(C);
                for (var ie = 0; ie < p.length; ie++) p[ie].multiplyScalar(se);
                return p
            },
            projectToScreen: function(C) {
                console.log("WARNING: Projecting to screen coordinates is not yet implemented")
            },
            unprojectFromScreen: function(C) {
                console.log("WARNING: unproject is not yet implemented")
            },
            unprojectFromWorld: function(C) {
                var p = [-C.x / (z.MERCATOR_A * z.DEG2RAD * z.PROJECTION_WORLD_SIZE), 2 * (Math.atan(Math.exp(C.y / (z.PROJECTION_WORLD_SIZE * -z.MERCATOR_A))) - Math.PI / 4) / z.DEG2RAD],
                    se = this.projectedUnitsPerMeter(p[1]),
                    ie = C.z || 0;
                return p.push(ie / se), p
            },
            toScreenPosition: function(C, p) {
                var se = new y.Vector3,
                    ie = .5 * renderer.context.canvas.width,
                    He = .5 * renderer.context.canvas.height;
                return C.updateMatrixWorld(), se.setFromMatrixPosition(C.matrixWorld), se.project(p), se.x = se.x * ie + ie, se.y = -(se.y * He) + He, {
                    x: se.x,
                    y: se.y
                }
            },
            getFeatureCenter: function(p, se, ie) {
                let He = [],
                    be = 0,
                    Ee = 0,
                    Lt = 0,
                    Tt = [...p.geometry.coordinates[0]];
                return p.geometry.type === "Point" ? He = [...Tt[0]] : (p.geometry.type === "MultiPolygon" && (Tt = Tt[0]), Tt.splice(-1, 1), Tt.forEach(function(Je) {
                    be += Je[0], Ee += Je[1]
                }), He = [be / Tt.length, Ee / Tt.length]), Lt = this.getObjectHeightOnFloor(p, se, ie), He.length < 3 ? He.push(Lt) : He[2] = Lt, He
            },
            getObjectHeightOnFloor: function(C, p, se = C.properties.level || 0) {
                let ie = se * (C.properties.levelHeight || 0),
                    He = C.properties.base_height || C.properties.min_height || 0,
                    Ee = (p && p.model ? 0 : C.properties.height - He) + He;
                return ie + Ee
            },
            _flipMaterialSides: function(C) {},
            normalizeVertices(C) {
                let p = new y.BufferGeometry,
                    se = [];
                for (var ie = 0; ie < C.length; ie++) {
                    let Ee = C[ie];
                    se.push(Ee.x, Ee.y, Ee.z), se.push(Ee.x, Ee.y, Ee.z)
                }
                p.setAttribute("position", new y.BufferAttribute(new Float32Array(se), 3)), p.computeBoundingSphere();
                var He = p.boundingSphere.center,
                    be = C.map(function(Ee) {
                        var Lt = Ee.sub(He);
                        return Lt
                    });
                return {
                    vertices: be,
                    position: He
                }
            },
            flattenVectors(C) {
                var p = [];
                for (let se of C) p.push(se.x, se.y, se.z);
                return p
            },
            lnglatsToWorld: function(C) {
                var p = C.map(function(se) {
                    var ie = Y.projectToWorld(se),
                        He = new y.Vector3(ie.x, ie.y, ie.z);
                    return He
                });
                return p
            },
            extend: function(C, p) {
                for (let se in p) C[se] = p[se]
            },
            clone: function(C) {
                var p = {};
                for (let se in C) p[se] = C[se];
                return p
            },
            clamp: function(C, p, se) {
                return Math.min(se, Math.max(p, C))
            },
            types: {
                rotation: function(C, p) {
                    C || (C = 0), typeof C == "number" && (C = {
                        z: C
                    });
                    var se = this.applyDefault([C.x, C.y, C.z], p),
                        ie = Y.radify(se);
                    return ie
                },
                scale: function(C, p) {
                    return C || (C = 1), typeof C == "number" ? C = [C, C, C] : this.applyDefault([C.x, C.y, C.z], p)
                },
                applyDefault: function(C, p) {
                    var se = C.map(function(ie, He) {
                        return ie = ie || p[He], ie
                    });
                    return se
                }
            },
            toDecimal: function(C, p) {
                return Number(C.toFixed(p))
            },
            equal: function(C, p) {
                const se = Object.keys(C),
                    ie = Object.keys(p);
                if (se.length !== ie.length || se.length == 0 && ie.length == 0 && se !== ie) return !1;
                for (const He of se) {
                    const be = C[He],
                        Ee = p[He],
                        Lt = this.isObject(be) && this.isObject(Ee);
                    if (Lt && !equal(be, Ee) || !Lt && be !== Ee) return !1
                }
                return !0
            },
            isObject: function(C) {
                return C != null && typeof C == "object"
            },
            curveToLine: (C, p) => {
                let {
                    width: se,
                    color: ie
                } = p, He = new y.BufferGeometry().setFromPoints(C.getPoints(100)), be = new y.LineBasicMaterial({
                    color: ie,
                    linewidth: se
                });
                return new y.Line(He, be)
            },
            curvesToLines: C => {
                var p = [16711680, 2031360, 2490623],
                    se = C.map((ie, He) => {
                        let be = {
                            width: 3,
                            color: p[He] || "purple"
                        };
                        return curveToLine(ie, be)
                    });
                return se
            },
            _validate: function(C, p) {
                C = C || {};
                var se = {};
                Y.extend(se, C);
                for (let ie of Object.keys(p))
                    if (C[ie] === void 0)
                        if (p[ie] === null) {
                            console.error(ie + " is required");
                            return
                        } else se[ie] = p[ie];
                else se[ie] = C[ie];
                return se
            },
            Validator: new V,
            exposedMethods: ["projectToWorld", "projectedUnitsPerMeter", "extend", "unprojectFromWorld"]
        };
    ue.exports = Y
})(yf);
var Ls = yf.exports;
(function(ue, R) {
    const y = Xa,
        z = Ls,
        V = Op;

    function Y(C, p, se) {
        this.map = C, this.camera = p, this.active = !0, this.camera.matrixAutoUpdate = !1, this.world = se || new y.Group, this.world.position.x = this.world.position.y = V.WORLD_SIZE / 2, this.world.matrixAutoUpdate = !1, this.state = {
            translateCenter: new y.Matrix4().makeTranslation(V.WORLD_SIZE / 2, -V.WORLD_SIZE / 2, 0),
            worldSizeRatio: V.TILE_SIZE / V.WORLD_SIZE,
            worldSize: V.TILE_SIZE * this.map.transform.scale
        };
        let ie = this;
        this.map.on("move", function() {
            ie.updateCamera()
        }).on("resize", function() {
            ie.setupCamera()
        }), this.setupCamera()
    }
    Y.prototype = {
        setupCamera: function() {
            this.state.fov = this.map.transform._fov;
            const C = this.map.transform;
            this.camera.aspect = C.width / C.height, this.camera.updateProjectionMatrix(), this.halfFov = this.state.fov / 2;
            const p = {
                    x: C.width / 2,
                    y: C.height / 2
                },
                se = .5 / Math.tan(this.halfFov) * C.height,
                ie = C._maxPitch * Math.PI / 180;
            this.acuteAngle = Math.PI / 2 - ie, this.state.cameraToCenterDistance = se, this.state.offset = p, this.state.cameraTranslateZ = new y.Matrix4().makeTranslation(0, 0, this.state.cameraToCenterDistance), this.state.maxFurthestDistance = this.state.cameraToCenterDistance * .95 * (Math.cos(this.acuteAngle) * Math.sin(this.halfFov) / Math.sin(Math.max(.01, Math.min(Math.PI - .01, this.acuteAngle - this.halfFov))) + 1), this.updateCamera()
        },
        updateCamera: function(C) {
            if (!this.camera) {
                console.log("nocamera");
                return
            }
            const p = this.map.transform;
            let se = 0,
                ie = 0;
            this.state.fov = p._fov, this.halfFov = this.state.fov / 2;
            const He = Math.PI / 2 + p._pitch,
                be = Math.cos(Math.PI / 2 - p._pitch);
            if (this.cameraToCenterDistance = .5 / Math.tan(this.halfFov) * p.height, window.mapboxgl && parseFloat(window.mapboxgl.version) >= 2) {
                const Kt = this.worldSize(p);
                this.mercatorZfromAltitude(1, p.center.lat) * Kt;
                const vi = this.fovAboveCenter(p),
                    Ei = (p._camera.position[2] * Kt - 0) / Math.cos(p._pitch),
                    ct = Math.sin(vi) * Ei / Math.sin(z.clamp(Math.PI - He - vi, .01, Math.PI - .01));
                ie = be * ct + Ei;
                const je = Ei * (1 / p._horizonShift);
                se = Math.min(ie * 1.01, je)
            } else {
                const Kt = Math.sin(this.halfFov) * this.state.cameraToCenterDistance / Math.sin(Math.PI - He - this.halfFov);
                ie = be * Kt + this.state.cameraToCenterDistance, se = ie * 1.01
            }
            this.state.cameraTranslateZ = new y.Matrix4().makeTranslation(0, 0, this.cameraToCenterDistance);
            const Ee = p.height / 50,
                Lt = Math.max(Ee * be, Ee),
                Tt = p.height,
                Je = p.width;
            this.camera instanceof y.OrthographicCamera ? this.camera.projectionMatrix = z.makeOrthographicMatrix(Je / -2, Je / 2, Tt / 2, Tt / -2, Lt, se) : this.camera.projectionMatrix = z.makePerspectiveMatrix(this.state.fov, Je / Tt, Lt, se);
            let wt = this.calcCameraMatrix(p._pitch, p.angle);
            this.camera.matrixWorld.copy(wt);
            let Ke = p.scale * this.state.worldSizeRatio,
                Ye = new y.Matrix4,
                jt = new y.Matrix4,
                di = new y.Matrix4;
            Ye.makeScale(Ke, Ke, Ke);
            let $e = p.x || p.point.x,
                vt = p.y || p.point.y;
            jt.makeTranslation(-$e, vt, 0), di.makeRotationZ(Math.PI), this.world.matrix = new y.Matrix4().premultiply(di).premultiply(this.state.translateCenter).premultiply(Ye).premultiply(jt), this.map.fire("CameraSynced", {
                detail: {
                    nearZ: Lt,
                    farZ: se,
                    pitch: p._pitch,
                    angle: p.angle,
                    furthestDistance: ie,
                    maxFurthestDistance: this.state.maxFurthestDistance,
                    cameraToCenterDistance: this.cameraToCenterDistance,
                    t: this.map.transform,
                    tbProjMatrix: this.camera.projectionMatrix.elements,
                    tbWorldMatrix: this.world.matrix.elements,
                    cameraSyn: Y
                }
            })
        },
        worldSize(C) {
            return C.tileSize * C.scale
        },
        fovAboveCenter(C) {
            return C._fov * (.5 + C.centerOffset.y / C.height)
        },
        mercatorZfromAltitude(C, p) {
            return C / this.circumferenceAtLatitude(p)
        },
        circumferenceAtLatitude(C) {
            return V.EARTH_CIRCUMFERENCE * Math.cos(C * Math.PI / 180)
        },
        calcCameraMatrix(C, p, se) {
            const ie = this.map.transform,
                He = C === void 0 ? ie._pitch : C,
                be = p === void 0 ? ie.angle : p,
                Ee = se === void 0 ? this.state.cameraTranslateZ : se;
            return new y.Matrix4().premultiply(Ee).premultiply(new y.Matrix4().makeRotationX(He)).premultiply(new y.Matrix4().makeRotationZ(be))
        }
    }, ue.exports = Y
})(gf);
var nm = gf.exports,
    xf = {
        exports: {}
    };
(function(ue, R) {
    (function() {
        var y = Math.PI,
            z = Math.sin,
            V = Math.cos,
            Y = Math.tan,
            C = Math.asin,
            p = Math.atan2,
            se = Math.acos,
            ie = y / 180,
            He = 1e3 * 60 * 60 * 24,
            be = 2440588,
            Ee = 2451545;

        function Lt(De) {
            return De.valueOf() / He - .5 + be
        }

        function Tt(De) {
            return new Date((De + .5 - be) * He)
        }

        function Je(De) {
            return Lt(De) - Ee
        }
        var wt = ie * 23.4397;

        function Ke(De, gt) {
            return p(z(De) * V(wt) - Y(gt) * z(wt), V(De))
        }

        function Ye(De, gt) {
            return C(z(gt) * V(wt) + V(gt) * z(wt) * z(De))
        }

        function jt(De, gt, Qt) {
            return p(z(De), V(De) * z(gt) - Y(Qt) * V(gt))
        }

        function di(De, gt, Qt) {
            return C(z(gt) * z(Qt) + V(gt) * V(Qt) * V(De))
        }

        function $e(De, gt) {
            return ie * (280.16 + 360.9856235 * De) - gt
        }

        function vt(De) {
            return De < 0 && (De = 0), 2967e-7 / Math.tan(De + .00312536 / (De + .08901179))
        }

        function Kt(De) {
            return ie * (357.5291 + .98560028 * De)
        }

        function vi(De) {
            var gt = ie * (1.9148 * z(De) + .02 * z(2 * De) + 3e-4 * z(3 * De)),
                Qt = ie * 102.9372;
            return De + gt + Qt + y
        }

        function Li(De) {
            var gt = Kt(De),
                Qt = vi(gt);
            return {
                dec: Ye(Qt, 0),
                ra: Ke(Qt, 0)
            }
        }
        var Ei = {};
        Ei.getPosition = function(De, gt, Qt) {
            var Ve = ie * -Qt,
                Dt = ie * gt,
                ei = Je(De),
                xi = Li(ei),
                oe = $e(ei, Ve) - xi.ra;
            return {
                azimuth: jt(oe, Dt, xi.dec),
                altitude: di(oe, Dt, xi.dec)
            }
        }, Ei.toJulian = function(De) {
            return Lt(De)
        };
        var ct = Ei.times = [
            [-.833, "sunrise", "sunset"],
            [-.3, "sunriseEnd", "sunsetStart"],
            [-6, "dawn", "dusk"],
            [-12, "nauticalDawn", "nauticalDusk"],
            [-18, "nightEnd", "night"],
            [6, "goldenHourEnd", "goldenHour"]
        ];
        Ei.addTime = function(De, gt, Qt) {
            ct.push([De, gt, Qt])
        };
        var je = 9e-4;

        function li(De, gt) {
            return Math.round(De - je - gt / (2 * y))
        }

        function O(De, gt, Qt) {
            return je + (De + gt) / (2 * y) + Qt
        }

        function K(De, gt, Qt) {
            return Ee + De + .0053 * z(gt) - .0069 * z(2 * Qt)
        }

        function ae(De, gt, Qt) {
            return se((z(De) - z(gt) * z(Qt)) / (V(gt) * V(Qt)))
        }

        function _e(De) {
            return -2.076 * Math.sqrt(De) / 60
        }

        function xe(De, gt, Qt, Ve, Dt, ei, xi) {
            var oe = ae(De, Qt, Ve),
                ve = O(oe, gt, Dt);
            return K(ve, ei, xi)
        }
        Ei.getTimes = function(De, gt, Qt, Ve) {
            Ve = Ve || 0;
            var Dt = ie * -Qt,
                ei = ie * gt,
                xi = _e(Ve),
                oe = Je(De),
                ve = li(oe, Dt),
                Ne = O(0, Dt, ve),
                Ue = Kt(Ne),
                Oe = vi(Ue),
                at = Ye(Oe, 0),
                ht = K(Ne, Ue, Oe),
                tt, Bt, Le, Ot, ii, Wt, bi = {
                    solarNoon: Tt(ht),
                    nadir: Tt(ht - .5)
                };
            for (tt = 0, Bt = ct.length; tt < Bt; tt += 1) Le = ct[tt], Ot = (Le[0] + xi) * ie, ii = xe(Ot, Dt, ei, at, ve, Ue, Oe), Wt = ht - (ii - ht), bi[Le[1]] = Tt(Wt), bi[Le[2]] = Tt(ii);
            return bi
        };

        function Ze(De) {
            var gt = ie * (218.316 + 13.176396 * De),
                Qt = ie * (134.963 + 13.064993 * De),
                Ve = ie * (93.272 + 13.22935 * De),
                Dt = gt + ie * 6.289 * z(Qt),
                ei = ie * 5.128 * z(Ve),
                xi = 385001 - 20905 * V(Qt);
            return {
                ra: Ke(Dt, ei),
                dec: Ye(Dt, ei),
                dist: xi
            }
        }
        Ei.getMoonPosition = function(De, gt, Qt) {
            var Ve = ie * -Qt,
                Dt = ie * gt,
                ei = Je(De),
                xi = Ze(ei),
                oe = $e(ei, Ve) - xi.ra,
                ve = di(oe, Dt, xi.dec),
                Ne = p(z(oe), Y(Dt) * V(xi.dec) - z(xi.dec) * V(oe));
            return ve = ve + vt(ve), {
                azimuth: jt(oe, Dt, xi.dec),
                altitude: ve,
                distance: xi.dist,
                parallacticAngle: Ne
            }
        }, Ei.getMoonIllumination = function(De) {
            var gt = Je(De || new Date),
                Qt = Li(gt),
                Ve = Ze(gt),
                Dt = 149598e3,
                ei = se(z(Qt.dec) * z(Ve.dec) + V(Qt.dec) * V(Ve.dec) * V(Qt.ra - Ve.ra)),
                xi = p(Dt * z(ei), Ve.dist - Dt * V(ei)),
                oe = p(V(Qt.dec) * z(Qt.ra - Ve.ra), z(Qt.dec) * V(Ve.dec) - V(Qt.dec) * z(Ve.dec) * V(Qt.ra - Ve.ra));
            return {
                fraction: (1 + V(xi)) / 2,
                phase: .5 + .5 * xi * (oe < 0 ? -1 : 1) / Math.PI,
                angle: oe
            }
        };

        function st(De, gt) {
            return new Date(De.valueOf() + gt * He / 24)
        }
        Ei.getMoonTimes = function(De, gt, Qt, Ve) {
            var Dt = new Date(De);
            Ve ? Dt.setUTCHours(0, 0, 0, 0) : Dt.setHours(0, 0, 0, 0);
            for (var ei = .133 * ie, xi = Ei.getMoonPosition(Dt, gt, Qt).altitude - ei, oe, ve, Ne, Ue, Oe, at, ht, tt, Bt, Le, Ot, ii, Wt, bi = 1; bi <= 24 && (oe = Ei.getMoonPosition(st(Dt, bi), gt, Qt).altitude - ei, ve = Ei.getMoonPosition(st(Dt, bi + 1), gt, Qt).altitude - ei, Oe = (xi + ve) / 2 - oe, at = (ve - xi) / 2, ht = -at / (2 * Oe), tt = (Oe * ht + at) * ht + oe, Bt = at * at - 4 * Oe * oe, Le = 0, Bt >= 0 && (Wt = Math.sqrt(Bt) / (Math.abs(Oe) * 2), Ot = ht - Wt, ii = ht + Wt, Math.abs(Ot) <= 1 && Le++, Math.abs(ii) <= 1 && Le++, Ot < -1 && (Ot = ii)), Le === 1 ? xi < 0 ? Ne = bi + Ot : Ue = bi + Ot : Le === 2 && (Ne = bi + (tt < 0 ? ii : Ot), Ue = bi + (tt < 0 ? Ot : ii)), !(Ne && Ue)); bi += 2) xi = ve;
            var Qi = {};
            return Ne && (Qi.rise = st(Dt, Ne)), Ue && (Qi.set = st(Dt, Ue)), !Ne && !Ue && (Qi[tt > 0 ? "alwaysUp" : "alwaysDown"] = !0), Qi
        }, ue.exports = Ei
    })()
})(xf);
var rm = xf.exports,
    bf = {
        exports: {}
    },
    wf = {
        exports: {}
    };
(function(ue, R) {
    var y = Ls,
        z = Xa,
        V = {
            material: "MeshBasicMaterial",
            color: "black",
            opacity: 1
        };

    function Y(C) {
        var p;
        C ? (C = y._validate(C, V), C.material && C.material.isMaterial ? p = C.material : C.material || C.color || C.opacity ? p = new z[C.material]({
            color: C.color,
            transparent: C.opacity < 1
        }) : p = se(), p.opacity = C.opacity, C.side && (p.side = C.side)) : p = se();

        function se() {
            return new z[V.material]({
                color: V.color
            })
        }
        return p
    }
    ue.exports = Y
})(wf);
var Vp = wf.exports,
    Ef = {
        exports: {}
    };
(function(ue, R) {
    const y = Xa,
        z = Ls;

    function V(C) {
        this.map = C, this.enrolledObjects = [], this.previousFrameTime
    }
    V.prototype = {
        unenroll: function(C) {
            this.enrolledObjects.splice(this.enrolledObjects.indexOf(C), 1)
        },
        enroll: function(C) {
            if (C.clock = new y.Clock, C.hasDefaultAnimation = !1, C.defaultAction, C.actions = [], C.mixer, C.animations && C.animations.length > 0) {
                C.hasDefaultAnimation = !0;
                let ie = C.userData.defaultAnimation ? C.userData.defaultAnimation : 0;
                C.mixer = new y.AnimationMixer(C), p(ie)
            }

            function p(ie) {
                for (let He = 0; He < C.animations.length; He++) {
                    ie > C.animations.length && console.log("The animation index " + ie + " doesn't exist for this object");
                    let be = C.animations[He],
                        Ee = C.mixer.clipAction(be);
                    C.actions.push(Ee), ie === He ? (C.defaultAction = Ee, Ee.setEffectiveWeight(1)) : Ee.setEffectiveWeight(0), Ee.play()
                }
            }
            let se = !1;
            Object.defineProperty(C, "isPlaying", {
                get() {
                    return se
                },
                set(ie) {
                    se != ie && (se = ie, C.dispatchEvent({
                        type: "IsPlayingChanged",
                        detail: C
                    }))
                }
            }), this.enrolledObjects.push(C), C.animationQueue = [], C.set = function(ie) {
                if (ie.duration > 0) {
                    let He = {
                        start: Date.now(),
                        expiration: Date.now() + ie.duration,
                        endState: {}
                    };
                    z.extend(ie, He);
                    let be = ie.coords,
                        Ee = ie.rotation,
                        Lt = ie.scale || ie.scaleX || ie.scaleY || ie.scaleZ;
                    if (Ee) {
                        let Je = C.rotation;
                        ie.startRotation = [Je.x, Je.y, Je.z], ie.endState.rotation = z.types.rotation(ie.rotation, ie.startRotation), ie.rotationPerMs = ie.endState.rotation.map(function(wt, Ke) {
                            return (wt - ie.startRotation[Ke]) / ie.duration
                        })
                    }
                    if (Lt) {
                        let Je = C.scale;
                        ie.startScale = [Je.x, Je.y, Je.z], ie.endState.scale = z.types.scale(ie.scale, ie.startScale), ie.scalePerMs = ie.endState.scale.map(function(wt, Ke) {
                            return (wt - ie.startScale[Ke]) / ie.duration
                        })
                    }
                    be && (ie.pathCurve = new y.CatmullRomCurve3(z.lnglatsToWorld([C.coordinates, ie.coords])));
                    let Tt = {
                        type: "set",
                        parameters: ie
                    };
                    this.animationQueue.push(Tt), tb.map.repaint = !0
                } else this.stop(), ie.rotation = z.radify(ie.rotation), this._setObject(ie);
                return this
            }, C.animationMethod = null, C.stop = function(ie) {
                return C.mixer && (C.isPlaying = !1, cancelAnimationFrame(C.animationMethod)), this.animationQueue = [], this
            }, C.followPath = function(ie, He) {
                let be = {
                    type: "followPath",
                    parameters: z._validate(ie, Y.followPath)
                };
                return z.extend(be.parameters, {
                    pathCurve: new y.CatmullRomCurve3(z.lnglatsToWorld(ie.path)),
                    start: Date.now(),
                    expiration: Date.now() + be.parameters.duration,
                    cb: He
                }), this.animationQueue.push(be), tb.map.repaint = !0, this
            }, C._setObject = function(ie) {
                C.setScale();
                let He = ie.position,
                    be = ie.rotation,
                    Ee = ie.scale,
                    Lt = ie.worldCoordinates,
                    Tt = ie.quaternion,
                    Je = ie.translate,
                    wt = ie.worldTranslate;
                if (He) {
                    this.coordinates = He;
                    let Ye = z.projectToWorld(He);
                    this.position.copy(Ye)
                }
                if (Je) {
                    this.coordinates = [this.coordinates[0] + Je[0], this.coordinates[1] + Je[1], this.coordinates[2] + Je[2]];
                    let Ye = z.projectToWorld(Je);
                    this.position.copy(Ye), ie.position = this.coordinates
                }
                if (wt) {
                    this.translateX(wt.x), this.translateY(wt.y), this.translateZ(wt.z);
                    let Ye = z.unprojectFromWorld(this.position);
                    this.coordinates = ie.position = Ye
                }
                if (be && (this.rotation.set(be[0], be[1], be[2]), ie.rotation = new y.Vector3(be[0], be[1], be[2])), Ee && (this.scale.set(Ee[0], Ee[1], Ee[2]), ie.scale = this.scale), Tt && (this.quaternion.setFromAxisAngle(Tt[0], Tt[1]), ie.rotation = Tt[0].multiplyScalar(Tt[1])), Lt) {
                    this.position.copy(Lt);
                    let Ye = z.unprojectFromWorld(Lt);
                    this.coordinates = ie.position = Ye
                }
                this.setBoundingBoxShadowFloor(), this.setReceiveShadowFloor(), this.updateMatrixWorld(), tb.map.repaint = !0;
                let Ke = {
                    type: "ObjectChanged",
                    detail: {
                        object: this,
                        action: {
                            position: ie.position,
                            rotation: ie.rotation,
                            scale: ie.scale
                        }
                    }
                };
                this.dispatchEvent(Ke)
            }, C.playDefault = function(ie) {
                if (C.mixer && C.hasDefaultAnimation) {
                    let He = {
                        start: Date.now(),
                        expiration: Date.now() + ie.duration,
                        endState: {}
                    };
                    z.extend(ie, He), C.mixer.timeScale = ie.speed || 1;
                    let be = {
                        type: "playDefault",
                        parameters: ie
                    };
                    return this.animationQueue.push(be), tb.map.repaint = !0, this
                }
            }, C.playAnimation = function(ie) {
                C.mixer && (ie.animation && p(ie.animation), C.playDefault(ie))
            }, C.pauseAllActions = function() {
                C.mixer && C.actions.forEach(function(ie) {
                    ie.paused = !0
                })
            }, C.unPauseAllActions = function() {
                C.mixer && C.actions.forEach(function(ie) {
                    ie.paused = !1
                })
            }, C.deactivateAllActions = function() {
                C.mixer && C.actions.forEach(function(ie) {
                    ie.stop()
                })
            }, C.activateAllActions = function() {
                C.mixer && C.actions.forEach(function(ie) {
                    ie.play()
                })
            }, C.idle = function() {
                return C.mixer && C.mixer.update(.01), tb.map.repaint = !0, this
            }
        },
        update: function(C) {
            if (this.previousFrameTime === void 0 && (this.previousFrameTime = C), !this.enrolledObjects) return !1;
            for (let p = this.enrolledObjects.length - 1; p >= 0; p--) {
                let se = this.enrolledObjects[p];
                if (!(!se.animationQueue || se.animationQueue.length === 0))
                    for (let ie = se.animationQueue.length - 1; ie >= 0; ie--) {
                        let He = se.animationQueue[ie];
                        if (!He) continue;
                        let be = He.parameters;
                        if (!be.expiration) {
                            se.animationQueue.splice(ie, 1), se.animationQueue[ie] && (se.animationQueue[ie].parameters.start = C);
                            return
                        }
                        if (C >= be.expiration) be.expiration = !1, He.type === "playDefault" ? se.stop() : (be.endState && se._setObject(be.endState), typeof be.cb != "undefined" && be.cb());
                        else {
                            let Lt = (C - be.start) / be.duration;
                            if (He.type === "set") {
                                let Tt = {};
                                be.pathCurve && (Tt.worldCoordinates = be.pathCurve.getPoint(Lt)), be.rotationPerMs && (Tt.rotation = be.startRotation.map(function(Je, wt) {
                                    return Je + be.rotationPerMs[wt] * Lt * be.duration
                                })), be.scalePerMs && (Tt.scale = be.startScale.map(function(Je, wt) {
                                    return Je + be.scalePerMs[wt] * Lt * be.duration
                                })), se._setObject(Tt)
                            }
                            if (He.type === "followPath") {
                                let Je = {
                                    worldCoordinates: be.pathCurve.getPointAt(Lt)
                                };
                                if (be.trackHeading) {
                                    let wt = be.pathCurve.getTangentAt(Lt).normalize(),
                                        Ke = new y.Vector3(0, 0, 0),
                                        Ye = new y.Vector3(0, 1, 0);
                                    Ke.crossVectors(Ye, wt).normalize();
                                    let jt = Math.acos(Ye.dot(wt));
                                    Je.quaternion = [Ke, jt]
                                }
                                se._setObject(Je)
                            }
                            He.type === "playDefault" && (se.activateAllActions(), se.isPlaying = !0, se.animationMethod = requestAnimationFrame(this.update), se.mixer.update(se.clock.getDelta()), tb.map.repaint = !0)
                        }
                    }
            }
            this.previousFrameTime = C
        }
    };
    const Y = {
        followPath: {
            path: null,
            duration: 1e3,
            trackHeading: !0
        }
    };
    ue.exports = V
})(Ef);
var am = Ef.exports,
    Sf = {
        exports: {}
    };
(function(ue, R) {
    const y = Xa;
    y.CSS2DObject = function(z) {
        y.Object3D.call(this), this.element = z || document.createElement("div"), this.element.style.position = "absolute", this.alwaysVisible = !1, Object.defineProperty(this, "layer", {
            get() {
                return this.parent && this.parent.parent ? this.parent.parent.layer : null
            }
        }), this.dispose = function() {
            this.remove(), this.element = null
        }, this.remove = function() {
            this.element instanceof Element && this.element.parentNode !== null && this.element.parentNode.removeChild(this.element)
        }, this.addEventListener("removed", function() {
            this.remove()
        })
    }, y.CSS2DObject.prototype = Object.assign(Object.create(y.Object3D.prototype), {
        constructor: y.CSS2DObject,
        copy: function(z, V) {
            return y.Object3D.prototype.copy.call(this, z, V), this.element = z.element.cloneNode(!0), this
        }
    }), y.CSS2DRenderer = function() {
        var z = this,
            V, Y, C, p, se = new y.Vector3,
            ie = new y.Matrix4,
            He = new y.Matrix4,
            be = {
                objects: new WeakMap,
                list: new Map
            };
        this.cacheList = be.list;
        var Ee = document.createElement("div");
        Ee.style.overflow = "hidden", this.domElement = Ee, this.getSize = function() {
            return {
                width: V,
                height: Y
            }
        }, this.setSize = function(wt, Ke) {
            V = wt, Y = Ke, C = V / 2, p = Y / 2, Ee.style.width = wt + "px", Ee.style.height = Ke + "px"
        }, this.renderObject = function(wt, Ke, Ye) {
            if (wt instanceof y.CSS2DObject)
                if (!wt.visible) be.objects.delete({
                    key: wt.uuid
                }), be.list.delete(wt.uuid), wt.remove();
                else {
                    wt.onBeforeRender(z, Ke, Ye), se.setFromMatrixPosition(wt.matrixWorld), se.applyMatrix4(He);
                    var jt = wt.element,
                        di = "translate(-50%,-50%) translate(" + (se.x * C + C) + "px," + (-se.y * p + p) + "px)";
                    jt.style.WebkitTransform = di, jt.style.MozTransform = di, jt.style.oTransform = di, jt.style.transform = di, jt.style.display = wt.visible && se.z >= -1 && se.z <= 1 ? "" : "none";
                    var $e = {
                        distanceToCameraSquared: Lt(Ye, wt)
                    };
                    be.objects.set({
                        key: wt.uuid
                    }, $e), be.list.set(wt.uuid, wt), jt.parentNode !== Ee && Ee.appendChild(jt), wt.onAfterRender(z, Ke, Ye)
                } for (var vt = 0, Kt = wt.children.length; vt < Kt; vt++) this.renderObject(wt.children[vt], Ke, Ye)
        };
        var Lt = function() {
                var wt = new y.Vector3,
                    Ke = new y.Vector3;
                return function(Ye, jt) {
                    return wt.setFromMatrixPosition(Ye.matrixWorld), Ke.setFromMatrixPosition(jt.matrixWorld), wt.distanceToSquared(Ke)
                }
            }(),
            Tt = function(wt) {
                var Ke = [];
                return wt.traverse(function(Ye) {
                    Ye instanceof y.CSS2DObject && Ke.push(Ye)
                }), Ke
            },
            Je = function(wt) {
                for (var Ke = Tt(wt).sort(function($e, vt) {
                        let Kt = be.objects.get({
                                key: $e.uuid
                            }),
                            vi = be.objects.get({
                                key: vt.uuid
                            });
                        if (Kt && vi) {
                            var Li = Kt.distanceToCameraSquared,
                                Ei = vi.distanceToCameraSquared;
                            return Li - Ei
                        }
                    }), Ye = Ke.length, jt = 0, di = Ke.length; jt < di; jt++) Ke[jt].element.style.zIndex = Ye - jt
            };
        this.render = function(wt, Ke) {
            wt.autoUpdate === !0 && wt.updateMatrixWorld(), Ke.parent === null && Ke.updateMatrixWorld(), ie.copy(Ke.matrixWorldInverse), He.multiplyMatrices(Ke.projectionMatrix, ie), this.renderObject(wt, wt, Ke), Je(wt)
        }
    }, ue.exports = {
        CSS2DRenderer: y.CSS2DRenderer,
        CSS2DObject: y.CSS2DObject
    }
})(Sf);
var vp = Sf.exports;
(function(ue, R) {
    const y = Ls,
        z = Xa,
        V = am,
        Y = vp;

    function C() {}
    C.prototype = {
        line: function(p) {
            p = y._validate(p, this._defaults.line);
            var se = y.lnglatsToWorld(p.geometry),
                ie = y.normalizeVertices(se),
                He = y.flattenVectors(ie.vertices),
                be = new Float32Array(He),
                Ee = new z.BufferGeometry;
            Ee.setAttribute("position", new z.BufferAttribute(be, 3));
            var Lt = new z.LineBasicMaterial({
                    color: 16711680,
                    linewidth: 21
                }),
                Tt = new z.Line(Ee, Lt);
            return Tt.options = options || {}, Tt.position.copy(ie.position), Tt
        },
        extrusion: function(p) {},
        unenroll: function(p, se) {
            var ie = this;
            se || ie.animationManager.unenroll(p)
        },
        _addMethods: function(p, se) {
            var ie = this;
            const He = "label",
                be = "tooltip",
                Ee = "help",
                Lt = "shadowPlane";
            if (!se) {
                let Ke = function(ct, je, li, O) {
                        let K = y.radify(O);
                        ct.position.sub(je), ct.position.applyAxisAngle(li, K), ct.position.add(je), ct.rotateOnAxis(li, K), tb.map.repaint = !0
                    },
                    Ei = function(ct) {
                        return Math.pow(2, ct)
                    };
                var Je = Ke,
                    wt = Ei;
                p.coordinates || (p.coordinates = [0, 0, 0]), Object.defineProperty(p, "model", {
                    get() {
                        return p.getObjectByName("model")
                    }
                }), Object.defineProperty(p, "animations", {
                    get() {
                        const ct = p.model;
                        return ct ? ct.animations : null
                    }
                }), ie.animationManager.enroll(p), p.setCoords = function(ct) {
                    return p.userData.topMargin && p.userData.feature && (ct[2] += ((p.userData.feature.properties.height || 0) - (p.userData.feature.properties.base_height || p.userData.feature.properties.min_height || 0)) * (p.userData.topMargin || 0)), p.coordinates = ct, p.set({
                        position: ct
                    }), p
                }, p.setTranslate = function(ct) {
                    return p.set({
                        translate: ct
                    }), p
                }, p.setRotation = function(ct) {
                    typeof ct == "number" && (ct = {
                        z: ct
                    });
                    var je = {
                        x: y.radify(ct.x) || p.rotation.x,
                        y: y.radify(ct.y) || p.rotation.y,
                        z: y.radify(ct.z) || p.rotation.z
                    };
                    p._setObject({
                        rotation: [je.x, je.y, je.z]
                    })
                }, p.calculateAdjustedPosition = function(ct, je, li) {
                    let O = ct.slice(),
                        K = y.unprojectFromWorld(p.modelSize);
                    return li ? (O[0] -= je.x != 0 ? K[0] / je.x : 0, O[1] -= je.y != 0 ? K[1] / je.y : 0, O[2] -= je.z != 0 ? K[2] / je.z : 0) : (O[0] += je.x != 0 ? K[0] / je.x : 0, O[1] += je.y != 0 ? K[1] / je.y : 0, O[2] += je.z != 0 ? K[2] / je.z : 0), O
                }, p.setRotationAxis = function(ct) {
                    typeof ct == "number" && (ct = {
                        z: ct
                    });
                    let je = p.modelBox(),
                        li = new z.Vector3(je.max.x, je.max.y, je.min.z);
                    ct.x != 0 && Ke(p, li, new z.Vector3(0, 0, 1), ct.x), ct.y != 0 && Ke(p, li, new z.Vector3(0, 0, 1), ct.y), ct.z != 0 && Ke(p, li, new z.Vector3(0, 0, 1), ct.z)
                }, Object.defineProperty(p, "scaleGroup", {
                    get() {
                        return p.getObjectByName("scaleGroup")
                    }
                }), Object.defineProperty(p, "boxGroup", {
                    get() {
                        return p.getObjectByName("boxGroup")
                    }
                }), Object.defineProperty(p, "boundingBox", {
                    get() {
                        return p.getObjectByName("boxModel")
                    }
                }), Object.defineProperty(p, "boundingBoxShadow", {
                    get() {
                        return p.getObjectByName("boxShadow")
                    }
                }), p.drawBoundingBox = function() {
                    let ct = p.box3(),
                        je = new z.Group;
                    je.name = "boxGroup", je.updateMatrixWorld(!0);
                    let li = new z.Box3Helper(ct, C.prototype._defaults.colors.yellow);
                    li.name = "boxModel", je.add(li), li.layers.disable(0);
                    let O = ct.clone();
                    O.max.z = O.min.z;
                    let K = new z.Box3Helper(O, C.prototype._defaults.colors.black);
                    K.name = "boxShadow", je.add(K), K.layers.disable(0), je.visible = !1, p.scaleGroup.add(je), p.setBoundingBoxShadowFloor()
                }, p.setBoundingBoxShadowFloor = function() {
                    if (p.boundingBoxShadow) {
                        let ct = -p.modelHeight,
                            je = p.rotation,
                            li = p.boundingBoxShadow;
                        li.box.max.z = li.box.min.z = ct, li.rotation.y = je.y, li.rotation.x = -je.x
                    }
                }, p.setAnchor = function(ct) {
                    const je = p.box3(),
                        li = je.getCenter(new z.Vector3);
                    switch (p.none = {
                            x: 0,
                            y: 0,
                            z: 0
                        }, p.center = {
                            x: li.x,
                            y: li.y,
                            z: je.min.z
                        }, p.bottom = {
                            x: li.x,
                            y: je.max.y,
                            z: je.min.z
                        }, p.bottomLeft = {
                            x: je.max.x,
                            y: je.max.y,
                            z: je.min.z
                        }, p.bottomRight = {
                            x: je.min.x,
                            y: je.max.y,
                            z: je.min.z
                        }, p.top = {
                            x: li.x,
                            y: je.min.y,
                            z: je.min.z
                        }, p.topLeft = {
                            x: je.max.x,
                            y: je.min.y,
                            z: je.min.z
                        }, p.topRight = {
                            x: je.min.x,
                            y: je.min.y,
                            z: je.min.z
                        }, p.left = {
                            x: je.max.x,
                            y: li.y,
                            z: je.min.z
                        }, p.right = {
                            x: je.min.x,
                            y: li.y,
                            z: je.min.z
                        }, ct) {
                        case "center":
                            p.anchor = p.center;
                            break;
                        case "top":
                            p.anchor = p.top;
                            break;
                        case "top-left":
                            p.anchor = p.topLeft;
                            break;
                        case "top-right":
                            p.anchor = p.topRight;
                            break;
                        case "left":
                            p.anchor = p.left;
                            break;
                        case "right":
                            p.anchor = p.right;
                            break;
                        case "bottom":
                            p.anchor = p.bottom;
                            break;
                        case "bottom-left":
                        default:
                            p.anchor = p.bottomLeft;
                            break;
                        case "bottom-right":
                            p.anchor = p.bottomRight;
                            break;
                        case "auto":
                        case "none":
                            p.anchor = p.none
                    }
                    p.model.position.set(-p.anchor.x, -p.anchor.y, -p.anchor.z)
                }, p.setCenter = function(ct) {
                    if (ct && (ct.x != 0 || ct.y != 0 || ct.z != 0)) {
                        let je = p.getSize();
                        p.anchor = {
                            x: p.anchor.x - je.x * ct.x,
                            y: p.anchor.y - je.y * ct.y,
                            z: p.anchor.z - je.z * ct.z
                        }, p.model.position.set(-p.anchor.x, -p.anchor.y, -p.anchor.z)
                    }
                }, Object.defineProperty(p, "label", {
                    get() {
                        return p.getObjectByName(He)
                    }
                }), Object.defineProperty(p, "tooltip", {
                    get() {
                        return p.getObjectByName(be)
                    }
                }), Object.defineProperty(p, "help", {
                    get() {
                        return p.getObjectByName(Ee)
                    }
                }), Object.defineProperty(p, "visibility", {
                    get() {
                        return p.visible
                    },
                    set(ct) {
                        let je = ct;
                        if (ct == "visible" || ct == !0) je = !0, p.label && (p.label.visible = je);
                        else if (ct == "none" || ct == !1) je = !1, p.label && p.label.alwaysVisible && (p.label.visible = je), p.tooltip && (p.tooltip.visible = je);
                        else return;
                        p.visible != je && (p.visible = je, p.model && p.model.traverse(function(li) {
                            (li.type == "Mesh" || li.type == "SkinnedMesh") && (je && p.raycasted ? li.layers.enable(0) : li.layers.disable(0)), li.type == "LineSegments" && li.layers.disableAll()
                        }))
                    }
                }), p.addLabel = function(ct, je, li, O) {
                    ct && p.drawLabelHTML(ct, je, li, O)
                }, p.removeLabel = function() {
                    p.removeCSS2D(He)
                }, p.drawLabelHTML = function(ct, je = !1, li = p.anchor, O = .5) {
                    let K = ie.drawLabelHTML(ct, C.prototype._defaults.label.cssClass),
                        ae = p.addCSS2D(K, He, li, O);
                    return ae.alwaysVisible = je, ae.visible = je, ae
                }, p.addTooltip = function(ct, je, li, O = !0, K = 1) {
                    let ae = p.addHelp(ct, be, je, li, K);
                    ae.visible = !1, ae.custom = O
                }, p.removeTooltip = function() {
                    p.removeCSS2D(be)
                }, p.addHelp = function(ct, je = Ee, li = !1, O = p.anchor, K = 0) {
                    let ae = ie.drawTooltip(ct, li),
                        _e = p.addCSS2D(ae, je, O, K);
                    return _e.visible = !0, _e
                }, p.removeHelp = function() {
                    p.removeCSS2D(Ee)
                }, p.addCSS2D = function(ct, je, li = p.anchor, O = 1) {
                    if (ct) {
                        const K = p.box3(),
                            ae = K.getSize(new z.Vector3);
                        let _e = {
                            x: K.max.x,
                            y: K.max.y,
                            z: K.min.z
                        };
                        p.removeCSS2D(je);
                        let xe = new Y.CSS2DObject(ct);
                        return xe.name = je, xe.position.set(-ae.x * .5 - p.model.position.x - li.x + _e.x, -ae.y * .5 - p.model.position.y - li.y + _e.y, ae.z * O), xe.visible = !1, p.scaleGroup.add(xe), xe
                    }
                }, p.removeCSS2D = function(ct) {
                    let je = p.getObjectByName(ct);
                    if (je) {
                        je.dispose();
                        let li = p.scaleGroup.children;
                        li.splice(li.indexOf(je), 1)
                    }
                }, Object.defineProperty(p, "shadowPlane", {
                    get() {
                        return p.getObjectByName(Lt)
                    }
                });
                let Ye = !1;
                Object.defineProperty(p, "castShadow", {
                    get() {
                        return Ye
                    },
                    set(ct) {
                        if (!(!p.model || Ye === ct)) {
                            if (p.model.traverse(function(je) {
                                    je.isMesh && (je.castShadow = !0)
                                }), ct) {
                                const je = p.modelSize,
                                    li = [je.x, je.y, je.z, p.modelHeight],
                                    O = Math.max(...li) * 10,
                                    K = new z.PlaneBufferGeometry(O, O),
                                    ae = new z.ShadowMaterial;
                                ae.opacity = .5;
                                let _e = new z.Mesh(K, ae);
                                _e.name = Lt, _e.layers.enable(1), _e.layers.disable(0), _e.receiveShadow = ct, p.add(_e)
                            } else p.traverse(function(je) {
                                je.isMesh && je.material instanceof z.ShadowMaterial && p.remove(je)
                            });
                            Ye = ct
                        }
                    }
                }), p.setReceiveShadowFloor = function() {
                    if (p.castShadow) {
                        let ct = p.shadowPlane,
                            je = ct.position,
                            li = ct.rotation;
                        if (je.z = -p.modelHeight, li.y = p.rotation.y, li.x = -p.rotation.x, p.userData.units === "meters") {
                            const O = p.modelSize,
                                K = [O.x, O.y, O.z, -je.z],
                                _e = Math.max(...K) * 10 / ct.geometry.parameters.width;
                            ct.scale.set(_e, _e, _e)
                        }
                    }
                };
                let jt = !1;
                Object.defineProperty(p, "receiveShadow", {
                    get() {
                        return jt
                    },
                    set(ct) {
                        !p.model || jt === ct || (p.model.traverse(function(je) {
                            je.isMesh && (je.receiveShadow = !0)
                        }), jt = ct)
                    }
                });
                let di = !1;
                Object.defineProperty(p, "wireframe", {
                    get() {
                        return di
                    },
                    set(ct) {
                        !p.model || di === ct || (p.model.traverse(function(je) {
                            if (je.type == "Mesh" || je.type == "SkinnedMesh") {
                                let li = [];
                                Array.isArray(je.material) ? li = je.material : li.push(je.material);
                                let O = li[0];
                                ct ? (je.userData.materials = O, je.material = O.clone(), je.material.wireframe = je.material.transparent = ct, je.material.opacity = .3) : (je.material.dispose(), je.material = je.userData.materials, je.userData.materials.dispose(), je.userData.materials = null), ct ? (je.layers.disable(0), je.layers.enable(1)) : (je.layers.disable(1), je.layers.enable(0))
                            }
                            je.type == "LineSegments" && je.layers.disableAll()
                        }), di = ct, p.dispatchEvent({
                            type: "Wireframed",
                            detail: p
                        }))
                    }
                });
                let $e = null;
                Object.defineProperty(p, "color", {
                    get() {
                        return $e
                    },
                    set(ct) {
                        !p.model || $e === ct || (p.model.traverse(function(je) {
                            if (je.type == "Mesh" || je.type == "SkinnedMesh") {
                                let li = [];
                                Array.isArray(je.material) ? li = je.material : li.push(je.material);
                                let O = li[0];
                                ct ? (je.userData.materials = O, je.material = new z.MeshStandardMaterial, je.material.color.setHex(ct)) : (je.material.dispose(), je.material = je.userData.materials, je.userData.materials.dispose(), je.userData.materials = null)
                            }
                        }), $e = ct)
                    }
                });
                let vt = !1;
                Object.defineProperty(p, "selected", {
                    get() {
                        return vt
                    },
                    set(ct) {
                        ct ? (p.userData.bbox && !p.boundingBox && p.drawBoundingBox(), p.boxGroup && (p.boundingBox.material = C.prototype._defaults.materials.boxSelectedMaterial, p.boundingBox.parent.visible = !0, p.boundingBox.layers.enable(1), p.boundingBoxShadow.layers.enable(1)), p.label && !p.label.alwaysVisible && (p.label.visible = !0)) : (p.boxGroup && p.remove(p.boxGroup), p.label && !p.label.alwaysVisible && (p.label.visible = !1), p.removeHelp()), p.tooltip && (p.tooltip.visible = ct), vt != ct && (vt = ct, p.dispatchEvent({
                            type: "SelectedChange",
                            detail: p
                        }))
                    }
                });
                let Kt = !0;
                Object.defineProperty(p, "raycasted", {
                    get() {
                        return Kt
                    },
                    set(ct) {
                        !p.model || Kt === ct || (p.model.traverse(function(je) {
                            (je.type == "Mesh" || je.type == "SkinnedMesh") && (ct ? (je.layers.disable(1), je.layers.enable(0)) : (je.layers.disable(0), je.layers.enable(1)))
                        }), Kt = ct)
                    }
                });
                let vi = !1;
                Object.defineProperty(p, "over", {
                    get() {
                        return vi
                    },
                    set(ct) {
                        ct ? (p.selected || (p.userData.bbox && !p.boundingBox && p.drawBoundingBox(), p.userData.tooltip && !p.tooltip && p.addTooltip(p.uuid, !0, p.anchor, !1), p.boxGroup && (p.boundingBox.material = C.prototype._defaults.materials.boxOverMaterial, p.boundingBox.parent.visible = !0, p.boundingBox.layers.enable(1), p.boundingBoxShadow.layers.enable(1))), p.label && !p.label.alwaysVisible && (p.label.visible = !0), p.dispatchEvent({
                            type: "ObjectMouseOver",
                            detail: p
                        })) : (p.selected || (p.boxGroup && (p.remove(p.boxGroup), p.tooltip && !p.tooltip.custom && p.removeTooltip()), p.label && !p.label.alwaysVisible && (p.label.visible = !1)), p.dispatchEvent({
                            type: "ObjectMouseOut",
                            detail: p
                        })), p.tooltip && (p.tooltip.visible = ct || p.selected), vi = ct
                    }
                }), p.box3 = function() {
                    p.updateMatrix(), p.updateMatrixWorld(!0, !0);
                    let ct;
                    if (p.model) {
                        let je = p.clone(!0),
                            li = p.model.clone();
                        if (ct = new z.Box3().setFromObject(li), p.parent) {
                            let O = new z.Matrix4,
                                K = new z.Matrix4;
                            p.matrix.extractRotation(O), K.copy(O).invert(), je.setRotationFromMatrix(K), ct = new z.Box3().setFromObject(li)
                        }
                    }
                    return ct
                }, p.modelBox = function() {
                    return p.box3()
                }, p.getSize = function() {
                    return p.box3().getSize(new z.Vector3(0, 0, 0))
                };
                let Li = !1;
                Object.defineProperty(p, "modelSize", {
                    get() {
                        return Li = p.getSize(), Li
                    },
                    set(ct) {
                        Li != ct && (Li = ct)
                    }
                }), Object.defineProperty(p, "modelHeight", {
                    get() {
                        let ct = p.coordinates[2] || 0;
                        return p.userData.units === "scene" && (ct *= p.unitsPerMeter / p.scale.x), ct
                    }
                }), Object.defineProperty(p, "unitsPerMeter", {
                    get() {
                        return Number(y.projectedUnitsPerMeter(p.coordinates[1]).toFixed(7))
                    }
                }), Object.defineProperty(p, "fixedZoom", {
                    get() {
                        return p.userData.fixedZoom
                    },
                    set(ct) {
                        p.userData.fixedZoom !== ct && (p.userData.fixedZoom = ct, p.userData.units = ct ? "scene" : "meters")
                    }
                }), p.setFixedZoom = function(ct) {
                    if (p.fixedZoom != null) {
                        ct || (ct = p.userData.mapScale);
                        let je = Ei(p.fixedZoom);
                        if (je > ct) {
                            let li = je / ct;
                            p.scale.set(li, li, li)
                        } else p.scale.set(1, 1, 1)
                    }
                }, p.setScale = function(ct) {
                    if (p.userData.units === "meters" && !p.fixedZoom) {
                        let je = p.unitsPerMeter;
                        p.scale.set(je, je, je)
                    } else p.fixedZoom ? (ct && (p.userData.mapScale = ct), p.setFixedZoom(p.userData.mapScale)) : p.scale.set(1, 1, 1)
                }, p.setObjectScale = function(ct) {
                    p.setScale(ct), p.setBoundingBoxShadowFloor(), p.setReceiveShadowFloor()
                }
            }
            p.add = function(Ke) {
                return p.scaleGroup.add(Ke), Ke.position.z = p.coordinates[2] ? -p.coordinates[2] : 0, Ke
            }, p.remove = function(Ke) {
                Ke && (Ke.traverse(Ye => {
                    if (Ye.geometry && Ye.geometry.dispose(), Ye.material)
                        if (Ye.material.isMaterial) Tt(Ye.material);
                        else
                            for (const jt of Ye.material) Tt(jt);
                    Ye.dispose && Ye.dispose()
                }), p.scaleGroup.remove(Ke), tb.map.repaint = !0)
            }, p.duplicate = function(Ke) {
                let Ye = p.clone(!0);
                if (Ye.getObjectByName("model").animations = p.animations, Ye.userData.feature && (Ke && Ke.feature && (Ye.userData.feature = Ke.feature), Ye.userData.feature.properties.uuid = Ye.uuid), ie._addMethods(Ye), !Ke || y.equal(Ke.scale, p.userData.scale)) return Ye.copyAnchor(p), Ye;
                {
                    Ye.userData = Ke, Ye.userData.isGeoGroup = !0, Ye.remove(Ye.boxGroup);
                    const jt = y.types.rotation(Ke.rotation, [0, 0, 0]),
                        di = y.types.scale(Ke.scale, [1, 1, 1]);
                    return Ye.model.position.set(0, 0, 0), Ye.model.rotation.set(jt[0], jt[1], jt[2]), Ye.model.scale.set(di[0], di[1], di[2]), Ye.setAnchor(Ke.anchor), Ye.setCenter(Ke.adjustment), Ye
                }
            }, p.copyAnchor = function(Ke) {
                p.anchor = Ke.anchor, p.none = {
                    x: 0,
                    y: 0,
                    z: 0
                }, p.center = Ke.center, p.bottom = Ke.bottom, p.bottomLeft = Ke.bottomLeft, p.bottomRight = Ke.bottomRight, p.top = Ke.top, p.topLeft = Ke.topLeft, p.topRight = Ke.topRight, p.left = Ke.left, p.right = Ke.right
            }, p.dispose = function() {
                C.prototype.unenroll(p), p.traverse(Ke => {
                    if (!(Ke.parent && Ke.parent.name == "world") && Ke.name !== "threeboxObject") {
                        if (Ke.geometry && Ke.geometry.dispose(), Ke.material)
                            if (Ke.material.isMaterial) Tt(Ke.material);
                            else
                                for (const Ye of Ke.material) Tt(Ye);
                        Ke.dispose && Ke.dispose()
                    }
                }), p.children = []
            };
            const Tt = Ke => {
                Ke.dispose();
                for (const di of Object.keys(Ke)) {
                    const $e = Ke[di];
                    $e && typeof $e == "object" && "minFilter" in $e && $e.dispose()
                }
                let Ye = Ke;
                (Ye.map || Ye.alphaMap || Ye.aoMap || Ye.bumpMap || Ye.displacementMap || Ye.emissiveMap || Ye.envMap || Ye.lightMap || Ye.metalnessMap || Ye.normalMap || Ye.roughnessMap) && (Ye.map && Ye.map.dispose(), Ye.alphaMap && Ye.alphaMap.dispose(), Ye.aoMap && Ye.aoMap.dispose(), Ye.bumpMap && Ye.bumpMap.dispose(), Ye.displacementMap && Ye.displacementMap.dispose(), Ye.emissiveMap && Ye.emissiveMap.dispose(), Ye.envMap && Ye.envMap.dispose(), Ye.lightMap && Ye.lightMap.dispose(), Ye.metalnessMap && Ye.metalnessMap.dispose(), Ye.normalMap && Ye.normalMap.dispose(), Ye.roughnessMap && Ye.roughnessMap.dispose())
            };
            return p
        },
        _makeGroup: function(p, se) {
            let ie = new z.Group;
            ie.name = "scaleGroup", ie.add(p);
            var He = new z.Group;
            He.userData = se || {}, He.userData.isGeoGroup = !0, He.userData.feature && (He.userData.feature.properties.uuid = He.uuid);
            var be = ie.length;
            if (be)
                for (o of ie) He.add(o);
            else He.add(ie);
            return He.name = "threeboxObject", He
        },
        animationManager: new V,
        drawTooltip: function(p, se = !1) {
            if (p) {
                let ie;
                if (se) {
                    let He = document.createElement("div");
                    He.className = "mapboxgl-popup-content";
                    let be = document.createElement("strong");
                    be.innerHTML = p, He.appendChild(be);
                    let Ee = document.createElement("div");
                    Ee.className = "mapboxgl-popup-tip";
                    let Lt = document.createElement("div");
                    Lt.className = "marker mapboxgl-popup-anchor-bottom", Lt.appendChild(Ee), Lt.appendChild(He), ie = document.createElement("div"), ie.className += "label3D", ie.appendChild(Lt)
                } else ie = document.createElement("span"), ie.className = this._defaults.tooltip.cssClass, ie.innerHTML = p;
                return ie
            }
        },
        drawLabelHTML: function(p, se) {
            let ie = document.createElement("div");
            return ie.className += se, typeof p == "string" ? ie.innerHTML = p : ie.innerHTML = p.outerHTML, ie
        },
        _defaults: {
            colors: {
                red: new z.Color(16711680),
                yellow: new z.Color(16776960),
                green: new z.Color(65280),
                black: new z.Color(0)
            },
            materials: {
                boxNormalMaterial: new z.LineBasicMaterial({
                    color: new z.Color(16711680)
                }),
                boxOverMaterial: new z.LineBasicMaterial({
                    color: new z.Color(16776960)
                }),
                boxSelectedMaterial: new z.LineBasicMaterial({
                    color: new z.Color(65280)
                })
            },
            line: {
                geometry: null,
                color: "black",
                width: 1,
                opacity: 1
            },
            label: {
                htmlElement: null,
                cssClass: " label3D",
                alwaysVisible: !1,
                topMargin: -.5
            },
            tooltip: {
                text: "",
                cssClass: "toolTip text-xs",
                mapboxStyle: !1,
                topMargin: 0
            },
            sphere: {
                position: [0, 0, 0],
                radius: 1,
                sides: 20,
                units: "scene",
                material: "MeshBasicMaterial",
                anchor: "bottom-left",
                bbox: !0,
                tooltip: !0,
                raycasted: !0
            },
            tube: {
                geometry: null,
                radius: 1,
                sides: 6,
                units: "scene",
                material: "MeshBasicMaterial",
                anchor: "center",
                bbox: !0,
                tooltip: !0,
                raycasted: !0
            },
            loadObj: {
                type: null,
                obj: null,
                units: "scene",
                scale: 1,
                rotation: 0,
                defaultAnimation: 0,
                anchor: "bottom-left",
                bbox: !0,
                tooltip: !0,
                raycasted: !0
            },
            Object3D: {
                obj: null,
                units: "scene",
                anchor: "bottom-left",
                bbox: !0,
                tooltip: !0,
                raycasted: !0
            },
            extrusion: {
                coordinates: [
                    [
                        []
                    ]
                ],
                geometryOptions: {},
                height: 100,
                materials: null,
                scale: 1,
                rotation: 0,
                units: "scene",
                anchor: "center",
                bbox: !0,
                tooltip: !0,
                raycasted: !0
            }
        },
        geometries: {
            line: ["LineString"],
            tube: ["LineString"],
            sphere: ["Point"]
        }
    }, ue.exports = C
})(bf);
var zl = bf.exports,
    Af = {
        exports: {}
    },
    Tf = {
        exports: {}
    };
(function(ue, R) {
    const y = zl,
        z = Ls;

    function V(Y) {
        Y = z._validate(Y, y.prototype._defaults.Object3D);
        let C = Y.obj;
        const p = z.types.rotation(Y.rotation, [0, 0, 0]),
            se = z.types.scale(Y.scale, [1, 1, 1]);
        C.rotation.set(p[0], p[1], p[2]), C.scale.set(se[0], se[1], se[2]), C.name = "model";
        let ie = y.prototype._makeGroup(C, Y);
        return Y.obj.name = "model", y.prototype._addMethods(ie), ie.setAnchor(Y.anchor), ie.setCenter(Y.adjustment), ie.raycasted = Y.raycasted, ie.visibility = !0, ie
    }
    ue.exports = V
})(Tf);
var _p = Tf.exports;
(function(ue, R) {
    const y = Ls,
        z = Vp,
        V = zl,
        Y = _p;

    function C(p) {
        p = y._validate(p, V.prototype._defaults.sphere);
        let se = new THREE.SphereBufferGeometry(p.radius, p.sides, p.sides),
            ie = z(p),
            He = new THREE.Mesh(se, ie);
        return new Y({
            obj: He,
            units: p.units,
            anchor: p.anchor,
            adjustment: p.adjustment,
            bbox: p.bbox,
            tooltip: p.tooltip,
            raycasted: p.raycasted
        })
    }
    ue.exports = C
})(Af);
var sm = Af.exports,
    Mf = {
        exports: {}
    };
(function(ue, R) {
    const y = zl,
        z = Ls,
        V = Xa,
        Y = _p;

    function C(p) {
        p = z._validate(p, y.prototype._defaults.extrusion);
        let se = C.prototype.buildShape(p.coordinates),
            ie = C.prototype.buildGeometry(se, p.geometryOptions),
            He = new V.Mesh(ie, p.materials);
        return p.obj = He, new Y(p)
    }
    C.prototype = {
        buildShape: function(p) {
            if (p[0] instanceof(V.Vector2 || V.Vector3)) return new V.Shape(p);
            let se = new V.Shape;
            for (let ie = 0; ie < p.length; ie++) ie === 0 ? se = new V.Shape(this.buildPoints(p[0], p[0])) : se.holes.push(new V.Path(this.buildPoints(p[ie], p[0])));
            return se
        },
        buildPoints: function(p, se) {
            const ie = [];
            let He = z.projectToWorld([se[0][0], se[0][1], 0]);
            for (let be = 0; be < p.length; be++) {
                let Ee = z.projectToWorld([p[be][0], p[be][1], 0]);
                ie.push(new V.Vector2(z.toDecimal(Ee.x - He.x, 9), z.toDecimal(Ee.y - He.y, 9)))
            }
            return ie
        },
        buildGeometry: function(p, se) {
            let ie = new V.ExtrudeBufferGeometry(p, se);
            return ie.computeBoundingBox(), ie
        }
    }, ue.exports = C
})(Mf);
var om = Mf.exports,
    Cf = {
        exports: {}
    };
(function(ue, R) {
    const y = Ls,
        z = zl,
        V = vp;

    function Y(C) {
        C = y._validate(C, z.prototype._defaults.label);
        let p = z.prototype.drawLabelHTML(C.htmlElement, C.cssClass),
            se = new V.CSS2DObject(p);
        se.name = "label", se.visible = C.alwaysVisible, se.alwaysVisible = C.alwaysVisible;
        var ie = z.prototype._makeGroup(se, C);
        return z.prototype._addMethods(ie), ie.visibility = C.alwaysVisible, ie
    }
    ue.exports = Y
})(Cf);
var lm = Cf.exports,
    Bf = {
        exports: {}
    };
(function(ue, R) {
    const y = Ls,
        z = zl,
        V = vp;

    function Y(C) {
        if (C = y._validate(C, z.prototype._defaults.tooltip), C.text) {
            let se = z.prototype.drawTooltip(C.text, C.mapboxStyle),
                ie = new V.CSS2DObject(se);
            ie.visible = !1, ie.name = "tooltip";
            var p = z.prototype._makeGroup(ie, C);
            return z.prototype._addMethods(p), p
        }
    }
    ue.exports = Y
})(Bf);
var cm = Bf.exports,
    Rf = {
        exports: {}
    },
    Ff = {
        exports: {}
    };
(function(ue, R) {
    const y = Xa;
    y.OBJLoader = function() {
        var z = /^[og]\s*(.+)?/,
            V = /^mtllib /,
            Y = /^usemtl /,
            C = /^usemap /,
            p = new y.Vector3,
            se = new y.Vector3,
            ie = new y.Vector3,
            He = new y.Vector3,
            be = new y.Vector3;

        function Ee() {
            var Tt = {
                objects: [],
                object: {},
                vertices: [],
                normals: [],
                colors: [],
                uvs: [],
                materials: {},
                materialLibraries: [],
                startObject: function(Je, wt) {
                    if (this.object && this.object.fromDeclaration === !1) {
                        this.object.name = Je, this.object.fromDeclaration = wt !== !1;
                        return
                    }
                    var Ke = this.object && typeof this.object.currentMaterial == "function" ? this.object.currentMaterial() : void 0;
                    if (this.object && typeof this.object._finalize == "function" && this.object._finalize(!0), this.object = {
                            name: Je || "",
                            fromDeclaration: wt !== !1,
                            geometry: {
                                vertices: [],
                                normals: [],
                                colors: [],
                                uvs: [],
                                hasUVIndices: !1
                            },
                            materials: [],
                            smooth: !0,
                            startMaterial: function(jt, di) {
                                var $e = this._finalize(!1);
                                $e && ($e.inherited || $e.groupCount <= 0) && this.materials.splice($e.index, 1);
                                var vt = {
                                    index: this.materials.length,
                                    name: jt || "",
                                    mtllib: Array.isArray(di) && di.length > 0 ? di[di.length - 1] : "",
                                    smooth: $e !== void 0 ? $e.smooth : this.smooth,
                                    groupStart: $e !== void 0 ? $e.groupEnd : 0,
                                    groupEnd: -1,
                                    groupCount: -1,
                                    inherited: !1,
                                    clone: function(Kt) {
                                        var vi = {
                                            index: typeof Kt == "number" ? Kt : this.index,
                                            name: this.name,
                                            mtllib: this.mtllib,
                                            smooth: this.smooth,
                                            groupStart: 0,
                                            groupEnd: -1,
                                            groupCount: -1,
                                            inherited: !1
                                        };
                                        return vi.clone = this.clone.bind(vi), vi
                                    }
                                };
                                return this.materials.push(vt), vt
                            },
                            currentMaterial: function() {
                                if (this.materials.length > 0) return this.materials[this.materials.length - 1]
                            },
                            _finalize: function(jt) {
                                var di = this.currentMaterial();
                                if (di && di.groupEnd === -1 && (di.groupEnd = this.geometry.vertices.length / 3, di.groupCount = di.groupEnd - di.groupStart, di.inherited = !1), jt && this.materials.length > 1)
                                    for (var $e = this.materials.length - 1; $e >= 0; $e--) this.materials[$e].groupCount <= 0 && this.materials.splice($e, 1);
                                return jt && this.materials.length === 0 && this.materials.push({
                                    name: "",
                                    smooth: this.smooth
                                }), di
                            }
                        }, Ke && Ke.name && typeof Ke.clone == "function") {
                        var Ye = Ke.clone(0);
                        Ye.inherited = !0, this.object.materials.push(Ye)
                    }
                    this.objects.push(this.object)
                },
                finalize: function() {
                    this.object && typeof this.object._finalize == "function" && this.object._finalize(!0)
                },
                parseVertexIndex: function(Je, wt) {
                    var Ke = parseInt(Je, 10);
                    return (Ke >= 0 ? Ke - 1 : Ke + wt / 3) * 3
                },
                parseNormalIndex: function(Je, wt) {
                    var Ke = parseInt(Je, 10);
                    return (Ke >= 0 ? Ke - 1 : Ke + wt / 3) * 3
                },
                parseUVIndex: function(Je, wt) {
                    var Ke = parseInt(Je, 10);
                    return (Ke >= 0 ? Ke - 1 : Ke + wt / 2) * 2
                },
                addVertex: function(Je, wt, Ke) {
                    var Ye = this.vertices,
                        jt = this.object.geometry.vertices;
                    jt.push(Ye[Je + 0], Ye[Je + 1], Ye[Je + 2]), jt.push(Ye[wt + 0], Ye[wt + 1], Ye[wt + 2]), jt.push(Ye[Ke + 0], Ye[Ke + 1], Ye[Ke + 2])
                },
                addVertexPoint: function(Je) {
                    var wt = this.vertices,
                        Ke = this.object.geometry.vertices;
                    Ke.push(wt[Je + 0], wt[Je + 1], wt[Je + 2])
                },
                addVertexLine: function(Je) {
                    var wt = this.vertices,
                        Ke = this.object.geometry.vertices;
                    Ke.push(wt[Je + 0], wt[Je + 1], wt[Je + 2])
                },
                addNormal: function(Je, wt, Ke) {
                    var Ye = this.normals,
                        jt = this.object.geometry.normals;
                    jt.push(Ye[Je + 0], Ye[Je + 1], Ye[Je + 2]), jt.push(Ye[wt + 0], Ye[wt + 1], Ye[wt + 2]), jt.push(Ye[Ke + 0], Ye[Ke + 1], Ye[Ke + 2])
                },
                addFaceNormal: function(Je, wt, Ke) {
                    var Ye = this.vertices,
                        jt = this.object.geometry.normals;
                    p.fromArray(Ye, Je), se.fromArray(Ye, wt), ie.fromArray(Ye, Ke), be.subVectors(ie, se), He.subVectors(p, se), be.cross(He), be.normalize(), jt.push(be.x, be.y, be.z), jt.push(be.x, be.y, be.z), jt.push(be.x, be.y, be.z)
                },
                addColor: function(Je, wt, Ke) {
                    var Ye = this.colors,
                        jt = this.object.geometry.colors;
                    Ye[Je] !== void 0 && jt.push(Ye[Je + 0], Ye[Je + 1], Ye[Je + 2]), Ye[wt] !== void 0 && jt.push(Ye[wt + 0], Ye[wt + 1], Ye[wt + 2]), Ye[Ke] !== void 0 && jt.push(Ye[Ke + 0], Ye[Ke + 1], Ye[Ke + 2])
                },
                addUV: function(Je, wt, Ke) {
                    var Ye = this.uvs,
                        jt = this.object.geometry.uvs;
                    jt.push(Ye[Je + 0], Ye[Je + 1]), jt.push(Ye[wt + 0], Ye[wt + 1]), jt.push(Ye[Ke + 0], Ye[Ke + 1])
                },
                addDefaultUV: function() {
                    var Je = this.object.geometry.uvs;
                    Je.push(0, 0), Je.push(0, 0), Je.push(0, 0)
                },
                addUVLine: function(Je) {
                    var wt = this.uvs,
                        Ke = this.object.geometry.uvs;
                    Ke.push(wt[Je + 0], wt[Je + 1])
                },
                addFace: function(Je, wt, Ke, Ye, jt, di, $e, vt, Kt) {
                    var vi = this.vertices.length,
                        Li = this.parseVertexIndex(Je, vi),
                        Ei = this.parseVertexIndex(wt, vi),
                        ct = this.parseVertexIndex(Ke, vi);
                    if (this.addVertex(Li, Ei, ct), this.addColor(Li, Ei, ct), $e !== void 0 && $e !== "") {
                        var je = this.normals.length;
                        Li = this.parseNormalIndex($e, je), Ei = this.parseNormalIndex(vt, je), ct = this.parseNormalIndex(Kt, je), this.addNormal(Li, Ei, ct)
                    } else this.addFaceNormal(Li, Ei, ct);
                    if (Ye !== void 0 && Ye !== "") {
                        var li = this.uvs.length;
                        Li = this.parseUVIndex(Ye, li), Ei = this.parseUVIndex(jt, li), ct = this.parseUVIndex(di, li), this.addUV(Li, Ei, ct), this.object.geometry.hasUVIndices = !0
                    } else this.addDefaultUV()
                },
                addPointGeometry: function(Je) {
                    this.object.geometry.type = "Points";
                    for (var wt = this.vertices.length, Ke = 0, Ye = Je.length; Ke < Ye; Ke++) {
                        var jt = this.parseVertexIndex(Je[Ke], wt);
                        this.addVertexPoint(jt), this.addColor(jt)
                    }
                },
                addLineGeometry: function(Je, wt) {
                    this.object.geometry.type = "Line";
                    for (var Ke = this.vertices.length, Ye = this.uvs.length, jt = 0, di = Je.length; jt < di; jt++) this.addVertexLine(this.parseVertexIndex(Je[jt], Ke));
                    for (var $e = 0, di = wt.length; $e < di; $e++) this.addUVLine(this.parseUVIndex(wt[$e], Ye))
                }
            };
            return Tt.startObject("", !1), Tt
        }

        function Lt(Tt) {
            y.Loader.call(this, Tt), this.materials = null
        }
        return Lt.prototype = Object.assign(Object.create(y.Loader.prototype), {
            constructor: Lt,
            load: function(Tt, Je, wt, Ke) {
                var Ye = this,
                    jt = new y.FileLoader(this.manager);
                jt.setPath(this.path), jt.setRequestHeader(this.requestHeader), jt.setWithCredentials(this.withCredentials), jt.load(Tt, function(di) {
                    try {
                        Je(Ye.parse(di))
                    } catch ($e) {
                        Ke ? Ke($e) : console.error($e), Ye.manager.itemError(Tt)
                    }
                }, wt, Ke)
            },
            setMaterials: function(Tt) {
                return this.materials = Tt, this
            },
            parse: function(Tt) {
                var Je = new Ee;
                Tt.indexOf(`\r
`) !== -1 && (Tt = Tt.replace(/\r\n/g, `
`)), Tt.indexOf(`\\
`) !== -1 && (Tt = Tt.replace(/\\\n/g, ""));
                for (var wt = Tt.split(`
`), Ke = "", Ye = "", jt = 0, di = [], $e = typeof "".trimLeft == "function", vt = 0, Kt = wt.length; vt < Kt; vt++)
                    if (Ke = wt[vt], Ke = $e ? Ke.trimLeft() : Ke.trim(), jt = Ke.length, jt !== 0 && (Ye = Ke.charAt(0), Ye !== "#"))
                        if (Ye === "v") {
                            var vi = Ke.split(/\s+/);
                            switch (vi[0]) {
                                case "v":
                                    Je.vertices.push(parseFloat(vi[1]), parseFloat(vi[2]), parseFloat(vi[3])), vi.length >= 7 ? Je.colors.push(parseFloat(vi[4]), parseFloat(vi[5]), parseFloat(vi[6])) : Je.colors.push(void 0, void 0, void 0);
                                    break;
                                case "vn":
                                    Je.normals.push(parseFloat(vi[1]), parseFloat(vi[2]), parseFloat(vi[3]));
                                    break;
                                case "vt":
                                    Je.uvs.push(parseFloat(vi[1]), parseFloat(vi[2]));
                                    break
                            }
                        } else if (Ye === "f") {
                    for (var Li = Ke.substr(1).trim(), Ei = Li.split(/\s+/), ct = [], je = 0, li = Ei.length; je < li; je++) {
                        var O = Ei[je];
                        if (O.length > 0) {
                            var K = O.split("/");
                            ct.push(K)
                        }
                    }
                    for (var ae = ct[0], je = 1, li = ct.length - 1; je < li; je++) {
                        var _e = ct[je],
                            xe = ct[je + 1];
                        Je.addFace(ae[0], _e[0], xe[0], ae[1], _e[1], xe[1], ae[2], _e[2], xe[2])
                    }
                } else if (Ye === "l") {
                    var Ze = Ke.substring(1).trim().split(" "),
                        st = [],
                        De = [];
                    if (Ke.indexOf("/") === -1) st = Ze;
                    else
                        for (var gt = 0, Qt = Ze.length; gt < Qt; gt++) {
                            var Ve = Ze[gt].split("/");
                            Ve[0] !== "" && st.push(Ve[0]), Ve[1] !== "" && De.push(Ve[1])
                        }
                    Je.addLineGeometry(st, De)
                } else if (Ye === "p") {
                    var Li = Ke.substr(1).trim(),
                        Dt = Li.split(" ");
                    Je.addPointGeometry(Dt)
                } else if ((di = z.exec(Ke)) !== null) {
                    var ei = (" " + di[0].substr(1).trim()).substr(1);
                    Je.startObject(ei)
                } else if (Y.test(Ke)) Je.object.startMaterial(Ke.substring(7).trim(), Je.materialLibraries);
                else if (V.test(Ke)) Je.materialLibraries.push(Ke.substring(7).trim());
                else if (C.test(Ke)) console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
                else if (Ye === "s") {
                    if (di = Ke.split(" "), di.length > 1) {
                        var xi = di[1].trim().toLowerCase();
                        Je.object.smooth = xi !== "0" && xi !== "off"
                    } else Je.object.smooth = !0;
                    var oe = Je.object.currentMaterial();
                    oe && (oe.smooth = Je.object.smooth)
                } else {
                    if (Ke === "\0") continue;
                    console.warn('THREE.OBJLoader: Unexpected line: "' + Ke + '"')
                }
                Je.finalize();
                var ve = new y.Group;
                ve.materialLibraries = [].concat(Je.materialLibraries);
                var Ne = !(Je.objects.length === 1 && Je.objects[0].geometry.vertices.length === 0);
                if (Ne === !0)
                    for (var vt = 0, Kt = Je.objects.length; vt < Kt; vt++) {
                        var Ue = Je.objects[vt],
                            Oe = Ue.geometry,
                            at = Ue.materials,
                            ht = Oe.type === "Line",
                            tt = Oe.type === "Points",
                            Bt = !1;
                        if (Oe.vertices.length !== 0) {
                            var Le = new y.BufferGeometry;
                            Le.setAttribute("position", new y.Float32BufferAttribute(Oe.vertices, 3)), Oe.normals.length > 0 && Le.setAttribute("normal", new y.Float32BufferAttribute(Oe.normals, 3)), Oe.colors.length > 0 && (Bt = !0, Le.setAttribute("color", new y.Float32BufferAttribute(Oe.colors, 3))), Oe.hasUVIndices === !0 && Le.setAttribute("uv", new y.Float32BufferAttribute(Oe.uvs, 2));
                            for (var Ot = [], ii = 0, Wt = at.length; ii < Wt; ii++) {
                                var bi = at[ii],
                                    Qi = bi.name + "_" + bi.smooth + "_" + Bt,
                                    oe = Je.materials[Qi];
                                if (this.materials !== null) {
                                    if (oe = this.materials.create(bi.name), ht && oe && !(oe instanceof y.LineBasicMaterial)) {
                                        var sn = new y.LineBasicMaterial;
                                        y.Material.prototype.copy.call(sn, oe), sn.color.copy(oe.color), oe = sn
                                    } else if (tt && oe && !(oe instanceof y.PointsMaterial)) {
                                        var yn = new y.PointsMaterial({
                                            size: 10,
                                            sizeAttenuation: !1
                                        });
                                        y.Material.prototype.copy.call(yn, oe), yn.color.copy(oe.color), yn.map = oe.map, oe = yn
                                    }
                                }
                                oe === void 0 && (ht ? oe = new y.LineBasicMaterial : tt ? oe = new y.PointsMaterial({
                                    size: 1,
                                    sizeAttenuation: !1
                                }) : oe = new y.MeshPhongMaterial, oe.name = bi.name, oe.flatShading = !bi.smooth, oe.vertexColors = Bt, Je.materials[Qi] = oe), Ot.push(oe)
                            }
                            var Yi;
                            if (Ot.length > 1) {
                                for (var ii = 0, Wt = at.length; ii < Wt; ii++) {
                                    var bi = at[ii];
                                    Le.addGroup(bi.groupStart, bi.groupCount, ii)
                                }
                                ht ? Yi = new y.LineSegments(Le, Ot) : tt ? Yi = new y.Points(Le, Ot) : Yi = new y.Mesh(Le, Ot)
                            } else ht ? Yi = new y.LineSegments(Le, Ot[0]) : tt ? Yi = new y.Points(Le, Ot[0]) : Yi = new y.Mesh(Le, Ot[0]);
                            Yi.name = Ue.name, ve.add(Yi)
                        }
                    } else if (Je.vertices.length > 0) {
                        var oe = new y.PointsMaterial({
                                size: 1,
                                sizeAttenuation: !1
                            }),
                            Le = new y.BufferGeometry;
                        Le.setAttribute("position", new y.Float32BufferAttribute(Je.vertices, 3)), Je.colors.length > 0 && Je.colors[0] !== void 0 && (Le.setAttribute("color", new y.Float32BufferAttribute(Je.colors, 3)), oe.vertexColors = !0);
                        var rn = new y.Points(Le, oe);
                        ve.add(rn)
                    } return ve
            }
        }), Lt
    }(), ue.exports = y.OBJLoader
})(Ff);
var hm = Ff.exports,
    Lf = {
        exports: {}
    };
(function(ue, R) {
    const y = Xa;
    y.MTLLoader = function(z) {
        y.Loader.call(this, z)
    }, y.MTLLoader.prototype = Object.assign(Object.create(y.Loader.prototype), {
        constructor: y.MTLLoader,
        load: function(z, V, Y, C) {
            var p = this,
                se = this.path === "" ? y.LoaderUtils.extractUrlBase(z || "") : this.path,
                ie = new y.FileLoader(this.manager);
            ie.setPath(this.path), ie.setRequestHeader(this.requestHeader), ie.setWithCredentials(this.withCredentials), ie.load(z, function(He) {
                try {
                    V(p.parse(He, se))
                } catch (be) {
                    C ? C(be) : console.error(be), p.manager.itemError(z)
                }
            }, Y, C)
        },
        setMaterialOptions: function(z) {
            return this.materialOptions = z, this
        },
        parse: function(z, V) {
            for (var Y = z.split(`
`), C = {}, p = /\s+/, se = {}, ie = 0; ie < Y.length; ie++) {
                var He = Y[ie];
                if (He = He.trim(), !(He.length === 0 || He.charAt(0) === "#")) {
                    var be = He.indexOf(" "),
                        Ee = be >= 0 ? He.substring(0, be) : He;
                    Ee = Ee.toLowerCase();
                    var Lt = be >= 0 ? He.substring(be + 1) : "";
                    if (Lt = Lt.trim(), Ee === "newmtl") C = {
                        name: Lt
                    }, se[Lt] = C;
                    else if (Ee === "ka" || Ee === "kd" || Ee === "ks" || Ee === "ke") {
                        var Tt = Lt.split(p, 3);
                        C[Ee] = [parseFloat(Tt[0]), parseFloat(Tt[1]), parseFloat(Tt[2])]
                    } else C[Ee] = Lt
                }
            }
            var Je = new y.MTLLoader.MaterialCreator(this.resourcePath || V, this.materialOptions);
            return Je.setCrossOrigin(this.crossOrigin), Je.setManager(this.manager), Je.setMaterials(se), Je
        }
    }), y.MTLLoader.MaterialCreator = function(z, V) {
        this.baseUrl = z || "", this.options = V, this.materialsInfo = {}, this.materials = {}, this.materialsArray = [], this.nameLookup = {}, this.side = this.options && this.options.side ? this.options.side : y.FrontSide, this.wrap = this.options && this.options.wrap ? this.options.wrap : y.RepeatWrapping
    }, y.MTLLoader.MaterialCreator.prototype = {
        constructor: y.MTLLoader.MaterialCreator,
        crossOrigin: "anonymous",
        setCrossOrigin: function(z) {
            return this.crossOrigin = z, this
        },
        setManager: function(z) {
            this.manager = z
        },
        setMaterials: function(z) {
            this.materialsInfo = this.convert(z), this.materials = {}, this.materialsArray = [], this.nameLookup = {}
        },
        convert: function(z) {
            if (!this.options) return z;
            var V = {};
            for (var Y in z) {
                var C = z[Y],
                    p = {};
                V[Y] = p;
                for (var se in C) {
                    var ie = !0,
                        He = C[se],
                        be = se.toLowerCase();
                    switch (be) {
                        case "kd":
                        case "ka":
                        case "ks":
                            this.options && this.options.normalizeRGB && (He = [He[0] / 255, He[1] / 255, He[2] / 255]), this.options && this.options.ignoreZeroRGBs && He[0] === 0 && He[1] === 0 && He[2] === 0 && (ie = !1);
                            break
                    }
                    ie && (p[be] = He)
                }
            }
            return V
        },
        preload: function() {
            for (var z in this.materialsInfo) this.create(z)
        },
        getIndex: function(z) {
            return this.nameLookup[z]
        },
        getAsArray: function() {
            var z = 0;
            for (var V in this.materialsInfo) this.materialsArray[z] = this.create(V), this.nameLookup[V] = z, z++;
            return this.materialsArray
        },
        create: function(z) {
            return this.materials[z] === void 0 && this.createMaterial_(z), this.materials[z]
        },
        createMaterial_: function(z) {
            var V = this,
                Y = this.materialsInfo[z],
                C = {
                    name: z,
                    side: this.side
                };

            function p(Ee, Lt) {
                return typeof Lt != "string" || Lt === "" ? "" : /^https?:\/\//i.test(Lt) ? Lt : Ee + Lt
            }

            function se(Ee, Lt) {
                if (!C[Ee]) {
                    var Tt = V.getTextureParams(Lt, C),
                        Je = V.loadTexture(p(V.baseUrl, Tt.url));
                    Je.repeat.copy(Tt.scale), Je.offset.copy(Tt.offset), Je.wrapS = V.wrap, Je.wrapT = V.wrap, C[Ee] = Je
                }
            }
            for (var ie in Y) {
                var He = Y[ie],
                    be;
                if (He !== "") switch (ie.toLowerCase()) {
                    case "kd":
                        C.color = new y.Color().fromArray(He);
                        break;
                    case "ks":
                        C.specular = new y.Color().fromArray(He);
                        break;
                    case "ke":
                        C.emissive = new y.Color().fromArray(He);
                        break;
                    case "map_kd":
                        se("map", He);
                        break;
                    case "map_ks":
                        se("specularMap", He);
                        break;
                    case "map_ke":
                        se("emissiveMap", He);
                        break;
                    case "norm":
                        se("normalMap", He);
                        break;
                    case "map_bump":
                    case "bump":
                        se("bumpMap", He);
                        break;
                    case "map_d":
                        se("alphaMap", He), C.transparent = !0;
                        break;
                    case "ns":
                        C.shininess = parseFloat(He);
                        break;
                    case "d":
                        be = parseFloat(He), be < 1 && (C.opacity = be, C.transparent = !0);
                        break;
                    case "tr":
                        be = parseFloat(He), this.options && this.options.invertTrProperty && (be = 1 - be), be > 0 && (C.opacity = 1 - be, C.transparent = !0);
                        break
                }
            }
            return this.materials[z] = new y.MeshPhongMaterial(C), this.materials[z]
        },
        getTextureParams: function(z, V) {
            var Y = {
                    scale: new y.Vector2(1, 1),
                    offset: new y.Vector2(0, 0)
                },
                C = z.split(/\s+/),
                p;
            return p = C.indexOf("-bm"), p >= 0 && (V.bumpScale = parseFloat(C[p + 1]), C.splice(p, 2)), p = C.indexOf("-s"), p >= 0 && (Y.scale.set(parseFloat(C[p + 1]), parseFloat(C[p + 2])), C.splice(p, 4)), p = C.indexOf("-o"), p >= 0 && (Y.offset.set(parseFloat(C[p + 1]), parseFloat(C[p + 2])), C.splice(p, 4)), Y.url = C.join(" ").trim(), Y
        },
        loadTexture: function(z, V, Y, C, p) {
            var se, ie = this.manager !== void 0 ? this.manager : y.DefaultLoadingManager,
                He = ie.getHandler(z);
            return He === null && (He = new y.TextureLoader(ie)), He.setCrossOrigin && He.setCrossOrigin(this.crossOrigin), se = He.load(z, Y, C, p), V !== void 0 && (se.mapping = V), se
        }
    }, ue.exports = y.MTLLoader
})(Lf);
var um = Lf.exports,
    Qf = {
        exports: {}
    },
    Pp = {
        exports: {}
    };
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
*/
(function(ue, R) {
    (function(y) {
        ue.exports = y()
    })(function() {
        var y = {};
        y.__esModule = !0;
        var z = function(Z) {
                var q;
                try {
                    q("require('worker_threads')").Worker
                } catch (de) {}
                return R.default = function(de, Pe, Et, Ft, _t) {
                    setImmediate(function() {
                        return _t(Error("async operations unsupported - update to Node 12+ (or Node 10-11 with the --experimental-worker CLI flag)"), null)
                    });
                    var Yt = function() {};
                    return {
                        terminate: Yt,
                        postMessage: Yt
                    }
                }, Z
            }({}),
            V = Uint8Array,
            Y = Uint16Array,
            C = Uint32Array,
            p = new V([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
            se = new V([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
            ie = new V([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
            He = function(Z, q) {
                for (var de = new Y(31), Pe = 0; Pe < 31; ++Pe) de[Pe] = q += 1 << Z[Pe - 1];
                var Et = new C(de[30]);
                for (Pe = 1; Pe < 30; ++Pe)
                    for (var Ft = de[Pe]; Ft < de[Pe + 1]; ++Ft) Et[Ft] = Ft - de[Pe] << 5 | Pe;
                return [de, Et]
            },
            be = He(p, 2),
            Ee = be[0],
            Lt = be[1];
        Ee[28] = 258, Lt[258] = 28;
        for (var Tt = He(se, 0), Je = Tt[0], wt = Tt[1], Ke = new Y(32768), Ye = 0; Ye < 32768; ++Ye) {
            var jt = (43690 & Ye) >>> 1 | (21845 & Ye) << 1;
            Ke[Ye] = ((65280 & (jt = (61680 & (jt = (52428 & jt) >>> 2 | (13107 & jt) << 2)) >>> 4 | (3855 & jt) << 4)) >>> 8 | (255 & jt) << 8) >>> 1
        }
        var di = function(Z, q, de) {
                for (var Pe = Z.length, Et = 0, Ft = new Y(q); Et < Pe; ++Et) ++Ft[Z[Et] - 1];
                var _t, Yt = new Y(q);
                for (Et = 0; Et < q; ++Et) Yt[Et] = Yt[Et - 1] + Ft[Et - 1] << 1;
                if (de) {
                    _t = new Y(1 << q);
                    var J = 15 - q;
                    for (Et = 0; Et < Pe; ++Et)
                        if (Z[Et])
                            for (var W = Et << 4 | Z[Et], re = q - Z[Et], ye = Yt[Z[Et] - 1]++ << re, me = ye | (1 << re) - 1; ye <= me; ++ye) _t[Ke[ye] >>> J] = W
                } else
                    for (_t = new Y(Pe), Et = 0; Et < Pe; ++Et) Z[Et] && (_t[Et] = Ke[Yt[Z[Et] - 1]++] >>> 15 - Z[Et]);
                return _t
            },
            $e = new V(288);
        for (Ye = 0; Ye < 144; ++Ye) $e[Ye] = 8;
        for (Ye = 144; Ye < 256; ++Ye) $e[Ye] = 9;
        for (Ye = 256; Ye < 280; ++Ye) $e[Ye] = 7;
        for (Ye = 280; Ye < 288; ++Ye) $e[Ye] = 8;
        var vt = new V(32);
        for (Ye = 0; Ye < 32; ++Ye) vt[Ye] = 5;
        var Kt = di($e, 9, 0),
            vi = di($e, 9, 1),
            Li = di(vt, 5, 0),
            Ei = di(vt, 5, 1),
            ct = function(Z) {
                for (var q = Z[0], de = 1; de < Z.length; ++de) Z[de] > q && (q = Z[de]);
                return q
            },
            je = function(Z, q, de) {
                var Pe = q / 8 | 0;
                return (Z[Pe] | Z[Pe + 1] << 8) >> (7 & q) & de
            },
            li = function(Z, q) {
                var de = q / 8 | 0;
                return (Z[de] | Z[de + 1] << 8 | Z[de + 2] << 16) >> (7 & q)
            },
            O = function(Z) {
                return (Z / 8 | 0) + (7 & Z && 1)
            },
            K = function(Z, q, de) {
                (q == null || q < 0) && (q = 0), (de == null || de > Z.length) && (de = Z.length);
                var Pe = new(Z instanceof Y ? Y : Z instanceof C ? C : V)(de - q);
                return Pe.set(Z.subarray(q, de)), Pe
            },
            ae = function(Z, q, de) {
                var Pe = Z.length;
                if (!Pe || de && !de.l && Pe < 5) return q || new V(0);
                var Et = !q || de,
                    Ft = !de || de.i;
                de || (de = {}), q || (q = new V(3 * Pe));
                var _t = function(ro) {
                        var Or = q.length;
                        if (ro > Or) {
                            var ls = new V(Math.max(2 * Or, ro));
                            ls.set(q), q = ls
                        }
                    },
                    Yt = de.f || 0,
                    J = de.p || 0,
                    W = de.b || 0,
                    re = de.l,
                    ye = de.d,
                    me = de.m,
                    rt = de.n,
                    At = 8 * Pe;
                do {
                    if (!re) {
                        de.f = Yt = je(Z, J, 1);
                        var Mt = je(Z, J + 1, 3);
                        if (J += 3, !Mt) {
                            var si = Z[(pn = O(J) + 4) - 4] | Z[pn - 3] << 8,
                                ti = pn + si;
                            if (ti > Pe) {
                                if (Ft) throw "unexpected EOF";
                                break
                            }
                            Et && _t(W + si), q.set(Z.subarray(pn, ti), W), de.b = W += si, de.p = J = 8 * ti;
                            continue
                        }
                        if (Mt == 1) re = vi, ye = Ei, me = 9, rt = 5;
                        else {
                            if (Mt != 2) throw "invalid block type";
                            var ni = je(Z, J, 31) + 257,
                                ri = je(Z, J + 10, 15) + 4,
                                Wi = ni + je(Z, J + 5, 31) + 1;
                            J += 14;
                            for (var Ci = new V(Wi), Pi = new V(19), ai = 0; ai < ri; ++ai) Pi[ie[ai]] = je(Z, J + 3 * ai, 7);
                            J += 3 * ri;
                            var Rt = ct(Pi),
                                Gi = (1 << Rt) - 1;
                            if (!Ft && J + Wi * (Rt + 7) > At) break;
                            var ki = di(Pi, Rt, 1);
                            for (ai = 0; ai < Wi;) {
                                var pn, pi = ki[je(Z, J, Gi)];
                                if (J += 15 & pi, (pn = pi >>> 4) < 16) Ci[ai++] = pn;
                                else {
                                    var Hi = 0,
                                        en = 0;
                                    for (pn == 16 ? (en = 3 + je(Z, J, 3), J += 2, Hi = Ci[ai - 1]) : pn == 17 ? (en = 3 + je(Z, J, 7), J += 3) : pn == 18 && (en = 11 + je(Z, J, 127), J += 7); en--;) Ci[ai++] = Hi
                                }
                            }
                            var Bi = Ci.subarray(0, ni),
                                Xi = Ci.subarray(ni);
                            me = ct(Bi), rt = ct(Xi), re = di(Bi, me, 1), ye = di(Xi, rt, 1)
                        }
                        if (J > At) throw "unexpected EOF"
                    }
                    Et && _t(W + 131072);
                    for (var Un = (1 << me) - 1, lr = (1 << rt) - 1, Qr = me + rt + 18; Ft || J + Qr < At;) {
                        var aa = (Hi = re[li(Z, J) & Un]) >>> 4;
                        if ((J += 15 & Hi) > At) throw "unexpected EOF";
                        if (!Hi) throw "invalid length/literal";
                        if (aa < 256) q[W++] = aa;
                        else {
                            if (aa == 256) {
                                re = null;
                                break
                            }
                            var Ai = aa - 254;
                            aa > 264 && (Ai = je(Z, J, (1 << (Kr = p[ai = aa - 257])) - 1) + Ee[ai], J += Kr);
                            var ca = ye[li(Z, J) & lr],
                                Ea = ca >>> 4;
                            if (!ca) throw "invalid distance";
                            if (J += 15 & ca, Xi = Je[Ea], Ea > 3) {
                                var Kr = se[Ea];
                                Xi += li(Z, J) & (1 << Kr) - 1, J += Kr
                            }
                            if (J > At) throw "unexpected EOF";
                            Et && _t(W + 131072);
                            for (var Er = W + Ai; W < Er; W += 4) q[W] = q[W - Xi], q[W + 1] = q[W + 1 - Xi], q[W + 2] = q[W + 2 - Xi], q[W + 3] = q[W + 3 - Xi];
                            W = Er
                        }
                    }
                    de.l = re, de.p = J, de.b = W, re && (Yt = 1, de.m = me, de.d = ye, de.n = rt)
                } while (!Yt);
                return W == q.length ? q : K(q, 0, W)
            },
            _e = function(Z, q, de) {
                var Pe = q / 8 | 0;
                Z[Pe] |= de <<= 7 & q, Z[Pe + 1] |= de >>> 8
            },
            xe = function(Z, q, de) {
                var Pe = q / 8 | 0;
                Z[Pe] |= de <<= 7 & q, Z[Pe + 1] |= de >>> 8, Z[Pe + 2] |= de >>> 16
            },
            Ze = function(Z, q) {
                for (var de = [], Pe = 0; Pe < Z.length; ++Pe) Z[Pe] && de.push({
                    s: Pe,
                    f: Z[Pe]
                });
                var Et = de.length,
                    Ft = de.slice();
                if (!Et) return [ei, 0];
                if (Et == 1) {
                    var _t = new V(de[0].s + 1);
                    return _t[de[0].s] = 1, [_t, 1]
                }
                de.sort(function(Ci, Pi) {
                    return Ci.f - Pi.f
                }), de.push({
                    s: -1,
                    f: 25001
                });
                var Yt = de[0],
                    J = de[1],
                    W = 0,
                    re = 1,
                    ye = 2;
                for (de[0] = {
                        s: -1,
                        f: Yt.f + J.f,
                        l: Yt,
                        r: J
                    }; re != Et - 1;) Yt = de[de[W].f < de[ye].f ? W++ : ye++], J = de[W != re && de[W].f < de[ye].f ? W++ : ye++], de[re++] = {
                    s: -1,
                    f: Yt.f + J.f,
                    l: Yt,
                    r: J
                };
                var me = Ft[0].s;
                for (Pe = 1; Pe < Et; ++Pe) Ft[Pe].s > me && (me = Ft[Pe].s);
                var rt = new Y(me + 1),
                    At = st(de[re - 1], rt, 0);
                if (At > q) {
                    Pe = 0;
                    var Mt = 0,
                        si = At - q,
                        ti = 1 << si;
                    for (Ft.sort(function(Ci, Pi) {
                            return rt[Pi.s] - rt[Ci.s] || Ci.f - Pi.f
                        }); Pe < Et; ++Pe) {
                        var ni = Ft[Pe].s;
                        if (!(rt[ni] > q)) break;
                        Mt += ti - (1 << At - rt[ni]), rt[ni] = q
                    }
                    for (Mt >>>= si; Mt > 0;) {
                        var ri = Ft[Pe].s;
                        rt[ri] < q ? Mt -= 1 << q - rt[ri]++ - 1 : ++Pe
                    }
                    for (; Pe >= 0 && Mt; --Pe) {
                        var Wi = Ft[Pe].s;
                        rt[Wi] == q && (--rt[Wi], ++Mt)
                    }
                    At = q
                }
                return [new V(rt), At]
            },
            st = function(Z, q, de) {
                return Z.s == -1 ? Math.max(st(Z.l, q, de + 1), st(Z.r, q, de + 1)) : q[Z.s] = de
            },
            De = function(Z) {
                for (var q = Z.length; q && !Z[--q];);
                for (var de = new Y(++q), Pe = 0, Et = Z[0], Ft = 1, _t = function(J) {
                        de[Pe++] = J
                    }, Yt = 1; Yt <= q; ++Yt)
                    if (Z[Yt] == Et && Yt != q) ++Ft;
                    else {
                        if (!Et && Ft > 2) {
                            for (; Ft > 138; Ft -= 138) _t(32754);
                            Ft > 2 && (_t(Ft > 10 ? Ft - 11 << 5 | 28690 : Ft - 3 << 5 | 12305), Ft = 0)
                        } else if (Ft > 3) {
                            for (_t(Et), --Ft; Ft > 6; Ft -= 6) _t(8304);
                            Ft > 2 && (_t(Ft - 3 << 5 | 8208), Ft = 0)
                        }
                        for (; Ft--;) _t(Et);
                        Ft = 1, Et = Z[Yt]
                    } return [de.subarray(0, Pe), q]
            },
            gt = function(Z, q) {
                for (var de = 0, Pe = 0; Pe < q.length; ++Pe) de += Z[Pe] * q[Pe];
                return de
            },
            Qt = function(Z, q, de) {
                var Pe = de.length,
                    Et = O(q + 2);
                Z[Et] = 255 & Pe, Z[Et + 1] = Pe >>> 8, Z[Et + 2] = 255 ^ Z[Et], Z[Et + 3] = 255 ^ Z[Et + 1];
                for (var Ft = 0; Ft < Pe; ++Ft) Z[Et + Ft + 4] = de[Ft];
                return 8 * (Et + 4 + Pe)
            },
            Ve = function(Z, q, de, Pe, Et, Ft, _t, Yt, J, W, re) {
                _e(q, re++, de), ++Et[256];
                for (var ye = Ze(Et, 15), me = ye[0], rt = ye[1], At = Ze(Ft, 15), Mt = At[0], si = At[1], ti = De(me), ni = ti[0], ri = ti[1], Wi = De(Mt), Ci = Wi[0], Pi = Wi[1], ai = new Y(19), Rt = 0; Rt < ni.length; ++Rt) ai[31 & ni[Rt]]++;
                for (Rt = 0; Rt < Ci.length; ++Rt) ai[31 & Ci[Rt]]++;
                for (var Gi = Ze(ai, 7), ki = Gi[0], pn = Gi[1], pi = 19; pi > 4 && !ki[ie[pi - 1]]; --pi);
                var Hi, en, Bi, Xi, Un = W + 5 << 3,
                    lr = gt(Et, $e) + gt(Ft, vt) + _t,
                    Qr = gt(Et, me) + gt(Ft, Mt) + _t + 14 + 3 * pi + gt(ai, ki) + (2 * ai[16] + 3 * ai[17] + 7 * ai[18]);
                if (Un <= lr && Un <= Qr) return Qt(q, re, Z.subarray(J, J + W));
                if (_e(q, re, 1 + (Qr < lr)), re += 2, Qr < lr) {
                    Hi = di(me, rt, 0), en = me, Bi = di(Mt, si, 0), Xi = Mt;
                    var aa = di(ki, pn, 0);
                    for (_e(q, re, ri - 257), _e(q, re + 5, Pi - 1), _e(q, re + 10, pi - 4), re += 14, Rt = 0; Rt < pi; ++Rt) _e(q, re + 3 * Rt, ki[ie[Rt]]);
                    re += 3 * pi;
                    for (var Ai = [ni, Ci], ca = 0; ca < 2; ++ca) {
                        var Ea = Ai[ca];
                        for (Rt = 0; Rt < Ea.length; ++Rt) _e(q, re, aa[Kr = 31 & Ea[Rt]]), re += ki[Kr], Kr > 15 && (_e(q, re, Ea[Rt] >>> 5 & 127), re += Ea[Rt] >>> 12)
                    }
                } else Hi = Kt, en = $e, Bi = Li, Xi = vt;
                for (Rt = 0; Rt < Yt; ++Rt)
                    if (Pe[Rt] > 255) {
                        var Kr;
                        xe(q, re, Hi[257 + (Kr = Pe[Rt] >>> 18 & 31)]), re += en[Kr + 257], Kr > 7 && (_e(q, re, Pe[Rt] >>> 23 & 31), re += p[Kr]);
                        var Er = 31 & Pe[Rt];
                        xe(q, re, Bi[Er]), re += Xi[Er], Er > 3 && (xe(q, re, Pe[Rt] >>> 5 & 8191), re += se[Er])
                    } else xe(q, re, Hi[Pe[Rt]]), re += en[Pe[Rt]];
                return xe(q, re, Hi[256]), re + en[256]
            },
            Dt = new C([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]),
            ei = new V(0),
            xi = function(Z, q, de, Pe, Et, Ft) {
                var _t = Z.length,
                    Yt = new V(Pe + _t + 5 * (1 + Math.ceil(_t / 7e3)) + Et),
                    J = Yt.subarray(Pe, Yt.length - Et),
                    W = 0;
                if (!q || _t < 8)
                    for (var re = 0; re <= _t; re += 65535) {
                        var ye = re + 65535;
                        ye < _t ? W = Qt(J, W, Z.subarray(re, ye)) : (J[re] = Ft, W = Qt(J, W, Z.subarray(re, _t)))
                    } else {
                        for (var me = Dt[q - 1], rt = me >>> 13, At = 8191 & me, Mt = (1 << de) - 1, si = new Y(32768), ti = new Y(Mt + 1), ni = Math.ceil(de / 3), ri = 2 * ni, Wi = function(Pr) {
                                return (Z[Pr] ^ Z[Pr + 1] << ni ^ Z[Pr + 2] << ri) & Mt
                            }, Ci = new C(25e3), Pi = new Y(288), ai = new Y(32), Rt = 0, Gi = 0, ki = (re = 0, 0), pn = 0, pi = 0; re < _t; ++re) {
                            var Hi = Wi(re),
                                en = 32767 & re,
                                Bi = ti[Hi];
                            if (si[en] = Bi, ti[Hi] = en, pn <= re) {
                                var Xi = _t - re;
                                if ((Rt > 7e3 || ki > 24576) && Xi > 423) {
                                    W = Ve(Z, J, 0, Ci, Pi, ai, Gi, ki, pi, re - pi, W), ki = Rt = Gi = 0, pi = re;
                                    for (var Un = 0; Un < 286; ++Un) Pi[Un] = 0;
                                    for (Un = 0; Un < 30; ++Un) ai[Un] = 0
                                }
                                var lr = 2,
                                    Qr = 0,
                                    aa = At,
                                    Ai = en - Bi & 32767;
                                if (Xi > 2 && Hi == Wi(re - Ai))
                                    for (var ca = Math.min(rt, Xi) - 1, Ea = Math.min(32767, re), Kr = Math.min(258, Xi); Ai <= Ea && --aa && en != Bi;) {
                                        if (Z[re + lr] == Z[re + lr - Ai]) {
                                            for (var Er = 0; Er < Kr && Z[re + Er] == Z[re + Er - Ai]; ++Er);
                                            if (Er > lr) {
                                                if (lr = Er, Qr = Ai, Er > ca) break;
                                                var ro = Math.min(Ai, Er - 2),
                                                    Or = 0;
                                                for (Un = 0; Un < ro; ++Un) {
                                                    var ls = re - Ai + Un + 32768 & 32767,
                                                        ms = ls - si[ls] + 32768 & 32767;
                                                    ms > Or && (Or = ms, Bi = ls)
                                                }
                                            }
                                        }
                                        Ai += (en = Bi) - (Bi = si[en]) + 32768 & 32767
                                    }
                                if (Qr) {
                                    Ci[ki++] = 268435456 | Lt[lr] << 18 | wt[Qr];
                                    var _a = 31 & Lt[lr],
                                        ks = 31 & wt[Qr];
                                    Gi += p[_a] + se[ks], ++Pi[257 + _a], ++ai[ks], pn = re + lr, ++Rt
                                } else Ci[ki++] = Z[re], ++Pi[Z[re]]
                            }
                        }
                        W = Ve(Z, J, Ft, Ci, Pi, ai, Gi, ki, pi, re - pi, W), !Ft && 7 & W && (W = Qt(J, W + 1, ei))
                    }
                return K(Yt, 0, Pe + O(W) + Et)
            },
            oe = function() {
                for (var Z = new C(256), q = 0; q < 256; ++q) {
                    for (var de = q, Pe = 9; --Pe;) de = (1 & de && 3988292384) ^ de >>> 1;
                    Z[q] = de
                }
                return Z
            }(),
            ve = function() {
                var Z = -1;
                return {
                    p: function(q) {
                        for (var de = Z, Pe = 0; Pe < q.length; ++Pe) de = oe[255 & de ^ q[Pe]] ^ de >>> 8;
                        Z = de
                    },
                    d: function() {
                        return ~Z
                    }
                }
            },
            Ne = function() {
                var Z = 1,
                    q = 0;
                return {
                    p: function(de) {
                        for (var Pe = Z, Et = q, Ft = de.length, _t = 0; _t != Ft;) {
                            for (var Yt = Math.min(_t + 2655, Ft); _t < Yt; ++_t) Et += Pe += de[_t];
                            Pe = (65535 & Pe) + 15 * (Pe >> 16), Et = (65535 & Et) + 15 * (Et >> 16)
                        }
                        Z = Pe, q = Et
                    },
                    d: function() {
                        return ((Z %= 65521) >>> 8 << 16 | (255 & (q %= 65521)) << 8 | q >>> 8) + 2 * ((255 & Z) << 23)
                    }
                }
            },
            Ue = function(Z, q, de, Pe, Et) {
                return xi(Z, q.level == null ? 6 : q.level, q.mem == null ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(Z.length)))) : 12 + q.mem, de, Pe, !Et)
            },
            Oe = function(Z, q) {
                var de = {};
                for (var Pe in Z) de[Pe] = Z[Pe];
                for (var Pe in q) de[Pe] = q[Pe];
                return de
            },
            at = function(Z, q, de) {
                for (var Pe = Z(), Et = "" + Z, Ft = Et.slice(Et.indexOf("[") + 1, Et.lastIndexOf("]")).replace(/ /g, "").split(","), _t = 0; _t < Pe.length; ++_t) {
                    var Yt = Pe[_t],
                        J = Ft[_t];
                    if (typeof Yt == "function") {
                        q += ";" + J + "=";
                        var W = "" + Yt;
                        if (Yt.prototype)
                            if (W.indexOf("[native code]") != -1) {
                                var re = W.indexOf(" ", 8) + 1;
                                q += W.slice(re, W.indexOf("(", re))
                            } else
                                for (var ye in q += W, Yt.prototype) q += ";" + J + ".prototype." + ye + "=" + Yt.prototype[ye];
                        else q += W
                    } else de[J] = Yt
                }
                return [q, de]
            },
            ht = [],
            tt = function(Z) {
                var q = [];
                for (var de in Z)(Z[de] instanceof V || Z[de] instanceof Y || Z[de] instanceof C) && q.push((Z[de] = new Z[de].constructor(Z[de])).buffer);
                return q
            },
            Bt = function(Z, q, de, Pe) {
                var Et;
                if (!ht[de]) {
                    for (var Ft = "", _t = {}, Yt = Z.length - 1, J = 0; J < Yt; ++J) Ft = (Et = at(Z[J], Ft, _t))[0], _t = Et[1];
                    ht[de] = at(Z[Yt], Ft, _t)
                }
                var W = Oe({}, ht[de][1]);
                return z.default(ht[de][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + q + "}", de, W, tt(W), Pe)
            },
            Le = function() {
                return [V, Y, C, p, se, ie, Ee, Je, vi, Ei, Ke, di, ct, je, li, O, K, ae, Ae, sn, yn]
            },
            Ot = function() {
                return [V, Y, C, p, se, ie, Lt, wt, Kt, $e, Li, vt, Ke, Dt, ei, di, _e, xe, Ze, st, De, gt, Qt, Ve, O, K, xi, Ue, Te, sn]
            },
            ii = function() {
                return [na, Si, ji, ve, oe]
            },
            Wt = function() {
                return [cn, yi]
            },
            bi = function() {
                return [qi, ji, Ne]
            },
            Qi = function() {
                return [Nn]
            },
            sn = function(Z) {
                return postMessage(Z, [Z.buffer])
            },
            yn = function(Z) {
                return Z && Z.size && new V(Z.size)
            },
            Yi = function(Z, q, de, Pe, Et, Ft) {
                var _t = Bt(de, Pe, Et, function(Yt, J) {
                    _t.terminate(), Ft(Yt, J)
                });
                return _t.postMessage([Z, q], q.consume ? [Z.buffer] : []),
                    function() {
                        _t.terminate()
                    }
            },
            rn = function(Z) {
                return Z.ondata = function(q, de) {
                        return postMessage([q, de], [q.buffer])
                    },
                    function(q) {
                        return Z.push(q.data[0], q.data[1])
                    }
            },
            Mi = function(Z, q, de, Pe, Et) {
                var Ft, _t = Bt(Z, Pe, Et, function(Yt, J) {
                    Yt ? (_t.terminate(), q.ondata.call(q, Yt)) : (J[1] && _t.terminate(), q.ondata.call(q, Yt, J[0], J[1]))
                });
                _t.postMessage(de), q.push = function(Yt, J) {
                    if (Ft) throw "stream finished";
                    if (!q.ondata) throw "no stream handler";
                    _t.postMessage([Yt, Ft = J], [Yt.buffer])
                }, q.terminate = function() {
                    _t.terminate()
                }
            },
            Ht = function(Z, q) {
                return Z[q] | Z[q + 1] << 8
            },
            Pt = function(Z, q) {
                return (Z[q] | Z[q + 1] << 8 | Z[q + 2] << 16) + 2 * (Z[q + 3] << 23)
            },
            qn = function(Z, q) {
                return Pt(Z, q) | 4294967296 * Pt(Z, q)
            },
            ji = function(Z, q, de) {
                for (; de; ++q) Z[q] = de, de >>>= 8
            },
            na = function(Z, q) {
                var de = q.filename;
                if (Z[0] = 31, Z[1] = 139, Z[2] = 8, Z[8] = q.level < 2 ? 4 : q.level == 9 ? 2 : 0, Z[9] = 3, q.mtime != 0 && ji(Z, 4, Math.floor(new Date(q.mtime || Date.now()) / 1e3)), de) {
                    Z[3] = 8;
                    for (var Pe = 0; Pe <= de.length; ++Pe) Z[Pe + 10] = de.charCodeAt(Pe)
                }
            },
            cn = function(Z) {
                if (Z[0] != 31 || Z[1] != 139 || Z[2] != 8) throw "invalid gzip data";
                var q = Z[3],
                    de = 10;
                4 & q && (de += Z[10] | 2 + (Z[11] << 8));
                for (var Pe = (q >> 3 & 1) + (q >> 4 & 1); Pe > 0; Pe -= !Z[de++]);
                return de + (2 & q)
            },
            yi = function(Z) {
                var q = Z.length;
                return (Z[q - 4] | Z[q - 3] << 8 | Z[q - 2] << 16) + 2 * (Z[q - 1] << 23)
            },
            Si = function(Z) {
                return 10 + (Z.filename && Z.filename.length + 1 || 0)
            },
            qi = function(Z, q) {
                var de = q.level,
                    Pe = de == 0 ? 0 : de < 6 ? 1 : de == 9 ? 3 : 2;
                Z[0] = 120, Z[1] = Pe << 6 | (Pe ? 32 - 2 * Pe : 1)
            },
            Nn = function(Z) {
                if ((15 & Z[0]) != 8 || Z[0] >>> 4 > 7 || (Z[0] << 8 | Z[1]) % 31) throw "invalid zlib data";
                if (32 & Z[1]) throw "invalid zlib data: preset dictionaries not supported"
            };

        function Bn(Z, q) {
            return q || typeof Z != "function" || (q = Z, Z = {}), this.ondata = q, Z
        }
        var ge = function() {
            function Z(q, de) {
                de || typeof q != "function" || (de = q, q = {}), this.ondata = de, this.o = q || {}
            }
            return Z.prototype.p = function(q, de) {
                this.ondata(Ue(q, this.o, 0, 0, !de), de)
            }, Z.prototype.push = function(q, de) {
                if (this.d) throw "stream finished";
                if (!this.ondata) throw "no stream handler";
                this.d = de, this.p(q, de || !1)
            }, Z
        }();
        y.Deflate = ge;
        var ga = function() {
            return function(Z, q) {
                Mi([Ot, function() {
                    return [rn, ge]
                }], this, Bn.call(this, Z, q), function(de) {
                    var Pe = new ge(de.data);
                    onmessage = rn(Pe)
                }, 6)
            }
        }();

        function On(Z, q, de) {
            if (de || (de = q, q = {}), typeof de != "function") throw "no callback";
            return Yi(Z, q, [Ot], function(Pe) {
                return sn(Te(Pe.data[0], Pe.data[1]))
            }, 0, de)
        }

        function Te(Z, q) {
            return Ue(Z, q || {}, 0, 0)
        }
        y.AsyncDeflate = ga, y.deflate = On, y.deflateSync = Te;
        var te = function() {
            function Z(q) {
                this.s = {}, this.p = new V(0), this.ondata = q
            }
            return Z.prototype.e = function(q) {
                if (this.d) throw "stream finished";
                if (!this.ondata) throw "no stream handler";
                var de = this.p.length,
                    Pe = new V(de + q.length);
                Pe.set(this.p), Pe.set(q, de), this.p = Pe
            }, Z.prototype.c = function(q) {
                this.d = this.s.i = q || !1;
                var de = this.s.b,
                    Pe = ae(this.p, this.o, this.s);
                this.ondata(K(Pe, de, this.s.b), this.d), this.o = K(Pe, this.s.b - 32768), this.s.b = this.o.length, this.p = K(this.p, this.s.p / 8 | 0), this.s.p &= 7
            }, Z.prototype.push = function(q, de) {
                this.e(q), this.c(de)
            }, Z
        }();
        y.Inflate = te;
        var he = function() {
            return function(Z) {
                this.ondata = Z, Mi([Le, function() {
                    return [rn, te]
                }], this, 0, function() {
                    var q = new te;
                    onmessage = rn(q)
                }, 7)
            }
        }();

        function fe(Z, q, de) {
            if (de || (de = q, q = {}), typeof de != "function") throw "no callback";
            return Yi(Z, q, [Le], function(Pe) {
                return sn(Ae(Pe.data[0], yn(Pe.data[1])))
            }, 1, de)
        }

        function Ae(Z, q) {
            return ae(Z, q)
        }
        y.AsyncInflate = he, y.inflate = fe, y.inflateSync = Ae;
        var qe = function() {
            function Z(q, de) {
                this.c = ve(), this.l = 0, this.v = 1, ge.call(this, q, de)
            }
            return Z.prototype.push = function(q, de) {
                ge.prototype.push.call(this, q, de)
            }, Z.prototype.p = function(q, de) {
                this.c.p(q), this.l += q.length;
                var Pe = Ue(q, this.o, this.v && Si(this.o), de && 8, !de);
                this.v && (na(Pe, this.o), this.v = 0), de && (ji(Pe, Pe.length - 8, this.c.d()), ji(Pe, Pe.length - 4, this.l)), this.ondata(Pe, de)
            }, Z
        }();
        y.Gzip = qe, y.Compress = qe;
        var et = function() {
            return function(Z, q) {
                Mi([Ot, ii, function() {
                    return [rn, ge, qe]
                }], this, Bn.call(this, Z, q), function(de) {
                    var Pe = new qe(de.data);
                    onmessage = rn(Pe)
                }, 8)
            }
        }();

        function it(Z, q, de) {
            if (de || (de = q, q = {}), typeof de != "function") throw "no callback";
            return Yi(Z, q, [Ot, ii, function() {
                return [We]
            }], function(Pe) {
                return sn(We(Pe.data[0], Pe.data[1]))
            }, 2, de)
        }

        function We(Z, q) {
            q || (q = {});
            var de = ve(),
                Pe = Z.length;
            de.p(Z);
            var Et = Ue(Z, q, Si(q), 8),
                Ft = Et.length;
            return na(Et, q), ji(Et, Ft - 8, de.d()), ji(Et, Ft - 4, Pe), Et
        }
        y.AsyncGzip = et, y.AsyncCompress = et, y.gzip = it, y.compress = it, y.gzipSync = We, y.compressSync = We;
        var ft = function() {
            function Z(q) {
                this.v = 1, te.call(this, q)
            }
            return Z.prototype.push = function(q, de) {
                if (te.prototype.e.call(this, q), this.v) {
                    var Pe = this.p.length > 3 ? cn(this.p) : 4;
                    if (Pe >= this.p.length && !de) return;
                    this.p = this.p.subarray(Pe), this.v = 0
                }
                if (de) {
                    if (this.p.length < 8) throw "invalid gzip stream";
                    this.p = this.p.subarray(0, -8)
                }
                te.prototype.c.call(this, de)
            }, Z
        }();
        y.Gunzip = ft;
        var Jt = function() {
            return function(Z) {
                this.ondata = Z, Mi([Le, Wt, function() {
                    return [rn, te, ft]
                }], this, 0, function() {
                    var q = new ft;
                    onmessage = rn(q)
                }, 9)
            }
        }();

        function zt(Z, q, de) {
            if (de || (de = q, q = {}), typeof de != "function") throw "no callback";
            return Yi(Z, q, [Le, Wt, function() {
                return [It]
            }], function(Pe) {
                return sn(It(Pe.data[0]))
            }, 3, de)
        }

        function It(Z, q) {
            return ae(Z.subarray(cn(Z), -8), q || new V(yi(Z)))
        }
        y.AsyncGunzip = Jt, y.gunzip = zt, y.gunzipSync = It;
        var zi = function() {
            function Z(q, de) {
                this.c = Ne(), this.v = 1, ge.call(this, q, de)
            }
            return Z.prototype.push = function(q, de) {
                ge.prototype.push.call(this, q, de)
            }, Z.prototype.p = function(q, de) {
                this.c.p(q);
                var Pe = Ue(q, this.o, this.v && 2, de && 4, !de);
                this.v && (qi(Pe, this.o), this.v = 0), de && ji(Pe, Pe.length - 4, this.c.d()), this.ondata(Pe, de)
            }, Z
        }();
        y.Zlib = zi;
        var Zi = function() {
            return function(Z, q) {
                Mi([Ot, bi, function() {
                    return [rn, ge, zi]
                }], this, Bn.call(this, Z, q), function(de) {
                    var Pe = new zi(de.data);
                    onmessage = rn(Pe)
                }, 10)
            }
        }();

        function dn(Z, q, de) {
            if (de || (de = q, q = {}), typeof de != "function") throw "no callback";
            return Yi(Z, q, [Ot, bi, function() {
                return [on]
            }], function(Pe) {
                return sn(on(Pe.data[0], Pe.data[1]))
            }, 4, de)
        }

        function on(Z, q) {
            q || (q = {});
            var de = Ne();
            de.p(Z);
            var Pe = Ue(Z, q, 2, 4);
            return qi(Pe, q), ji(Pe, Pe.length - 4, de.d()), Pe
        }
        y.AsyncZlib = Zi, y.zlib = dn, y.zlibSync = on;
        var vn = function() {
            function Z(q) {
                this.v = 1, te.call(this, q)
            }
            return Z.prototype.push = function(q, de) {
                if (te.prototype.e.call(this, q), this.v) {
                    if (this.p.length < 2 && !de) return;
                    this.p = this.p.subarray(2), this.v = 0
                }
                if (de) {
                    if (this.p.length < 4) throw "invalid zlib stream";
                    this.p = this.p.subarray(0, -4)
                }
                te.prototype.c.call(this, de)
            }, Z
        }();
        y.Unzlib = vn;
        var Pn = function() {
            return function(Z) {
                this.ondata = Z, Mi([Le, Qi, function() {
                    return [rn, te, vn]
                }], this, 0, function() {
                    var q = new vn;
                    onmessage = rn(q)
                }, 11)
            }
        }();

        function Fn(Z, q, de) {
            if (de || (de = q, q = {}), typeof de != "function") throw "no callback";
            return Yi(Z, q, [Le, Qi, function() {
                return [kn]
            }], function(Pe) {
                return sn(kn(Pe.data[0], yn(Pe.data[1])))
            }, 5, de)
        }

        function kn(Z, q) {
            return ae((Nn(Z), Z.subarray(2, -4)), q)
        }
        y.AsyncUnzlib = Pn, y.unzlib = Fn, y.unzlibSync = kn;
        var hn = function() {
            function Z(q) {
                this.G = ft, this.I = te, this.Z = vn, this.ondata = q
            }
            return Z.prototype.push = function(q, de) {
                if (!this.ondata) throw "no stream handler";
                if (this.s) this.s.push(q, de);
                else {
                    if (this.p && this.p.length) {
                        var Pe = new V(this.p.length + q.length);
                        Pe.set(this.p), Pe.set(q, this.p.length)
                    } else this.p = q;
                    if (this.p.length > 2) {
                        var Et = this,
                            Ft = function() {
                                Et.ondata.apply(Et, arguments)
                            };
                        this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(Ft) : (15 & this.p[0]) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(Ft) : new this.Z(Ft), this.s.push(this.p, de), this.p = null
                    }
                }
            }, Z
        }();
        y.Decompress = hn;
        var Vn = function() {
            function Z(q) {
                this.G = Jt, this.I = he, this.Z = Pn, this.ondata = q
            }
            return Z.prototype.push = function(q, de) {
                hn.prototype.push.call(this, q, de)
            }, Z
        }();

        function Gn(Z, q, de) {
            if (de || (de = q, q = {}), typeof de != "function") throw "no callback";
            return Z[0] == 31 && Z[1] == 139 && Z[2] == 8 ? zt(Z, q, de) : (15 & Z[0]) != 8 || Z[0] >> 4 > 7 || (Z[0] << 8 | Z[1]) % 31 ? fe(Z, q, de) : Fn(Z, q, de)
        }

        function zr(Z, q) {
            return Z[0] == 31 && Z[1] == 139 && Z[2] == 8 ? It(Z, q) : (15 & Z[0]) != 8 || Z[0] >> 4 > 7 || (Z[0] << 8 | Z[1]) % 31 ? Ae(Z, q) : kn(Z, q)
        }
        y.AsyncDecompress = Vn, y.decompress = Gn, y.decompressSync = zr;
        var br = function(Z, q, de, Pe) {
                for (var Et in Z) {
                    var Ft = Z[Et],
                        _t = q + Et;
                    Ft instanceof V ? de[_t] = [Ft, Pe] : Array.isArray(Ft) ? de[_t] = [Ft[0], Oe(Pe, Ft[1])] : br(Ft, _t + "/", de, Pe)
                }
            },
            ur = typeof TextEncoder != "undefined" && new TextEncoder,
            wr = typeof TextDecoder != "undefined" && new TextDecoder,
            Ui = 0;
        try {
            wr.decode(ei, {
                stream: !0
            }), Ui = 1
        } catch (Z) {}
        var ya = function(Z) {
                for (var q = "", de = 0;;) {
                    var Pe = Z[de++],
                        Et = (Pe > 127) + (Pe > 223) + (Pe > 239);
                    if (de + Et > Z.length) return [q, K(Z, de - 1)];
                    Et ? Et == 3 ? (Pe = ((15 & Pe) << 18 | (63 & Z[de++]) << 12 | (63 & Z[de++]) << 6 | 63 & Z[de++]) - 65536, q += String.fromCharCode(55296 | Pe >> 10, 56320 | 1023 & Pe)) : q += String.fromCharCode(1 & Et ? (31 & Pe) << 6 | 63 & Z[de++] : (15 & Pe) << 12 | (63 & Z[de++]) << 6 | 63 & Z[de++]) : q += String.fromCharCode(Pe)
                }
            },
            _n = function() {
                function Z(q) {
                    this.ondata = q, Ui ? this.t = new TextDecoder : this.p = ei
                }
                return Z.prototype.push = function(q, de) {
                    if (!this.ondata) throw "no callback";
                    if (de || (de = !1), this.t) return this.ondata(this.t.decode(q, {
                        stream: !de
                    }), de);
                    var Pe = new V(this.p.length + q.length);
                    Pe.set(this.p), Pe.set(q, this.p.length);
                    var Et = ya(Pe),
                        Ft = Et[0],
                        _t = Et[1];
                    if (de && _t.length) throw "invalid utf-8 data";
                    this.p = _t, this.ondata(Ft, de)
                }, Z
            }();
        y.DecodeUTF8 = _n;
        var Qs = function() {
            function Z(q) {
                this.ondata = q
            }
            return Z.prototype.push = function(q, de) {
                if (!this.ondata) throw "no callback";
                this.ondata(Ra(q), de || !1)
            }, Z
        }();

        function Ra(Z, q) {
            if (q) {
                for (var de = new V(Z.length), Pe = 0; Pe < Z.length; ++Pe) de[Pe] = Z.charCodeAt(Pe);
                return de
            }
            if (ur) return ur.encode(Z);
            var Et = Z.length,
                Ft = new V(Z.length + (Z.length >> 1)),
                _t = 0,
                Yt = function(re) {
                    Ft[_t++] = re
                };
            for (Pe = 0; Pe < Et; ++Pe) {
                if (_t + 5 > Ft.length) {
                    var J = new V(_t + 8 + (Et - Pe << 1));
                    J.set(Ft), Ft = J
                }
                var W = Z.charCodeAt(Pe);
                W < 128 || q ? Yt(W) : W < 2048 ? (Yt(192 | W >>> 6), Yt(128 | 63 & W)) : W > 55295 && W < 57344 ? (Yt(240 | (W = 65536 + (1047552 & W) | 1023 & Z.charCodeAt(++Pe)) >>> 18), Yt(128 | W >>> 12 & 63), Yt(128 | W >>> 6 & 63), Yt(128 | 63 & W)) : (Yt(224 | W >>> 12), Yt(128 | W >>> 6 & 63), Yt(128 | 63 & W))
            }
            return K(Ft, 0, _t)
        }

        function rr(Z, q) {
            if (q) {
                for (var de = "", Pe = 0; Pe < Z.length; Pe += 16384) de += String.fromCharCode.apply(null, Z.subarray(Pe, Pe + 16384));
                return de
            }
            if (wr) return wr.decode(Z);
            var Et = ya(Z);
            if (Et[1].length) throw "invalid utf-8 data";
            return Et[0]
        }
        y.EncodeUTF8 = Qs, y.strToU8 = Ra, y.strFromU8 = rr;
        var Fr = function(Z) {
                return Z == 1 ? 3 : Z < 6 ? 2 : Z == 9 ? 1 : 0
            },
            Lr = function(Z, q) {
                return q + 30 + Ht(Z, q + 26) + Ht(Z, q + 28)
            },
            ra = function(Z, q, de) {
                var Pe = Ht(Z, q + 28),
                    Et = rr(Z.subarray(q + 46, q + 46 + Pe), !(2048 & Ht(Z, q + 8))),
                    Ft = q + 46 + Pe,
                    _t = Pt(Z, q + 20),
                    Yt = de && _t == 4294967295 ? $r(Z, Ft) : [_t, Pt(Z, q + 24), Pt(Z, q + 42)],
                    J = Yt[0],
                    W = Yt[1],
                    re = Yt[2];
                return [Ht(Z, q + 10), J, W, Et, Ft + Ht(Z, q + 30) + Ht(Z, q + 32), re]
            },
            $r = function(Z, q) {
                for (; Ht(Z, q) != 1; q += 4 + Ht(Z, q + 2));
                return [qn(Z, q + 12), qn(Z, q + 4), qn(Z, q + 20)]
            },
            gr = function(Z) {
                var q = 0;
                if (Z)
                    for (var de in Z) {
                        var Pe = Z[de].length;
                        if (Pe > 65535) throw "extra field too long";
                        q += Pe + 4
                    }
                return q
            },
            Jr = function(Z, q, de, Pe, Et, Ft, _t, Yt) {
                var J = Pe.length,
                    W = de.extra,
                    re = Yt && Yt.length,
                    ye = gr(W);
                ji(Z, q, _t != null ? 33639248 : 67324752), q += 4, _t != null && (Z[q++] = 20, Z[q++] = de.os), Z[q] = 20, q += 2, Z[q++] = de.flag << 1 | (Ft == null && 8), Z[q++] = Et && 8, Z[q++] = 255 & de.compression, Z[q++] = de.compression >> 8;
                var me = new Date(de.mtime == null ? Date.now() : de.mtime),
                    rt = me.getFullYear() - 1980;
                if (rt < 0 || rt > 119) throw "date not in range 1980-2099";
                if (ji(Z, q, 2 * (rt << 24) | me.getMonth() + 1 << 21 | me.getDate() << 16 | me.getHours() << 11 | me.getMinutes() << 5 | me.getSeconds() >>> 1), q += 4, Ft != null && (ji(Z, q, de.crc), ji(Z, q + 4, Ft), ji(Z, q + 8, de.size)), ji(Z, q + 12, J), ji(Z, q + 14, ye), q += 16, _t != null && (ji(Z, q, re), ji(Z, q + 6, de.attrs), ji(Z, q + 10, _t), q += 14), Z.set(Pe, q), q += J, ye)
                    for (var At in W) {
                        var Mt = W[At],
                            si = Mt.length;
                        ji(Z, q, +At), ji(Z, q + 2, si), Z.set(Mt, q + 4), q += 4 + si
                    }
                return re && (Z.set(Yt, q), q += re), q
            },
            or = function(Z, q, de, Pe, Et) {
                ji(Z, q, 101010256), ji(Z, q + 8, de), ji(Z, q + 10, de), ji(Z, q + 12, Pe), ji(Z, q + 16, Et)
            },
            wa = function() {
                function Z(q) {
                    this.filename = q, this.c = ve(), this.size = 0, this.compression = 0
                }
                return Z.prototype.process = function(q, de) {
                    this.ondata(null, q, de)
                }, Z.prototype.push = function(q, de) {
                    if (!this.ondata) throw "no callback - add to ZIP archive before pushing";
                    this.c.p(q), this.size += q.length, de && (this.crc = this.c.d()), this.process(q, de || !1)
                }, Z
            }();
        y.ZipPassThrough = wa;
        var la = function() {
            function Z(q, de) {
                var Pe = this;
                de || (de = {}), wa.call(this, q), this.d = new ge(de, function(Et, Ft) {
                    Pe.ondata(null, Et, Ft)
                }), this.compression = 8, this.flag = Fr(de.level)
            }
            return Z.prototype.process = function(q, de) {
                try {
                    this.d.push(q, de)
                } catch (Pe) {
                    this.ondata(Pe, null, de)
                }
            }, Z.prototype.push = function(q, de) {
                wa.prototype.push.call(this, q, de)
            }, Z
        }();
        y.ZipDeflate = la;
        var Ln = function() {
            function Z(q, de) {
                var Pe = this;
                de || (de = {}), wa.call(this, q), this.d = new ga(de, function(Et, Ft, _t) {
                    Pe.ondata(Et, Ft, _t)
                }), this.compression = 8, this.flag = Fr(de.level), this.terminate = this.d.terminate
            }
            return Z.prototype.process = function(q, de) {
                this.d.push(q, de)
            }, Z.prototype.push = function(q, de) {
                wa.prototype.push.call(this, q, de)
            }, Z
        }();
        y.AsyncZipDeflate = Ln;
        var ja = function() {
            function Z(q) {
                this.ondata = q, this.u = [], this.d = 1
            }
            return Z.prototype.add = function(q) {
                var de = this;
                if (2 & this.d) throw "stream finished";
                var Pe = Ra(q.filename),
                    Et = Pe.length,
                    Ft = q.comment,
                    _t = Ft && Ra(Ft),
                    Yt = Et != q.filename.length || _t && Ft.length != _t.length,
                    J = Et + gr(q.extra) + 30;
                if (Et > 65535) throw "filename too long";
                var W = new V(J);
                Jr(W, 0, q, Pe, Yt);
                var re = [W],
                    ye = function() {
                        for (var si = 0, ti = re; si < ti.length; si++) de.ondata(null, ti[si], !1);
                        re = []
                    },
                    me = this.d;
                this.d = 0;
                var rt = this.u.length,
                    At = Oe(q, {
                        f: Pe,
                        u: Yt,
                        o: _t,
                        t: function() {
                            q.terminate && q.terminate()
                        },
                        r: function() {
                            if (ye(), me) {
                                var si = de.u[rt + 1];
                                si ? si.r() : de.d = 1
                            }
                            me = 1
                        }
                    }),
                    Mt = 0;
                q.ondata = function(si, ti, ni) {
                    if (si) de.ondata(si, ti, ni), de.terminate();
                    else if (Mt += ti.length, re.push(ti), ni) {
                        var ri = new V(16);
                        ji(ri, 0, 134695760), ji(ri, 4, q.crc), ji(ri, 8, Mt), ji(ri, 12, q.size), re.push(ri), At.c = Mt, At.b = J + Mt + 16, At.crc = q.crc, At.size = q.size, me && At.r(), me = 1
                    } else me && ye()
                }, this.u.push(At)
            }, Z.prototype.end = function() {
                var q = this;
                if (2 & this.d) throw 1 & this.d ? "stream finishing" : "stream finished";
                this.d ? this.e() : this.u.push({
                    r: function() {
                        1 & q.d && (q.u.splice(-1, 1), q.e())
                    },
                    t: function() {}
                }), this.d = 3
            }, Z.prototype.e = function() {
                for (var q = 0, de = 0, Pe = 0, Et = 0, Ft = this.u; Et < Ft.length; Et++) Pe += 46 + (W = Ft[Et]).f.length + gr(W.extra) + (W.o ? W.o.length : 0);
                for (var _t = new V(Pe + 22), Yt = 0, J = this.u; Yt < J.length; Yt++) {
                    var W;
                    Jr(_t, q, W = J[Yt], W.f, W.u, W.c, de, W.o), q += 46 + W.f.length + gr(W.extra) + (W.o ? W.o.length : 0), de += W.b
                }
                or(_t, q, this.u.length, Pe, de), this.ondata(null, _t, !0), this.d = 2
            }, Z.prototype.terminate = function() {
                for (var q = 0, de = this.u; q < de.length; q++) de[q].t();
                this.d = 2
            }, Z
        }();

        function Nr(Z, q, de) {
            if (de || (de = q, q = {}), typeof de != "function") throw "no callback";
            var Pe = {};
            br(Z, "", Pe, q);
            var Et = Object.keys(Pe),
                Ft = Et.length,
                _t = 0,
                Yt = 0,
                J = Ft,
                W = Array(Ft),
                re = [],
                ye = function() {
                    for (var Mt = 0; Mt < re.length; ++Mt) re[Mt]()
                },
                me = function() {
                    var Mt = new V(Yt + 22),
                        si = _t,
                        ti = Yt - _t;
                    Yt = 0;
                    for (var ni = 0; ni < J; ++ni) {
                        var ri = W[ni];
                        try {
                            var Wi = ri.c.length;
                            Jr(Mt, Yt, ri, ri.f, ri.u, Wi);
                            var Ci = 30 + ri.f.length + gr(ri.extra),
                                Pi = Yt + Ci;
                            Mt.set(ri.c, Pi), Jr(Mt, _t, ri, ri.f, ri.u, Wi, Yt, ri.m), _t += 16 + Ci + (ri.m ? ri.m.length : 0), Yt = Pi + Wi
                        } catch (ai) {
                            return de(ai, null)
                        }
                    }
                    or(Mt, _t, W.length, ti, si), de(null, Mt)
                };
            Ft || me();
            for (var rt = function(Mt) {
                    var si = Et[Mt],
                        ti = Pe[si],
                        ni = ti[0],
                        ri = ti[1],
                        Wi = ve(),
                        Ci = ni.length;
                    Wi.p(ni);
                    var Pi = Ra(si),
                        ai = Pi.length,
                        Rt = ri.comment,
                        Gi = Rt && Ra(Rt),
                        ki = Gi && Gi.length,
                        pn = gr(ri.extra),
                        pi = ri.level == 0 ? 0 : 8,
                        Hi = function(en, Bi) {
                            if (en) ye(), de(en, null);
                            else {
                                var Xi = Bi.length;
                                W[Mt] = Oe(ri, {
                                    size: Ci,
                                    crc: Wi.d(),
                                    c: Bi,
                                    f: Pi,
                                    m: Gi,
                                    u: ai != si.length || Gi && Rt.length != ki,
                                    compression: pi
                                }), _t += 30 + ai + pn + Xi, Yt += 76 + 2 * (ai + pn) + (ki || 0) + Xi, --Ft || me()
                            }
                        };
                    if (ai > 65535 && Hi("filename too long", null), pi)
                        if (Ci < 16e4) try {
                            Hi(null, Te(ni, ri))
                        } catch (en) {
                            Hi(en, null)
                        } else re.push(On(ni, ri, Hi));
                        else Hi(null, ni)
                }, At = 0; At < J; ++At) rt(At);
            return ye
        }

        function Ps(Z, q) {
            q || (q = {});
            var de = {},
                Pe = [];
            br(Z, "", de, q);
            var Et = 0,
                Ft = 0;
            for (var _t in de) {
                var Yt = de[_t],
                    J = Yt[0],
                    W = Yt[1],
                    re = W.level == 0 ? 0 : 8,
                    ye = (ai = Ra(_t)).length,
                    me = W.comment,
                    rt = me && Ra(me),
                    At = rt && rt.length,
                    Mt = gr(W.extra);
                if (ye > 65535) throw "filename too long";
                var si = re ? Te(J, W) : J,
                    ti = si.length,
                    ni = ve();
                ni.p(J), Pe.push(Oe(W, {
                    size: J.length,
                    crc: ni.d(),
                    c: si,
                    f: ai,
                    m: rt,
                    u: ye != _t.length || rt && me.length != At,
                    o: Et,
                    compression: re
                })), Et += 30 + ye + Mt + ti, Ft += 76 + 2 * (ye + Mt) + (At || 0) + ti
            }
            for (var ri = new V(Ft + 22), Wi = Et, Ci = Ft - Et, Pi = 0; Pi < Pe.length; ++Pi) {
                var ai;
                Jr(ri, (ai = Pe[Pi]).o, ai, ai.f, ai.u, ai.c.length);
                var Rt = 30 + ai.f.length + gr(ai.extra);
                ri.set(ai.c, ai.o + Rt), Jr(ri, Et, ai, ai.f, ai.u, ai.c.length, ai.o, ai.m), Et += 16 + Rt + (ai.m ? ai.m.length : 0)
            }
            return or(ri, Et, Pe.length, Ci, Wi), ri
        }
        y.Zip = ja, y.zip = Nr, y.zipSync = Ps;
        var va = function() {
            function Z() {}
            return Z.prototype.push = function(q, de) {
                this.ondata(null, q, de)
            }, Z.compression = 0, Z
        }();
        y.UnzipPassThrough = va;
        var $n = function() {
            function Z() {
                var q = this;
                this.i = new te(function(de, Pe) {
                    q.ondata(null, de, Pe)
                })
            }
            return Z.prototype.push = function(q, de) {
                try {
                    this.i.push(q, de)
                } catch (Pe) {
                    this.ondata(Pe, q, de)
                }
            }, Z.compression = 8, Z
        }();
        y.UnzipInflate = $n;
        var Qn = function() {
            function Z(q, de) {
                var Pe = this;
                de < 32e4 ? this.i = new te(function(Et, Ft) {
                    Pe.ondata(null, Et, Ft)
                }) : (this.i = new he(function(Et, Ft, _t) {
                    Pe.ondata(Et, Ft, _t)
                }), this.terminate = this.i.terminate)
            }
            return Z.prototype.push = function(q, de) {
                this.i.terminate && (q = K(q, 0)), this.i.push(q, de)
            }, Z.compression = 8, Z
        }();
        y.AsyncUnzipInflate = Qn;
        var os = function() {
            function Z(q) {
                this.onfile = q, this.k = [], this.o = {
                    0: va
                }, this.p = ei
            }
            return Z.prototype.push = function(q, de) {
                var Pe = this;
                if (!this.onfile) throw "no callback";
                if (this.c > 0) {
                    var Et = Math.min(this.c, q.length),
                        Ft = q.subarray(0, Et);
                    if (this.c -= Et, this.d ? this.d.push(Ft, !this.c) : this.k[0].push(Ft), (q = q.subarray(Et)).length) return this.push(q, de)
                } else {
                    var _t = 0,
                        Yt = 0,
                        J = void 0,
                        W = void 0;
                    this.p.length ? q.length ? ((W = new V(this.p.length + q.length)).set(this.p), W.set(q, this.p.length)) : W = this.p : W = q;
                    for (var re = W.length, ye = this.c, me = ye && this.d, rt = function() {
                            var si, ti = Pt(W, Yt);
                            if (ti == 67324752) {
                                _t = 1, J = Yt, At.d = null, At.c = 0;
                                var ni = Ht(W, Yt + 6),
                                    ri = Ht(W, Yt + 8),
                                    Wi = 2048 & ni,
                                    Ci = 8 & ni,
                                    Pi = Ht(W, Yt + 26),
                                    ai = Ht(W, Yt + 28);
                                if (re > Yt + 30 + Pi + ai) {
                                    var Rt = [];
                                    At.k.unshift(Rt), _t = 2;
                                    var Gi = Pt(W, Yt + 18),
                                        ki = Pt(W, Yt + 22),
                                        pn = rr(W.subarray(Yt + 30, Yt += 30 + Pi), !Wi);
                                    Gi == 4294967295 ? (si = Ci ? [-2] : $r(W, Yt), Gi = si[0], ki = si[1]) : Ci && (Gi = -1), Yt += ai, At.c = Gi;
                                    var pi = {
                                        name: pn,
                                        compression: ri,
                                        start: function() {
                                            if (!pi.ondata) throw "no callback";
                                            if (Gi) {
                                                var Hi = Pe.o[ri];
                                                if (!Hi) throw "unknown compression type " + ri;
                                                var en = Gi < 0 ? new Hi(pn) : new Hi(pn, Gi, ki);
                                                en.ondata = function(Un, lr, Qr) {
                                                    pi.ondata(Un, lr, Qr)
                                                };
                                                for (var Bi = 0, Xi = Rt; Bi < Xi.length; Bi++) en.push(Xi[Bi], !1);
                                                Pe.k[0] == Rt ? Pe.d = en : en.push(ei, !0)
                                            } else pi.ondata(null, ei, !0)
                                        },
                                        terminate: function() {
                                            Pe.k[0] == Rt && Pe.d.terminate && Pe.d.terminate()
                                        }
                                    };
                                    Gi >= 0 && (pi.size = Gi, pi.originalSize = ki), At.onfile(pi)
                                }
                                return "break"
                            }
                            if (ye) {
                                if (ti == 134695760) return J = Yt += 12 + (ye == -2 && 8), _t = 2, At.c = 0, "break";
                                if (ti == 33639248) return J = Yt -= 4, _t = 2, At.c = 0, "break"
                            }
                        }, At = this; Yt < re - 4 && rt() !== "break"; ++Yt);
                    if (this.p = ei, ye < 0) {
                        var Mt = W.subarray(0, _t ? J - 12 - (ye == -2 && 8) - (Pt(W, J - 16) == 134695760 && 4) : Yt);
                        me ? me.push(Mt, !!_t) : this.k[+(_t == 2)].push(Mt)
                    }
                    if (2 & _t) return this.push(W.subarray(Yt), de);
                    this.p = W.subarray(Yt)
                }
                if (de && this.c) throw "invalid zip file"
            }, Z.prototype.register = function(q) {
                this.o[q.compression] = q
            }, Z
        }();

        function Va(Z, q) {
            if (typeof q != "function") throw "no callback";
            for (var de = [], Pe = function() {
                    for (var me = 0; me < de.length; ++me) de[me]()
                }, Et = {}, Ft = Z.length - 22; Pt(Z, Ft) != 101010256; --Ft)
                if (!Ft || Z.length - Ft > 65558) return void q("invalid zip file", null);
            var _t = Ht(Z, Ft + 8);
            _t || q(null, {});
            var Yt = _t,
                J = Pt(Z, Ft + 16),
                W = J == 4294967295;
            if (W) {
                if (Ft = Pt(Z, Ft - 12), Pt(Z, Ft) != 101075792) return void q("invalid zip file", null);
                Yt = _t = Pt(Z, Ft + 32), J = Pt(Z, Ft + 48)
            }
            for (var re = function(me) {
                    var rt = ra(Z, J, W),
                        At = rt[0],
                        Mt = rt[1],
                        si = rt[2],
                        ti = rt[3],
                        ni = rt[4],
                        ri = Lr(Z, rt[5]);
                    J = ni;
                    var Wi = function(Pi, ai) {
                        Pi ? (Pe(), q(Pi, null)) : (Et[ti] = ai, --_t || q(null, Et))
                    };
                    if (At)
                        if (At == 8) {
                            var Ci = Z.subarray(ri, ri + Mt);
                            if (Mt < 32e4) try {
                                Wi(null, Ae(Ci, new V(si)))
                            } catch (Pi) {
                                Wi(Pi, null)
                            } else de.push(fe(Ci, {
                                size: si
                            }, Wi))
                        } else Wi("unknown compression type " + At, null);
                    else Wi(null, K(Z, ri, ri + Mt))
                }, ye = 0; ye < Yt; ++ye) re();
            return Pe
        }

        function Da(Z) {
            for (var q = {}, de = Z.length - 22; Pt(Z, de) != 101010256; --de)
                if (!de || Z.length - de > 65558) throw "invalid zip file";
            var Pe = Ht(Z, de + 8);
            if (!Pe) return {};
            var Et = Pt(Z, de + 16),
                Ft = Et == 4294967295;
            if (Ft) {
                if (de = Pt(Z, de - 12), Pt(Z, de) != 101075792) throw "invalid zip file";
                Pe = Pt(Z, de + 32), Et = Pt(Z, de + 48)
            }
            for (var _t = 0; _t < Pe; ++_t) {
                var Yt = ra(Z, Et, Ft),
                    J = Yt[0],
                    W = Yt[1],
                    re = Yt[2],
                    ye = Yt[3],
                    me = Yt[4],
                    rt = Lr(Z, Yt[5]);
                if (Et = me, J) {
                    if (J != 8) throw "unknown compression type " + J;
                    q[ye] = Ae(Z.subarray(rt, rt + W), new V(re))
                } else q[ye] = K(Z, rt, rt + W)
            }
            return q
        }
        return y.Unzip = os, y.unzip = Va, y.unzipSync = Da, y
    })
})(Pp, Pp.exports);
var dm = Pp.exports;
(function(ue, R) {
    const y = Xa,
        z = dm;
    y.FBXLoader = function() {
        var V, Y, C;

        function p(O) {
            y.Loader.call(this, O)
        }
        p.prototype = Object.assign(Object.create(y.Loader.prototype), {
            constructor: p,
            load: function(O, K, ae, _e) {
                var xe = this,
                    Ze = xe.path === "" ? y.LoaderUtils.extractUrlBase(O) : xe.path,
                    st = new y.FileLoader(this.manager);
                st.setPath(xe.path), st.setResponseType("arraybuffer"), st.setRequestHeader(xe.requestHeader), st.setWithCredentials(xe.withCredentials), st.load(O, function(De) {
                    try {
                        K(xe.parse(De, Ze))
                    } catch (gt) {
                        _e ? _e(gt) : console.error(gt), xe.manager.itemError(O)
                    }
                }, ae, _e)
            },
            parse: function(O, K) {
                if (Je(O)) V = new Ee().parse(O);
                else {
                    var ae = Ei(O);
                    if (!wt(ae)) throw new Error("THREE.FBXLoader: Unknown format.");
                    if (Ke(ae) < 7e3) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + Ke(ae));
                    V = new be().parse(ae)
                }
                var _e = new y.TextureLoader(this.manager).setPath(this.resourcePath || K).setCrossOrigin(this.crossOrigin);
                return new se(_e, this.manager).parse(V)
            }
        });

        function se(O, K) {
            this.textureLoader = O, this.manager = K
        }
        se.prototype = {
            constructor: se,
            parse: function() {
                Y = this.parseConnections();
                var O = this.parseImages(),
                    K = this.parseTextures(O),
                    ae = this.parseMaterials(K),
                    _e = this.parseDeformers(),
                    xe = new ie().parse(_e);
                return this.parseScene(_e, xe, ae), C
            },
            parseConnections: function() {
                var O = new Map;
                if ("Connections" in V) {
                    var K = V.Connections.connections;
                    K.forEach(function(ae) {
                        var _e = ae[0],
                            xe = ae[1],
                            Ze = ae[2];
                        O.has(_e) || O.set(_e, {
                            parents: [],
                            children: []
                        });
                        var st = {
                            ID: xe,
                            relationship: Ze
                        };
                        O.get(_e).parents.push(st), O.has(xe) || O.set(xe, {
                            parents: [],
                            children: []
                        });
                        var De = {
                            ID: _e,
                            relationship: Ze
                        };
                        O.get(xe).children.push(De)
                    })
                }
                return O
            },
            parseImages: function() {
                var O = {},
                    K = {};
                if ("Video" in V.Objects) {
                    var ae = V.Objects.Video;
                    for (var _e in ae) {
                        var xe = ae[_e],
                            Ze = parseInt(_e);
                        if (O[Ze] = xe.RelativeFilename || xe.Filename, "Content" in xe) {
                            var st = xe.Content instanceof ArrayBuffer && xe.Content.byteLength > 0,
                                De = typeof xe.Content == "string" && xe.Content !== "";
                            if (st || De) {
                                var gt = this.parseImage(ae[_e]);
                                K[xe.RelativeFilename || xe.Filename] = gt
                            }
                        }
                    }
                }
                for (var Ze in O) {
                    var Qt = O[Ze];
                    K[Qt] !== void 0 ? O[Ze] = K[Qt] : O[Ze] = O[Ze].split("\\").pop()
                }
                return O
            },
            parseImage: function(O) {
                var K = O.Content,
                    ae = O.RelativeFilename || O.Filename,
                    _e = ae.slice(ae.lastIndexOf(".") + 1).toLowerCase(),
                    xe;
                switch (_e) {
                    case "bmp":
                        xe = "image/bmp";
                        break;
                    case "jpg":
                    case "jpeg":
                        xe = "image/jpeg";
                        break;
                    case "png":
                        xe = "image/png";
                        break;
                    case "tif":
                        xe = "image/tiff";
                        break;
                    case "tga":
                        this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", ae), xe = "image/tga";
                        break;
                    default:
                        console.warn('FBXLoader: Image type "' + _e + '" is not supported.');
                        return
                }
                if (typeof K == "string") return "data:" + xe + ";base64," + K;
                var Ze = new Uint8Array(K);
                return window.URL.createObjectURL(new Blob([Ze], {
                    type: xe
                }))
            },
            parseTextures: function(O) {
                var K = new Map;
                if ("Texture" in V.Objects) {
                    var ae = V.Objects.Texture;
                    for (var _e in ae) {
                        var xe = this.parseTexture(ae[_e], O);
                        K.set(parseInt(_e), xe)
                    }
                }
                return K
            },
            parseTexture: function(O, K) {
                var ae = this.loadTexture(O, K);
                ae.ID = O.id, ae.name = O.attrName;
                var _e = O.WrapModeU,
                    xe = O.WrapModeV,
                    Ze = _e !== void 0 ? _e.value : 0,
                    st = xe !== void 0 ? xe.value : 0;
                if (ae.wrapS = Ze === 0 ? y.RepeatWrapping : y.ClampToEdgeWrapping, ae.wrapT = st === 0 ? y.RepeatWrapping : y.ClampToEdgeWrapping, "Scaling" in O) {
                    var De = O.Scaling.value;
                    ae.repeat.x = De[0], ae.repeat.y = De[1]
                }
                return ae
            },
            loadTexture: function(O, K) {
                var ae, _e = this.textureLoader.path,
                    xe = Y.get(O.id).children;
                xe !== void 0 && xe.length > 0 && K[xe[0].ID] !== void 0 && (ae = K[xe[0].ID], (ae.indexOf("blob:") === 0 || ae.indexOf("data:") === 0) && this.textureLoader.setPath(void 0));
                var Ze, st = O.FileName.slice(-3).toLowerCase();
                if (st === "tga") {
                    var De = this.manager.getHandler(".tga");
                    De === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", O.RelativeFilename), Ze = new y.Texture) : Ze = De.load(ae)
                } else st === "psd" ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", O.RelativeFilename), Ze = new y.Texture) : Ze = this.textureLoader.load(ae);
                return this.textureLoader.setPath(_e), Ze
            },
            parseMaterials: function(O) {
                var K = new Map;
                if ("Material" in V.Objects) {
                    var ae = V.Objects.Material;
                    for (var _e in ae) {
                        var xe = this.parseMaterial(ae[_e], O);
                        xe !== null && K.set(parseInt(_e), xe)
                    }
                }
                return K
            },
            parseMaterial: function(O, K) {
                var ae = O.id,
                    _e = O.attrName,
                    xe = O.ShadingModel;
                if (typeof xe == "object" && (xe = xe.value), !Y.has(ae)) return null;
                var Ze = this.parseParameters(O, K, ae),
                    st;
                switch (xe.toLowerCase()) {
                    case "phong":
                        st = new y.MeshPhongMaterial;
                        break;
                    case "lambert":
                        st = new y.MeshLambertMaterial;
                        break;
                    default:
                        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', xe), st = new y.MeshPhongMaterial;
                        break
                }
                return st.setValues(Ze), st.name = _e, st
            },
            parseParameters: function(O, K, ae) {
                var _e = {};
                O.BumpFactor && (_e.bumpScale = O.BumpFactor.value), O.Diffuse ? _e.color = new y.Color().fromArray(O.Diffuse.value) : O.DiffuseColor && (O.DiffuseColor.type === "Color" || O.DiffuseColor.type === "ColorRGB") && (_e.color = new y.Color().fromArray(O.DiffuseColor.value)), O.DisplacementFactor && (_e.displacementScale = O.DisplacementFactor.value), O.Emissive ? _e.emissive = new y.Color().fromArray(O.Emissive.value) : O.EmissiveColor && (O.EmissiveColor.type === "Color" || O.EmissiveColor.type === "ColorRGB") && (_e.emissive = new y.Color().fromArray(O.EmissiveColor.value)), O.EmissiveFactor && (_e.emissiveIntensity = parseFloat(O.EmissiveFactor.value)), O.Opacity && (_e.opacity = parseFloat(O.Opacity.value)), _e.opacity < 1 && (_e.transparent = !0), O.ReflectionFactor && (_e.reflectivity = O.ReflectionFactor.value), O.Shininess && (_e.shininess = O.Shininess.value), O.Specular ? _e.specular = new y.Color().fromArray(O.Specular.value) : O.SpecularColor && O.SpecularColor.type === "Color" && (_e.specular = new y.Color().fromArray(O.SpecularColor.value));
                var xe = this;
                return Y.get(ae).children.forEach(function(Ze) {
                    var st = Ze.relationship;
                    switch (st) {
                        case "Bump":
                            _e.bumpMap = xe.getTexture(K, Ze.ID);
                            break;
                        case "Maya|TEX_ao_map":
                            _e.aoMap = xe.getTexture(K, Ze.ID);
                            break;
                        case "DiffuseColor":
                        case "Maya|TEX_color_map":
                            _e.map = xe.getTexture(K, Ze.ID), _e.map.encoding = y.sRGBEncoding;
                            break;
                        case "DisplacementColor":
                            _e.displacementMap = xe.getTexture(K, Ze.ID);
                            break;
                        case "EmissiveColor":
                            _e.emissiveMap = xe.getTexture(K, Ze.ID), _e.emissiveMap.encoding = y.sRGBEncoding;
                            break;
                        case "NormalMap":
                        case "Maya|TEX_normal_map":
                            _e.normalMap = xe.getTexture(K, Ze.ID);
                            break;
                        case "ReflectionColor":
                            _e.envMap = xe.getTexture(K, Ze.ID), _e.envMap.mapping = y.EquirectangularReflectionMapping, _e.envMap.encoding = y.sRGBEncoding;
                            break;
                        case "SpecularColor":
                            _e.specularMap = xe.getTexture(K, Ze.ID), _e.specularMap.encoding = y.sRGBEncoding;
                            break;
                        case "TransparentColor":
                        case "TransparencyFactor":
                            _e.alphaMap = xe.getTexture(K, Ze.ID), _e.transparent = !0;
                            break;
                        case "AmbientColor":
                        case "ShininessExponent":
                        case "SpecularFactor":
                        case "VectorDisplacementColor":
                        default:
                            console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", st);
                            break
                    }
                }), _e
            },
            getTexture: function(O, K) {
                return "LayeredTexture" in V.Objects && K in V.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), K = Y.get(K).children[0].ID), O.get(K)
            },
            parseDeformers: function() {
                var O = {},
                    K = {};
                if ("Deformer" in V.Objects) {
                    var ae = V.Objects.Deformer;
                    for (var _e in ae) {
                        var xe = ae[_e],
                            Ze = Y.get(parseInt(_e));
                        if (xe.attrType === "Skin") {
                            var st = this.parseSkeleton(Ze, ae);
                            st.ID = _e, Ze.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), st.geometryID = Ze.parents[0].ID, O[_e] = st
                        } else if (xe.attrType === "BlendShape") {
                            var De = {
                                id: _e
                            };
                            De.rawTargets = this.parseMorphTargets(Ze, ae), De.id = _e, Ze.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), K[_e] = De
                        }
                    }
                }
                return {
                    skeletons: O,
                    morphTargets: K
                }
            },
            parseSkeleton: function(O, K) {
                var ae = [];
                return O.children.forEach(function(_e) {
                    var xe = K[_e.ID];
                    if (xe.attrType === "Cluster") {
                        var Ze = {
                            ID: _e.ID,
                            indices: [],
                            weights: [],
                            transformLink: new y.Matrix4().fromArray(xe.TransformLink.a)
                        };
                        "Indexes" in xe && (Ze.indices = xe.Indexes.a, Ze.weights = xe.Weights.a), ae.push(Ze)
                    }
                }), {
                    rawBones: ae,
                    bones: []
                }
            },
            parseMorphTargets: function(O, K) {
                for (var ae = [], _e = 0; _e < O.children.length; _e++) {
                    var xe = O.children[_e],
                        Ze = K[xe.ID],
                        st = {
                            name: Ze.attrName,
                            initialWeight: Ze.DeformPercent,
                            id: Ze.id,
                            fullWeights: Ze.FullWeights.a
                        };
                    if (Ze.attrType !== "BlendShapeChannel") return;
                    st.geoID = Y.get(parseInt(xe.ID)).children.filter(function(De) {
                        return De.relationship === void 0
                    })[0].ID, ae.push(st)
                }
                return ae
            },
            parseScene: function(O, K, ae) {
                C = new y.Group;
                var _e = this.parseModels(O.skeletons, K, ae),
                    xe = V.Objects.Model,
                    Ze = this;
                _e.forEach(function(De) {
                    var gt = xe[De.ID];
                    Ze.setLookAtProperties(De, gt);
                    var Qt = Y.get(De.ID).parents;
                    Qt.forEach(function(Ve) {
                        var Dt = _e.get(Ve.ID);
                        Dt !== void 0 && Dt.add(De)
                    }), De.parent === null && C.add(De)
                }), this.bindSkeleton(O.skeletons, K, _e), this.createAmbientLight(), this.setupMorphMaterials(), C.traverse(function(De) {
                    if (De.userData.transformData) {
                        De.parent && (De.userData.transformData.parentMatrix = De.parent.matrix, De.userData.transformData.parentMatrixWorld = De.parent.matrixWorld);
                        var gt = Kt(De.userData.transformData);
                        De.applyMatrix4(gt), De.updateWorldMatrix()
                    }
                });
                var st = new He().parse();
                C.children.length === 1 && C.children[0].isGroup && (C.children[0].animations = st, C = C.children[0]), C.animations = st
            },
            parseModels: function(O, K, ae) {
                var _e = new Map,
                    xe = V.Objects.Model;
                for (var Ze in xe) {
                    var st = parseInt(Ze),
                        De = xe[Ze],
                        gt = Y.get(st),
                        Qt = this.buildSkeleton(gt, O, st, De.attrName);
                    if (!Qt) {
                        switch (De.attrType) {
                            case "Camera":
                                Qt = this.createCamera(gt);
                                break;
                            case "Light":
                                Qt = this.createLight(gt);
                                break;
                            case "Mesh":
                                Qt = this.createMesh(gt, K, ae);
                                break;
                            case "NurbsCurve":
                                Qt = this.createCurve(gt, K);
                                break;
                            case "LimbNode":
                            case "Root":
                                Qt = new y.Bone;
                                break;
                            case "Null":
                            default:
                                Qt = new y.Group;
                                break
                        }
                        Qt.name = De.attrName ? y.PropertyBinding.sanitizeNodeName(De.attrName) : "", Qt.ID = st
                    }
                    this.getTransformData(Qt, De), _e.set(st, Qt)
                }
                return _e
            },
            buildSkeleton: function(O, K, ae, _e) {
                var xe = null;
                return O.parents.forEach(function(Ze) {
                    for (var st in K) {
                        var De = K[st];
                        De.rawBones.forEach(function(gt, Qt) {
                            if (gt.ID === Ze.ID) {
                                var Ve = xe;
                                xe = new y.Bone, xe.matrixWorld.copy(gt.transformLink), xe.name = _e ? y.PropertyBinding.sanitizeNodeName(_e) : "", xe.ID = ae, De.bones[Qt] = xe, Ve !== null && xe.add(Ve)
                            }
                        })
                    }
                }), xe
            },
            createCamera: function(O) {
                var K, ae;
                if (O.children.forEach(function(Dt) {
                        var ei = V.Objects.NodeAttribute[Dt.ID];
                        ei !== void 0 && (ae = ei)
                    }), ae === void 0) K = new y.Object3D;
                else {
                    var _e = 0;
                    ae.CameraProjectionType !== void 0 && ae.CameraProjectionType.value === 1 && (_e = 1);
                    var xe = 1;
                    ae.NearPlane !== void 0 && (xe = ae.NearPlane.value / 1e3);
                    var Ze = 1e3;
                    ae.FarPlane !== void 0 && (Ze = ae.FarPlane.value / 1e3);
                    var st = window.innerWidth,
                        De = window.innerHeight;
                    ae.AspectWidth !== void 0 && ae.AspectHeight !== void 0 && (st = ae.AspectWidth.value, De = ae.AspectHeight.value);
                    var gt = st / De,
                        Qt = 45;
                    ae.FieldOfView !== void 0 && (Qt = ae.FieldOfView.value);
                    var Ve = ae.FocalLength ? ae.FocalLength.value : null;
                    switch (_e) {
                        case 0:
                            K = new y.PerspectiveCamera(Qt, gt, xe, Ze), Ve !== null && K.setFocalLength(Ve);
                            break;
                        case 1:
                            K = new y.OrthographicCamera(-st / 2, st / 2, De / 2, -De / 2, xe, Ze);
                            break;
                        default:
                            console.warn("THREE.FBXLoader: Unknown camera type " + _e + "."), K = new y.Object3D;
                            break
                    }
                }
                return K
            },
            createLight: function(O) {
                var K, ae;
                if (O.children.forEach(function(Ve) {
                        var Dt = V.Objects.NodeAttribute[Ve.ID];
                        Dt !== void 0 && (ae = Dt)
                    }), ae === void 0) K = new y.Object3D;
                else {
                    var _e;
                    ae.LightType === void 0 ? _e = 0 : _e = ae.LightType.value;
                    var xe = 16777215;
                    ae.Color !== void 0 && (xe = new y.Color().fromArray(ae.Color.value));
                    var Ze = ae.Intensity === void 0 ? 1 : ae.Intensity.value / 100;
                    ae.CastLightOnObject !== void 0 && ae.CastLightOnObject.value === 0 && (Ze = 0);
                    var st = 0;
                    ae.FarAttenuationEnd !== void 0 && (ae.EnableFarAttenuation !== void 0 && ae.EnableFarAttenuation.value === 0 ? st = 0 : st = ae.FarAttenuationEnd.value);
                    var De = 1;
                    switch (_e) {
                        case 0:
                            K = new y.PointLight(xe, Ze, st, De);
                            break;
                        case 1:
                            K = new y.DirectionalLight(xe, Ze);
                            break;
                        case 2:
                            var gt = Math.PI / 3;
                            ae.InnerAngle !== void 0 && (gt = y.MathUtils.degToRad(ae.InnerAngle.value));
                            var Qt = 0;
                            ae.OuterAngle !== void 0 && (Qt = y.MathUtils.degToRad(ae.OuterAngle.value), Qt = Math.max(Qt, 1)), K = new y.SpotLight(xe, Ze, st, gt, Qt, De);
                            break;
                        default:
                            console.warn("THREE.FBXLoader: Unknown light type " + ae.LightType.value + ", defaulting to a THREE.PointLight."), K = new y.PointLight(xe, Ze);
                            break
                    }
                    ae.CastShadows !== void 0 && ae.CastShadows.value === 1 && (K.castShadow = !0)
                }
                return K
            },
            createMesh: function(O, K, ae) {
                var _e, xe = null,
                    Ze = null,
                    st = [];
                return O.children.forEach(function(De) {
                    K.has(De.ID) && (xe = K.get(De.ID)), ae.has(De.ID) && st.push(ae.get(De.ID))
                }), st.length > 1 ? Ze = st : st.length > 0 ? Ze = st[0] : (Ze = new y.MeshPhongMaterial({
                    color: 13421772
                }), st.push(Ze)), "color" in xe.attributes && st.forEach(function(De) {
                    De.vertexColors = !0
                }), xe.FBX_Deformer ? (st.forEach(function(De) {
                    De.skinning = !0
                }), _e = new y.SkinnedMesh(xe, Ze), _e.normalizeSkinWeights()) : _e = new y.Mesh(xe, Ze), _e
            },
            createCurve: function(O, K) {
                var ae = O.children.reduce(function(xe, Ze) {
                        return K.has(Ze.ID) && (xe = K.get(Ze.ID)), xe
                    }, null),
                    _e = new y.LineBasicMaterial({
                        color: 3342591,
                        linewidth: 1
                    });
                return new y.Line(ae, _e)
            },
            getTransformData: function(O, K) {
                var ae = {};
                "InheritType" in K && (ae.inheritType = parseInt(K.InheritType.value)), "RotationOrder" in K ? ae.eulerOrder = vi(K.RotationOrder.value) : ae.eulerOrder = "ZYX", "Lcl_Translation" in K && (ae.translation = K.Lcl_Translation.value), "PreRotation" in K && (ae.preRotation = K.PreRotation.value), "Lcl_Rotation" in K && (ae.rotation = K.Lcl_Rotation.value), "PostRotation" in K && (ae.postRotation = K.PostRotation.value), "Lcl_Scaling" in K && (ae.scale = K.Lcl_Scaling.value), "ScalingOffset" in K && (ae.scalingOffset = K.ScalingOffset.value), "ScalingPivot" in K && (ae.scalingPivot = K.ScalingPivot.value), "RotationOffset" in K && (ae.rotationOffset = K.RotationOffset.value), "RotationPivot" in K && (ae.rotationPivot = K.RotationPivot.value), O.userData.transformData = ae
            },
            setLookAtProperties: function(O, K) {
                if ("LookAtProperty" in K) {
                    var ae = Y.get(O.ID).children;
                    ae.forEach(function(_e) {
                        if (_e.relationship === "LookAtProperty") {
                            var xe = V.Objects.Model[_e.ID];
                            if ("Lcl_Translation" in xe) {
                                var Ze = xe.Lcl_Translation.value;
                                O.target !== void 0 ? (O.target.position.fromArray(Ze), C.add(O.target)) : O.lookAt(new y.Vector3().fromArray(Ze))
                            }
                        }
                    })
                }
            },
            bindSkeleton: function(O, K, ae) {
                var _e = this.parsePoseNodes();
                for (var xe in O) {
                    var Ze = O[xe],
                        st = Y.get(parseInt(Ze.ID)).parents;
                    st.forEach(function(De) {
                        if (K.has(De.ID)) {
                            var gt = De.ID,
                                Qt = Y.get(gt);
                            Qt.parents.forEach(function(Ve) {
                                if (ae.has(Ve.ID)) {
                                    var Dt = ae.get(Ve.ID);
                                    Dt.bind(new y.Skeleton(Ze.bones), _e[Ve.ID])
                                }
                            })
                        }
                    })
                }
            },
            parsePoseNodes: function() {
                var O = {};
                if ("Pose" in V.Objects) {
                    var K = V.Objects.Pose;
                    for (var ae in K)
                        if (K[ae].attrType === "BindPose") {
                            var _e = K[ae].PoseNode;
                            Array.isArray(_e) ? _e.forEach(function(xe) {
                                O[xe.Node] = new y.Matrix4().fromArray(xe.Matrix.a)
                            }) : O[_e.Node] = new y.Matrix4().fromArray(_e.Matrix.a)
                        }
                }
                return O
            },
            createAmbientLight: function() {
                if ("GlobalSettings" in V && "AmbientColor" in V.GlobalSettings) {
                    var O = V.GlobalSettings.AmbientColor.value,
                        K = O[0],
                        ae = O[1],
                        _e = O[2];
                    if (K !== 0 || ae !== 0 || _e !== 0) {
                        var xe = new y.Color(K, ae, _e);
                        C.add(new y.AmbientLight(xe, 1))
                    }
                }
            },
            setupMorphMaterials: function() {
                var O = this;
                C.traverse(function(K) {
                    K.isMesh && K.geometry.morphAttributes.position && K.geometry.morphAttributes.position.length && (Array.isArray(K.material) ? K.material.forEach(function(ae, _e) {
                        O.setupMorphMaterial(K, ae, _e)
                    }) : O.setupMorphMaterial(K, K.material))
                })
            },
            setupMorphMaterial: function(O, K, ae) {
                var _e = O.uuid,
                    xe = K.uuid,
                    Ze = !1;
                if (C.traverse(function(De) {
                        De.isMesh && (Array.isArray(De.material) ? De.material.forEach(function(gt) {
                            gt.uuid === xe && De.uuid !== _e && (Ze = !0)
                        }) : De.material.uuid === xe && De.uuid !== _e && (Ze = !0))
                    }), Ze === !0) {
                    var st = K.clone();
                    st.morphTargets = !0, ae === void 0 ? O.material = st : O.material[ae] = st
                } else K.morphTargets = !0
            }
        };

        function ie() {}
        ie.prototype = {
            constructor: ie,
            parse: function(O) {
                var K = new Map;
                if ("Geometry" in V.Objects) {
                    var ae = V.Objects.Geometry;
                    for (var _e in ae) {
                        var xe = Y.get(parseInt(_e)),
                            Ze = this.parseGeometry(xe, ae[_e], O);
                        K.set(parseInt(_e), Ze)
                    }
                }
                return K
            },
            parseGeometry: function(O, K, ae) {
                switch (K.attrType) {
                    case "Mesh":
                        return this.parseMeshGeometry(O, K, ae);
                    case "NurbsCurve":
                        return this.parseNurbsGeometry(K)
                }
            },
            parseMeshGeometry: function(O, K, ae) {
                var _e = ae.skeletons,
                    xe = [],
                    Ze = O.parents.map(function(Ve) {
                        return V.Objects.Model[Ve.ID]
                    });
                if (Ze.length !== 0) {
                    var st = O.children.reduce(function(Ve, Dt) {
                        return _e[Dt.ID] !== void 0 && (Ve = _e[Dt.ID]), Ve
                    }, null);
                    O.children.forEach(function(Ve) {
                        ae.morphTargets[Ve.ID] !== void 0 && xe.push(ae.morphTargets[Ve.ID])
                    });
                    var De = Ze[0],
                        gt = {};
                    "RotationOrder" in De && (gt.eulerOrder = vi(De.RotationOrder.value)), "InheritType" in De && (gt.inheritType = parseInt(De.InheritType.value)), "GeometricTranslation" in De && (gt.translation = De.GeometricTranslation.value), "GeometricRotation" in De && (gt.rotation = De.GeometricRotation.value), "GeometricScaling" in De && (gt.scale = De.GeometricScaling.value);
                    var Qt = Kt(gt);
                    return this.genGeometry(K, st, xe, Qt)
                }
            },
            genGeometry: function(O, K, ae, _e) {
                var xe = new y.BufferGeometry;
                O.attrName && (xe.name = O.attrName);
                var Ze = this.parseGeoNode(O, K),
                    st = this.genBuffers(Ze),
                    De = new y.Float32BufferAttribute(st.vertex, 3);
                if (De.applyMatrix4(_e), xe.setAttribute("position", De), st.colors.length > 0 && xe.setAttribute("color", new y.Float32BufferAttribute(st.colors, 3)), K && (xe.setAttribute("skinIndex", new y.Uint16BufferAttribute(st.weightsIndices, 4)), xe.setAttribute("skinWeight", new y.Float32BufferAttribute(st.vertexWeights, 4)), xe.FBX_Deformer = K), st.normal.length > 0) {
                    var gt = new y.Matrix3().getNormalMatrix(_e),
                        Qt = new y.Float32BufferAttribute(st.normal, 3);
                    Qt.applyNormalMatrix(gt), xe.setAttribute("normal", Qt)
                }
                if (st.uvs.forEach(function(oe, ve) {
                        var Ne = "uv" + (ve + 1).toString();
                        ve === 0 && (Ne = "uv"), xe.setAttribute(Ne, new y.Float32BufferAttribute(st.uvs[ve], 2))
                    }), Ze.material && Ze.material.mappingType !== "AllSame") {
                    var Ve = st.materialIndex[0],
                        Dt = 0;
                    if (st.materialIndex.forEach(function(oe, ve) {
                            oe !== Ve && (xe.addGroup(Dt, ve - Dt, Ve), Ve = oe, Dt = ve)
                        }), xe.groups.length > 0) {
                        var ei = xe.groups[xe.groups.length - 1],
                            xi = ei.start + ei.count;
                        xi !== st.materialIndex.length && xe.addGroup(xi, st.materialIndex.length - xi, Ve)
                    }
                    xe.groups.length === 0 && xe.addGroup(0, st.materialIndex.length, st.materialIndex[0])
                }
                return this.addMorphTargets(xe, O, ae, _e), xe
            },
            parseGeoNode: function(O, K) {
                var ae = {};
                if (ae.vertexPositions = O.Vertices !== void 0 ? O.Vertices.a : [], ae.vertexIndices = O.PolygonVertexIndex !== void 0 ? O.PolygonVertexIndex.a : [], O.LayerElementColor && (ae.color = this.parseVertexColors(O.LayerElementColor[0])), O.LayerElementMaterial && (ae.material = this.parseMaterialIndices(O.LayerElementMaterial[0])), O.LayerElementNormal && (ae.normal = this.parseNormals(O.LayerElementNormal[0])), O.LayerElementUV) {
                    ae.uv = [];
                    for (var _e = 0; O.LayerElementUV[_e];) O.LayerElementUV[_e].UV && ae.uv.push(this.parseUVs(O.LayerElementUV[_e])), _e++
                }
                return ae.weightTable = {}, K !== null && (ae.skeleton = K, K.rawBones.forEach(function(xe, Ze) {
                    xe.indices.forEach(function(st, De) {
                        ae.weightTable[st] === void 0 && (ae.weightTable[st] = []), ae.weightTable[st].push({
                            id: Ze,
                            weight: xe.weights[De]
                        })
                    })
                })), ae
            },
            genBuffers: function(O) {
                var K = {
                        vertex: [],
                        normal: [],
                        colors: [],
                        uvs: [],
                        materialIndex: [],
                        vertexWeights: [],
                        weightsIndices: []
                    },
                    ae = 0,
                    _e = 0,
                    xe = !1,
                    Ze = [],
                    st = [],
                    De = [],
                    gt = [],
                    Qt = [],
                    Ve = [],
                    Dt = this;
                return O.vertexIndices.forEach(function(ei, xi) {
                    var oe = !1;
                    ei < 0 && (ei = ei ^ -1, oe = !0);
                    var ve = [],
                        Ne = [];
                    if (Ze.push(ei * 3, ei * 3 + 1, ei * 3 + 2), O.color) {
                        var Ue = di(xi, ae, ei, O.color);
                        De.push(Ue[0], Ue[1], Ue[2])
                    }
                    if (O.skeleton) {
                        if (O.weightTable[ei] !== void 0 && O.weightTable[ei].forEach(function(Bt) {
                                Ne.push(Bt.weight), ve.push(Bt.id)
                            }), Ne.length > 4) {
                            xe || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), xe = !0);
                            var Oe = [0, 0, 0, 0],
                                at = [0, 0, 0, 0];
                            Ne.forEach(function(Bt, Le) {
                                var Ot = Bt,
                                    ii = ve[Le];
                                at.forEach(function(Wt, bi, Qi) {
                                    if (Ot > Wt) {
                                        Qi[bi] = Ot, Ot = Wt;
                                        var sn = Oe[bi];
                                        Oe[bi] = ii, ii = sn
                                    }
                                })
                            }), ve = Oe, Ne = at
                        }
                        for (; Ne.length < 4;) Ne.push(0), ve.push(0);
                        for (var ht = 0; ht < 4; ++ht) Qt.push(Ne[ht]), Ve.push(ve[ht])
                    }
                    if (O.normal) {
                        var Ue = di(xi, ae, ei, O.normal);
                        st.push(Ue[0], Ue[1], Ue[2])
                    }
                    if (O.material && O.material.mappingType !== "AllSame") var tt = di(xi, ae, ei, O.material)[0];
                    O.uv && O.uv.forEach(function(Bt, Le) {
                        var Ot = di(xi, ae, ei, Bt);
                        gt[Le] === void 0 && (gt[Le] = []), gt[Le].push(Ot[0]), gt[Le].push(Ot[1])
                    }), _e++, oe && (Dt.genFace(K, O, Ze, tt, st, De, gt, Qt, Ve, _e), ae++, _e = 0, Ze = [], st = [], De = [], gt = [], Qt = [], Ve = [])
                }), K
            },
            genFace: function(O, K, ae, _e, xe, Ze, st, De, gt, Qt) {
                for (var Ve = 2; Ve < Qt; Ve++) O.vertex.push(K.vertexPositions[ae[0]]), O.vertex.push(K.vertexPositions[ae[1]]), O.vertex.push(K.vertexPositions[ae[2]]), O.vertex.push(K.vertexPositions[ae[(Ve - 1) * 3]]), O.vertex.push(K.vertexPositions[ae[(Ve - 1) * 3 + 1]]), O.vertex.push(K.vertexPositions[ae[(Ve - 1) * 3 + 2]]), O.vertex.push(K.vertexPositions[ae[Ve * 3]]), O.vertex.push(K.vertexPositions[ae[Ve * 3 + 1]]), O.vertex.push(K.vertexPositions[ae[Ve * 3 + 2]]), K.skeleton && (O.vertexWeights.push(De[0]), O.vertexWeights.push(De[1]), O.vertexWeights.push(De[2]), O.vertexWeights.push(De[3]), O.vertexWeights.push(De[(Ve - 1) * 4]), O.vertexWeights.push(De[(Ve - 1) * 4 + 1]), O.vertexWeights.push(De[(Ve - 1) * 4 + 2]), O.vertexWeights.push(De[(Ve - 1) * 4 + 3]), O.vertexWeights.push(De[Ve * 4]), O.vertexWeights.push(De[Ve * 4 + 1]), O.vertexWeights.push(De[Ve * 4 + 2]), O.vertexWeights.push(De[Ve * 4 + 3]), O.weightsIndices.push(gt[0]), O.weightsIndices.push(gt[1]), O.weightsIndices.push(gt[2]), O.weightsIndices.push(gt[3]), O.weightsIndices.push(gt[(Ve - 1) * 4]), O.weightsIndices.push(gt[(Ve - 1) * 4 + 1]), O.weightsIndices.push(gt[(Ve - 1) * 4 + 2]), O.weightsIndices.push(gt[(Ve - 1) * 4 + 3]), O.weightsIndices.push(gt[Ve * 4]), O.weightsIndices.push(gt[Ve * 4 + 1]), O.weightsIndices.push(gt[Ve * 4 + 2]), O.weightsIndices.push(gt[Ve * 4 + 3])), K.color && (O.colors.push(Ze[0]), O.colors.push(Ze[1]), O.colors.push(Ze[2]), O.colors.push(Ze[(Ve - 1) * 3]), O.colors.push(Ze[(Ve - 1) * 3 + 1]), O.colors.push(Ze[(Ve - 1) * 3 + 2]), O.colors.push(Ze[Ve * 3]), O.colors.push(Ze[Ve * 3 + 1]), O.colors.push(Ze[Ve * 3 + 2])), K.material && K.material.mappingType !== "AllSame" && (O.materialIndex.push(_e), O.materialIndex.push(_e), O.materialIndex.push(_e)), K.normal && (O.normal.push(xe[0]), O.normal.push(xe[1]), O.normal.push(xe[2]), O.normal.push(xe[(Ve - 1) * 3]), O.normal.push(xe[(Ve - 1) * 3 + 1]), O.normal.push(xe[(Ve - 1) * 3 + 2]), O.normal.push(xe[Ve * 3]), O.normal.push(xe[Ve * 3 + 1]), O.normal.push(xe[Ve * 3 + 2])), K.uv && K.uv.forEach(function(Dt, ei) {
                    O.uvs[ei] === void 0 && (O.uvs[ei] = []), O.uvs[ei].push(st[ei][0]), O.uvs[ei].push(st[ei][1]), O.uvs[ei].push(st[ei][(Ve - 1) * 2]), O.uvs[ei].push(st[ei][(Ve - 1) * 2 + 1]), O.uvs[ei].push(st[ei][Ve * 2]), O.uvs[ei].push(st[ei][Ve * 2 + 1])
                })
            },
            addMorphTargets: function(O, K, ae, _e) {
                if (ae.length !== 0) {
                    O.morphTargetsRelative = !0, O.morphAttributes.position = [];
                    var xe = this;
                    ae.forEach(function(Ze) {
                        Ze.rawTargets.forEach(function(st) {
                            var De = V.Objects.Geometry[st.geoID];
                            De !== void 0 && xe.genMorphGeometry(O, K, De, _e, st.name)
                        })
                    })
                }
            },
            genMorphGeometry: function(O, K, ae, _e, xe) {
                for (var Ze = K.PolygonVertexIndex !== void 0 ? K.PolygonVertexIndex.a : [], st = ae.Vertices !== void 0 ? ae.Vertices.a : [], De = ae.Indexes !== void 0 ? ae.Indexes.a : [], gt = O.attributes.position.count * 3, Qt = new Float32Array(gt), Ve = 0; Ve < De.length; Ve++) {
                    var Dt = De[Ve] * 3;
                    Qt[Dt] = st[Ve * 3], Qt[Dt + 1] = st[Ve * 3 + 1], Qt[Dt + 2] = st[Ve * 3 + 2]
                }
                var ei = {
                        vertexIndices: Ze,
                        vertexPositions: Qt
                    },
                    xi = this.genBuffers(ei),
                    oe = new y.Float32BufferAttribute(xi.vertex, 3);
                oe.name = xe || ae.attrName, oe.applyMatrix4(_e), O.morphAttributes.position.push(oe)
            },
            parseNormals: function(O) {
                var K = O.MappingInformationType,
                    ae = O.ReferenceInformationType,
                    _e = O.Normals.a,
                    xe = [];
                return ae === "IndexToDirect" && ("NormalIndex" in O ? xe = O.NormalIndex.a : "NormalsIndex" in O && (xe = O.NormalsIndex.a)), {
                    dataSize: 3,
                    buffer: _e,
                    indices: xe,
                    mappingType: K,
                    referenceType: ae
                }
            },
            parseUVs: function(O) {
                var K = O.MappingInformationType,
                    ae = O.ReferenceInformationType,
                    _e = O.UV.a,
                    xe = [];
                return ae === "IndexToDirect" && (xe = O.UVIndex.a), {
                    dataSize: 2,
                    buffer: _e,
                    indices: xe,
                    mappingType: K,
                    referenceType: ae
                }
            },
            parseVertexColors: function(O) {
                var K = O.MappingInformationType,
                    ae = O.ReferenceInformationType,
                    _e = O.Colors.a,
                    xe = [];
                return ae === "IndexToDirect" && (xe = O.ColorIndex.a), {
                    dataSize: 4,
                    buffer: _e,
                    indices: xe,
                    mappingType: K,
                    referenceType: ae
                }
            },
            parseMaterialIndices: function(O) {
                var K = O.MappingInformationType,
                    ae = O.ReferenceInformationType;
                if (K === "NoMappingInformation") return {
                    dataSize: 1,
                    buffer: [0],
                    indices: [0],
                    mappingType: "AllSame",
                    referenceType: ae
                };
                for (var _e = O.Materials.a, xe = [], Ze = 0; Ze < _e.length; ++Ze) xe.push(Ze);
                return {
                    dataSize: 1,
                    buffer: _e,
                    indices: xe,
                    mappingType: K,
                    referenceType: ae
                }
            },
            parseNurbsGeometry: function(O) {
                if (y.NURBSCurve === void 0) return console.error("THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."), new y.BufferGeometry;
                var K = parseInt(O.Order);
                if (isNaN(K)) return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", O.Order, O.id), new y.BufferGeometry;
                for (var ae = K - 1, _e = O.KnotVector.a, xe = [], Ze = O.Points.a, st = 0, De = Ze.length; st < De; st += 4) xe.push(new y.Vector4().fromArray(Ze, st));
                var gt, Qt;
                if (O.Form === "Closed") xe.push(xe[0]);
                else if (O.Form === "Periodic") {
                    gt = ae, Qt = _e.length - 1 - gt;
                    for (var st = 0; st < ae; ++st) xe.push(xe[st])
                }
                var Ve = new y.NURBSCurve(ae, _e, xe, gt, Qt),
                    Dt = Ve.getPoints(xe.length * 7),
                    ei = new Float32Array(Dt.length * 3);
                Dt.forEach(function(oe, ve) {
                    oe.toArray(ei, ve * 3)
                });
                var xi = new y.BufferGeometry;
                return xi.setAttribute("position", new y.BufferAttribute(ei, 3)), xi
            }
        };

        function He() {}
        He.prototype = {
            constructor: He,
            parse: function() {
                var O = [],
                    K = this.parseClips();
                if (K !== void 0)
                    for (var ae in K) {
                        var _e = K[ae],
                            xe = this.addClip(_e);
                        O.push(xe)
                    }
                return O
            },
            parseClips: function() {
                if (V.Objects.AnimationCurve !== void 0) {
                    var O = this.parseAnimationCurveNodes();
                    this.parseAnimationCurves(O);
                    var K = this.parseAnimationLayers(O),
                        ae = this.parseAnimStacks(K);
                    return ae
                }
            },
            parseAnimationCurveNodes: function() {
                var O = V.Objects.AnimationCurveNode,
                    K = new Map;
                for (var ae in O) {
                    var _e = O[ae];
                    if (_e.attrName.match(/S|R|T|DeformPercent/) !== null) {
                        var xe = {
                            id: _e.id,
                            attr: _e.attrName,
                            curves: {}
                        };
                        K.set(xe.id, xe)
                    }
                }
                return K
            },
            parseAnimationCurves: function(O) {
                var K = V.Objects.AnimationCurve;
                for (var ae in K) {
                    var _e = {
                            id: K[ae].id,
                            times: K[ae].KeyTime.a.map(Ye),
                            values: K[ae].KeyValueFloat.a
                        },
                        xe = Y.get(_e.id);
                    if (xe !== void 0) {
                        var Ze = xe.parents[0].ID,
                            st = xe.parents[0].relationship;
                        st.match(/X/) ? O.get(Ze).curves.x = _e : st.match(/Y/) ? O.get(Ze).curves.y = _e : st.match(/Z/) ? O.get(Ze).curves.z = _e : st.match(/d|DeformPercent/) && O.has(Ze) && (O.get(Ze).curves.morph = _e)
                    }
                }
            },
            parseAnimationLayers: function(O) {
                var K = V.Objects.AnimationLayer,
                    ae = new Map;
                for (var _e in K) {
                    var xe = [],
                        Ze = Y.get(parseInt(_e));
                    if (Ze !== void 0) {
                        var st = Ze.children;
                        st.forEach(function(De, gt) {
                            if (O.has(De.ID)) {
                                var Qt = O.get(De.ID);
                                if (Qt.curves.x !== void 0 || Qt.curves.y !== void 0 || Qt.curves.z !== void 0) {
                                    if (xe[gt] === void 0) {
                                        var Ve = Y.get(De.ID).parents.filter(function(Ne) {
                                            return Ne.relationship !== void 0
                                        })[0].ID;
                                        if (Ve !== void 0) {
                                            var Dt = V.Objects.Model[Ve.toString()];
                                            if (Dt === void 0) {
                                                console.warn("THREE.FBXLoader: Encountered a unused curve.", De);
                                                return
                                            }
                                            var ei = {
                                                modelName: Dt.attrName ? y.PropertyBinding.sanitizeNodeName(Dt.attrName) : "",
                                                ID: Dt.id,
                                                initialPosition: [0, 0, 0],
                                                initialRotation: [0, 0, 0],
                                                initialScale: [1, 1, 1]
                                            };
                                            C.traverse(function(Ne) {
                                                Ne.ID === Dt.id && (ei.transform = Ne.matrix, Ne.userData.transformData && (ei.eulerOrder = Ne.userData.transformData.eulerOrder))
                                            }), ei.transform || (ei.transform = new y.Matrix4), "PreRotation" in Dt && (ei.preRotation = Dt.PreRotation.value), "PostRotation" in Dt && (ei.postRotation = Dt.PostRotation.value), xe[gt] = ei
                                        }
                                    }
                                    xe[gt] && (xe[gt][Qt.attr] = Qt)
                                } else if (Qt.curves.morph !== void 0) {
                                    if (xe[gt] === void 0) {
                                        var xi = Y.get(De.ID).parents.filter(function(at) {
                                                return at.relationship !== void 0
                                            })[0].ID,
                                            oe = Y.get(xi).parents[0].ID,
                                            ve = Y.get(oe).parents[0].ID,
                                            Ve = Y.get(ve).parents[0].ID,
                                            Dt = V.Objects.Model[Ve],
                                            ei = {
                                                modelName: Dt.attrName ? y.PropertyBinding.sanitizeNodeName(Dt.attrName) : "",
                                                morphName: V.Objects.Deformer[xi].attrName
                                            };
                                        xe[gt] = ei
                                    }
                                    xe[gt][Qt.attr] = Qt
                                }
                            }
                        }), ae.set(parseInt(_e), xe)
                    }
                }
                return ae
            },
            parseAnimStacks: function(O) {
                var K = V.Objects.AnimationStack,
                    ae = {};
                for (var _e in K) {
                    var xe = Y.get(parseInt(_e)).children;
                    xe.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
                    var Ze = O.get(xe[0].ID);
                    ae[_e] = {
                        name: K[_e].attrName,
                        layer: Ze
                    }
                }
                return ae
            },
            addClip: function(O) {
                var K = [],
                    ae = this;
                return O.layer.forEach(function(_e) {
                    K = K.concat(ae.generateTracks(_e))
                }), new y.AnimationClip(O.name, -1, K)
            },
            generateTracks: function(O) {
                var K = [],
                    ae = new y.Vector3,
                    _e = new y.Quaternion,
                    xe = new y.Vector3;
                if (O.transform && O.transform.decompose(ae, _e, xe), ae = ae.toArray(), _e = new y.Euler().setFromQuaternion(_e, O.eulerOrder).toArray(), xe = xe.toArray(), O.T !== void 0 && Object.keys(O.T.curves).length > 0) {
                    var Ze = this.generateVectorTrack(O.modelName, O.T.curves, ae, "position");
                    Ze !== void 0 && K.push(Ze)
                }
                if (O.R !== void 0 && Object.keys(O.R.curves).length > 0) {
                    var st = this.generateRotationTrack(O.modelName, O.R.curves, _e, O.preRotation, O.postRotation, O.eulerOrder);
                    st !== void 0 && K.push(st)
                }
                if (O.S !== void 0 && Object.keys(O.S.curves).length > 0) {
                    var De = this.generateVectorTrack(O.modelName, O.S.curves, xe, "scale");
                    De !== void 0 && K.push(De)
                }
                if (O.DeformPercent !== void 0) {
                    var gt = this.generateMorphTrack(O);
                    gt !== void 0 && K.push(gt)
                }
                return K
            },
            generateVectorTrack: function(O, K, ae, _e) {
                var xe = this.getTimesForAllAxes(K),
                    Ze = this.getKeyframeTrackValues(xe, K, ae);
                return new y.VectorKeyframeTrack(O + "." + _e, xe, Ze)
            },
            generateRotationTrack: function(O, K, ae, _e, xe, Ze) {
                K.x !== void 0 && (this.interpolateRotations(K.x), K.x.values = K.x.values.map(y.MathUtils.degToRad)), K.y !== void 0 && (this.interpolateRotations(K.y), K.y.values = K.y.values.map(y.MathUtils.degToRad)), K.z !== void 0 && (this.interpolateRotations(K.z), K.z.values = K.z.values.map(y.MathUtils.degToRad));
                var st = this.getTimesForAllAxes(K),
                    De = this.getKeyframeTrackValues(st, K, ae);
                _e !== void 0 && (_e = _e.map(y.MathUtils.degToRad), _e.push(Ze), _e = new y.Euler().fromArray(_e), _e = new y.Quaternion().setFromEuler(_e)), xe !== void 0 && (xe = xe.map(y.MathUtils.degToRad), xe.push(Ze), xe = new y.Euler().fromArray(xe), xe = new y.Quaternion().setFromEuler(xe).invert());
                for (var gt = new y.Quaternion, Qt = new y.Euler, Ve = [], Dt = 0; Dt < De.length; Dt += 3) Qt.set(De[Dt], De[Dt + 1], De[Dt + 2], Ze), gt.setFromEuler(Qt), _e !== void 0 && gt.premultiply(_e), xe !== void 0 && gt.multiply(xe), gt.toArray(Ve, Dt / 3 * 4);
                return new y.QuaternionKeyframeTrack(O + ".quaternion", st, Ve)
            },
            generateMorphTrack: function(O) {
                var K = O.DeformPercent.curves.morph,
                    ae = K.values.map(function(xe) {
                        return xe / 100
                    }),
                    _e = C.getObjectByName(O.modelName).morphTargetDictionary[O.morphName];
                return new y.NumberKeyframeTrack(O.modelName + ".morphTargetInfluences[" + _e + "]", K.times, ae)
            },
            getTimesForAllAxes: function(O) {
                var K = [];
                if (O.x !== void 0 && (K = K.concat(O.x.times)), O.y !== void 0 && (K = K.concat(O.y.times)), O.z !== void 0 && (K = K.concat(O.z.times)), K = K.sort(function(st, De) {
                        return st - De
                    }), K.length > 1) {
                    for (var ae = 1, _e = K[0], xe = 1; xe < K.length; xe++) {
                        var Ze = K[xe];
                        Ze !== _e && (K[ae] = Ze, _e = Ze, ae++)
                    }
                    K = K.slice(0, ae)
                }
                return K
            },
            getKeyframeTrackValues: function(O, K, ae) {
                var _e = ae,
                    xe = [],
                    Ze = -1,
                    st = -1,
                    De = -1;
                return O.forEach(function(gt) {
                    if (K.x && (Ze = K.x.times.indexOf(gt)), K.y && (st = K.y.times.indexOf(gt)), K.z && (De = K.z.times.indexOf(gt)), Ze !== -1) {
                        var Qt = K.x.values[Ze];
                        xe.push(Qt), _e[0] = Qt
                    } else xe.push(_e[0]);
                    if (st !== -1) {
                        var Ve = K.y.values[st];
                        xe.push(Ve), _e[1] = Ve
                    } else xe.push(_e[1]);
                    if (De !== -1) {
                        var Dt = K.z.values[De];
                        xe.push(Dt), _e[2] = Dt
                    } else xe.push(_e[2])
                }), xe
            },
            interpolateRotations: function(O) {
                for (var K = 1; K < O.values.length; K++) {
                    var ae = O.values[K - 1],
                        _e = O.values[K] - ae,
                        xe = Math.abs(_e);
                    if (xe >= 180) {
                        for (var Ze = xe / 180, st = _e / Ze, De = ae + st, gt = O.times[K - 1], Qt = O.times[K] - gt, Ve = Qt / Ze, Dt = gt + Ve, ei = [], xi = []; Dt < O.times[K];) ei.push(Dt), Dt += Ve, xi.push(De), De += st;
                        O.times = li(O.times, K, ei), O.values = li(O.values, K, xi)
                    }
                }
            }
        };

        function be() {}
        be.prototype = {
            constructor: be,
            getPrevNode: function() {
                return this.nodeStack[this.currentIndent - 2]
            },
            getCurrentNode: function() {
                return this.nodeStack[this.currentIndent - 1]
            },
            getCurrentProp: function() {
                return this.currentProp
            },
            pushStack: function(O) {
                this.nodeStack.push(O), this.currentIndent += 1
            },
            popStack: function() {
                this.nodeStack.pop(), this.currentIndent -= 1
            },
            setCurrentProp: function(O, K) {
                this.currentProp = O, this.currentPropName = K
            },
            parse: function(O) {
                this.currentIndent = 0, this.allNodes = new Tt, this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
                var K = this,
                    ae = O.split(/[\r\n]+/);
                return ae.forEach(function(_e, xe) {
                    var Ze = _e.match(/^[\s\t]*;/),
                        st = _e.match(/^[\s\t]*$/);
                    if (!(Ze || st)) {
                        var De = _e.match("^\\t{" + K.currentIndent + "}(\\w+):(.*){", ""),
                            gt = _e.match("^\\t{" + K.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"),
                            Qt = _e.match("^\\t{" + (K.currentIndent - 1) + "}}");
                        De ? K.parseNodeBegin(_e, De) : gt ? K.parseNodeProperty(_e, gt, ae[++xe]) : Qt ? K.popStack() : _e.match(/^[^\s\t}]/) && K.parseNodePropertyContinued(_e)
                    }
                }), this.allNodes
            },
            parseNodeBegin: function(O, K) {
                var ae = K[1].trim().replace(/^"/, "").replace(/"$/, ""),
                    _e = K[2].split(",").map(function(De) {
                        return De.trim().replace(/^"/, "").replace(/"$/, "")
                    }),
                    xe = {
                        name: ae
                    },
                    Ze = this.parseNodeAttr(_e),
                    st = this.getCurrentNode();
                this.currentIndent === 0 ? this.allNodes.add(ae, xe) : ae in st ? (ae === "PoseNode" ? st.PoseNode.push(xe) : st[ae].id !== void 0 && (st[ae] = {}, st[ae][st[ae].id] = st[ae]), Ze.id !== "" && (st[ae][Ze.id] = xe)) : typeof Ze.id == "number" ? (st[ae] = {}, st[ae][Ze.id] = xe) : ae !== "Properties70" && (ae === "PoseNode" ? st[ae] = [xe] : st[ae] = xe), typeof Ze.id == "number" && (xe.id = Ze.id), Ze.name !== "" && (xe.attrName = Ze.name), Ze.type !== "" && (xe.attrType = Ze.type), this.pushStack(xe)
            },
            parseNodeAttr: function(O) {
                var K = O[0];
                O[0] !== "" && (K = parseInt(O[0]), isNaN(K) && (K = O[0]));
                var ae = "",
                    _e = "";
                return O.length > 1 && (ae = O[1].replace(/^(\w+)::/, ""), _e = O[2]), {
                    id: K,
                    name: ae,
                    type: _e
                }
            },
            parseNodeProperty: function(O, K, ae) {
                var _e = K[1].replace(/^"/, "").replace(/"$/, "").trim(),
                    xe = K[2].replace(/^"/, "").replace(/"$/, "").trim();
                _e === "Content" && xe === "," && (xe = ae.replace(/"/g, "").replace(/,$/, "").trim());
                var Ze = this.getCurrentNode(),
                    st = Ze.name;
                if (st === "Properties70") {
                    this.parseNodeSpecialProperty(O, _e, xe);
                    return
                }
                if (_e === "C") {
                    var De = xe.split(",").slice(1),
                        gt = parseInt(De[0]),
                        Qt = parseInt(De[1]),
                        Ve = xe.split(",").slice(3);
                    Ve = Ve.map(function(Dt) {
                        return Dt.trim().replace(/^"/, "")
                    }), _e = "connections", xe = [gt, Qt], ct(xe, Ve), Ze[_e] === void 0 && (Ze[_e] = [])
                }
                _e === "Node" && (Ze.id = xe), _e in Ze && Array.isArray(Ze[_e]) ? Ze[_e].push(xe) : _e !== "a" ? Ze[_e] = xe : Ze.a = xe, this.setCurrentProp(Ze, _e), _e === "a" && xe.slice(-1) !== "," && (Ze.a = Li(xe))
            },
            parseNodePropertyContinued: function(O) {
                var K = this.getCurrentNode();
                K.a += O, O.slice(-1) !== "," && (K.a = Li(K.a))
            },
            parseNodeSpecialProperty: function(O, K, ae) {
                var _e = ae.split('",').map(function(Qt) {
                        return Qt.trim().replace(/^\"/, "").replace(/\s/, "_")
                    }),
                    xe = _e[0],
                    Ze = _e[1],
                    st = _e[2],
                    De = _e[3],
                    gt = _e[4];
                switch (Ze) {
                    case "int":
                    case "enum":
                    case "bool":
                    case "ULongLong":
                    case "double":
                    case "Number":
                    case "FieldOfView":
                        gt = parseFloat(gt);
                        break;
                    case "Color":
                    case "ColorRGB":
                    case "Vector3D":
                    case "Lcl_Translation":
                    case "Lcl_Rotation":
                    case "Lcl_Scaling":
                        gt = Li(gt);
                        break
                }
                this.getPrevNode()[xe] = {
                    type: Ze,
                    type2: st,
                    flag: De,
                    value: gt
                }, this.setCurrentProp(this.getPrevNode(), xe)
            }
        };

        function Ee() {}
        Ee.prototype = {
            constructor: Ee,
            parse: function(O) {
                var K = new Lt(O);
                K.skip(23);
                var ae = K.getUint32();
                if (ae < 6400) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + ae);
                for (var _e = new Tt; !this.endOfContent(K);) {
                    var xe = this.parseNode(K, ae);
                    xe !== null && _e.add(xe.name, xe)
                }
                return _e
            },
            endOfContent: function(O) {
                return O.size() % 16 === 0 ? (O.getOffset() + 160 + 16 & -16) >= O.size() : O.getOffset() + 160 + 16 >= O.size()
            },
            parseNode: function(O, K) {
                var ae = {},
                    _e = K >= 7500 ? O.getUint64() : O.getUint32(),
                    xe = K >= 7500 ? O.getUint64() : O.getUint32();
                K >= 7500 ? O.getUint64() : O.getUint32();
                var Ze = O.getUint8(),
                    st = O.getString(Ze);
                if (_e === 0) return null;
                for (var De = [], gt = 0; gt < xe; gt++) De.push(this.parseProperty(O));
                var Qt = De.length > 0 ? De[0] : "",
                    Ve = De.length > 1 ? De[1] : "",
                    Dt = De.length > 2 ? De[2] : "";
                for (ae.singleProperty = xe === 1 && O.getOffset() === _e; _e > O.getOffset();) {
                    var ei = this.parseNode(O, K);
                    ei !== null && this.parseSubNode(st, ae, ei)
                }
                return ae.propertyList = De, typeof Qt == "number" && (ae.id = Qt), Ve !== "" && (ae.attrName = Ve), Dt !== "" && (ae.attrType = Dt), st !== "" && (ae.name = st), ae
            },
            parseSubNode: function(O, K, ae) {
                if (ae.singleProperty === !0) {
                    var _e = ae.propertyList[0];
                    Array.isArray(_e) ? (K[ae.name] = ae, ae.a = _e) : K[ae.name] = _e
                } else if (O === "Connections" && ae.name === "C") {
                    var xe = [];
                    ae.propertyList.forEach(function(Dt, ei) {
                        ei !== 0 && xe.push(Dt)
                    }), K.connections === void 0 && (K.connections = []), K.connections.push(xe)
                } else if (ae.name === "Properties70") {
                    var Ze = Object.keys(ae);
                    Ze.forEach(function(Dt) {
                        K[Dt] = ae[Dt]
                    })
                } else if (O === "Properties70" && ae.name === "P") {
                    var st = ae.propertyList[0],
                        De = ae.propertyList[1],
                        gt = ae.propertyList[2],
                        Qt = ae.propertyList[3],
                        Ve;
                    st.indexOf("Lcl ") === 0 && (st = st.replace("Lcl ", "Lcl_")), De.indexOf("Lcl ") === 0 && (De = De.replace("Lcl ", "Lcl_")), De === "Color" || De === "ColorRGB" || De === "Vector" || De === "Vector3D" || De.indexOf("Lcl_") === 0 ? Ve = [ae.propertyList[4], ae.propertyList[5], ae.propertyList[6]] : Ve = ae.propertyList[4], K[st] = {
                        type: De,
                        type2: gt,
                        flag: Qt,
                        value: Ve
                    }
                } else K[ae.name] === void 0 ? typeof ae.id == "number" ? (K[ae.name] = {}, K[ae.name][ae.id] = ae) : K[ae.name] = ae : ae.name === "PoseNode" ? (Array.isArray(K[ae.name]) || (K[ae.name] = [K[ae.name]]), K[ae.name].push(ae)) : K[ae.name][ae.id] === void 0 && (K[ae.name][ae.id] = ae)
            },
            parseProperty: function(O) {
                var K = O.getString(1);
                switch (K) {
                    case "C":
                        return O.getBoolean();
                    case "D":
                        return O.getFloat64();
                    case "F":
                        return O.getFloat32();
                    case "I":
                        return O.getInt32();
                    case "L":
                        return O.getInt64();
                    case "R":
                        var ae = O.getUint32();
                        return O.getArrayBuffer(ae);
                    case "S":
                        var ae = O.getUint32();
                        return O.getString(ae);
                    case "Y":
                        return O.getInt16();
                    case "b":
                    case "c":
                    case "d":
                    case "f":
                    case "i":
                    case "l":
                        var _e = O.getUint32(),
                            xe = O.getUint32(),
                            Ze = O.getUint32();
                        if (xe === 0) switch (K) {
                            case "b":
                            case "c":
                                return O.getBooleanArray(_e);
                            case "d":
                                return O.getFloat64Array(_e);
                            case "f":
                                return O.getFloat32Array(_e);
                            case "i":
                                return O.getInt32Array(_e);
                            case "l":
                                return O.getInt64Array(_e)
                        }
                        typeof z == "undefined" && console.error("THREE.FBXLoader: External library fflate.min.js required.");
                        var st = z.unzlibSync(new Uint8Array(O.getArrayBuffer(Ze))),
                            De = new Lt(st.buffer);
                        switch (K) {
                            case "b":
                            case "c":
                                return De.getBooleanArray(_e);
                            case "d":
                                return De.getFloat64Array(_e);
                            case "f":
                                return De.getFloat32Array(_e);
                            case "i":
                                return De.getInt32Array(_e);
                            case "l":
                                return De.getInt64Array(_e)
                        }
                    default:
                        throw new Error("THREE.FBXLoader: Unknown property type " + K)
                }
            }
        };

        function Lt(O, K) {
            this.dv = new DataView(O), this.offset = 0, this.littleEndian = K !== void 0 ? K : !0
        }
        Lt.prototype = {
            constructor: Lt,
            getOffset: function() {
                return this.offset
            },
            size: function() {
                return this.dv.buffer.byteLength
            },
            skip: function(O) {
                this.offset += O
            },
            getBoolean: function() {
                return (this.getUint8() & 1) === 1
            },
            getBooleanArray: function(O) {
                for (var K = [], ae = 0; ae < O; ae++) K.push(this.getBoolean());
                return K
            },
            getUint8: function() {
                var O = this.dv.getUint8(this.offset);
                return this.offset += 1, O
            },
            getInt16: function() {
                var O = this.dv.getInt16(this.offset, this.littleEndian);
                return this.offset += 2, O
            },
            getInt32: function() {
                var O = this.dv.getInt32(this.offset, this.littleEndian);
                return this.offset += 4, O
            },
            getInt32Array: function(O) {
                for (var K = [], ae = 0; ae < O; ae++) K.push(this.getInt32());
                return K
            },
            getUint32: function() {
                var O = this.dv.getUint32(this.offset, this.littleEndian);
                return this.offset += 4, O
            },
            getInt64: function() {
                var O, K;
                return this.littleEndian ? (O = this.getUint32(), K = this.getUint32()) : (K = this.getUint32(), O = this.getUint32()), K & 2147483648 ? (K = ~K & 4294967295, O = ~O & 4294967295, O === 4294967295 && (K = K + 1 & 4294967295), O = O + 1 & 4294967295, -(K * 4294967296 + O)) : K * 4294967296 + O
            },
            getInt64Array: function(O) {
                for (var K = [], ae = 0; ae < O; ae++) K.push(this.getInt64());
                return K
            },
            getUint64: function() {
                var O, K;
                return this.littleEndian ? (O = this.getUint32(), K = this.getUint32()) : (K = this.getUint32(), O = this.getUint32()), K * 4294967296 + O
            },
            getFloat32: function() {
                var O = this.dv.getFloat32(this.offset, this.littleEndian);
                return this.offset += 4, O
            },
            getFloat32Array: function(O) {
                for (var K = [], ae = 0; ae < O; ae++) K.push(this.getFloat32());
                return K
            },
            getFloat64: function() {
                var O = this.dv.getFloat64(this.offset, this.littleEndian);
                return this.offset += 8, O
            },
            getFloat64Array: function(O) {
                for (var K = [], ae = 0; ae < O; ae++) K.push(this.getFloat64());
                return K
            },
            getArrayBuffer: function(O) {
                var K = this.dv.buffer.slice(this.offset, this.offset + O);
                return this.offset += O, K
            },
            getString: function(O) {
                for (var K = [], ae = 0; ae < O; ae++) K[ae] = this.getUint8();
                var _e = K.indexOf(0);
                return _e >= 0 && (K = K.slice(0, _e)), y.LoaderUtils.decodeText(new Uint8Array(K))
            }
        };

        function Tt() {}
        Tt.prototype = {
            constructor: Tt,
            add: function(O, K) {
                this[O] = K
            }
        };

        function Je(O) {
            var K = "Kaydara FBX Binary  \0";
            return O.byteLength >= K.length && K === Ei(O, 0, K.length)
        }

        function wt(O) {
            var K = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"],
                ae = 0;

            function _e(st) {
                var De = O[st - 1];
                return O = O.slice(ae + st), ae++, De
            }
            for (var xe = 0; xe < K.length; ++xe) {
                var Ze = _e(1);
                if (Ze === K[xe]) return !1
            }
            return !0
        }

        function Ke(O) {
            var K = /FBXVersion: (\d+)/,
                ae = O.match(K);
            if (ae) {
                var _e = parseInt(ae[1]);
                return _e
            }
            throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")
        }

        function Ye(O) {
            return O / 46186158e3
        }
        var jt = [];

        function di(O, K, ae, _e) {
            var xe;
            switch (_e.mappingType) {
                case "ByPolygonVertex":
                    xe = O;
                    break;
                case "ByPolygon":
                    xe = K;
                    break;
                case "ByVertice":
                    xe = ae;
                    break;
                case "AllSame":
                    xe = _e.indices[0];
                    break;
                default:
                    console.warn("THREE.FBXLoader: unknown attribute mapping type " + _e.mappingType)
            }
            _e.referenceType === "IndexToDirect" && (xe = _e.indices[xe]);
            var Ze = xe * _e.dataSize,
                st = Ze + _e.dataSize;
            return je(jt, _e.buffer, Ze, st)
        }
        var $e = new y.Euler,
            vt = new y.Vector3;

        function Kt(O) {
            var K = new y.Matrix4,
                ae = new y.Matrix4,
                _e = new y.Matrix4,
                xe = new y.Matrix4,
                Ze = new y.Matrix4,
                st = new y.Matrix4,
                De = new y.Matrix4,
                gt = new y.Matrix4,
                Qt = new y.Matrix4,
                Ve = new y.Matrix4,
                Dt = new y.Matrix4,
                ei = new y.Matrix4,
                xi = O.inheritType ? O.inheritType : 0;
            if (O.translation && K.setPosition(vt.fromArray(O.translation)), O.preRotation) {
                var oe = O.preRotation.map(y.MathUtils.degToRad);
                oe.push(O.eulerOrder), ae.makeRotationFromEuler($e.fromArray(oe))
            }
            if (O.rotation) {
                var oe = O.rotation.map(y.MathUtils.degToRad);
                oe.push(O.eulerOrder), _e.makeRotationFromEuler($e.fromArray(oe))
            }
            if (O.postRotation) {
                var oe = O.postRotation.map(y.MathUtils.degToRad);
                oe.push(O.eulerOrder), xe.makeRotationFromEuler($e.fromArray(oe)), xe.invert()
            }
            O.scale && Ze.scale(vt.fromArray(O.scale)), O.scalingOffset && De.setPosition(vt.fromArray(O.scalingOffset)), O.scalingPivot && st.setPosition(vt.fromArray(O.scalingPivot)), O.rotationOffset && gt.setPosition(vt.fromArray(O.rotationOffset)), O.rotationPivot && Qt.setPosition(vt.fromArray(O.rotationPivot)), O.parentMatrixWorld && (Dt.copy(O.parentMatrix), Ve.copy(O.parentMatrixWorld));
            var ve = new y.Matrix4().copy(ae).multiply(_e).multiply(xe),
                Ne = new y.Matrix4;
            Ne.extractRotation(Ve);
            var Ue = new y.Matrix4;
            Ue.copyPosition(Ve);
            var Oe = new y.Matrix4,
                at = new y.Matrix4().copy(Ue).invert().multiply(Ve);
            Oe.copy(Ne).invert().multiply(at);
            var ht = Ze,
                tt = new y.Matrix4;
            if (xi === 0) tt.copy(Ne).multiply(ve).multiply(Oe).multiply(ht);
            else if (xi === 1) tt.copy(Ne).multiply(Oe).multiply(ve).multiply(ht);
            else {
                var Bt = new y.Matrix4().scale(new y.Vector3().setFromMatrixScale(Dt)),
                    Le = new y.Matrix4().copy(Bt).invert(),
                    Ot = new y.Matrix4().copy(Oe).multiply(Le);
                tt.copy(Ne).multiply(ve).multiply(Ot).multiply(ht)
            }
            var ii = new y.Matrix4;
            ii.copy(Qt).invert();
            var Wt = new y.Matrix4;
            Wt.copy(st).invert();
            var bi = new y.Matrix4;
            bi.copy(K).multiply(gt).multiply(Qt).multiply(ae).multiply(_e).multiply(xe).multiply(ii).multiply(De).multiply(st).multiply(Ze).multiply(Wt);
            var Qi = new y.Matrix4().copyPosition(bi),
                sn = new y.Matrix4().copy(Ve).multiply(Qi);
            return ei.copyPosition(sn), bi = new y.Matrix4().copy(ei).multiply(tt), bi.premultiply(Ve.invert()), bi
        }

        function vi(O) {
            O = O || 0;
            var K = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
            return O === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), K[0]) : K[O]
        }

        function Li(O) {
            var K = O.split(",").map(function(ae) {
                return parseFloat(ae)
            });
            return K
        }

        function Ei(O, K, ae) {
            return K === void 0 && (K = 0), ae === void 0 && (ae = O.byteLength), y.LoaderUtils.decodeText(new Uint8Array(O, K, ae))
        }

        function ct(O, K) {
            for (var ae = 0, _e = O.length, xe = K.length; ae < xe; ae++, _e++) O[_e] = K[ae]
        }

        function je(O, K, ae, _e) {
            for (var xe = ae, Ze = 0; xe < _e; xe++, Ze++) O[Ze] = K[xe];
            return O
        }

        function li(O, K, ae) {
            return O.slice(0, K).concat(ae).concat(O.slice(K))
        }
        return p
    }(), ue.exports = y.FBXLoader
})(Qf);
var pm = Qf.exports,
    Pf = {
        exports: {}
    };
(function(ue, R) {
    const y = Xa;
    y.GLTFLoader = function() {
        function z(oe) {
            y.Loader.call(this, oe), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(ve) {
                return new se(ve)
            }), this.register(function(ve) {
                return new He(ve)
            }), this.register(function(ve) {
                return new be(ve)
            }), this.register(function(ve) {
                return new ie(ve)
            }), this.register(function(ve) {
                return new C(ve)
            }), this.register(function(ve) {
                return new Ee(ve)
            })
        }
        z.prototype = Object.assign(Object.create(y.Loader.prototype), {
            constructor: z,
            load: function(oe, ve, Ne, Ue) {
                var Oe = this,
                    at;
                this.resourcePath !== "" ? at = this.resourcePath : this.path !== "" ? at = this.path : at = y.LoaderUtils.extractUrlBase(oe), this.manager.itemStart(oe);
                var ht = function(Bt) {
                        Ue ? Ue(Bt) : console.error(Bt), Oe.manager.itemError(oe), Oe.manager.itemEnd(oe)
                    },
                    tt = new y.FileLoader(this.manager);
                tt.setPath(this.path), tt.setResponseType("arraybuffer"), tt.setRequestHeader(this.requestHeader), tt.setWithCredentials(this.withCredentials), tt.load(oe, function(Bt) {
                    try {
                        Oe.parse(Bt, at, function(Le) {
                            ve(Le), Oe.manager.itemEnd(oe)
                        }, ht)
                    } catch (Le) {
                        ht(Le)
                    }
                }, Ne, ht)
            },
            setDRACOLoader: function(oe) {
                return this.dracoLoader = oe, this
            },
            setDDSLoader: function() {
                throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
            },
            setKTX2Loader: function(oe) {
                return this.ktx2Loader = oe, this
            },
            setMeshoptDecoder: function(oe) {
                return this.meshoptDecoder = oe, this
            },
            register: function(oe) {
                return this.pluginCallbacks.indexOf(oe) === -1 && this.pluginCallbacks.push(oe), this
            },
            unregister: function(oe) {
                return this.pluginCallbacks.indexOf(oe) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(oe), 1), this
            },
            parse: function(oe, ve, Ne, Ue) {
                var Oe, at = {},
                    ht = {};
                if (typeof oe == "string") Oe = oe;
                else {
                    var tt = y.LoaderUtils.decodeText(new Uint8Array(oe, 0, 4));
                    if (tt === Lt) {
                        try {
                            at[Y.KHR_BINARY_GLTF] = new wt(oe)
                        } catch (Qi) {
                            Ue && Ue(Qi);
                            return
                        }
                        Oe = at[Y.KHR_BINARY_GLTF].content
                    } else Oe = y.LoaderUtils.decodeText(new Uint8Array(oe))
                }
                var Bt = JSON.parse(Oe);
                if (Bt.asset === void 0 || Bt.asset.version[0] < 2) {
                    Ue && Ue(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                    return
                }
                var Le = new Ve(Bt, {
                    path: ve || this.resourcePath || "",
                    crossOrigin: this.crossOrigin,
                    requestHeader: this.requestHeader,
                    manager: this.manager,
                    ktx2Loader: this.ktx2Loader,
                    meshoptDecoder: this.meshoptDecoder
                });
                Le.fileLoader.setRequestHeader(this.requestHeader);
                for (var Ot = 0; Ot < this.pluginCallbacks.length; Ot++) {
                    var ii = this.pluginCallbacks[Ot](Le);
                    ht[ii.name] = ii, at[ii.name] = !0
                }
                if (Bt.extensionsUsed)
                    for (var Ot = 0; Ot < Bt.extensionsUsed.length; ++Ot) {
                        var Wt = Bt.extensionsUsed[Ot],
                            bi = Bt.extensionsRequired || [];
                        switch (Wt) {
                            case Y.KHR_MATERIALS_UNLIT:
                                at[Wt] = new p;
                                break;
                            case Y.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                                at[Wt] = new di;
                                break;
                            case Y.KHR_DRACO_MESH_COMPRESSION:
                                at[Wt] = new Ke(Bt, this.dracoLoader);
                                break;
                            case Y.KHR_TEXTURE_TRANSFORM:
                                at[Wt] = new Ye;
                                break;
                            case Y.KHR_MESH_QUANTIZATION:
                                at[Wt] = new $e;
                                break;
                            default:
                                bi.indexOf(Wt) >= 0 && ht[Wt] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + Wt + '".')
                        }
                    }
                Le.setExtensions(at), Le.setPlugins(ht), Le.parse(Ne, Ue)
            }
        });

        function V() {
            var oe = {};
            return {
                get: function(ve) {
                    return oe[ve]
                },
                add: function(ve, Ne) {
                    oe[ve] = Ne
                },
                remove: function(ve) {
                    delete oe[ve]
                },
                removeAll: function() {
                    oe = {}
                }
            }
        }
        var Y = {
            KHR_BINARY_GLTF: "KHR_binary_glTF",
            KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
            KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
            KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
            KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
            KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
            KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
            KHR_TEXTURE_BASISU: "KHR_texture_basisu",
            KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
            KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
            EXT_TEXTURE_WEBP: "EXT_texture_webp",
            EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
        };

        function C(oe) {
            this.parser = oe, this.name = Y.KHR_LIGHTS_PUNCTUAL, this.cache = {
                refs: {},
                uses: {}
            }
        }
        C.prototype._markDefs = function() {
            for (var oe = this.parser, ve = this.parser.json.nodes || [], Ne = 0, Ue = ve.length; Ne < Ue; Ne++) {
                var Oe = ve[Ne];
                Oe.extensions && Oe.extensions[this.name] && Oe.extensions[this.name].light !== void 0 && oe._addNodeRef(this.cache, Oe.extensions[this.name].light)
            }
        }, C.prototype._loadLight = function(oe) {
            var ve = this.parser,
                Ne = "light:" + oe,
                Ue = ve.cache.get(Ne);
            if (Ue) return Ue;
            var Oe = ve.json,
                at = Oe.extensions && Oe.extensions[this.name] || {},
                ht = at.lights || [],
                tt = ht[oe],
                Bt, Le = new y.Color(16777215);
            tt.color !== void 0 && Le.fromArray(tt.color);
            var Ot = tt.range !== void 0 ? tt.range : 0;
            switch (tt.type) {
                case "directional":
                    Bt = new y.DirectionalLight(Le), Bt.target.position.set(0, 0, -1), Bt.add(Bt.target);
                    break;
                case "point":
                    Bt = new y.PointLight(Le), Bt.distance = Ot;
                    break;
                case "spot":
                    Bt = new y.SpotLight(Le), Bt.distance = Ot, tt.spot = tt.spot || {}, tt.spot.innerConeAngle = tt.spot.innerConeAngle !== void 0 ? tt.spot.innerConeAngle : 0, tt.spot.outerConeAngle = tt.spot.outerConeAngle !== void 0 ? tt.spot.outerConeAngle : Math.PI / 4, Bt.angle = tt.spot.outerConeAngle, Bt.penumbra = 1 - tt.spot.innerConeAngle / tt.spot.outerConeAngle, Bt.target.position.set(0, 0, -1), Bt.add(Bt.target);
                    break;
                default:
                    throw new Error("THREE.GLTFLoader: Unexpected light type: " + tt.type)
            }
            return Bt.position.set(0, 0, 0), Bt.decay = 2, tt.intensity !== void 0 && (Bt.intensity = tt.intensity), Bt.name = ve.createUniqueName(tt.name || "light_" + oe), Ue = Promise.resolve(Bt), ve.cache.add(Ne, Ue), Ue
        }, C.prototype.createNodeAttachment = function(oe) {
            var ve = this,
                Ne = this.parser,
                Ue = Ne.json,
                Oe = Ue.nodes[oe],
                at = Oe.extensions && Oe.extensions[this.name] || {},
                ht = at.light;
            return ht === void 0 ? null : this._loadLight(ht).then(function(tt) {
                return Ne._getNodeRef(ve.cache, ht, tt)
            })
        };

        function p() {
            this.name = Y.KHR_MATERIALS_UNLIT
        }
        p.prototype.getMaterialType = function() {
            return y.MeshBasicMaterial
        }, p.prototype.extendParams = function(oe, ve, Ne) {
            var Ue = [];
            oe.color = new y.Color(1, 1, 1), oe.opacity = 1;
            var Oe = ve.pbrMetallicRoughness;
            if (Oe) {
                if (Array.isArray(Oe.baseColorFactor)) {
                    var at = Oe.baseColorFactor;
                    oe.color.fromArray(at), oe.opacity = at[3]
                }
                Oe.baseColorTexture !== void 0 && Ue.push(Ne.assignTexture(oe, "map", Oe.baseColorTexture))
            }
            return Promise.all(Ue)
        };

        function se(oe) {
            this.parser = oe, this.name = Y.KHR_MATERIALS_CLEARCOAT
        }
        se.prototype.getMaterialType = function(oe) {
            var ve = this.parser,
                Ne = ve.json.materials[oe];
            return !Ne.extensions || !Ne.extensions[this.name] ? null : y.MeshPhysicalMaterial
        }, se.prototype.extendMaterialParams = function(oe, ve) {
            var Ne = this.parser,
                Ue = Ne.json.materials[oe];
            if (!Ue.extensions || !Ue.extensions[this.name]) return Promise.resolve();
            var Oe = [],
                at = Ue.extensions[this.name];
            if (at.clearcoatFactor !== void 0 && (ve.clearcoat = at.clearcoatFactor), at.clearcoatTexture !== void 0 && Oe.push(Ne.assignTexture(ve, "clearcoatMap", at.clearcoatTexture)), at.clearcoatRoughnessFactor !== void 0 && (ve.clearcoatRoughness = at.clearcoatRoughnessFactor), at.clearcoatRoughnessTexture !== void 0 && Oe.push(Ne.assignTexture(ve, "clearcoatRoughnessMap", at.clearcoatRoughnessTexture)), at.clearcoatNormalTexture !== void 0 && (Oe.push(Ne.assignTexture(ve, "clearcoatNormalMap", at.clearcoatNormalTexture)), at.clearcoatNormalTexture.scale !== void 0)) {
                var ht = at.clearcoatNormalTexture.scale;
                ve.clearcoatNormalScale = new y.Vector2(ht, -ht)
            }
            return Promise.all(Oe)
        };

        function ie(oe) {
            this.parser = oe, this.name = Y.KHR_MATERIALS_TRANSMISSION
        }
        ie.prototype.getMaterialType = function(oe) {
            var ve = this.parser,
                Ne = ve.json.materials[oe];
            return !Ne.extensions || !Ne.extensions[this.name] ? null : y.MeshPhysicalMaterial
        }, ie.prototype.extendMaterialParams = function(oe, ve) {
            var Ne = this.parser,
                Ue = Ne.json.materials[oe];
            if (!Ue.extensions || !Ue.extensions[this.name]) return Promise.resolve();
            var Oe = [],
                at = Ue.extensions[this.name];
            return at.transmissionFactor !== void 0 && (ve.transmission = at.transmissionFactor), at.transmissionTexture !== void 0 && Oe.push(Ne.assignTexture(ve, "transmissionMap", at.transmissionTexture)), Promise.all(Oe)
        };

        function He(oe) {
            this.parser = oe, this.name = Y.KHR_TEXTURE_BASISU
        }
        He.prototype.loadTexture = function(oe) {
            var ve = this.parser,
                Ne = ve.json,
                Ue = Ne.textures[oe];
            if (!Ue.extensions || !Ue.extensions[this.name]) return null;
            var Oe = Ue.extensions[this.name],
                at = Ne.images[Oe.source],
                ht = ve.options.ktx2Loader;
            if (!ht) {
                if (Ne.extensionsRequired && Ne.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                return null
            }
            return ve.loadTextureImage(oe, at, ht)
        };

        function be(oe) {
            this.parser = oe, this.name = Y.EXT_TEXTURE_WEBP, this.isSupported = null
        }
        be.prototype.loadTexture = function(oe) {
            var ve = this.name,
                Ne = this.parser,
                Ue = Ne.json,
                Oe = Ue.textures[oe];
            if (!Oe.extensions || !Oe.extensions[ve]) return null;
            var at = Oe.extensions[ve],
                ht = Ue.images[at.source],
                tt = Ne.textureLoader;
            if (ht.uri) {
                var Bt = Ne.options.manager.getHandler(ht.uri);
                Bt !== null && (tt = Bt)
            }
            return this.detectSupport().then(function(Le) {
                if (Le) return Ne.loadTextureImage(oe, ht, tt);
                if (Ue.extensionsRequired && Ue.extensionsRequired.indexOf(ve) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                return Ne.loadTexture(oe)
            })
        }, be.prototype.detectSupport = function() {
            return this.isSupported || (this.isSupported = new Promise(function(oe) {
                var ve = new Image;
                ve.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", ve.onload = ve.onerror = function() {
                    oe(ve.height === 1)
                }
            })), this.isSupported
        };

        function Ee(oe) {
            this.name = Y.EXT_MESHOPT_COMPRESSION, this.parser = oe
        }
        Ee.prototype.loadBufferView = function(oe) {
            var ve = this.parser.json,
                Ne = ve.bufferViews[oe];
            if (Ne.extensions && Ne.extensions[this.name]) {
                var Ue = Ne.extensions[this.name],
                    Oe = this.parser.getDependency("buffer", Ue.buffer),
                    at = this.parser.options.meshoptDecoder;
                if (!at || !at.supported) {
                    if (ve.extensionsRequired && ve.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                    return null
                }
                return Promise.all([Oe, at.ready]).then(function(ht) {
                    var tt = Ue.byteOffset || 0,
                        Bt = Ue.byteLength || 0,
                        Le = Ue.count,
                        Ot = Ue.byteStride,
                        ii = new ArrayBuffer(Le * Ot),
                        Wt = new Uint8Array(ht[0], tt, Bt);
                    return at.decodeGltfBuffer(new Uint8Array(ii), Le, Ot, Wt, Ue.mode, Ue.filter), ii
                })
            } else return null
        };
        var Lt = "glTF",
            Tt = 12,
            Je = {
                JSON: 1313821514,
                BIN: 5130562
            };

        function wt(oe) {
            this.name = Y.KHR_BINARY_GLTF, this.content = null, this.body = null;
            var ve = new DataView(oe, 0, Tt);
            if (this.header = {
                    magic: y.LoaderUtils.decodeText(new Uint8Array(oe.slice(0, 4))),
                    version: ve.getUint32(4, !0),
                    length: ve.getUint32(8, !0)
                }, this.header.magic !== Lt) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
            if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
            for (var Ne = this.header.length - Tt, Ue = new DataView(oe, Tt), Oe = 0; Oe < Ne;) {
                var at = Ue.getUint32(Oe, !0);
                Oe += 4;
                var ht = Ue.getUint32(Oe, !0);
                if (Oe += 4, ht === Je.JSON) {
                    var tt = new Uint8Array(oe, Tt + Oe, at);
                    this.content = y.LoaderUtils.decodeText(tt)
                } else if (ht === Je.BIN) {
                    var Bt = Tt + Oe;
                    this.body = oe.slice(Bt, Bt + at)
                }
                Oe += at
            }
            if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.")
        }

        function Ke(oe, ve) {
            if (!ve) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
            this.name = Y.KHR_DRACO_MESH_COMPRESSION, this.json = oe, this.dracoLoader = ve, this.dracoLoader.preload()
        }
        Ke.prototype.decodePrimitive = function(oe, ve) {
            var Ne = this.json,
                Ue = this.dracoLoader,
                Oe = oe.extensions[this.name].bufferView,
                at = oe.extensions[this.name].attributes,
                ht = {},
                tt = {},
                Bt = {};
            for (var Le in at) {
                var Ot = je[Le] || Le.toLowerCase();
                ht[Ot] = at[Le]
            }
            for (Le in oe.attributes) {
                var Ot = je[Le] || Le.toLowerCase();
                if (at[Le] !== void 0) {
                    var ii = Ne.accessors[oe.attributes[Le]],
                        Wt = vi[ii.componentType];
                    Bt[Ot] = Wt, tt[Ot] = ii.normalized === !0
                }
            }
            return ve.getDependency("bufferView", Oe).then(function(bi) {
                return new Promise(function(Qi) {
                    Ue.decodeDracoFile(bi, function(sn) {
                        for (var yn in sn.attributes) {
                            var Yi = sn.attributes[yn],
                                rn = tt[yn];
                            rn !== void 0 && (Yi.normalized = rn)
                        }
                        Qi(sn)
                    }, ht, Bt)
                })
            })
        };

        function Ye() {
            this.name = Y.KHR_TEXTURE_TRANSFORM
        }
        Ye.prototype.extendTexture = function(oe, ve) {
            return oe = oe.clone(), ve.offset !== void 0 && oe.offset.fromArray(ve.offset), ve.rotation !== void 0 && (oe.rotation = ve.rotation), ve.scale !== void 0 && oe.repeat.fromArray(ve.scale), ve.texCoord !== void 0 && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), oe.needsUpdate = !0, oe
        };

        function jt(oe) {
            y.MeshStandardMaterial.call(this), this.isGLTFSpecularGlossinessMaterial = !0;
            var ve = ["#ifdef USE_SPECULARMAP", "	uniform sampler2D specularMap;", "#endif"].join(`
`),
                Ne = ["#ifdef USE_GLOSSINESSMAP", "	uniform sampler2D glossinessMap;", "#endif"].join(`
`),
                Ue = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "	vec4 texelSpecular = texture2D( specularMap, vUv );", "	texelSpecular = sRGBToLinear( texelSpecular );", "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "	specularFactor *= texelSpecular.rgb;", "#endif"].join(`
`),
                Oe = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );", "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "	glossinessFactor *= texelGlossiness.a;", "#endif"].join(`
`),
                at = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor;"].join(`
`),
                ht = {
                    specular: {
                        value: new y.Color().setHex(16777215)
                    },
                    glossiness: {
                        value: 1
                    },
                    specularMap: {
                        value: null
                    },
                    glossinessMap: {
                        value: null
                    }
                };
            this._extraUniforms = ht, this.onBeforeCompile = function(tt) {
                for (var Bt in ht) tt.uniforms[Bt] = ht[Bt];
                tt.fragmentShader = tt.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", ve).replace("#include <metalnessmap_pars_fragment>", Ne).replace("#include <roughnessmap_fragment>", Ue).replace("#include <metalnessmap_fragment>", Oe).replace("#include <lights_physical_fragment>", at)
            }, Object.defineProperties(this, {
                specular: {
                    get: function() {
                        return ht.specular.value
                    },
                    set: function(tt) {
                        ht.specular.value = tt
                    }
                },
                specularMap: {
                    get: function() {
                        return ht.specularMap.value
                    },
                    set: function(tt) {
                        ht.specularMap.value = tt, tt ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                    }
                },
                glossiness: {
                    get: function() {
                        return ht.glossiness.value
                    },
                    set: function(tt) {
                        ht.glossiness.value = tt
                    }
                },
                glossinessMap: {
                    get: function() {
                        return ht.glossinessMap.value
                    },
                    set: function(tt) {
                        ht.glossinessMap.value = tt, tt ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV)
                    }
                }
            }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(oe)
        }
        jt.prototype = Object.create(y.MeshStandardMaterial.prototype), jt.prototype.constructor = jt, jt.prototype.copy = function(oe) {
            return y.MeshStandardMaterial.prototype.copy.call(this, oe), this.specularMap = oe.specularMap, this.specular.copy(oe.specular), this.glossinessMap = oe.glossinessMap, this.glossiness = oe.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this
        };

        function di() {
            return {
                name: Y.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
                specularGlossinessParams: ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"],
                getMaterialType: function() {
                    return jt
                },
                extendParams: function(oe, ve, Ne) {
                    var Ue = ve.extensions[this.name];
                    oe.color = new y.Color(1, 1, 1), oe.opacity = 1;
                    var Oe = [];
                    if (Array.isArray(Ue.diffuseFactor)) {
                        var at = Ue.diffuseFactor;
                        oe.color.fromArray(at), oe.opacity = at[3]
                    }
                    if (Ue.diffuseTexture !== void 0 && Oe.push(Ne.assignTexture(oe, "map", Ue.diffuseTexture)), oe.emissive = new y.Color(0, 0, 0), oe.glossiness = Ue.glossinessFactor !== void 0 ? Ue.glossinessFactor : 1, oe.specular = new y.Color(1, 1, 1), Array.isArray(Ue.specularFactor) && oe.specular.fromArray(Ue.specularFactor), Ue.specularGlossinessTexture !== void 0) {
                        var ht = Ue.specularGlossinessTexture;
                        Oe.push(Ne.assignTexture(oe, "glossinessMap", ht)), Oe.push(Ne.assignTexture(oe, "specularMap", ht))
                    }
                    return Promise.all(Oe)
                },
                createMaterial: function(oe) {
                    var ve = new jt(oe);
                    return ve.fog = !0, ve.color = oe.color, ve.map = oe.map === void 0 ? null : oe.map, ve.lightMap = null, ve.lightMapIntensity = 1, ve.aoMap = oe.aoMap === void 0 ? null : oe.aoMap, ve.aoMapIntensity = 1, ve.emissive = oe.emissive, ve.emissiveIntensity = 1, ve.emissiveMap = oe.emissiveMap === void 0 ? null : oe.emissiveMap, ve.bumpMap = oe.bumpMap === void 0 ? null : oe.bumpMap, ve.bumpScale = 1, ve.normalMap = oe.normalMap === void 0 ? null : oe.normalMap, ve.normalMapType = y.TangentSpaceNormalMap, oe.normalScale && (ve.normalScale = oe.normalScale), ve.displacementMap = null, ve.displacementScale = 1, ve.displacementBias = 0, ve.specularMap = oe.specularMap === void 0 ? null : oe.specularMap, ve.specular = oe.specular, ve.glossinessMap = oe.glossinessMap === void 0 ? null : oe.glossinessMap, ve.glossiness = oe.glossiness, ve.alphaMap = null, ve.envMap = oe.envMap === void 0 ? null : oe.envMap, ve.envMapIntensity = 1, ve.refractionRatio = .98, ve
                }
            }
        }

        function $e() {
            this.name = Y.KHR_MESH_QUANTIZATION
        }

        function vt(oe, ve, Ne, Ue) {
            y.Interpolant.call(this, oe, ve, Ne, Ue)
        }
        vt.prototype = Object.create(y.Interpolant.prototype), vt.prototype.constructor = vt, vt.prototype.copySampleValue_ = function(oe) {
            for (var ve = this.resultBuffer, Ne = this.sampleValues, Ue = this.valueSize, Oe = oe * Ue * 3 + Ue, at = 0; at !== Ue; at++) ve[at] = Ne[Oe + at];
            return ve
        }, vt.prototype.beforeStart_ = vt.prototype.copySampleValue_, vt.prototype.afterEnd_ = vt.prototype.copySampleValue_, vt.prototype.interpolate_ = function(oe, ve, Ne, Ue) {
            for (var Oe = this.resultBuffer, at = this.sampleValues, ht = this.valueSize, tt = ht * 2, Bt = ht * 3, Le = Ue - ve, Ot = (Ne - ve) / Le, ii = Ot * Ot, Wt = ii * Ot, bi = oe * Bt, Qi = bi - Bt, sn = -2 * Wt + 3 * ii, yn = Wt - ii, Yi = 1 - sn, rn = yn - ii + Ot, Mi = 0; Mi !== ht; Mi++) {
                var Ht = at[Qi + Mi + ht],
                    Pt = at[Qi + Mi + tt] * Le,
                    qn = at[bi + Mi + ht],
                    ji = at[bi + Mi] * Le;
                Oe[Mi] = Yi * Ht + rn * Pt + sn * qn + yn * ji
            }
            return Oe
        };
        var Kt = {
                FLOAT: 5126,
                FLOAT_MAT3: 35675,
                FLOAT_MAT4: 35676,
                FLOAT_VEC2: 35664,
                FLOAT_VEC3: 35665,
                FLOAT_VEC4: 35666,
                LINEAR: 9729,
                REPEAT: 10497,
                SAMPLER_2D: 35678,
                POINTS: 0,
                LINES: 1,
                LINE_LOOP: 2,
                LINE_STRIP: 3,
                TRIANGLES: 4,
                TRIANGLE_STRIP: 5,
                TRIANGLE_FAN: 6,
                UNSIGNED_BYTE: 5121,
                UNSIGNED_SHORT: 5123
            },
            vi = {
                5120: Int8Array,
                5121: Uint8Array,
                5122: Int16Array,
                5123: Uint16Array,
                5125: Uint32Array,
                5126: Float32Array
            },
            Li = {
                9728: y.NearestFilter,
                9729: y.LinearFilter,
                9984: y.NearestMipmapNearestFilter,
                9985: y.LinearMipmapNearestFilter,
                9986: y.NearestMipmapLinearFilter,
                9987: y.LinearMipmapLinearFilter
            },
            Ei = {
                33071: y.ClampToEdgeWrapping,
                33648: y.MirroredRepeatWrapping,
                10497: y.RepeatWrapping
            },
            ct = {
                SCALAR: 1,
                VEC2: 2,
                VEC3: 3,
                VEC4: 4,
                MAT2: 4,
                MAT3: 9,
                MAT4: 16
            },
            je = {
                POSITION: "position",
                NORMAL: "normal",
                TANGENT: "tangent",
                TEXCOORD_0: "uv",
                TEXCOORD_1: "uv2",
                COLOR_0: "color",
                WEIGHTS_0: "skinWeight",
                JOINTS_0: "skinIndex"
            },
            li = {
                scale: "scale",
                translation: "position",
                rotation: "quaternion",
                weights: "morphTargetInfluences"
            },
            O = {
                CUBICSPLINE: void 0,
                LINEAR: y.InterpolateLinear,
                STEP: y.InterpolateDiscrete
            },
            K = {
                OPAQUE: "OPAQUE",
                MASK: "MASK",
                BLEND: "BLEND"
            };

        function ae(oe, ve) {
            return typeof oe != "string" || oe === "" ? "" : (/^https?:\/\//i.test(ve) && /^\//.test(oe) && (ve = ve.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(oe) || /^data:.*,.*$/i.test(oe) || /^blob:.*$/i.test(oe) ? oe : ve + oe)
        }

        function _e(oe) {
            return oe.DefaultMaterial === void 0 && (oe.DefaultMaterial = new y.MeshStandardMaterial({
                color: 16777215,
                emissive: 0,
                metalness: 1,
                roughness: 1,
                transparent: !1,
                depthTest: !0,
                side: y.FrontSide
            })), oe.DefaultMaterial
        }

        function xe(oe, ve, Ne) {
            for (var Ue in Ne.extensions) oe[Ue] === void 0 && (ve.userData.gltfExtensions = ve.userData.gltfExtensions || {}, ve.userData.gltfExtensions[Ue] = Ne.extensions[Ue])
        }

        function Ze(oe, ve) {
            ve.extras !== void 0 && (typeof ve.extras == "object" ? Object.assign(oe.userData, ve.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + ve.extras))
        }

        function st(oe, ve, Ne) {
            for (var Ue = !1, Oe = !1, at = 0, ht = ve.length; at < ht; at++) {
                var tt = ve[at];
                if (tt.POSITION !== void 0 && (Ue = !0), tt.NORMAL !== void 0 && (Oe = !0), Ue && Oe) break
            }
            if (!Ue && !Oe) return Promise.resolve(oe);
            for (var Bt = [], Le = [], at = 0, ht = ve.length; at < ht; at++) {
                var tt = ve[at];
                if (Ue) {
                    var Ot = tt.POSITION !== void 0 ? Ne.getDependency("accessor", tt.POSITION) : oe.attributes.position;
                    Bt.push(Ot)
                }
                if (Oe) {
                    var Ot = tt.NORMAL !== void 0 ? Ne.getDependency("accessor", tt.NORMAL) : oe.attributes.normal;
                    Le.push(Ot)
                }
            }
            return Promise.all([Promise.all(Bt), Promise.all(Le)]).then(function(ii) {
                var Wt = ii[0],
                    bi = ii[1];
                return Ue && (oe.morphAttributes.position = Wt), Oe && (oe.morphAttributes.normal = bi), oe.morphTargetsRelative = !0, oe
            })
        }

        function De(oe, ve) {
            if (oe.updateMorphTargets(), ve.weights !== void 0)
                for (var Ne = 0, Ue = ve.weights.length; Ne < Ue; Ne++) oe.morphTargetInfluences[Ne] = ve.weights[Ne];
            if (ve.extras && Array.isArray(ve.extras.targetNames)) {
                var Oe = ve.extras.targetNames;
                if (oe.morphTargetInfluences.length === Oe.length) {
                    oe.morphTargetDictionary = {};
                    for (var Ne = 0, Ue = Oe.length; Ne < Ue; Ne++) oe.morphTargetDictionary[Oe[Ne]] = Ne
                } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
            }
        }

        function gt(oe) {
            var ve = oe.extensions && oe.extensions[Y.KHR_DRACO_MESH_COMPRESSION],
                Ne;
            return ve ? Ne = "draco:" + ve.bufferView + ":" + ve.indices + ":" + Qt(ve.attributes) : Ne = oe.indices + ":" + Qt(oe.attributes) + ":" + oe.mode, Ne
        }

        function Qt(oe) {
            for (var ve = "", Ne = Object.keys(oe).sort(), Ue = 0, Oe = Ne.length; Ue < Oe; Ue++) ve += Ne[Ue] + ":" + oe[Ne[Ue]] + ";";
            return ve
        }

        function Ve(oe, ve) {
            this.json = oe || {}, this.extensions = {}, this.plugins = {}, this.options = ve || {}, this.cache = new V, this.associations = new Map, this.primitiveCache = {}, this.meshCache = {
                refs: {},
                uses: {}
            }, this.cameraCache = {
                refs: {},
                uses: {}
            }, this.lightCache = {
                refs: {},
                uses: {}
            }, this.nodeNamesUsed = {}, typeof createImageBitmap != "undefined" && /Firefox/.test(navigator.userAgent) === !1 ? this.textureLoader = new y.ImageBitmapLoader(this.options.manager) : this.textureLoader = new y.TextureLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new y.FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
        }
        Ve.prototype.setExtensions = function(oe) {
            this.extensions = oe
        }, Ve.prototype.setPlugins = function(oe) {
            this.plugins = oe
        }, Ve.prototype.parse = function(oe, ve) {
            var Ne = this,
                Ue = this.json,
                Oe = this.extensions;
            this.cache.removeAll(), this._invokeAll(function(at) {
                return at._markDefs && at._markDefs()
            }), Promise.all(this._invokeAll(function(at) {
                return at.beforeRoot && at.beforeRoot()
            })).then(function() {
                return Promise.all([Ne.getDependencies("scene"), Ne.getDependencies("animation"), Ne.getDependencies("camera")])
            }).then(function(at) {
                var ht = {
                    scene: at[0][Ue.scene || 0],
                    scenes: at[0],
                    animations: at[1],
                    cameras: at[2],
                    asset: Ue.asset,
                    parser: Ne,
                    userData: {}
                };
                xe(Oe, ht, Ue), Ze(ht, Ue), Promise.all(Ne._invokeAll(function(tt) {
                    return tt.afterRoot && tt.afterRoot(ht)
                })).then(function() {
                    oe(ht)
                })
            }).catch(ve)
        }, Ve.prototype._markDefs = function() {
            for (var oe = this.json.nodes || [], ve = this.json.skins || [], Ne = this.json.meshes || [], Ue = 0, Oe = ve.length; Ue < Oe; Ue++)
                for (var at = ve[Ue].joints, ht = 0, tt = at.length; ht < tt; ht++) oe[at[ht]].isBone = !0;
            for (var Bt = 0, Le = oe.length; Bt < Le; Bt++) {
                var Ot = oe[Bt];
                Ot.mesh !== void 0 && (this._addNodeRef(this.meshCache, Ot.mesh), Ot.skin !== void 0 && (Ne[Ot.mesh].isSkinnedMesh = !0)), Ot.camera !== void 0 && this._addNodeRef(this.cameraCache, Ot.camera)
            }
        }, Ve.prototype._addNodeRef = function(oe, ve) {
            ve !== void 0 && (oe.refs[ve] === void 0 && (oe.refs[ve] = oe.uses[ve] = 0), oe.refs[ve]++)
        }, Ve.prototype._getNodeRef = function(oe, ve, Ne) {
            if (oe.refs[ve] <= 1) return Ne;
            var Ue = Ne.clone();
            return Ue.name += "_instance_" + oe.uses[ve]++, Ue
        }, Ve.prototype._invokeOne = function(oe) {
            var ve = Object.values(this.plugins);
            ve.push(this);
            for (var Ne = 0; Ne < ve.length; Ne++) {
                var Ue = oe(ve[Ne]);
                if (Ue) return Ue
            }
        }, Ve.prototype._invokeAll = function(oe) {
            var ve = Object.values(this.plugins);
            ve.unshift(this);
            for (var Ne = [], Ue = 0; Ue < ve.length; Ue++) {
                var Oe = oe(ve[Ue]);
                Oe && Ne.push(Oe)
            }
            return Ne
        }, Ve.prototype.getDependency = function(oe, ve) {
            var Ne = oe + ":" + ve,
                Ue = this.cache.get(Ne);
            if (!Ue) {
                switch (oe) {
                    case "scene":
                        Ue = this.loadScene(ve);
                        break;
                    case "node":
                        Ue = this.loadNode(ve);
                        break;
                    case "mesh":
                        Ue = this._invokeOne(function(Oe) {
                            return Oe.loadMesh && Oe.loadMesh(ve)
                        });
                        break;
                    case "accessor":
                        Ue = this.loadAccessor(ve);
                        break;
                    case "bufferView":
                        Ue = this._invokeOne(function(Oe) {
                            return Oe.loadBufferView && Oe.loadBufferView(ve)
                        });
                        break;
                    case "buffer":
                        Ue = this.loadBuffer(ve);
                        break;
                    case "material":
                        Ue = this._invokeOne(function(Oe) {
                            return Oe.loadMaterial && Oe.loadMaterial(ve)
                        });
                        break;
                    case "texture":
                        Ue = this._invokeOne(function(Oe) {
                            return Oe.loadTexture && Oe.loadTexture(ve)
                        });
                        break;
                    case "skin":
                        Ue = this.loadSkin(ve);
                        break;
                    case "animation":
                        Ue = this.loadAnimation(ve);
                        break;
                    case "camera":
                        Ue = this.loadCamera(ve);
                        break;
                    default:
                        throw new Error("Unknown type: " + oe)
                }
                this.cache.add(Ne, Ue)
            }
            return Ue
        }, Ve.prototype.getDependencies = function(oe) {
            var ve = this.cache.get(oe);
            if (!ve) {
                var Ne = this,
                    Ue = this.json[oe + (oe === "mesh" ? "es" : "s")] || [];
                ve = Promise.all(Ue.map(function(Oe, at) {
                    return Ne.getDependency(oe, at)
                })), this.cache.add(oe, ve)
            }
            return ve
        }, Ve.prototype.loadBuffer = function(oe) {
            var ve = this.json.buffers[oe],
                Ne = this.fileLoader;
            if (ve.type && ve.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + ve.type + " buffer type is not supported.");
            if (ve.uri === void 0 && oe === 0) return Promise.resolve(this.extensions[Y.KHR_BINARY_GLTF].body);
            var Ue = this.options;
            return new Promise(function(Oe, at) {
                Ne.load(ae(ve.uri, Ue.path), Oe, void 0, function() {
                    at(new Error('THREE.GLTFLoader: Failed to load buffer "' + ve.uri + '".'))
                })
            })
        }, Ve.prototype.loadBufferView = function(oe) {
            var ve = this.json.bufferViews[oe];
            return this.getDependency("buffer", ve.buffer).then(function(Ne) {
                var Ue = ve.byteLength || 0,
                    Oe = ve.byteOffset || 0;
                return Ne.slice(Oe, Oe + Ue)
            })
        }, Ve.prototype.loadAccessor = function(oe) {
            var ve = this,
                Ne = this.json,
                Ue = this.json.accessors[oe];
            if (Ue.bufferView === void 0 && Ue.sparse === void 0) return Promise.resolve(null);
            var Oe = [];
            return Ue.bufferView !== void 0 ? Oe.push(this.getDependency("bufferView", Ue.bufferView)) : Oe.push(null), Ue.sparse !== void 0 && (Oe.push(this.getDependency("bufferView", Ue.sparse.indices.bufferView)), Oe.push(this.getDependency("bufferView", Ue.sparse.values.bufferView))), Promise.all(Oe).then(function(at) {
                var ht = at[0],
                    tt = ct[Ue.type],
                    Bt = vi[Ue.componentType],
                    Le = Bt.BYTES_PER_ELEMENT,
                    Ot = Le * tt,
                    ii = Ue.byteOffset || 0,
                    Wt = Ue.bufferView !== void 0 ? Ne.bufferViews[Ue.bufferView].byteStride : void 0,
                    bi = Ue.normalized === !0,
                    Qi, sn;
                if (Wt && Wt !== Ot) {
                    var yn = Math.floor(ii / Wt),
                        Yi = "InterleavedBuffer:" + Ue.bufferView + ":" + Ue.componentType + ":" + yn + ":" + Ue.count,
                        rn = ve.cache.get(Yi);
                    rn || (Qi = new Bt(ht, yn * Wt, Ue.count * Wt / Le), rn = new y.InterleavedBuffer(Qi, Wt / Le), ve.cache.add(Yi, rn)), sn = new y.InterleavedBufferAttribute(rn, tt, ii % Wt / Le, bi)
                } else ht === null ? Qi = new Bt(Ue.count * tt) : Qi = new Bt(ht, ii, Ue.count * tt), sn = new y.BufferAttribute(Qi, tt, bi);
                if (Ue.sparse !== void 0) {
                    var Mi = ct.SCALAR,
                        Ht = vi[Ue.sparse.indices.componentType],
                        Pt = Ue.sparse.indices.byteOffset || 0,
                        qn = Ue.sparse.values.byteOffset || 0,
                        ji = new Ht(at[1], Pt, Ue.sparse.count * Mi),
                        na = new Bt(at[2], qn, Ue.sparse.count * tt);
                    ht !== null && (sn = new y.BufferAttribute(sn.array.slice(), sn.itemSize, sn.normalized));
                    for (var cn = 0, yi = ji.length; cn < yi; cn++) {
                        var Si = ji[cn];
                        if (sn.setX(Si, na[cn * tt]), tt >= 2 && sn.setY(Si, na[cn * tt + 1]), tt >= 3 && sn.setZ(Si, na[cn * tt + 2]), tt >= 4 && sn.setW(Si, na[cn * tt + 3]), tt >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                    }
                }
                return sn
            })
        }, Ve.prototype.loadTexture = function(oe) {
            var ve = this.json,
                Ne = this.options,
                Ue = ve.textures[oe],
                Oe = ve.images[Ue.source],
                at = this.textureLoader;
            if (Oe.uri) {
                var ht = Ne.manager.getHandler(Oe.uri);
                ht !== null && (at = ht)
            }
            return this.loadTextureImage(oe, Oe, at)
        }, Ve.prototype.loadTextureImage = function(oe, ve, Ne) {
            var Ue = this,
                Oe = this.json,
                at = this.options,
                ht = Oe.textures[oe],
                tt = self.URL || self.webkitURL,
                Bt = ve.uri,
                Le = !1,
                Ot = !0;
            if (ve.mimeType === "image/jpeg" && (Ot = !1), ve.bufferView !== void 0) Bt = Ue.getDependency("bufferView", ve.bufferView).then(function(ii) {
                if (ve.mimeType === "image/png") {
                    var Wt = new DataView(ii, 25, 1).getUint8(0, !1);
                    Ot = Wt === 6 || Wt === 4 || Wt === 3
                }
                Le = !0;
                var bi = new Blob([ii], {
                    type: ve.mimeType
                });
                return Bt = tt.createObjectURL(bi), Bt
            });
            else if (ve.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + oe + " is missing URI and bufferView");
            return Promise.resolve(Bt).then(function(ii) {
                return new Promise(function(Wt, bi) {
                    var Qi = Wt;
                    Ne.isImageBitmapLoader === !0 && (Qi = function(sn) {
                        Wt(new y.CanvasTexture(sn))
                    }), Ne.load(ae(ii, at.path), Qi, void 0, bi)
                })
            }).then(function(ii) {
                Le === !0 && tt.revokeObjectURL(Bt), ii.flipY = !1, ht.name && (ii.name = ht.name), Ot || (ii.format = y.RGBFormat);
                var Wt = Oe.samplers || {},
                    bi = Wt[ht.sampler] || {};
                return ii.magFilter = Li[bi.magFilter] || y.LinearFilter, ii.minFilter = Li[bi.minFilter] || y.LinearMipmapLinearFilter, ii.wrapS = Ei[bi.wrapS] || y.RepeatWrapping, ii.wrapT = Ei[bi.wrapT] || y.RepeatWrapping, Ue.associations.set(ii, {
                    type: "textures",
                    index: oe
                }), ii
            })
        }, Ve.prototype.assignTexture = function(oe, ve, Ne) {
            var Ue = this;
            return this.getDependency("texture", Ne.index).then(function(Oe) {
                if (Ne.texCoord !== void 0 && Ne.texCoord != 0 && !(ve === "aoMap" && Ne.texCoord == 1) && console.warn("THREE.GLTFLoader: Custom UV set " + Ne.texCoord + " for texture " + ve + " not yet supported."), Ue.extensions[Y.KHR_TEXTURE_TRANSFORM]) {
                    var at = Ne.extensions !== void 0 ? Ne.extensions[Y.KHR_TEXTURE_TRANSFORM] : void 0;
                    if (at) {
                        var ht = Ue.associations.get(Oe);
                        Oe = Ue.extensions[Y.KHR_TEXTURE_TRANSFORM].extendTexture(Oe, at), Ue.associations.set(Oe, ht)
                    }
                }
                oe[ve] = Oe
            })
        }, Ve.prototype.assignFinalMaterial = function(oe) {
            var ve = oe.geometry,
                Ne = oe.material,
                Ue = ve.attributes.tangent !== void 0,
                Oe = ve.attributes.color !== void 0,
                at = ve.attributes.normal === void 0,
                ht = oe.isSkinnedMesh === !0,
                tt = Object.keys(ve.morphAttributes).length > 0,
                Bt = tt && ve.morphAttributes.normal !== void 0;
            if (oe.isPoints) {
                var Le = "PointsMaterial:" + Ne.uuid,
                    Ot = this.cache.get(Le);
                Ot || (Ot = new y.PointsMaterial, y.Material.prototype.copy.call(Ot, Ne), Ot.color.copy(Ne.color), Ot.map = Ne.map, Ot.sizeAttenuation = !1, this.cache.add(Le, Ot)), Ne = Ot
            } else if (oe.isLine) {
                var Le = "LineBasicMaterial:" + Ne.uuid,
                    ii = this.cache.get(Le);
                ii || (ii = new y.LineBasicMaterial, y.Material.prototype.copy.call(ii, Ne), ii.color.copy(Ne.color), this.cache.add(Le, ii)), Ne = ii
            }
            if (Ue || Oe || at || ht || tt) {
                var Le = "ClonedMaterial:" + Ne.uuid + ":";
                Ne.isGLTFSpecularGlossinessMaterial && (Le += "specular-glossiness:"), ht && (Le += "skinning:"), Ue && (Le += "vertex-tangents:"), Oe && (Le += "vertex-colors:"), at && (Le += "flat-shading:"), tt && (Le += "morph-targets:"), Bt && (Le += "morph-normals:");
                var Wt = this.cache.get(Le);
                Wt || (Wt = Ne.clone(), ht && (Wt.skinning = !0), Oe && (Wt.vertexColors = !0), at && (Wt.flatShading = !0), tt && (Wt.morphTargets = !0), Bt && (Wt.morphNormals = !0), Ue && (Wt.vertexTangents = !0, Wt.normalScale && (Wt.normalScale.y *= -1), Wt.clearcoatNormalScale && (Wt.clearcoatNormalScale.y *= -1)), this.cache.add(Le, Wt), this.associations.set(Wt, this.associations.get(Ne))), Ne = Wt
            }
            Ne.aoMap && ve.attributes.uv2 === void 0 && ve.attributes.uv !== void 0 && ve.setAttribute("uv2", ve.attributes.uv), oe.material = Ne
        }, Ve.prototype.getMaterialType = function() {
            return y.MeshStandardMaterial
        }, Ve.prototype.loadMaterial = function(oe) {
            var ve = this,
                Ne = this.json,
                Ue = this.extensions,
                Oe = Ne.materials[oe],
                at, ht = {},
                tt = Oe.extensions || {},
                Bt = [];
            if (tt[Y.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                var Le = Ue[Y.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                at = Le.getMaterialType(), Bt.push(Le.extendParams(ht, Oe, ve))
            } else if (tt[Y.KHR_MATERIALS_UNLIT]) {
                var Ot = Ue[Y.KHR_MATERIALS_UNLIT];
                at = Ot.getMaterialType(), Bt.push(Ot.extendParams(ht, Oe, ve))
            } else {
                var ii = Oe.pbrMetallicRoughness || {};
                if (ht.color = new y.Color(1, 1, 1), ht.opacity = 1, Array.isArray(ii.baseColorFactor)) {
                    var Wt = ii.baseColorFactor;
                    ht.color.fromArray(Wt), ht.opacity = Wt[3]
                }
                ii.baseColorTexture !== void 0 && Bt.push(ve.assignTexture(ht, "map", ii.baseColorTexture)), ht.metalness = ii.metallicFactor !== void 0 ? ii.metallicFactor : 1, ht.roughness = ii.roughnessFactor !== void 0 ? ii.roughnessFactor : 1, ii.metallicRoughnessTexture !== void 0 && (Bt.push(ve.assignTexture(ht, "metalnessMap", ii.metallicRoughnessTexture)), Bt.push(ve.assignTexture(ht, "roughnessMap", ii.metallicRoughnessTexture))), at = this._invokeOne(function(Qi) {
                    return Qi.getMaterialType && Qi.getMaterialType(oe)
                }), Bt.push(Promise.all(this._invokeAll(function(Qi) {
                    return Qi.extendMaterialParams && Qi.extendMaterialParams(oe, ht)
                })))
            }
            Oe.doubleSided === !0 && (ht.side = y.DoubleSide);
            var bi = Oe.alphaMode || K.OPAQUE;
            return bi === K.BLEND ? (ht.transparent = !0, ht.depthWrite = !1) : (ht.transparent = !1, bi === K.MASK && (ht.alphaTest = Oe.alphaCutoff !== void 0 ? Oe.alphaCutoff : .5)), Oe.normalTexture !== void 0 && at !== y.MeshBasicMaterial && (Bt.push(ve.assignTexture(ht, "normalMap", Oe.normalTexture)), ht.normalScale = new y.Vector2(1, -1), Oe.normalTexture.scale !== void 0 && ht.normalScale.set(Oe.normalTexture.scale, -Oe.normalTexture.scale)), Oe.occlusionTexture !== void 0 && at !== y.MeshBasicMaterial && (Bt.push(ve.assignTexture(ht, "aoMap", Oe.occlusionTexture)), Oe.occlusionTexture.strength !== void 0 && (ht.aoMapIntensity = Oe.occlusionTexture.strength)), Oe.emissiveFactor !== void 0 && at !== y.MeshBasicMaterial && (ht.emissive = new y.Color().fromArray(Oe.emissiveFactor)), Oe.emissiveTexture !== void 0 && at !== y.MeshBasicMaterial && Bt.push(ve.assignTexture(ht, "emissiveMap", Oe.emissiveTexture)), Promise.all(Bt).then(function() {
                var Qi;
                return at === jt ? Qi = Ue[Y.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(ht) : Qi = new at(ht), Oe.name && (Qi.name = Oe.name), Qi.map && (Qi.map.encoding = y.sRGBEncoding), Qi.emissiveMap && (Qi.emissiveMap.encoding = y.sRGBEncoding), Ze(Qi, Oe), ve.associations.set(Qi, {
                    type: "materials",
                    index: oe
                }), Oe.extensions && xe(Ue, Qi, Oe), Qi
            })
        }, Ve.prototype.createUniqueName = function(oe) {
            for (var ve = y.PropertyBinding.sanitizeNodeName(oe || ""), Ne = ve, Ue = 1; this.nodeNamesUsed[Ne]; ++Ue) Ne = ve + "_" + Ue;
            return this.nodeNamesUsed[Ne] = !0, Ne
        };

        function Dt(oe, ve, Ne) {
            var Ue = ve.attributes,
                Oe = new y.Box3;
            if (Ue.POSITION !== void 0) {
                var at = Ne.json.accessors[Ue.POSITION],
                    ht = at.min,
                    tt = at.max;
                if (ht !== void 0 && tt !== void 0) Oe.set(new y.Vector3(ht[0], ht[1], ht[2]), new y.Vector3(tt[0], tt[1], tt[2]));
                else {
                    console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                    return
                }
            } else return;
            var Bt = ve.targets;
            if (Bt !== void 0) {
                for (var Le = new y.Vector3, Ot = new y.Vector3, ii = 0, Wt = Bt.length; ii < Wt; ii++) {
                    var bi = Bt[ii];
                    if (bi.POSITION !== void 0) {
                        var at = Ne.json.accessors[bi.POSITION],
                            ht = at.min,
                            tt = at.max;
                        ht !== void 0 && tt !== void 0 ? (Ot.setX(Math.max(Math.abs(ht[0]), Math.abs(tt[0]))), Ot.setY(Math.max(Math.abs(ht[1]), Math.abs(tt[1]))), Ot.setZ(Math.max(Math.abs(ht[2]), Math.abs(tt[2]))), Le.max(Ot)) : console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                    }
                }
                Oe.expandByVector(Le)
            }
            oe.boundingBox = Oe;
            var Qi = new y.Sphere;
            Oe.getCenter(Qi.center), Qi.radius = Oe.min.distanceTo(Oe.max) / 2, oe.boundingSphere = Qi
        }

        function ei(oe, ve, Ne) {
            var Ue = ve.attributes,
                Oe = [];

            function at(Le, Ot) {
                return Ne.getDependency("accessor", Le).then(function(ii) {
                    oe.setAttribute(Ot, ii)
                })
            }
            for (var ht in Ue) {
                var tt = je[ht] || ht.toLowerCase();
                tt in oe.attributes || Oe.push(at(Ue[ht], tt))
            }
            if (ve.indices !== void 0 && !oe.index) {
                var Bt = Ne.getDependency("accessor", ve.indices).then(function(Le) {
                    oe.setIndex(Le)
                });
                Oe.push(Bt)
            }
            return Ze(oe, ve), Dt(oe, ve, Ne), Promise.all(Oe).then(function() {
                return ve.targets !== void 0 ? st(oe, ve.targets, Ne) : oe
            })
        }

        function xi(oe, ve) {
            var Ne = oe.getIndex();
            if (Ne === null) {
                var Ue = [],
                    Oe = oe.getAttribute("position");
                if (Oe !== void 0) {
                    for (var at = 0; at < Oe.count; at++) Ue.push(at);
                    oe.setIndex(Ue), Ne = oe.getIndex()
                } else return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), oe
            }
            var ht = Ne.count - 2,
                tt = [];
            if (ve === y.TriangleFanDrawMode)
                for (var at = 1; at <= ht; at++) tt.push(Ne.getX(0)), tt.push(Ne.getX(at)), tt.push(Ne.getX(at + 1));
            else
                for (var at = 0; at < ht; at++) at % 2 === 0 ? (tt.push(Ne.getX(at)), tt.push(Ne.getX(at + 1)), tt.push(Ne.getX(at + 2))) : (tt.push(Ne.getX(at + 2)), tt.push(Ne.getX(at + 1)), tt.push(Ne.getX(at)));
            tt.length / 3 !== ht && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
            var Bt = oe.clone();
            return Bt.setIndex(tt), Bt
        }
        return Ve.prototype.loadGeometries = function(oe) {
            var ve = this,
                Ne = this.extensions,
                Ue = this.primitiveCache;

            function Oe(Wt) {
                return Ne[Y.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(Wt, ve).then(function(bi) {
                    return ei(bi, Wt, ve)
                })
            }
            for (var at = [], ht = 0, tt = oe.length; ht < tt; ht++) {
                var Bt = oe[ht],
                    Le = gt(Bt),
                    Ot = Ue[Le];
                if (Ot) at.push(Ot.promise);
                else {
                    var ii;
                    Bt.extensions && Bt.extensions[Y.KHR_DRACO_MESH_COMPRESSION] ? ii = Oe(Bt) : ii = ei(new y.BufferGeometry, Bt, ve), Ue[Le] = {
                        primitive: Bt,
                        promise: ii
                    }, at.push(ii)
                }
            }
            return Promise.all(at)
        }, Ve.prototype.loadMesh = function(oe) {
            for (var ve = this, Ne = this.json, Ue = this.extensions, Oe = Ne.meshes[oe], at = Oe.primitives, ht = [], tt = 0, Bt = at.length; tt < Bt; tt++) {
                var Le = at[tt].material === void 0 ? _e(this.cache) : this.getDependency("material", at[tt].material);
                ht.push(Le)
            }
            return ht.push(ve.loadGeometries(at)), Promise.all(ht).then(function(Ot) {
                for (var ii = Ot.slice(0, Ot.length - 1), Wt = Ot[Ot.length - 1], bi = [], Qi = 0, sn = Wt.length; Qi < sn; Qi++) {
                    var yn = Wt[Qi],
                        Yi = at[Qi],
                        rn, Mi = ii[Qi];
                    if (Yi.mode === Kt.TRIANGLES || Yi.mode === Kt.TRIANGLE_STRIP || Yi.mode === Kt.TRIANGLE_FAN || Yi.mode === void 0) rn = Oe.isSkinnedMesh === !0 ? new y.SkinnedMesh(yn, Mi) : new y.Mesh(yn, Mi), rn.isSkinnedMesh === !0 && !rn.geometry.attributes.skinWeight.normalized && rn.normalizeSkinWeights(), Yi.mode === Kt.TRIANGLE_STRIP ? rn.geometry = xi(rn.geometry, y.TriangleStripDrawMode) : Yi.mode === Kt.TRIANGLE_FAN && (rn.geometry = xi(rn.geometry, y.TriangleFanDrawMode));
                    else if (Yi.mode === Kt.LINES) rn = new y.LineSegments(yn, Mi);
                    else if (Yi.mode === Kt.LINE_STRIP) rn = new y.Line(yn, Mi);
                    else if (Yi.mode === Kt.LINE_LOOP) rn = new y.LineLoop(yn, Mi);
                    else if (Yi.mode === Kt.POINTS) rn = new y.Points(yn, Mi);
                    else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + Yi.mode);
                    Object.keys(rn.geometry.morphAttributes).length > 0 && De(rn, Oe), rn.name = ve.createUniqueName(Oe.name || "mesh_" + oe), Ze(rn, Oe), Yi.extensions && xe(Ue, rn, Yi), ve.assignFinalMaterial(rn), bi.push(rn)
                }
                if (bi.length === 1) return bi[0];
                for (var Ht = new y.Group, Qi = 0, sn = bi.length; Qi < sn; Qi++) Ht.add(bi[Qi]);
                return Ht
            })
        }, Ve.prototype.loadCamera = function(oe) {
            var ve, Ne = this.json.cameras[oe],
                Ue = Ne[Ne.type];
            if (!Ue) {
                console.warn("THREE.GLTFLoader: Missing camera parameters.");
                return
            }
            return Ne.type === "perspective" ? ve = new y.PerspectiveCamera(y.MathUtils.radToDeg(Ue.yfov), Ue.aspectRatio || 1, Ue.znear || 1, Ue.zfar || 2e6) : Ne.type === "orthographic" && (ve = new y.OrthographicCamera(-Ue.xmag, Ue.xmag, Ue.ymag, -Ue.ymag, Ue.znear, Ue.zfar)), Ne.name && (ve.name = this.createUniqueName(Ne.name)), Ze(ve, Ne), Promise.resolve(ve)
        }, Ve.prototype.loadSkin = function(oe) {
            var ve = this.json.skins[oe],
                Ne = {
                    joints: ve.joints
                };
            return ve.inverseBindMatrices === void 0 ? Promise.resolve(Ne) : this.getDependency("accessor", ve.inverseBindMatrices).then(function(Ue) {
                return Ne.inverseBindMatrices = Ue, Ne
            })
        }, Ve.prototype.loadAnimation = function(oe) {
            for (var ve = this.json, Ne = ve.animations[oe], Ue = [], Oe = [], at = [], ht = [], tt = [], Bt = 0, Le = Ne.channels.length; Bt < Le; Bt++) {
                var Ot = Ne.channels[Bt],
                    ii = Ne.samplers[Ot.sampler],
                    Wt = Ot.target,
                    bi = Wt.node !== void 0 ? Wt.node : Wt.id,
                    Qi = Ne.parameters !== void 0 ? Ne.parameters[ii.input] : ii.input,
                    sn = Ne.parameters !== void 0 ? Ne.parameters[ii.output] : ii.output;
                Ue.push(this.getDependency("node", bi)), Oe.push(this.getDependency("accessor", Qi)), at.push(this.getDependency("accessor", sn)), ht.push(ii), tt.push(Wt)
            }
            return Promise.all([Promise.all(Ue), Promise.all(Oe), Promise.all(at), Promise.all(ht), Promise.all(tt)]).then(function(yn) {
                for (var Yi = yn[0], rn = yn[1], Mi = yn[2], Ht = yn[3], Pt = yn[4], qn = [], ji = 0, na = Yi.length; ji < na; ji++) {
                    var cn = Yi[ji],
                        yi = rn[ji],
                        Si = Mi[ji],
                        qi = Ht[ji],
                        Nn = Pt[ji];
                    if (cn !== void 0) {
                        cn.updateMatrix(), cn.matrixAutoUpdate = !0;
                        var Bn;
                        switch (li[Nn.path]) {
                            case li.weights:
                                Bn = y.NumberKeyframeTrack;
                                break;
                            case li.rotation:
                                Bn = y.QuaternionKeyframeTrack;
                                break;
                            case li.position:
                            case li.scale:
                            default:
                                Bn = y.VectorKeyframeTrack;
                                break
                        }
                        var ge = cn.name ? cn.name : cn.uuid,
                            ga = qi.interpolation !== void 0 ? O[qi.interpolation] : y.InterpolateLinear,
                            On = [];
                        li[Nn.path] === li.weights ? cn.traverse(function(it) {
                            it.isMesh === !0 && it.morphTargetInfluences && On.push(it.name ? it.name : it.uuid)
                        }) : On.push(ge);
                        var Te = Si.array;
                        if (Si.normalized) {
                            var te;
                            if (Te.constructor === Int8Array) te = 1 / 127;
                            else if (Te.constructor === Uint8Array) te = 1 / 255;
                            else if (Te.constructor == Int16Array) te = 1 / 32767;
                            else if (Te.constructor === Uint16Array) te = 1 / 65535;
                            else throw new Error("THREE.GLTFLoader: Unsupported output accessor component type.");
                            for (var he = new Float32Array(Te.length), fe = 0, Ae = Te.length; fe < Ae; fe++) he[fe] = Te[fe] * te;
                            Te = he
                        }
                        for (var fe = 0, Ae = On.length; fe < Ae; fe++) {
                            var qe = new Bn(On[fe] + "." + li[Nn.path], yi.array, Te, ga);
                            qi.interpolation === "CUBICSPLINE" && (qe.createInterpolant = function(Jt) {
                                return new vt(this.times, this.values, this.getValueSize() / 3, Jt)
                            }, qe.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), qn.push(qe)
                        }
                    }
                }
                var et = Ne.name ? Ne.name : "animation_" + oe;
                return new y.AnimationClip(et, void 0, qn)
            })
        }, Ve.prototype.loadNode = function(oe) {
            var ve = this.json,
                Ne = this.extensions,
                Ue = this,
                Oe = ve.nodes[oe],
                at = Oe.name ? Ue.createUniqueName(Oe.name) : "";
            return function() {
                var ht = [];
                return Oe.mesh !== void 0 && ht.push(Ue.getDependency("mesh", Oe.mesh).then(function(tt) {
                    var Bt = Ue._getNodeRef(Ue.meshCache, Oe.mesh, tt);
                    return Oe.weights !== void 0 && Bt.traverse(function(Le) {
                        if (Le.isMesh)
                            for (var Ot = 0, ii = Oe.weights.length; Ot < ii; Ot++) Le.morphTargetInfluences[Ot] = Oe.weights[Ot]
                    }), Bt
                })), Oe.camera !== void 0 && ht.push(Ue.getDependency("camera", Oe.camera).then(function(tt) {
                    return Ue._getNodeRef(Ue.cameraCache, Oe.camera, tt)
                })), Ue._invokeAll(function(tt) {
                    return tt.createNodeAttachment && tt.createNodeAttachment(oe)
                }).forEach(function(tt) {
                    ht.push(tt)
                }), Promise.all(ht)
            }().then(function(ht) {
                var tt;
                if (Oe.isBone === !0 ? tt = new y.Bone : ht.length > 1 ? tt = new y.Group : ht.length === 1 ? tt = ht[0] : tt = new y.Object3D, tt !== ht[0])
                    for (var Bt = 0, Le = ht.length; Bt < Le; Bt++) tt.add(ht[Bt]);
                if (Oe.name && (tt.userData.name = Oe.name, tt.name = at), Ze(tt, Oe), Oe.extensions && xe(Ne, tt, Oe), Oe.matrix !== void 0) {
                    var Ot = new y.Matrix4;
                    Ot.fromArray(Oe.matrix), tt.applyMatrix4(Ot)
                } else Oe.translation !== void 0 && tt.position.fromArray(Oe.translation), Oe.rotation !== void 0 && tt.quaternion.fromArray(Oe.rotation), Oe.scale !== void 0 && tt.scale.fromArray(Oe.scale);
                return Ue.associations.set(tt, {
                    type: "nodes",
                    index: oe
                }), tt
            })
        }, Ve.prototype.loadScene = function() {
            function oe(ve, Ne, Ue, Oe) {
                var at = Ue.nodes[ve];
                return Oe.getDependency("node", ve).then(function(ht) {
                    if (at.skin === void 0) return ht;
                    var tt;
                    return Oe.getDependency("skin", at.skin).then(function(Bt) {
                        tt = Bt;
                        for (var Le = [], Ot = 0, ii = tt.joints.length; Ot < ii; Ot++) Le.push(Oe.getDependency("node", tt.joints[Ot]));
                        return Promise.all(Le)
                    }).then(function(Bt) {
                        return ht.traverse(function(Le) {
                            if (Le.isMesh) {
                                for (var Ot = [], ii = [], Wt = 0, bi = Bt.length; Wt < bi; Wt++) {
                                    var Qi = Bt[Wt];
                                    if (Qi) {
                                        Ot.push(Qi);
                                        var sn = new y.Matrix4;
                                        tt.inverseBindMatrices !== void 0 && sn.fromArray(tt.inverseBindMatrices.array, Wt * 16), ii.push(sn)
                                    } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', tt.joints[Wt])
                                }
                                Le.bind(new y.Skeleton(Ot, ii), Le.matrixWorld)
                            }
                        }), ht
                    })
                }).then(function(ht) {
                    Ne.add(ht);
                    var tt = [];
                    if (at.children)
                        for (var Bt = at.children, Le = 0, Ot = Bt.length; Le < Ot; Le++) {
                            var ii = Bt[Le];
                            tt.push(oe(ii, ht, Ue, Oe))
                        }
                    return Promise.all(tt)
                })
            }
            return function(Ne) {
                var Ue = this.json,
                    Oe = this.extensions,
                    at = this.json.scenes[Ne],
                    ht = this,
                    tt = new y.Group;
                at.name && (tt.name = ht.createUniqueName(at.name)), Ze(tt, at), at.extensions && xe(Oe, tt, at);
                for (var Bt = at.nodes || [], Le = [], Ot = 0, ii = Bt.length; Ot < ii; Ot++) Le.push(oe(Bt[Ot], tt, Ue, ht));
                return Promise.all(Le).then(function() {
                    return tt
                })
            }
        }(), z
    }(), ue.exports = y.GLTFLoader
})(Pf);
var fm = Pf.exports,
    kf = {
        exports: {}
    };
(function(ue, R) {
    const y = Xa;
    y.ColladaLoader = function(z) {
        y.Loader.call(this, z)
    }, y.ColladaLoader.prototype = Object.assign(Object.create(y.Loader.prototype), {
        constructor: y.ColladaLoader,
        load: function(z, V, Y, C) {
            var p = this,
                se = p.path === "" ? y.LoaderUtils.extractUrlBase(z) : p.path,
                ie = new y.FileLoader(p.manager);
            ie.setPath(p.path), ie.setRequestHeader(p.requestHeader), ie.setWithCredentials(p.withCredentials), ie.load(z, function(He) {
                try {
                    V(p.parse(He, se))
                } catch (be) {
                    C ? C(be) : console.error(be), p.manager.itemError(z)
                }
            }, Y, C)
        },
        options: {
            set convertUpAxis(z) {
                console.warn("THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.")
            }
        },
        parse: function(z, V) {
            function Y(J, W) {
                for (var re = [], ye = J.childNodes, me = 0, rt = ye.length; me < rt; me++) {
                    var At = ye[me];
                    At.nodeName === W && re.push(At)
                }
                return re
            }

            function C(J) {
                if (J.length === 0) return [];
                for (var W = J.trim().split(/\s+/), re = new Array(W.length), ye = 0, me = W.length; ye < me; ye++) re[ye] = W[ye];
                return re
            }

            function p(J) {
                if (J.length === 0) return [];
                for (var W = J.trim().split(/\s+/), re = new Array(W.length), ye = 0, me = W.length; ye < me; ye++) re[ye] = parseFloat(W[ye]);
                return re
            }

            function se(J) {
                if (J.length === 0) return [];
                for (var W = J.trim().split(/\s+/), re = new Array(W.length), ye = 0, me = W.length; ye < me; ye++) re[ye] = parseInt(W[ye]);
                return re
            }

            function ie(J) {
                return J.substring(1)
            }

            function He() {
                return "three_default_" + Ft++
            }

            function be(J) {
                return Object.keys(J).length === 0
            }

            function Ee(J) {
                return {
                    unit: Lt(Y(J, "unit")[0]),
                    upAxis: Tt(Y(J, "up_axis")[0])
                }
            }

            function Lt(J) {
                return J !== void 0 && J.hasAttribute("meter") === !0 ? parseFloat(J.getAttribute("meter")) : 1
            }

            function Tt(J) {
                return J !== void 0 ? J.textContent : "Y_UP"
            }

            function Je(J, W, re, ye) {
                var me = Y(J, W)[0];
                if (me !== void 0)
                    for (var rt = Y(me, re), At = 0; At < rt.length; At++) ye(rt[At])
            }

            function wt(J, W) {
                for (var re in J) {
                    var ye = J[re];
                    ye.build = W(J[re])
                }
            }

            function Ke(J, W) {
                return J.build !== void 0 || (J.build = W(J)), J.build
            }

            function Ye(J) {
                for (var W = {
                        sources: {},
                        samplers: {},
                        channels: {}
                    }, re = !1, ye = 0, me = J.childNodes.length; ye < me; ye++) {
                    var rt = J.childNodes[ye];
                    if (rt.nodeType === 1) {
                        var At;
                        switch (rt.nodeName) {
                            case "source":
                                At = rt.getAttribute("id"), W.sources[At] = Te(rt);
                                break;
                            case "sampler":
                                At = rt.getAttribute("id"), W.samplers[At] = jt(rt);
                                break;
                            case "channel":
                                At = rt.getAttribute("target"), W.channels[At] = di(rt);
                                break;
                            case "animation":
                                Ye(rt), re = !0;
                                break;
                            default:
                                console.log(rt)
                        }
                    }
                }
                re === !1 && (_t.animations[J.getAttribute("id") || y.MathUtils.generateUUID()] = W)
            }

            function jt(J) {
                for (var W = {
                        inputs: {}
                    }, re = 0, ye = J.childNodes.length; re < ye; re++) {
                    var me = J.childNodes[re];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "input":
                            var rt = ie(me.getAttribute("source")),
                                At = me.getAttribute("semantic");
                            W.inputs[At] = rt;
                            break
                    }
                }
                return W
            }

            function di(J) {
                var W = {},
                    re = J.getAttribute("target"),
                    ye = re.split("/"),
                    me = ye.shift(),
                    rt = ye.shift(),
                    At = rt.indexOf("(") !== -1,
                    Mt = rt.indexOf(".") !== -1;
                if (Mt) ye = rt.split("."), rt = ye.shift(), W.member = ye.shift();
                else if (At) {
                    var si = rt.split("(");
                    rt = si.shift();
                    for (var ti = 0; ti < si.length; ti++) si[ti] = parseInt(si[ti].replace(/\)/, ""));
                    W.indices = si
                }
                return W.id = me, W.sid = rt, W.arraySyntax = At, W.memberSyntax = Mt, W.sampler = ie(J.getAttribute("source")), W
            }

            function $e(J) {
                var W = [],
                    re = J.channels,
                    ye = J.samplers,
                    me = J.sources;
                for (var rt in re)
                    if (re.hasOwnProperty(rt)) {
                        var At = re[rt],
                            Mt = ye[At.sampler],
                            si = Mt.inputs.INPUT,
                            ti = Mt.inputs.OUTPUT,
                            ni = me[si],
                            ri = me[ti],
                            Wi = Kt(At, ni, ri);
                        je(Wi, W)
                    } return W
            }

            function vt(J) {
                return Ke(_t.animations[J], $e)
            }

            function Kt(J, W, re) {
                var ye = _t.nodes[J.id],
                    me = Jr(ye.id),
                    rt = ye.transforms[J.sid],
                    At = ye.matrix.clone().transpose(),
                    Mt, si, ti, ni, ri, Wi, Ci = {};
                switch (rt) {
                    case "matrix":
                        for (ti = 0, ni = W.array.length; ti < ni; ti++)
                            if (Mt = W.array[ti], si = ti * re.stride, Ci[Mt] === void 0 && (Ci[Mt] = {}), J.arraySyntax === !0) {
                                var Pi = re.array[si],
                                    ai = J.indices[0] + 4 * J.indices[1];
                                Ci[Mt][ai] = Pi
                            } else
                                for (ri = 0, Wi = re.stride; ri < Wi; ri++) Ci[Mt][ri] = re.array[si + ri];
                        break;
                    case "translate":
                        console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', rt);
                        break;
                    case "rotate":
                        console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', rt);
                        break;
                    case "scale":
                        console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', rt);
                        break
                }
                var Rt = vi(Ci, At),
                    Gi = {
                        name: me.uuid,
                        keyframes: Rt
                    };
                return Gi
            }

            function vi(J, W) {
                var re = [];
                for (var ye in J) re.push({
                    time: parseFloat(ye),
                    value: J[ye]
                });
                re.sort(rt);
                for (var me = 0; me < 16; me++) li(re, me, W.elements[me]);
                return re;

                function rt(At, Mt) {
                    return At.time - Mt.time
                }
            }
            var Li = new y.Vector3,
                Ei = new y.Vector3,
                ct = new y.Quaternion;

            function je(J, W) {
                for (var re = J.keyframes, ye = J.name, me = [], rt = [], At = [], Mt = [], si = 0, ti = re.length; si < ti; si++) {
                    var ni = re[si],
                        ri = ni.time,
                        Wi = ni.value;
                    Ui.fromArray(Wi).transpose(), Ui.decompose(Li, ct, Ei), me.push(ri), rt.push(Li.x, Li.y, Li.z), At.push(ct.x, ct.y, ct.z, ct.w), Mt.push(Ei.x, Ei.y, Ei.z)
                }
                return rt.length > 0 && W.push(new y.VectorKeyframeTrack(ye + ".position", me, rt)), At.length > 0 && W.push(new y.QuaternionKeyframeTrack(ye + ".quaternion", me, At)), Mt.length > 0 && W.push(new y.VectorKeyframeTrack(ye + ".scale", me, Mt)), W
            }

            function li(J, W, re) {
                var ye, me = !0,
                    rt, At;
                for (rt = 0, At = J.length; rt < At; rt++) ye = J[rt], ye.value[W] === void 0 ? ye.value[W] = null : me = !1;
                if (me === !0)
                    for (rt = 0, At = J.length; rt < At; rt++) ye = J[rt], ye.value[W] = re;
                else O(J, W)
            }

            function O(J, W) {
                for (var re, ye, me = 0, rt = J.length; me < rt; me++) {
                    var At = J[me];
                    if (At.value[W] === null) {
                        if (re = K(J, me, W), ye = ae(J, me, W), re === null) {
                            At.value[W] = ye.value[W];
                            continue
                        }
                        if (ye === null) {
                            At.value[W] = re.value[W];
                            continue
                        }
                        _e(At, re, ye, W)
                    }
                }
            }

            function K(J, W, re) {
                for (; W >= 0;) {
                    var ye = J[W];
                    if (ye.value[re] !== null) return ye;
                    W--
                }
                return null
            }

            function ae(J, W, re) {
                for (; W < J.length;) {
                    var ye = J[W];
                    if (ye.value[re] !== null) return ye;
                    W++
                }
                return null
            }

            function _e(J, W, re, ye) {
                if (re.time - W.time === 0) {
                    J.value[ye] = W.value[ye];
                    return
                }
                J.value[ye] = (J.time - W.time) * (re.value[ye] - W.value[ye]) / (re.time - W.time) + W.value[ye]
            }

            function xe(J) {
                for (var W = {
                        name: J.getAttribute("id") || "default",
                        start: parseFloat(J.getAttribute("start") || 0),
                        end: parseFloat(J.getAttribute("end") || 0),
                        animations: []
                    }, re = 0, ye = J.childNodes.length; re < ye; re++) {
                    var me = J.childNodes[re];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "instance_animation":
                            W.animations.push(ie(me.getAttribute("url")));
                            break
                    }
                }
                _t.clips[J.getAttribute("id")] = W
            }

            function Ze(J) {
                for (var W = [], re = J.name, ye = J.end - J.start || -1, me = J.animations, rt = 0, At = me.length; rt < At; rt++)
                    for (var Mt = vt(me[rt]), si = 0, ti = Mt.length; si < ti; si++) W.push(Mt[si]);
                return new y.AnimationClip(re, ye, W)
            }

            function st(J) {
                return Ke(_t.clips[J], Ze)
            }

            function De(J) {
                for (var W = {}, re = 0, ye = J.childNodes.length; re < ye; re++) {
                    var me = J.childNodes[re];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "skin":
                            W.id = ie(me.getAttribute("source")), W.skin = gt(me);
                            break;
                        case "morph":
                            W.id = ie(me.getAttribute("source")), console.warn("THREE.ColladaLoader: Morph target animation not supported yet.");
                            break
                    }
                }
                _t.controllers[J.getAttribute("id")] = W
            }

            function gt(J) {
                for (var W = {
                        sources: {}
                    }, re = 0, ye = J.childNodes.length; re < ye; re++) {
                    var me = J.childNodes[re];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "bind_shape_matrix":
                            W.bindShapeMatrix = p(me.textContent);
                            break;
                        case "source":
                            var rt = me.getAttribute("id");
                            W.sources[rt] = Te(me);
                            break;
                        case "joints":
                            W.joints = Qt(me);
                            break;
                        case "vertex_weights":
                            W.vertexWeights = Ve(me);
                            break
                    }
                }
                return W
            }

            function Qt(J) {
                for (var W = {
                        inputs: {}
                    }, re = 0, ye = J.childNodes.length; re < ye; re++) {
                    var me = J.childNodes[re];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "input":
                            var rt = me.getAttribute("semantic"),
                                At = ie(me.getAttribute("source"));
                            W.inputs[rt] = At;
                            break
                    }
                }
                return W
            }

            function Ve(J) {
                for (var W = {
                        inputs: {}
                    }, re = 0, ye = J.childNodes.length; re < ye; re++) {
                    var me = J.childNodes[re];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "input":
                            var rt = me.getAttribute("semantic"),
                                At = ie(me.getAttribute("source")),
                                Mt = parseInt(me.getAttribute("offset"));
                            W.inputs[rt] = {
                                id: At,
                                offset: Mt
                            };
                            break;
                        case "vcount":
                            W.vcount = se(me.textContent);
                            break;
                        case "v":
                            W.v = se(me.textContent);
                            break
                    }
                }
                return W
            }

            function Dt(J) {
                var W = {
                        id: J.id
                    },
                    re = _t.geometries[W.id];
                return J.skin !== void 0 && (W.skin = ei(J.skin), re.sources.skinIndices = W.skin.indices, re.sources.skinWeights = W.skin.weights), W
            }

            function ei(J) {
                var W = 4,
                    re = {
                        joints: [],
                        indices: {
                            array: [],
                            stride: W
                        },
                        weights: {
                            array: [],
                            stride: W
                        }
                    },
                    ye = J.sources,
                    me = J.vertexWeights,
                    rt = me.vcount,
                    At = me.v,
                    Mt = me.inputs.JOINT.offset,
                    si = me.inputs.WEIGHT.offset,
                    ti = J.sources[J.joints.inputs.JOINT],
                    ni = J.sources[J.joints.inputs.INV_BIND_MATRIX],
                    ri = ye[me.inputs.WEIGHT.id].array,
                    Wi = 0,
                    Ci, Pi, ai;
                for (Ci = 0, ai = rt.length; Ci < ai; Ci++) {
                    var Rt = rt[Ci],
                        Gi = [];
                    for (Pi = 0; Pi < Rt; Pi++) {
                        var ki = At[Wi + Mt],
                            pn = At[Wi + si],
                            pi = ri[pn];
                        Gi.push({
                            index: ki,
                            weight: pi
                        }), Wi += 2
                    }
                    for (Gi.sort(Xi), Pi = 0; Pi < W; Pi++) {
                        var Hi = Gi[Pi];
                        Hi !== void 0 ? (re.indices.array.push(Hi.index), re.weights.array.push(Hi.weight)) : (re.indices.array.push(0), re.weights.array.push(0))
                    }
                }
                for (J.bindShapeMatrix ? re.bindMatrix = new y.Matrix4().fromArray(J.bindShapeMatrix).transpose() : re.bindMatrix = new y.Matrix4().identity(), Ci = 0, ai = ti.array.length; Ci < ai; Ci++) {
                    var en = ti.array[Ci],
                        Bi = new y.Matrix4().fromArray(ni.array, Ci * ni.stride).transpose();
                    re.joints.push({
                        name: en,
                        boneInverse: Bi
                    })
                }
                return re;

                function Xi(Un, lr) {
                    return lr.weight - Un.weight
                }
            }

            function xi(J) {
                return Ke(_t.controllers[J], Dt)
            }

            function oe(J) {
                var W = {
                    init_from: Y(J, "init_from")[0].textContent
                };
                _t.images[J.getAttribute("id")] = W
            }

            function ve(J) {
                return J.build !== void 0 ? J.build : J.init_from
            }

            function Ne(J) {
                var W = _t.images[J];
                return W !== void 0 ? Ke(W, ve) : (console.warn("THREE.ColladaLoader: Couldn't find image with ID:", J), null)
            }

            function Ue(J) {
                for (var W = {}, re = 0, ye = J.childNodes.length; re < ye; re++) {
                    var me = J.childNodes[re];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "profile_COMMON":
                            W.profile = Oe(me);
                            break
                    }
                }
                _t.effects[J.getAttribute("id")] = W
            }

            function Oe(J) {
                for (var W = {
                        surfaces: {},
                        samplers: {}
                    }, re = 0, ye = J.childNodes.length; re < ye; re++) {
                    var me = J.childNodes[re];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "newparam":
                            at(me, W);
                            break;
                        case "technique":
                            W.technique = Bt(me);
                            break;
                        case "extra":
                            W.extra = Qi(me);
                            break
                    }
                }
                return W
            }

            function at(J, W) {
                for (var re = J.getAttribute("sid"), ye = 0, me = J.childNodes.length; ye < me; ye++) {
                    var rt = J.childNodes[ye];
                    if (rt.nodeType === 1) switch (rt.nodeName) {
                        case "surface":
                            W.surfaces[re] = ht(rt);
                            break;
                        case "sampler2D":
                            W.samplers[re] = tt(rt);
                            break
                    }
                }
            }

            function ht(J) {
                for (var W = {}, re = 0, ye = J.childNodes.length; re < ye; re++) {
                    var me = J.childNodes[re];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "init_from":
                            W.init_from = me.textContent;
                            break
                    }
                }
                return W
            }

            function tt(J) {
                for (var W = {}, re = 0, ye = J.childNodes.length; re < ye; re++) {
                    var me = J.childNodes[re];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "source":
                            W.source = me.textContent;
                            break
                    }
                }
                return W
            }

            function Bt(J) {
                for (var W = {}, re = 0, ye = J.childNodes.length; re < ye; re++) {
                    var me = J.childNodes[re];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "constant":
                        case "lambert":
                        case "blinn":
                        case "phong":
                            W.type = me.nodeName, W.parameters = Le(me);
                            break
                    }
                }
                return W
            }

            function Le(J) {
                for (var W = {}, re = 0, ye = J.childNodes.length; re < ye; re++) {
                    var me = J.childNodes[re];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "emission":
                        case "diffuse":
                        case "specular":
                        case "bump":
                        case "ambient":
                        case "shininess":
                        case "transparency":
                            W[me.nodeName] = Ot(me);
                            break;
                        case "transparent":
                            W[me.nodeName] = {
                                opaque: me.getAttribute("opaque"),
                                data: Ot(me)
                            };
                            break
                    }
                }
                return W
            }

            function Ot(J) {
                for (var W = {}, re = 0, ye = J.childNodes.length; re < ye; re++) {
                    var me = J.childNodes[re];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "color":
                            W[me.nodeName] = p(me.textContent);
                            break;
                        case "float":
                            W[me.nodeName] = parseFloat(me.textContent);
                            break;
                        case "texture":
                            W[me.nodeName] = {
                                id: me.getAttribute("texture"),
                                extra: ii(me)
                            };
                            break
                    }
                }
                return W
            }

            function ii(J) {
                for (var W = {
                        technique: {}
                    }, re = 0, ye = J.childNodes.length; re < ye; re++) {
                    var me = J.childNodes[re];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "extra":
                            Wt(me, W);
                            break
                    }
                }
                return W
            }

            function Wt(J, W) {
                for (var re = 0, ye = J.childNodes.length; re < ye; re++) {
                    var me = J.childNodes[re];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "technique":
                            bi(me, W);
                            break
                    }
                }
            }

            function bi(J, W) {
                for (var re = 0, ye = J.childNodes.length; re < ye; re++) {
                    var me = J.childNodes[re];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "repeatU":
                        case "repeatV":
                        case "offsetU":
                        case "offsetV":
                            W.technique[me.nodeName] = parseFloat(me.textContent);
                            break;
                        case "wrapU":
                        case "wrapV":
                            me.textContent.toUpperCase() === "TRUE" ? W.technique[me.nodeName] = 1 : me.textContent.toUpperCase() === "FALSE" ? W.technique[me.nodeName] = 0 : W.technique[me.nodeName] = parseInt(me.textContent);
                            break
                    }
                }
            }

            function Qi(J) {
                for (var W = {}, re = 0, ye = J.childNodes.length; re < ye; re++) {
                    var me = J.childNodes[re];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "technique":
                            W.technique = sn(me);
                            break
                    }
                }
                return W
            }

            function sn(J) {
                for (var W = {}, re = 0, ye = J.childNodes.length; re < ye; re++) {
                    var me = J.childNodes[re];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "double_sided":
                            W[me.nodeName] = parseInt(me.textContent);
                            break
                    }
                }
                return W
            }

            function yn(J) {
                return J
            }

            function Yi(J) {
                return Ke(_t.effects[J], yn)
            }

            function rn(J) {
                for (var W = {
                        name: J.getAttribute("name")
                    }, re = 0, ye = J.childNodes.length; re < ye; re++) {
                    var me = J.childNodes[re];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "instance_effect":
                            W.url = ie(me.getAttribute("url"));
                            break
                    }
                }
                _t.materials[J.getAttribute("id")] = W
            }

            function Mi(J) {
                var W, re = J.slice((J.lastIndexOf(".") - 1 >>> 0) + 2);
                switch (re = re.toLowerCase(), re) {
                    case "tga":
                        W = de;
                        break;
                    default:
                        W = q
                }
                return W
            }

            function Ht(J) {
                var W = Yi(J.url),
                    re = W.profile.technique,
                    ye = W.profile.extra,
                    me;
                switch (re.type) {
                    case "phong":
                    case "blinn":
                        me = new y.MeshPhongMaterial;
                        break;
                    case "lambert":
                        me = new y.MeshLambertMaterial;
                        break;
                    default:
                        me = new y.MeshBasicMaterial;
                        break
                }
                me.name = J.name || "";

                function rt(Wi) {
                    var Ci = W.profile.samplers[Wi.id],
                        Pi = null;
                    if (Ci !== void 0) {
                        var ai = W.profile.surfaces[Ci.source];
                        Pi = Ne(ai.init_from)
                    } else console.warn("THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530)."), Pi = Ne(Wi.id);
                    if (Pi !== null) {
                        var Rt = Mi(Pi);
                        if (Rt !== void 0) {
                            var Gi = Rt.load(Pi),
                                ki = Wi.extra;
                            if (ki !== void 0 && ki.technique !== void 0 && be(ki.technique) === !1) {
                                var pn = ki.technique;
                                Gi.wrapS = pn.wrapU ? y.RepeatWrapping : y.ClampToEdgeWrapping, Gi.wrapT = pn.wrapV ? y.RepeatWrapping : y.ClampToEdgeWrapping, Gi.offset.set(pn.offsetU || 0, pn.offsetV || 0), Gi.repeat.set(pn.repeatU || 1, pn.repeatV || 1)
                            } else Gi.wrapS = y.RepeatWrapping, Gi.wrapT = y.RepeatWrapping;
                            return Gi
                        } else return console.warn("THREE.ColladaLoader: Loader for texture %s not found.", Pi), null
                    } else return console.warn("THREE.ColladaLoader: Couldn't create texture with ID:", Wi.id), null
                }
                var At = re.parameters;
                for (var Mt in At) {
                    var si = At[Mt];
                    switch (Mt) {
                        case "diffuse":
                            si.color && me.color.fromArray(si.color), si.texture && (me.map = rt(si.texture));
                            break;
                        case "specular":
                            si.color && me.specular && me.specular.fromArray(si.color), si.texture && (me.specularMap = rt(si.texture));
                            break;
                        case "bump":
                            si.texture && (me.normalMap = rt(si.texture));
                            break;
                        case "ambient":
                            si.texture && (me.lightMap = rt(si.texture));
                            break;
                        case "shininess":
                            si.float && me.shininess && (me.shininess = si.float);
                            break;
                        case "emission":
                            si.color && me.emissive && me.emissive.fromArray(si.color), si.texture && (me.emissiveMap = rt(si.texture));
                            break
                    }
                }
                var ti = At.transparent,
                    ni = At.transparency;
                if (ni === void 0 && ti && (ni = {
                        float: 1
                    }), ti === void 0 && ni && (ti = {
                        opaque: "A_ONE",
                        data: {
                            color: [1, 1, 1, 1]
                        }
                    }), ti && ni)
                    if (ti.data.texture) me.transparent = !0;
                    else {
                        var ri = ti.data.color;
                        switch (ti.opaque) {
                            case "A_ONE":
                                me.opacity = ri[3] * ni.float;
                                break;
                            case "RGB_ZERO":
                                me.opacity = 1 - ri[0] * ni.float;
                                break;
                            case "A_ZERO":
                                me.opacity = 1 - ri[3] * ni.float;
                                break;
                            case "RGB_ONE":
                                me.opacity = ri[0] * ni.float;
                                break;
                            default:
                                console.warn('THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.', ti.opaque)
                        }
                        me.opacity < 1 && (me.transparent = !0)
                    } return ye !== void 0 && ye.technique !== void 0 && ye.technique.double_sided === 1 && (me.side = y.DoubleSide), me
            }

            function Pt(J) {
                return Ke(_t.materials[J], Ht)
            }

            function qn(J) {
                for (var W = {
                        name: J.getAttribute("name")
                    }, re = 0, ye = J.childNodes.length; re < ye; re++) {
                    var me = J.childNodes[re];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "optics":
                            W.optics = ji(me);
                            break
                    }
                }
                _t.cameras[J.getAttribute("id")] = W
            }

            function ji(J) {
                for (var W = 0; W < J.childNodes.length; W++) {
                    var re = J.childNodes[W];
                    switch (re.nodeName) {
                        case "technique_common":
                            return na(re)
                    }
                }
                return {}
            }

            function na(J) {
                for (var W = {}, re = 0; re < J.childNodes.length; re++) {
                    var ye = J.childNodes[re];
                    switch (ye.nodeName) {
                        case "perspective":
                        case "orthographic":
                            W.technique = ye.nodeName, W.parameters = cn(ye);
                            break
                    }
                }
                return W
            }

            function cn(J) {
                for (var W = {}, re = 0; re < J.childNodes.length; re++) {
                    var ye = J.childNodes[re];
                    switch (ye.nodeName) {
                        case "xfov":
                        case "yfov":
                        case "xmag":
                        case "ymag":
                        case "znear":
                        case "zfar":
                        case "aspect_ratio":
                            W[ye.nodeName] = parseFloat(ye.textContent);
                            break
                    }
                }
                return W
            }

            function yi(J) {
                var W;
                switch (J.optics.technique) {
                    case "perspective":
                        W = new y.PerspectiveCamera(J.optics.parameters.yfov, J.optics.parameters.aspect_ratio, J.optics.parameters.znear, J.optics.parameters.zfar);
                        break;
                    case "orthographic":
                        var re = J.optics.parameters.ymag,
                            ye = J.optics.parameters.xmag,
                            me = J.optics.parameters.aspect_ratio;
                        ye = ye === void 0 ? re * me : ye, re = re === void 0 ? ye / me : re, ye *= .5, re *= .5, W = new y.OrthographicCamera(-ye, ye, re, -re, J.optics.parameters.znear, J.optics.parameters.zfar);
                        break;
                    default:
                        W = new y.PerspectiveCamera;
                        break
                }
                return W.name = J.name || "", W
            }

            function Si(J) {
                var W = _t.cameras[J];
                return W !== void 0 ? Ke(W, yi) : (console.warn("THREE.ColladaLoader: Couldn't find camera with ID:", J), null)
            }

            function qi(J) {
                for (var W = {}, re = 0, ye = J.childNodes.length; re < ye; re++) {
                    var me = J.childNodes[re];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "technique_common":
                            W = Nn(me);
                            break
                    }
                }
                _t.lights[J.getAttribute("id")] = W
            }

            function Nn(J) {
                for (var W = {}, re = 0, ye = J.childNodes.length; re < ye; re++) {
                    var me = J.childNodes[re];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "directional":
                        case "point":
                        case "spot":
                        case "ambient":
                            W.technique = me.nodeName, W.parameters = Bn(me)
                    }
                }
                return W
            }

            function Bn(J) {
                for (var W = {}, re = 0, ye = J.childNodes.length; re < ye; re++) {
                    var me = J.childNodes[re];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "color":
                            var rt = p(me.textContent);
                            W.color = new y.Color().fromArray(rt);
                            break;
                        case "falloff_angle":
                            W.falloffAngle = parseFloat(me.textContent);
                            break;
                        case "quadratic_attenuation":
                            var At = parseFloat(me.textContent);
                            W.distance = At ? Math.sqrt(1 / At) : 0;
                            break
                    }
                }
                return W
            }

            function ge(J) {
                var W;
                switch (J.technique) {
                    case "directional":
                        W = new y.DirectionalLight;
                        break;
                    case "point":
                        W = new y.PointLight;
                        break;
                    case "spot":
                        W = new y.SpotLight;
                        break;
                    case "ambient":
                        W = new y.AmbientLight;
                        break
                }
                return J.parameters.color && W.color.copy(J.parameters.color), J.parameters.distance && (W.distance = J.parameters.distance), W
            }

            function ga(J) {
                var W = _t.lights[J];
                return W !== void 0 ? Ke(W, ge) : (console.warn("THREE.ColladaLoader: Couldn't find light with ID:", J), null)
            }

            function On(J) {
                var W = {
                        name: J.getAttribute("name"),
                        sources: {},
                        vertices: {},
                        primitives: []
                    },
                    re = Y(J, "mesh")[0];
                if (re !== void 0) {
                    for (var ye = 0; ye < re.childNodes.length; ye++) {
                        var me = re.childNodes[ye];
                        if (me.nodeType === 1) {
                            var rt = me.getAttribute("id");
                            switch (me.nodeName) {
                                case "source":
                                    W.sources[rt] = Te(me);
                                    break;
                                case "vertices":
                                    W.vertices = te(me);
                                    break;
                                case "polygons":
                                    console.warn("THREE.ColladaLoader: Unsupported primitive type: ", me.nodeName);
                                    break;
                                case "lines":
                                case "linestrips":
                                case "polylist":
                                case "triangles":
                                    W.primitives.push(he(me));
                                    break;
                                default:
                                    console.log(me)
                            }
                        }
                    }
                    _t.geometries[J.getAttribute("id")] = W
                }
            }

            function Te(J) {
                for (var W = {
                        array: [],
                        stride: 3
                    }, re = 0; re < J.childNodes.length; re++) {
                    var ye = J.childNodes[re];
                    if (ye.nodeType === 1) switch (ye.nodeName) {
                        case "float_array":
                            W.array = p(ye.textContent);
                            break;
                        case "Name_array":
                            W.array = C(ye.textContent);
                            break;
                        case "technique_common":
                            var me = Y(ye, "accessor")[0];
                            me !== void 0 && (W.stride = parseInt(me.getAttribute("stride")));
                            break
                    }
                }
                return W
            }

            function te(J) {
                for (var W = {}, re = 0; re < J.childNodes.length; re++) {
                    var ye = J.childNodes[re];
                    ye.nodeType === 1 && (W[ye.getAttribute("semantic")] = ie(ye.getAttribute("source")))
                }
                return W
            }

            function he(J) {
                for (var W = {
                        type: J.nodeName,
                        material: J.getAttribute("material"),
                        count: parseInt(J.getAttribute("count")),
                        inputs: {},
                        stride: 0,
                        hasUV: !1
                    }, re = 0, ye = J.childNodes.length; re < ye; re++) {
                    var me = J.childNodes[re];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "input":
                            var rt = ie(me.getAttribute("source")),
                                At = me.getAttribute("semantic"),
                                Mt = parseInt(me.getAttribute("offset")),
                                si = parseInt(me.getAttribute("set")),
                                ti = si > 0 ? At + si : At;
                            W.inputs[ti] = {
                                id: rt,
                                offset: Mt
                            }, W.stride = Math.max(W.stride, Mt + 1), At === "TEXCOORD" && (W.hasUV = !0);
                            break;
                        case "vcount":
                            W.vcount = se(me.textContent);
                            break;
                        case "p":
                            W.p = se(me.textContent);
                            break
                    }
                }
                return W
            }

            function fe(J) {
                for (var W = {}, re = 0; re < J.length; re++) {
                    var ye = J[re];
                    W[ye.type] === void 0 && (W[ye.type] = []), W[ye.type].push(ye)
                }
                return W
            }

            function Ae(J) {
                for (var W = 0, re = 0, ye = J.length; re < ye; re++) {
                    var me = J[re];
                    me.hasUV === !0 && W++
                }
                W > 0 && W < J.length && (J.uvsNeedsFix = !0)
            }

            function qe(J) {
                var W = {},
                    re = J.sources,
                    ye = J.vertices,
                    me = J.primitives;
                if (me.length === 0) return {};
                var rt = fe(me);
                for (var At in rt) {
                    var Mt = rt[At];
                    Ae(Mt), W[At] = et(Mt, re, ye)
                }
                return W
            }

            function et(J, W, re) {
                for (var ye = {}, me = {
                        array: [],
                        stride: 0
                    }, rt = {
                        array: [],
                        stride: 0
                    }, At = {
                        array: [],
                        stride: 0
                    }, Mt = {
                        array: [],
                        stride: 0
                    }, si = {
                        array: [],
                        stride: 0
                    }, ti = {
                        array: [],
                        stride: 4
                    }, ni = {
                        array: [],
                        stride: 4
                    }, ri = new y.BufferGeometry, Wi = [], Ci = 0, Pi = 0; Pi < J.length; Pi++) {
                    var ai = J[Pi],
                        Rt = ai.inputs,
                        Gi = 0;
                    switch (ai.type) {
                        case "lines":
                        case "linestrips":
                            Gi = ai.count * 2;
                            break;
                        case "triangles":
                            Gi = ai.count * 3;
                            break;
                        case "polylist":
                            for (var ki = 0; ki < ai.count; ki++) {
                                var pn = ai.vcount[ki];
                                switch (pn) {
                                    case 3:
                                        Gi += 3;
                                        break;
                                    case 4:
                                        Gi += 6;
                                        break;
                                    default:
                                        Gi += (pn - 2) * 3;
                                        break
                                }
                            }
                            break;
                        default:
                            console.warn("THREE.ColladaLoader: Unknow primitive type:", ai.type)
                    }
                    ri.addGroup(Ci, Gi, Pi), Ci += Gi, ai.material && Wi.push(ai.material);
                    for (var pi in Rt) {
                        var Hi = Rt[pi];
                        switch (pi) {
                            case "VERTEX":
                                for (var en in re) {
                                    var Bi = re[en];
                                    switch (en) {
                                        case "POSITION":
                                            var Xi = me.array.length;
                                            if (it(ai, W[Bi], Hi.offset, me.array), me.stride = W[Bi].stride, W.skinWeights && W.skinIndices && (it(ai, W.skinIndices, Hi.offset, ti.array), it(ai, W.skinWeights, Hi.offset, ni.array)), ai.hasUV === !1 && J.uvsNeedsFix === !0)
                                                for (var Gi = (me.array.length - Xi) / me.stride, Un = 0; Un < Gi; Un++) At.array.push(0, 0);
                                            break;
                                        case "NORMAL":
                                            it(ai, W[Bi], Hi.offset, rt.array), rt.stride = W[Bi].stride;
                                            break;
                                        case "COLOR":
                                            it(ai, W[Bi], Hi.offset, si.array), si.stride = W[Bi].stride;
                                            break;
                                        case "TEXCOORD":
                                            it(ai, W[Bi], Hi.offset, At.array), At.stride = W[Bi].stride;
                                            break;
                                        case "TEXCOORD1":
                                            it(ai, W[Bi], Hi.offset, Mt.array), At.stride = W[Bi].stride;
                                            break;
                                        default:
                                            console.warn('THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.', en)
                                    }
                                }
                                break;
                            case "NORMAL":
                                it(ai, W[Hi.id], Hi.offset, rt.array), rt.stride = W[Hi.id].stride;
                                break;
                            case "COLOR":
                                it(ai, W[Hi.id], Hi.offset, si.array), si.stride = W[Hi.id].stride;
                                break;
                            case "TEXCOORD":
                                it(ai, W[Hi.id], Hi.offset, At.array), At.stride = W[Hi.id].stride;
                                break;
                            case "TEXCOORD1":
                                it(ai, W[Hi.id], Hi.offset, Mt.array), Mt.stride = W[Hi.id].stride;
                                break
                        }
                    }
                }
                return me.array.length > 0 && ri.setAttribute("position", new y.Float32BufferAttribute(me.array, me.stride)), rt.array.length > 0 && ri.setAttribute("normal", new y.Float32BufferAttribute(rt.array, rt.stride)), si.array.length > 0 && ri.setAttribute("color", new y.Float32BufferAttribute(si.array, si.stride)), At.array.length > 0 && ri.setAttribute("uv", new y.Float32BufferAttribute(At.array, At.stride)), Mt.array.length > 0 && ri.setAttribute("uv2", new y.Float32BufferAttribute(Mt.array, Mt.stride)), ti.array.length > 0 && ri.setAttribute("skinIndex", new y.Float32BufferAttribute(ti.array, ti.stride)), ni.array.length > 0 && ri.setAttribute("skinWeight", new y.Float32BufferAttribute(ni.array, ni.stride)), ye.data = ri, ye.type = J[0].type, ye.materialKeys = Wi, ye
            }

            function it(J, W, re, ye) {
                var me = J.p,
                    rt = J.stride,
                    At = J.vcount;

                function Mt(pi) {
                    for (var Hi = me[pi + re] * ti, en = Hi + ti; Hi < en; Hi++) ye.push(si[Hi])
                }
                var si = W.array,
                    ti = W.stride;
                if (J.vcount !== void 0)
                    for (var ni = 0, ri = 0, Wi = At.length; ri < Wi; ri++) {
                        var Ci = At[ri];
                        if (Ci === 4) {
                            var Pi = ni + rt * 0,
                                ai = ni + rt * 1,
                                Rt = ni + rt * 2,
                                Gi = ni + rt * 3;
                            Mt(Pi), Mt(ai), Mt(Gi), Mt(ai), Mt(Rt), Mt(Gi)
                        } else if (Ci === 3) {
                            var Pi = ni + rt * 0,
                                ai = ni + rt * 1,
                                Rt = ni + rt * 2;
                            Mt(Pi), Mt(ai), Mt(Rt)
                        } else if (Ci > 4)
                            for (var ki = 1, pn = Ci - 2; ki <= pn; ki++) {
                                var Pi = ni + rt * 0,
                                    ai = ni + rt * ki,
                                    Rt = ni + rt * (ki + 1);
                                Mt(Pi), Mt(ai), Mt(Rt)
                            }
                        ni += rt * Ci
                    } else
                        for (var ri = 0, Wi = me.length; ri < Wi; ri += rt) Mt(ri)
            }

            function We(J) {
                return Ke(_t.geometries[J], qe)
            }

            function ft(J) {
                for (var W = {
                        name: J.getAttribute("name") || "",
                        joints: {},
                        links: []
                    }, re = 0; re < J.childNodes.length; re++) {
                    var ye = J.childNodes[re];
                    if (ye.nodeType === 1) switch (ye.nodeName) {
                        case "technique_common":
                            It(ye, W);
                            break
                    }
                }
                _t.kinematicsModels[J.getAttribute("id")] = W
            }

            function Jt(J) {
                return J.build !== void 0 ? J.build : J
            }

            function zt(J) {
                return Ke(_t.kinematicsModels[J], Jt)
            }

            function It(J, W) {
                for (var re = 0; re < J.childNodes.length; re++) {
                    var ye = J.childNodes[re];
                    if (ye.nodeType === 1) switch (ye.nodeName) {
                        case "joint":
                            W.joints[ye.getAttribute("sid")] = zi(ye);
                            break;
                        case "link":
                            W.links.push(dn(ye));
                            break
                    }
                }
            }

            function zi(J) {
                for (var W, re = 0; re < J.childNodes.length; re++) {
                    var ye = J.childNodes[re];
                    if (ye.nodeType === 1) switch (ye.nodeName) {
                        case "prismatic":
                        case "revolute":
                            W = Zi(ye);
                            break
                    }
                }
                return W
            }

            function Zi(J, re) {
                for (var re = {
                        sid: J.getAttribute("sid"),
                        name: J.getAttribute("name") || "",
                        axis: new y.Vector3,
                        limits: {
                            min: 0,
                            max: 0
                        },
                        type: J.nodeName,
                        static: !1,
                        zeroPosition: 0,
                        middlePosition: 0
                    }, ye = 0; ye < J.childNodes.length; ye++) {
                    var me = J.childNodes[ye];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "axis":
                            var rt = p(me.textContent);
                            re.axis.fromArray(rt);
                            break;
                        case "limits":
                            var At = me.getElementsByTagName("max")[0],
                                Mt = me.getElementsByTagName("min")[0];
                            re.limits.max = parseFloat(At.textContent), re.limits.min = parseFloat(Mt.textContent);
                            break
                    }
                }
                return re.limits.min >= re.limits.max && (re.static = !0), re.middlePosition = (re.limits.min + re.limits.max) / 2, re
            }

            function dn(J) {
                for (var W = {
                        sid: J.getAttribute("sid"),
                        name: J.getAttribute("name") || "",
                        attachments: [],
                        transforms: []
                    }, re = 0; re < J.childNodes.length; re++) {
                    var ye = J.childNodes[re];
                    if (ye.nodeType === 1) switch (ye.nodeName) {
                        case "attachment_full":
                            W.attachments.push(on(ye));
                            break;
                        case "matrix":
                        case "translate":
                        case "rotate":
                            W.transforms.push(vn(ye));
                            break
                    }
                }
                return W
            }

            function on(J) {
                for (var W = {
                        joint: J.getAttribute("joint").split("/").pop(),
                        transforms: [],
                        links: []
                    }, re = 0; re < J.childNodes.length; re++) {
                    var ye = J.childNodes[re];
                    if (ye.nodeType === 1) switch (ye.nodeName) {
                        case "link":
                            W.links.push(dn(ye));
                            break;
                        case "matrix":
                        case "translate":
                        case "rotate":
                            W.transforms.push(vn(ye));
                            break
                    }
                }
                return W
            }

            function vn(J) {
                var W = {
                        type: J.nodeName
                    },
                    re = p(J.textContent);
                switch (W.type) {
                    case "matrix":
                        W.obj = new y.Matrix4, W.obj.fromArray(re).transpose();
                        break;
                    case "translate":
                        W.obj = new y.Vector3, W.obj.fromArray(re);
                        break;
                    case "rotate":
                        W.obj = new y.Vector3, W.obj.fromArray(re), W.angle = y.MathUtils.degToRad(re[3]);
                        break
                }
                return W
            }

            function Pn(J) {
                for (var W = {
                        name: J.getAttribute("name") || "",
                        rigidBodies: {}
                    }, re = 0; re < J.childNodes.length; re++) {
                    var ye = J.childNodes[re];
                    if (ye.nodeType === 1) switch (ye.nodeName) {
                        case "rigid_body":
                            W.rigidBodies[ye.getAttribute("name")] = {}, Fn(ye, W.rigidBodies[ye.getAttribute("name")]);
                            break
                    }
                }
                _t.physicsModels[J.getAttribute("id")] = W
            }

            function Fn(J, W) {
                for (var re = 0; re < J.childNodes.length; re++) {
                    var ye = J.childNodes[re];
                    if (ye.nodeType === 1) switch (ye.nodeName) {
                        case "technique_common":
                            kn(ye, W);
                            break
                    }
                }
            }

            function kn(J, W) {
                for (var re = 0; re < J.childNodes.length; re++) {
                    var ye = J.childNodes[re];
                    if (ye.nodeType === 1) switch (ye.nodeName) {
                        case "inertia":
                            W.inertia = p(ye.textContent);
                            break;
                        case "mass":
                            W.mass = p(ye.textContent)[0];
                            break
                    }
                }
            }

            function hn(J) {
                for (var W = {
                        bindJointAxis: []
                    }, re = 0; re < J.childNodes.length; re++) {
                    var ye = J.childNodes[re];
                    if (ye.nodeType === 1) switch (ye.nodeName) {
                        case "bind_joint_axis":
                            W.bindJointAxis.push(Vn(ye));
                            break
                    }
                }
                _t.kinematicsScenes[ie(J.getAttribute("url"))] = W
            }

            function Vn(J) {
                for (var W = {
                        target: J.getAttribute("target").split("/").pop()
                    }, re = 0; re < J.childNodes.length; re++) {
                    var ye = J.childNodes[re];
                    if (ye.nodeType === 1) switch (ye.nodeName) {
                        case "axis":
                            var me = ye.getElementsByTagName("param")[0];
                            W.axis = me.textContent;
                            var rt = W.axis.split("inst_").pop().split("axis")[0];
                            W.jointIndex = rt.substr(0, rt.length - 1);
                            break
                    }
                }
                return W
            }

            function Gn(J) {
                return J.build !== void 0 ? J.build : J
            }

            function zr(J) {
                return Ke(_t.kinematicsScenes[J], Gn)
            }

            function br() {
                var J = Object.keys(_t.kinematicsModels)[0],
                    W = Object.keys(_t.kinematicsScenes)[0],
                    re = Object.keys(_t.visualScenes)[0];
                if (J === void 0 || W === void 0) return;
                for (var ye = zt(J), me = zr(W), rt = Ln(re), At = me.bindJointAxis, Mt = {}, si = 0, ti = At.length; si < ti; si++) {
                    var ni = At[si],
                        ri = $n.querySelector('[sid="' + ni.target + '"]');
                    if (ri) {
                        var Wi = ri.parentElement;
                        Ci(ni.jointIndex, Wi)
                    }
                }

                function Ci(ai, Rt) {
                    var Gi = Rt.getAttribute("name"),
                        ki = ye.joints[ai];
                    rt.traverse(function(pn) {
                        pn.name === Gi && (Mt[ai] = {
                            object: pn,
                            transforms: ur(Rt),
                            joint: ki,
                            position: ki.zeroPosition
                        })
                    })
                }
                var Pi = new y.Matrix4;
                Et = {
                    joints: ye && ye.joints,
                    getJointValue: function(ai) {
                        var Rt = Mt[ai];
                        if (Rt) return Rt.position;
                        console.warn("THREE.ColladaLoader: Joint " + ai + " doesn't exist.")
                    },
                    setJointValue: function(ai, Rt) {
                        var Gi = Mt[ai];
                        if (Gi) {
                            var ki = Gi.joint;
                            if (Rt > ki.limits.max || Rt < ki.limits.min) console.warn("THREE.ColladaLoader: Joint " + ai + " value " + Rt + " outside of limits (min: " + ki.limits.min + ", max: " + ki.limits.max + ").");
                            else if (ki.static) console.warn("THREE.ColladaLoader: Joint " + ai + " is static.");
                            else {
                                var pn = Gi.object,
                                    pi = ki.axis,
                                    Hi = Gi.transforms;
                                Ui.identity();
                                for (var en = 0; en < Hi.length; en++) {
                                    var Bi = Hi[en];
                                    if (Bi.sid && Bi.sid.indexOf(ai) !== -1) switch (ki.type) {
                                        case "revolute":
                                            Ui.multiply(Pi.makeRotationAxis(pi, y.MathUtils.degToRad(Rt)));
                                            break;
                                        case "prismatic":
                                            Ui.multiply(Pi.makeTranslation(pi.x * Rt, pi.y * Rt, pi.z * Rt));
                                            break;
                                        default:
                                            console.warn("THREE.ColladaLoader: Unknown joint type: " + ki.type);
                                            break
                                    } else switch (Bi.type) {
                                        case "matrix":
                                            Ui.multiply(Bi.obj);
                                            break;
                                        case "translate":
                                            Ui.multiply(Pi.makeTranslation(Bi.obj.x, Bi.obj.y, Bi.obj.z));
                                            break;
                                        case "scale":
                                            Ui.scale(Bi.obj);
                                            break;
                                        case "rotate":
                                            Ui.multiply(Pi.makeRotationAxis(Bi.obj, Bi.angle));
                                            break
                                    }
                                }
                                pn.matrix.copy(Ui), pn.matrix.decompose(pn.position, pn.quaternion, pn.scale), Mt[ai].position = Rt
                            }
                        } else console.log("THREE.ColladaLoader: " + ai + " does not exist.")
                    }
                }
            }

            function ur(J) {
                for (var W = [], re = $n.querySelector('[id="' + J.id + '"]'), ye = 0; ye < re.childNodes.length; ye++) {
                    var me = re.childNodes[ye];
                    if (me.nodeType === 1) switch (me.nodeName) {
                        case "matrix":
                            var At = p(me.textContent),
                                rt = new y.Matrix4().fromArray(At).transpose();
                            W.push({
                                sid: me.getAttribute("sid"),
                                type: me.nodeName,
                                obj: rt
                            });
                            break;
                        case "translate":
                        case "scale":
                            var At = p(me.textContent),
                                Mt = new y.Vector3().fromArray(At);
                            W.push({
                                sid: me.getAttribute("sid"),
                                type: me.nodeName,
                                obj: Mt
                            });
                            break;
                        case "rotate":
                            var At = p(me.textContent),
                                Mt = new y.Vector3().fromArray(At),
                                si = y.MathUtils.degToRad(At[3]);
                            W.push({
                                sid: me.getAttribute("sid"),
                                type: me.nodeName,
                                obj: Mt,
                                angle: si
                            });
                            break
                    }
                }
                return W
            }

            function wr(J) {
                for (var W = J.getElementsByTagName("node"), re = 0; re < W.length; re++) {
                    var ye = W[re];
                    ye.hasAttribute("id") === !1 && ye.setAttribute("id", He())
                }
            }
            var Ui = new y.Matrix4,
                ya = new y.Vector3;

            function _n(J) {
                for (var W = {
                        name: J.getAttribute("name") || "",
                        type: J.getAttribute("type"),
                        id: J.getAttribute("id"),
                        sid: J.getAttribute("sid"),
                        matrix: new y.Matrix4,
                        nodes: [],
                        instanceCameras: [],
                        instanceControllers: [],
                        instanceLights: [],
                        instanceGeometries: [],
                        instanceNodes: [],
                        transforms: {}
                    }, re = 0; re < J.childNodes.length; re++) {
                    var ye = J.childNodes[re];
                    if (ye.nodeType === 1) switch (ye.nodeName) {
                        case "node":
                            W.nodes.push(ye.getAttribute("id")), _n(ye);
                            break;
                        case "instance_camera":
                            W.instanceCameras.push(ie(ye.getAttribute("url")));
                            break;
                        case "instance_controller":
                            W.instanceControllers.push(Qs(ye));
                            break;
                        case "instance_light":
                            W.instanceLights.push(ie(ye.getAttribute("url")));
                            break;
                        case "instance_geometry":
                            W.instanceGeometries.push(Qs(ye));
                            break;
                        case "instance_node":
                            W.instanceNodes.push(ie(ye.getAttribute("url")));
                            break;
                        case "matrix":
                            var rt = p(ye.textContent);
                            W.matrix.multiply(Ui.fromArray(rt).transpose()), W.transforms[ye.getAttribute("sid")] = ye.nodeName;
                            break;
                        case "translate":
                            var rt = p(ye.textContent);
                            ya.fromArray(rt), W.matrix.multiply(Ui.makeTranslation(ya.x, ya.y, ya.z)), W.transforms[ye.getAttribute("sid")] = ye.nodeName;
                            break;
                        case "rotate":
                            var rt = p(ye.textContent),
                                me = y.MathUtils.degToRad(rt[3]);
                            W.matrix.multiply(Ui.makeRotationAxis(ya.fromArray(rt), me)), W.transforms[ye.getAttribute("sid")] = ye.nodeName;
                            break;
                        case "scale":
                            var rt = p(ye.textContent);
                            W.matrix.scale(ya.fromArray(rt)), W.transforms[ye.getAttribute("sid")] = ye.nodeName;
                            break;
                        case "extra":
                            break;
                        default:
                            console.log(ye)
                    }
                }
                return gr(W.id) ? console.warn("THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.", W.id) : _t.nodes[W.id] = W, W
            }

            function Qs(J) {
                for (var W = {
                        id: ie(J.getAttribute("url")),
                        materials: {},
                        skeletons: []
                    }, re = 0; re < J.childNodes.length; re++) {
                    var ye = J.childNodes[re];
                    switch (ye.nodeName) {
                        case "bind_material":
                            for (var me = ye.getElementsByTagName("instance_material"), rt = 0; rt < me.length; rt++) {
                                var At = me[rt],
                                    Mt = At.getAttribute("symbol"),
                                    si = At.getAttribute("target");
                                W.materials[Mt] = ie(si)
                            }
                            break;
                        case "skeleton":
                            W.skeletons.push(ie(ye.textContent));
                            break
                    }
                }
                return W
            }

            function Ra(J, W) {
                var re = [],
                    ye = [],
                    me, rt, At;
                for (me = 0; me < J.length; me++) {
                    var Mt = J[me],
                        si;
                    if (gr(Mt)) si = Jr(Mt), rr(si, W, re);
                    else if (la(Mt))
                        for (var ti = _t.visualScenes[Mt], ni = ti.children, rt = 0; rt < ni.length; rt++) {
                            var ri = ni[rt];
                            if (ri.type === "JOINT") {
                                var si = Jr(ri.id);
                                rr(si, W, re)
                            }
                        } else console.error("THREE.ColladaLoader: Unable to find root bone of skeleton with ID:", Mt)
                }
                for (me = 0; me < W.length; me++)
                    for (rt = 0; rt < re.length; rt++)
                        if (At = re[rt], At.bone.name === W[me].name) {
                            ye[me] = At, At.processed = !0;
                            break
                        } for (me = 0; me < re.length; me++) At = re[me], At.processed === !1 && (ye.push(At), At.processed = !0);
                var Wi = [],
                    Ci = [];
                for (me = 0; me < ye.length; me++) At = ye[me], Wi.push(At.bone), Ci.push(At.boneInverse);
                return new y.Skeleton(Wi, Ci)
            }

            function rr(J, W, re) {
                J.traverse(function(ye) {
                    if (ye.isBone === !0) {
                        for (var me, rt = 0; rt < W.length; rt++) {
                            var At = W[rt];
                            if (At.name === ye.name) {
                                me = At.boneInverse;
                                break
                            }
                        }
                        me === void 0 && (me = new y.Matrix4), re.push({
                            bone: ye,
                            boneInverse: me,
                            processed: !1
                        })
                    }
                })
            }

            function Fr(J) {
                for (var W = [], re = J.matrix, ye = J.nodes, me = J.type, rt = J.instanceCameras, At = J.instanceControllers, Mt = J.instanceLights, si = J.instanceGeometries, ti = J.instanceNodes, ni = 0, ri = ye.length; ni < ri; ni++) W.push(Jr(ye[ni]));
                for (var ni = 0, ri = rt.length; ni < ri; ni++) {
                    var Wi = Si(rt[ni]);
                    Wi !== null && W.push(Wi.clone())
                }
                for (var ni = 0, ri = At.length; ni < ri; ni++)
                    for (var Ci = At[ni], Pi = xi(Ci.id), ai = We(Pi.id), Rt = $r(ai, Ci.materials), Gi = Ci.skeletons, ki = Pi.skin.joints, pn = Ra(Gi, ki), pi = 0, Hi = Rt.length; pi < Hi; pi++) {
                        var Bi = Rt[pi];
                        Bi.isSkinnedMesh && (Bi.bind(pn, Pi.skin.bindMatrix), Bi.normalizeSkinWeights()), W.push(Bi)
                    }
                for (var ni = 0, ri = Mt.length; ni < ri; ni++) {
                    var en = ga(Mt[ni]);
                    en !== null && W.push(en.clone())
                }
                for (var ni = 0, ri = si.length; ni < ri; ni++)
                    for (var Ci = si[ni], ai = We(Ci.id), Rt = $r(ai, Ci.materials), pi = 0, Hi = Rt.length; pi < Hi; pi++) W.push(Rt[pi]);
                for (var ni = 0, ri = ti.length; ni < ri; ni++) W.push(Jr(ti[ni]).clone());
                var Bi;
                if (ye.length === 0 && W.length === 1) Bi = W[0];
                else {
                    Bi = me === "JOINT" ? new y.Bone : new y.Group;
                    for (var ni = 0; ni < W.length; ni++) Bi.add(W[ni])
                }
                return Bi.name = me === "JOINT" ? J.sid : J.name, Bi.matrix.copy(re), Bi.matrix.decompose(Bi.position, Bi.quaternion, Bi.scale), Bi
            }
            var Lr = new y.MeshBasicMaterial({
                color: 16711935
            });

            function ra(J, W) {
                for (var re = [], ye = 0, me = J.length; ye < me; ye++) {
                    var rt = W[J[ye]];
                    rt === void 0 ? (console.warn("THREE.ColladaLoader: Material with key %s not found. Apply fallback material.", J[ye]), re.push(Lr)) : re.push(Pt(rt))
                }
                return re
            }

            function $r(J, W) {
                var re = [];
                for (var ye in J) {
                    var me = J[ye],
                        rt = ra(me.materialKeys, W);
                    rt.length === 0 && (ye === "lines" || ye === "linestrips" ? rt.push(new y.LineBasicMaterial) : rt.push(new y.MeshPhongMaterial));
                    var At = me.data.attributes.skinIndex !== void 0;
                    if (At)
                        for (var Mt = 0, si = rt.length; Mt < si; Mt++) rt[Mt].skinning = !0;
                    var ti = rt.length === 1 ? rt[0] : rt,
                        ni;
                    switch (ye) {
                        case "lines":
                            ni = new y.LineSegments(me.data, ti);
                            break;
                        case "linestrips":
                            ni = new y.Line(me.data, ti);
                            break;
                        case "triangles":
                        case "polylist":
                            At ? ni = new y.SkinnedMesh(me.data, ti) : ni = new y.Mesh(me.data, ti);
                            break
                    }
                    re.push(ni)
                }
                return re
            }

            function gr(J) {
                return _t.nodes[J] !== void 0
            }

            function Jr(J) {
                return Ke(_t.nodes[J], Fr)
            }

            function or(J) {
                var W = {
                    name: J.getAttribute("name"),
                    children: []
                };
                wr(J);
                for (var re = Y(J, "node"), ye = 0; ye < re.length; ye++) W.children.push(_n(re[ye]));
                _t.visualScenes[J.getAttribute("id")] = W
            }

            function wa(J) {
                var W = new y.Group;
                W.name = J.name;
                for (var re = J.children, ye = 0; ye < re.length; ye++) {
                    var me = re[ye];
                    W.add(Jr(me.id))
                }
                return W
            }

            function la(J) {
                return _t.visualScenes[J] !== void 0
            }

            function Ln(J) {
                return Ke(_t.visualScenes[J], wa)
            }

            function ja(J) {
                var W = Y(J, "instance_visual_scene")[0];
                return Ln(ie(W.getAttribute("url")))
            }

            function Nr() {
                var J = _t.clips;
                if (be(J) === !0) {
                    if (be(_t.animations) === !1) {
                        var W = [];
                        for (var re in _t.animations)
                            for (var ye = vt(re), me = 0, rt = ye.length; me < rt; me++) W.push(ye[me]);
                        Pe.push(new y.AnimationClip("default", -1, W))
                    }
                } else
                    for (var re in J) Pe.push(st(re))
            }

            function Ps(J) {
                for (var W = "", re = [J]; re.length;) {
                    var ye = re.shift();
                    ye.nodeType === Node.TEXT_NODE ? W += ye.textContent : (W += `
`, re.push.apply(re, ye.childNodes))
                }
                return W.trim()
            }
            if (z.length === 0) return {
                scene: new y.Scene
            };
            var va = new DOMParser().parseFromString(z, "application/xml"),
                $n = Y(va, "COLLADA")[0],
                Qn = va.getElementsByTagName("parsererror")[0];
            if (Qn !== void 0) {
                var os = Y(Qn, "div")[0],
                    Va;
                return os ? Va = os.textContent : Va = Ps(Qn), console.error(`THREE.ColladaLoader: Failed to parse collada file.
`, Va), null
            }
            var Da = $n.getAttribute("version");
            console.log("THREE.ColladaLoader: File version", Da);
            var Z = Ee(Y($n, "asset")[0]),
                q = new y.TextureLoader(this.manager);
            q.setPath(this.resourcePath || V).setCrossOrigin(this.crossOrigin);
            var de;
            y.TGALoader && (de = new y.TGALoader(this.manager), de.setPath(this.resourcePath || V));
            var Pe = [],
                Et = {},
                Ft = 0,
                _t = {
                    animations: {},
                    clips: {},
                    controllers: {},
                    images: {},
                    effects: {},
                    materials: {},
                    cameras: {},
                    lights: {},
                    geometries: {},
                    nodes: {},
                    visualScenes: {},
                    kinematicsModels: {},
                    physicsModels: {},
                    kinematicsScenes: {}
                };
            Je($n, "library_animations", "animation", Ye), Je($n, "library_animation_clips", "animation_clip", xe), Je($n, "library_controllers", "controller", De), Je($n, "library_images", "image", oe), Je($n, "library_effects", "effect", Ue), Je($n, "library_materials", "material", rn), Je($n, "library_cameras", "camera", qn), Je($n, "library_lights", "light", qi), Je($n, "library_geometries", "geometry", On), Je($n, "library_nodes", "node", _n), Je($n, "library_visual_scenes", "visual_scene", or), Je($n, "library_kinematics_models", "kinematics_model", ft), Je($n, "library_physics_models", "physics_model", Pn), Je($n, "scene", "instance_kinematics_scene", hn), wt(_t.animations, $e), wt(_t.clips, Ze), wt(_t.controllers, Dt), wt(_t.images, ve), wt(_t.effects, yn), wt(_t.materials, Ht), wt(_t.cameras, yi), wt(_t.lights, ge), wt(_t.geometries, qe), wt(_t.visualScenes, wa), Nr(), br();
            var Yt = ja(Y($n, "scene")[0]);
            return Yt.animations = Pe, Z.upAxis === "Z_UP" && Yt.quaternion.setFromEuler(new y.Euler(-Math.PI / 2, 0, 0)), Yt.scale.multiplyScalar(Z.unit), {
                get animations() {
                    return console.warn("THREE.ColladaLoader: Please access animations over scene.animations now."), Pe
                },
                kinematics: Et,
                library: _t,
                scene: Yt
            }
        }
    }), ue.exports = y.ColladaLoader
})(kf);
var mm = kf.exports;
(function(ue, R) {
    const y = Ls,
        z = zl,
        V = hm,
        Y = um,
        C = pm,
        p = fm,
        se = mm,
        ie = new V,
        He = new Y,
        be = new p,
        Ee = new C,
        Lt = new se;

    function Tt(Je, wt, Ke) {
        if (Je === void 0) return console.error("Invalid options provided to loadObj()");
        Je = y._validate(Je, z.prototype._defaults.loadObj);
        let Ye;
        switch (Je.type || (Je.type = "mtl"), Je.type) {
            case "mtl":
                Ye = ie;
                break;
            case "gltf":
            case "glb":
                Ye = be;
                break;
            case "fbx":
                Ye = Ee;
                break;
            case "dae":
                Ye = Lt;
                break
        }
        He.load(Je.mtl, jt, () => null, $e => {
            console.warn("No material file found for SymbolLayer3D model " + m)
        });

        function jt($e) {
            $e && Je.type == "mtl" && ($e.preload(), Ye.setMaterials($e)), Ye.load(Je.obj, vt => {
                let Kt = [];
                switch (Je.type) {
                    case "mtl":
                        vt = vt.children[0];
                        break;
                    case "gltf":
                    case "glb":
                    case "dae":
                        Kt = vt.animations, vt = vt.scene;
                        break;
                    case "fbx":
                        Kt = vt.animations;
                        break
                }
                vt.animations = Kt;
                const vi = y.types.rotation(Je.rotation, [0, 0, 0]),
                    Li = y.types.scale(Je.scale, [1, 1, 1]);
                vt.rotation.set(vi[0], vi[1], vi[2]), vt.scale.set(Li[0], Li[1], Li[2]), Je.normalize && di(vt), vt.name = "model";
                let Ei = z.prototype._makeGroup(vt, Je);
                z.prototype._addMethods(Ei), Ei.setAnchor(Je.anchor), Ei.setCenter(Je.adjustment), Ei.raycasted = Je.raycasted, Ke(Ei), wt(Ei), Ei.setFixedZoom(Je.mapScale), Ei.idle()
            }, () => null, vt => {
                console.error("Could not load model file: " + Je.obj + ` 
 ` + vt.stack), Ke("Error loading the model")
            })
        }

        function di($e) {
            $e.traverse(function(vt) {
                if (vt.isMesh) {
                    let Kt;
                    vt.material.type == "MeshStandardMaterial" ? (vt.material.metalness && (vt.material.metalness *= .1), vt.material.glossiness && (vt.material.glossiness *= .25), Kt = new THREE.Color(12, 12, 12)) : vt.material.type == "MeshPhongMaterial" && (vt.material.shininess = .1, Kt = new THREE.Color(20, 20, 20)), vt.material.specular && vt.material.specular.isColor && (vt.material.specular = Kt)
                }
            })
        }
    }
    ue.exports = Tt
})(Rf);
var gm = Rf.exports,
    Df = {
        exports: {}
    };
(function(ue, R) {
    const y = Xa,
        z = Ls,
        V = zl;

    function Y(C) {
        C = z._validate(C, V.prototype._defaults.line);
        var p = z.lnglatsToWorld(C.geometry),
            se = z.normalizeVertices(p),
            ie = z.flattenVectors(se.vertices),
            He = new y.LineGeometry;
        He.setPositions(ie);
        let be = new y.LineMaterial({
            color: C.color,
            linewidth: C.width,
            dashed: !1,
            opacity: C.opacity
        });
        return be.resolution.set(window.innerWidth, window.innerHeight), be.isMaterial = !0, be.transparent = !0, be.depthWrite = !1, Y = new y.Line2(He, be), Y.position.copy(se.position), Y.computeLineDistances(), Y
    }
    ue.exports = Y, y.LineSegmentsGeometry = function() {
        y.InstancedBufferGeometry.call(this), this.type = "LineSegmentsGeometry";
        var C = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0],
            p = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2],
            se = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
        this.setIndex(se), this.setAttribute("position", new y.Float32BufferAttribute(C, 3)), this.setAttribute("uv", new y.Float32BufferAttribute(p, 2))
    }, y.LineSegmentsGeometry.prototype = Object.assign(Object.create(y.InstancedBufferGeometry.prototype), {
        constructor: y.LineSegmentsGeometry,
        isLineSegmentsGeometry: !0,
        applyMatrix4: function(C) {
            var p = this.attributes.instanceStart,
                se = this.attributes.instanceEnd;
            return p !== void 0 && (p.applyMatrix4(C), se.applyMatrix4(C), p.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this
        },
        setPositions: function(C) {
            var p;
            C instanceof Float32Array ? p = C : Array.isArray(C) && (p = new Float32Array(C));
            var se = new y.InstancedInterleavedBuffer(p, 6, 1);
            return this.setAttribute("instanceStart", new y.InterleavedBufferAttribute(se, 3, 0)), this.setAttribute("instanceEnd", new y.InterleavedBufferAttribute(se, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this
        },
        setColors: function(C) {
            var p;
            C instanceof Float32Array ? p = C : Array.isArray(C) && (p = new Float32Array(C));
            var se = new y.InstancedInterleavedBuffer(p, 6, 1);
            return this.setAttribute("instanceColorStart", new y.InterleavedBufferAttribute(se, 3, 0)), this.setAttribute("instanceColorEnd", new y.InterleavedBufferAttribute(se, 3, 3)), this
        },
        fromWireframeGeometry: function(C) {
            return this.setPositions(C.attributes.position.array), this
        },
        fromEdgesGeometry: function(C) {
            return this.setPositions(C.attributes.position.array), this
        },
        fromMesh: function(C) {
            return this.fromWireframeGeometry(new y.WireframeGeometry(C.geometry)), this
        },
        fromLineSegments: function(C) {
            var p = C.geometry;
            if (p.isGeometry) {
                console.error("THREE.LineSegmentsGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                return
            } else p.isBufferGeometry && this.setPositions(p.attributes.position.array);
            return this
        },
        computeBoundingBox: function() {
            var C = new y.Box3;
            return function() {
                this.boundingBox === null && (this.boundingBox = new y.Box3);
                var se = this.attributes.instanceStart,
                    ie = this.attributes.instanceEnd;
                se !== void 0 && ie !== void 0 && (this.boundingBox.setFromBufferAttribute(se), C.setFromBufferAttribute(ie), this.boundingBox.union(C))
            }
        }(),
        computeBoundingSphere: function() {
            var C = new y.Vector3;
            return function() {
                this.boundingSphere === null && (this.boundingSphere = new y.Sphere), this.boundingBox === null && this.computeBoundingBox();
                var se = this.attributes.instanceStart,
                    ie = this.attributes.instanceEnd;
                if (se !== void 0 && ie !== void 0) {
                    var He = this.boundingSphere.center;
                    this.boundingBox.getCenter(He);
                    for (var be = 0, Ee = 0, Lt = se.count; Ee < Lt; Ee++) C.fromBufferAttribute(se, Ee), be = Math.max(be, He.distanceToSquared(C)), C.fromBufferAttribute(ie, Ee), be = Math.max(be, He.distanceToSquared(C));
                    this.boundingSphere.radius = Math.sqrt(be), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this)
                }
            }
        }(),
        toJSON: function() {},
        applyMatrix: function(C) {
            return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(C)
        }
    }), y.LineGeometry = function() {
        y.LineSegmentsGeometry.call(this), this.type = "LineGeometry"
    }, y.LineGeometry.prototype = Object.assign(Object.create(y.LineSegmentsGeometry.prototype), {
        constructor: y.LineGeometry,
        isLineGeometry: !0,
        setPositions: function(C) {
            for (var p = C.length - 3, se = new Float32Array(2 * p), ie = 0; ie < p; ie += 3) se[2 * ie] = C[ie], se[2 * ie + 1] = C[ie + 1], se[2 * ie + 2] = C[ie + 2], se[2 * ie + 3] = C[ie + 3], se[2 * ie + 4] = C[ie + 4], se[2 * ie + 5] = C[ie + 5];
            return y.LineSegmentsGeometry.prototype.setPositions.call(this, se), this
        },
        setColors: function(C) {
            for (var p = C.length - 3, se = new Float32Array(2 * p), ie = 0; ie < p; ie += 3) se[2 * ie] = C[ie], se[2 * ie + 1] = C[ie + 1], se[2 * ie + 2] = C[ie + 2], se[2 * ie + 3] = C[ie + 3], se[2 * ie + 4] = C[ie + 4], se[2 * ie + 5] = C[ie + 5];
            return y.LineSegmentsGeometry.prototype.setColors.call(this, se), this
        },
        fromLine: function(C) {
            var p = C.geometry;
            if (p.isGeometry) {
                console.error("THREE.LineGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                return
            } else p.isBufferGeometry && this.setPositions(p.attributes.position.array);
            return this
        },
        copy: function() {
            return this
        }
    }), y.WireframeGeometry2 = function(C) {
        y.LineSegmentsGeometry.call(this), this.type = "WireframeGeometry2", this.fromWireframeGeometry(new y.WireframeGeometry(C))
    }, y.WireframeGeometry2.prototype = Object.assign(Object.create(y.LineSegmentsGeometry.prototype), {
        constructor: y.WireframeGeometry2,
        isWireframeGeometry2: !0
    }), y.UniformsLib.line = {
        linewidth: {
            value: 1
        },
        resolution: {
            value: new y.Vector2(1, 1)
        },
        dashScale: {
            value: 1
        },
        dashSize: {
            value: 1
        },
        dashOffset: {
            value: 0
        },
        gapSize: {
            value: 1
        },
        opacity: {
            value: 1
        }
    }, y.ShaderLib.line = {
        uniforms: y.UniformsUtils.merge([y.UniformsLib.common, y.UniformsLib.fog, y.UniformsLib.line]),
        vertexShader: `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		varying vec2 vUv;

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;

			#endif

			float aspect = resolution.x / resolution.y;

			vUv = uv;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec2 ndcStart = clipStart.xy / clipStart.w;
			vec2 ndcEnd = clipEnd.xy / clipEnd.w;

			// direction
			vec2 dir = ndcEnd - ndcStart;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			// perpendicular to dir
			vec2 offset = vec2( dir.y, - dir.x );

			// undo aspect ratio adjustment
			dir.x /= aspect;
			offset.x /= aspect;

			// sign flip
			if ( position.x < 0.0 ) offset *= - 1.0;

			// endcaps
			if ( position.y < 0.0 ) {

				offset += - dir;

			} else if ( position.y > 1.0 ) {

				offset += dir;

			}

			// adjust for linewidth
			offset *= linewidth;

			// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
			offset /= resolution.y;

			// select end
			vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

			// back to clip space
			offset *= clip.w;

			clip.xy += offset;

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,
        fragmentShader: `
		uniform vec3 diffuse;
		uniform float opacity;

		#ifdef USE_DASH

			uniform float dashSize;
			uniform float dashOffset;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		varying vec2 vUv;

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			if ( abs( vUv.y ) > 1.0 ) {

				float a = vUv.x;
				float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
				float len2 = a * a + b * b;

				if ( len2 > 1.0 ) discard;

			}

			vec4 diffuseColor = vec4( diffuse, opacity );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
    }, y.LineMaterial = function(C) {
        y.ShaderMaterial.call(this, {
            type: "LineMaterial",
            uniforms: y.UniformsUtils.clone(y.ShaderLib.line.uniforms),
            vertexShader: y.ShaderLib.line.vertexShader,
            fragmentShader: y.ShaderLib.line.fragmentShader,
            clipping: !0
        }), this.dashed = !1, Object.defineProperties(this, {
            color: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.diffuse.value
                },
                set: function(p) {
                    this.uniforms.diffuse.value = p
                }
            },
            linewidth: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.linewidth.value
                },
                set: function(p) {
                    this.uniforms.linewidth.value = p
                }
            },
            dashScale: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.dashScale.value
                },
                set: function(p) {
                    this.uniforms.dashScale.value = p
                }
            },
            dashSize: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.dashSize.value
                },
                set: function(p) {
                    this.uniforms.dashSize.value = p
                }
            },
            dashOffset: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.dashOffset.value
                },
                set: function(p) {
                    this.uniforms.dashOffset.value = p
                }
            },
            gapSize: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.gapSize.value
                },
                set: function(p) {
                    this.uniforms.gapSize.value = p
                }
            },
            opacity: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.opacity.value
                },
                set: function(p) {
                    this.uniforms.opacity.value = p
                }
            },
            resolution: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.resolution.value
                },
                set: function(p) {
                    this.uniforms.resolution.value.copy(p)
                }
            }
        }), this.setValues(C)
    }, y.LineMaterial.prototype = Object.create(y.ShaderMaterial.prototype), y.LineMaterial.prototype.constructor = y.LineMaterial, y.LineMaterial.prototype.isLineMaterial = !0, y.LineSegments2 = function(C, p) {
        C === void 0 && (C = new y.LineSegmentsGeometry), p === void 0 && (p = new y.LineMaterial({
            color: Math.random() * 16777215
        })), y.Mesh.call(this, C, p), this.type = "LineSegments2"
    }, y.LineSegments2.prototype = Object.assign(Object.create(y.Mesh.prototype), {
        constructor: y.LineSegments2,
        isLineSegments2: !0,
        computeLineDistances: function() {
            var C = new y.Vector3,
                p = new y.Vector3;
            return function() {
                for (var ie = this.geometry, He = ie.attributes.instanceStart, be = ie.attributes.instanceEnd, Ee = new Float32Array(2 * He.data.count), Lt = 0, Tt = 0, Je = He.data.count; Lt < Je; Lt++, Tt += 2) C.fromBufferAttribute(He, Lt), p.fromBufferAttribute(be, Lt), Ee[Tt] = Tt === 0 ? 0 : Ee[Tt - 1], Ee[Tt + 1] = Ee[Tt] + C.distanceTo(p);
                var wt = new y.InstancedInterleavedBuffer(Ee, 2, 1);
                return ie.setAttribute("instanceDistanceStart", new y.InterleavedBufferAttribute(wt, 1, 0)), ie.setAttribute("instanceDistanceEnd", new y.InterleavedBufferAttribute(wt, 1, 1)), this
            }
        }(),
        raycast: function() {
            var C = new y.Vector4,
                p = new y.Vector4,
                se = new y.Vector4,
                ie = new y.Vector3,
                He = new y.Matrix4,
                be = new y.Line3,
                Ee = new y.Vector3;
            return function(Tt, Je) {
                Tt.camera === null && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.');
                var wt = Tt.params.Line2 !== void 0 && Tt.params.Line2.threshold || 0,
                    Ke = Tt.ray,
                    Ye = Tt.camera,
                    jt = Ye.projectionMatrix,
                    di = this.geometry,
                    $e = this.material,
                    vt = $e.resolution,
                    Kt = $e.linewidth + wt,
                    vi = di.attributes.instanceStart,
                    Li = di.attributes.instanceEnd,
                    Ei = -Ye.near;
                Ke.at(1, se), se.w = 1, se.applyMatrix4(Ye.matrixWorldInverse), se.applyMatrix4(jt), se.multiplyScalar(1 / se.w), se.x *= vt.x / 2, se.y *= vt.y / 2, se.z = 0, ie.copy(se);
                var ct = this.matrixWorld;
                He.multiplyMatrices(Ye.matrixWorldInverse, ct);
                for (var je = 0, li = vi.count; je < li; je++) {
                    C.fromBufferAttribute(vi, je), p.fromBufferAttribute(Li, je), C.w = 1, p.w = 1, C.applyMatrix4(He), p.applyMatrix4(He);
                    var O = C.z > Ei && p.z > Ei;
                    if (!O) {
                        if (C.z > Ei) {
                            const De = C.z - p.z,
                                gt = (C.z - Ei) / De;
                            C.lerp(p, gt)
                        } else if (p.z > Ei) {
                            const De = p.z - C.z,
                                gt = (p.z - Ei) / De;
                            p.lerp(C, gt)
                        }
                        C.applyMatrix4(jt), p.applyMatrix4(jt), C.multiplyScalar(1 / C.w), p.multiplyScalar(1 / p.w), C.x *= vt.x / 2, C.y *= vt.y / 2, p.x *= vt.x / 2, p.y *= vt.y / 2, be.start.copy(C), be.start.z = 0, be.end.copy(p), be.end.z = 0;
                        var K = be.closestPointToPointParameter(ie, !0);
                        be.at(K, Ee);
                        var ae = y.MathUtils.lerp(C.z, p.z, K),
                            _e = ae >= -1 && ae <= 1,
                            xe = ie.distanceTo(Ee) < Kt * .5;
                        if (_e && xe) {
                            be.start.fromBufferAttribute(vi, je), be.end.fromBufferAttribute(Li, je), be.start.applyMatrix4(ct), be.end.applyMatrix4(ct);
                            var Ze = new y.Vector3,
                                st = new y.Vector3;
                            Ke.distanceSqToSegment(be.start, be.end, st, Ze), Je.push({
                                point: st,
                                pointOnLine: Ze,
                                distance: Ke.origin.distanceTo(st),
                                object: this,
                                face: null,
                                faceIndex: je,
                                uv: null,
                                uv2: null
                            })
                        }
                    }
                }
            }
        }()
    }), y.Line2 = function(C, p) {
        C === void 0 && (C = new y.LineGeometry), p === void 0 && (p = new y.LineMaterial({
            color: Math.random() * 16777215
        })), y.LineSegments2.call(this, C, p), this.type = "Line2"
    }, y.Line2.prototype = Object.assign(Object.create(y.LineSegments2.prototype), {
        constructor: y.Line2,
        isLine2: !0
    }), y.Wireframe = function(C, p) {
        y.Mesh.call(this), this.type = "Wireframe", this.geometry = C !== void 0 ? C : new y.LineSegmentsGeometry, this.material = p !== void 0 ? p : new y.LineMaterial({
            color: Math.random() * 16777215
        })
    }, y.Wireframe.prototype = Object.assign(Object.create(y.Mesh.prototype), {
        constructor: y.Wireframe,
        isWireframe: !0,
        computeLineDistances: function() {
            var C = new y.Vector3,
                p = new y.Vector3;
            return function() {
                for (var ie = this.geometry, He = ie.attributes.instanceStart, be = ie.attributes.instanceEnd, Ee = new Float32Array(2 * He.data.count), Lt = 0, Tt = 0, Je = He.data.count; Lt < Je; Lt++, Tt += 2) C.fromBufferAttribute(He, Lt), p.fromBufferAttribute(be, Lt), Ee[Tt] = Tt === 0 ? 0 : Ee[Tt - 1], Ee[Tt + 1] = Ee[Tt] + C.distanceTo(p);
                var wt = new y.InstancedInterleavedBuffer(Ee, 2, 1);
                return ie.setAttribute("instanceDistanceStart", new y.InterleavedBufferAttribute(wt, 1, 0)), ie.setAttribute("instanceDistanceEnd", new y.InterleavedBufferAttribute(wt, 1, 1)), this
            }
        }()
    })
})(Df);
var ym = Df.exports,
    Uf = {
        exports: {}
    };
(function(ue, R) {
    const y = Ls,
        z = Vp,
        V = zl,
        Y = Xa,
        C = _p;

    function p(se, ie) {
        se = y._validate(se, V.prototype._defaults.tube);
        let He = [];
        se.geometry.forEach(Je => {
            He.push(new Y.Vector3(Je[0], Je[1], Je[2]))
        });
        const be = new Y.CatmullRomCurve3(He);
        let Ee = new Y.TubeGeometry(be, He.length, se.radius, se.sides, !1),
            Lt = z(se),
            Tt = new Y.Mesh(Ee, Lt);
        return new C({
            obj: Tt,
            units: se.units,
            anchor: se.anchor,
            adjustment: se.adjustment,
            bbox: se.bbox,
            tooltip: se.tooltip,
            raycasted: se.raycasted
        })
    }
    ue.exports = p
})(Uf);
var vm = Uf.exports,
    If = {
        exports: {}
    };
(function(ue, R) {
    const y = vp;

    function z(V) {
        this.map = V, this.renderer = new y.CSS2DRenderer, this.renderer.setSize(this.map.getCanvas().clientWidth, this.map.getCanvas().clientHeight), this.renderer.domElement.style.position = "absolute", this.renderer.domElement.id = "labelCanvas", this.renderer.domElement.style.top = 0, this.renderer.domElement.style.zIndex = "0", this.map.getCanvasContainer().appendChild(this.renderer.domElement), this.scene, this.camera, this.dispose = function() {
            this.map.getCanvasContainer().removeChild(this.renderer.domElement), this.renderer.domElement.remove(), this.renderer = {}
        }, this.setSize = function(Y, C) {
            this.renderer.setSize(Y, C)
        }, this.map.on("resize", function() {
            this.renderer.setSize(this.map.getCanvas().clientWidth, this.map.getCanvas().clientHeight)
        }.bind(this)), this.state = {
            reset: function() {}
        }, this.render = function(Y, C) {
            return no(this, null, function*() {
                return this.scene = Y, this.camera = C, new Promise(p => {
                    p(this.renderer.render(Y, C))
                })
            })
        }, this.toggleLabels = function(Y, C) {
            return no(this, null, function*() {
                return new Promise(p => {
                    p(this.setVisibility(Y, C, this.scene, this.camera, this.renderer))
                })
            })
        }, this.setVisibility = function(Y, C, p, se, ie) {
            var He = this.renderer.cacheList;
            He.forEach(function(be) {
                be.visible != C && be.layer === Y && (C && be.alwaysVisible || !C) && (be.visible = C, ie.renderObject(be, p, se))
            })
        }
    }
    ue.exports = z
})(If);
var _m = If.exports,
    zf = {
        exports: {}
    };
(function(ue, R) {
    class y {
        constructor(V, Y) {
            this.id = V.layerId, this.type = "custom", this.renderingMode = "3d", this.opacity = .5, this.buildingsLayerId = V.buildingsLayerId, this.minAltitude = V.minAltitude || .1, this.tb = Y
        }
        onAdd(V, Y) {
            this.map = V;
            const C = `
			uniform mat4 u_matrix;
			uniform float u_height_factor;
			uniform float u_altitude;
			uniform float u_azimuth;
			attribute vec2 a_pos;
			attribute vec4 a_normal_ed;
			attribute lowp vec2 a_base;
			attribute lowp vec2 a_height;
			void main() {
				float base = max(0.0, a_base.x);
				float height = max(0.0, a_height.x);
				float t = mod(a_normal_ed.x, 2.0);
				vec4 pos = vec4(a_pos, t > 0.0 ? height : base, 1);
				float len = pos.z * u_height_factor / tan(u_altitude);
				pos.x += cos(u_azimuth) * len;
				pos.y += sin(u_azimuth) * len;
				pos.z = 0.0;
				gl_Position = u_matrix * pos;
			}
			`,
                p = `
			void main() {
				gl_FragColor = vec4(0.0, 0.0, 0.0, 0.7);
			}
			`,
                se = Y.createShader(Y.VERTEX_SHADER);
            Y.shaderSource(se, C), Y.compileShader(se);
            const ie = Y.createShader(Y.FRAGMENT_SHADER);
            Y.shaderSource(ie, p), Y.compileShader(ie), this.program = Y.createProgram(), Y.attachShader(this.program, se), Y.attachShader(this.program, ie), Y.linkProgram(this.program), Y.validateProgram(this.program), this.uMatrix = Y.getUniformLocation(this.program, "u_matrix"), this.uHeightFactor = Y.getUniformLocation(this.program, "u_height_factor"), this.uAltitude = Y.getUniformLocation(this.program, "u_altitude"), this.uAzimuth = Y.getUniformLocation(this.program, "u_azimuth"), this.aPos = Y.getAttribLocation(this.program, "a_pos"), this.aNormal = Y.getAttribLocation(this.program, "a_normal_ed"), this.aBase = Y.getAttribLocation(this.program, "a_base"), this.aHeight = Y.getAttribLocation(this.program, "a_height")
        }
        render(V, Y) {
            V.useProgram(this.program);
            const C = this.map.style.sourceCaches.composite,
                p = C.getVisibleCoordinates().reverse(),
                se = this.map.getLayer(this.buildingsLayerId),
                ie = this.map.painter.context,
                {
                    lng: He,
                    lat: be
                } = this.map.getCenter(),
                Ee = this.tb.getSunPosition(this.tb.lightDateTime, [He, be]);
            V.uniform1f(this.uAltitude, Ee.altitude > this.minAltitude ? Ee.altitude : 0), V.uniform1f(this.uAzimuth, Ee.azimuth + 3 * Math.PI / 2), V.enable(V.BLEND), V.blendFunc(V.SRC_ALPHA, V.ONE_MINUS_SRC_ALPHA), V.getExtension("EXT_blend_minmax"), V.disable(V.DEPTH_TEST);
            for (const Lt of p) {
                const Tt = C.getTile(Lt),
                    Je = Tt.getBucket(se);
                if (!Je) continue;
                const [wt, Ke] = Je.programConfigurations.programConfigurations[this.buildingsLayerId]._buffers;
                V.uniformMatrix4fv(this.uMatrix, !1, Lt.posMatrix), V.uniform1f(this.uHeightFactor, Math.pow(2, Lt.overscaledZ) / Tt.tileSize / 8);
                for (const Ye of Je.segments.get()) {
                    const jt = ie.currentNumAttributes || 0,
                        di = 2;
                    for (let vt = di; vt < jt; vt++) V.disableVertexAttribArray(vt);
                    const $e = Ye.vertexOffset || 0;
                    V.enableVertexAttribArray(this.aPos), V.enableVertexAttribArray(this.aNormal), V.enableVertexAttribArray(this.aHeight), V.enableVertexAttribArray(this.aBase), Je.layoutVertexBuffer.bind(), V.vertexAttribPointer(this.aPos, 2, V.SHORT, !1, 12, 12 * $e), V.vertexAttribPointer(this.aNormal, 4, V.SHORT, !1, 12, 4 + 12 * $e), wt.bind(), V.vertexAttribPointer(this.aHeight, 1, V.FLOAT, !1, 4, 4 * $e), Ke.bind(), V.vertexAttribPointer(this.aBase, 1, V.FLOAT, !1, 4, 4 * $e), Je.indexBuffer.bind(), ie.currentNumAttributes = di, V.drawElements(V.TRIANGLES, Ye.primitiveLength * 3, V.UNSIGNED_SHORT, Ye.primitiveOffset * 3 * 2)
                }
            }
        }
    }
    ue.exports = y
})(zf);
var xm = zf.exports;
(function(ue, R) {
    const y = Xa,
        z = nm,
        V = Ls,
        Y = rm,
        C = Op,
        p = zl,
        se = Vp,
        ie = sm,
        He = om,
        be = lm,
        Ee = cm,
        Lt = gm,
        Tt = _p,
        Je = ym,
        wt = vm,
        Ke = _m,
        Ye = xm;

    function jt($e, vt, Kt) {
        this.init($e, vt, Kt)
    }
    jt.prototype = {
        repaint: function() {
            this.map.repaint = !0
        },
        init: function($e, vt, Kt) {
            this.options = V._validate(Kt || {}, di), this.map = $e, this.map.tb = this, this.objects = new p, this.renderer = new y.WebGLRenderer({
                alpha: !0,
                antialias: !0,
                preserveDrawingBuffer: Kt.preserveDrawingBuffer,
                canvas: $e.getCanvas(),
                context: vt
            }), this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.setSize(this.map.getCanvas().clientWidth, this.map.getCanvas().clientHeight), this.renderer.outputEncoding = y.sRGBEncoding, this.renderer.autoClear = !1, this.labelRenderer = new Ke(this.map), this.scene = new y.Scene, this.world = new y.Group, this.world.name = "world", this.scene.add(this.world), this.objectsCache = new Map, this.zoomLayers = [], this.fov = this.options.fov, this.orthographic = this.options.orthographic || !1, this.raycaster = new y.Raycaster, this.raycaster.layers.set(0), this.mapCenter = this.map.getCenter(), this.mapCenterUnits = V.projectToWorld([this.mapCenter.lng, this.mapCenter.lat]), this.lightDateTime = new Date, this.lightLng = this.mapCenter.lng, this.lightLat = this.mapCenter.lat, this.sunPosition, this.rotationStep = 5, this.gridStep = 6, this.altitudeStep = .1, this.lights = this.initLights, this.options.defaultLights && this.defaultLights(), this.options.realSunlight && this.realSunlight(this.options.realSunlightHelper), this.skyLayerName = "sky-layer", this.sky = this.options.sky, this.enableSelectingFeatures = this.options.enableSelectingFeatures || !1, this.enableSelectingObjects = this.options.enableSelectingObjects || !1, this.enableDraggingObjects = this.options.enableDraggingObjects || !1, this.enableRotatingObjects = this.options.enableRotatingObjects || !1, this.enableTooltips = this.options.enableTooltips || !1, this.multiLayer = this.options.multiLayer || !1, this.map.on("style.load", function() {
                this.tb.zoomLayers = [], this.tb.options.multiLayer && this.addLayer({
                    id: "threebox_layer",
                    type: "custom",
                    renderingMode: "3d",
                    map: this,
                    onAdd: function(vi, Li) {},
                    render: function(vi, Li) {
                        this.map.tb.update()
                    }
                }), this.tb.sky && this.tb.createSkyLayer()
            }), this.map.on("load", function() {
                this.selectedObject, this.selectedFeature, this.draggedObject;
                let vi;
                this.overedObject, this.overedFeature;
                let Li = this.getCanvasContainer();
                this.getCanvasContainer().style.cursor = "default";
                let Ei, ct = [],
                    je, li, O, K;

                function ae(Ve) {
                    var Dt = Li.getBoundingClientRect();
                    return {
                        x: Ve.originalEvent.clientX - Dt.left - Li.clientLeft,
                        y: Ve.originalEvent.clientY - Dt.top - Li.clientTop
                    }
                }
                this.unselectObject = function() {
                    this.selectedObject.selected = !1, this.selectedObject = null
                }, this.outObject = function() {
                    this.overedObject.over = !1, this.overedObject = null
                }, this.unselectFeature = function(Ve) {
                    typeof Ve.id != "undefined" && (this.setFeatureState({
                        source: Ve.source,
                        sourceLayer: Ve.sourceLayer,
                        id: Ve.id
                    }, {
                        select: !1
                    }), this.removeTooltip(Ve), Ve = this.queryRenderedFeatures({
                        layers: [Ve.layer.id],
                        filter: ["==", ["id"], Ve.id]
                    })[0], Ve && this.fire("SelectedFeatureChange", {
                        detail: Ve
                    }), this.selectedFeature = null)
                }, this.selectFeature = function(Ve) {
                    this.selectedFeature = Ve, this.setFeatureState({
                        source: this.selectedFeature.source,
                        sourceLayer: this.selectedFeature.sourceLayer,
                        id: this.selectedFeature.id
                    }, {
                        select: !0
                    }), this.selectedFeature = this.queryRenderedFeatures({
                        layers: [this.selectedFeature.layer.id],
                        filter: ["==", ["id"], this.selectedFeature.id]
                    })[0], this.addTooltip(this.selectedFeature), this.fire("SelectedFeatureChange", {
                        detail: this.selectedFeature
                    })
                }, this.outFeature = function(Ve) {
                    this.overedFeature && typeof this.overedFeature != "undefined" && this.overedFeature.id != Ve && ($e.setFeatureState({
                        source: this.overedFeature.source,
                        sourceLayer: this.overedFeature.sourceLayer,
                        id: this.overedFeature.id
                    }, {
                        hover: !1
                    }), this.removeTooltip(this.overedFeature), this.overedFeature = null)
                }, this.addTooltip = function(Ve) {
                    if (!this.tb.enableTooltips) return;
                    let Dt = this.tb.getFeatureCenter(Ve),
                        ei = this.tb.tooltip({
                            text: Ve.properties.name || Ve.id || Ve.type,
                            mapboxStyle: !0,
                            feature: Ve
                        });
                    ei.setCoords(Dt), this.tb.add(ei, Ve.layer.id), Ve.tooltip = ei, Ve.tooltip.tooltip.visible = !0
                }, this.removeTooltip = function(Ve) {
                    Ve.tooltip && (Ve.tooltip.visibility = !1, this.tb.remove(Ve.tooltip), Ve.tooltip = null)
                }, $e.onContextMenu = function(Ve) {
                    alert("contextMenu")
                }, this.onClick = function(Ve) {
                    let Dt, ei = [];
                    if ($e.tb.enableSelectingObjects && (ei = this.tb.queryRenderedFeatures(Ve.point)), Dt = typeof ei[0] == "object", Dt) {
                        let xi = jt.prototype.findParent3DObject(ei[0]);
                        if (xi) {
                            if (this.selectedFeature && this.unselectFeature(this.selectedFeature), !this.selectedObject) this.selectedObject = xi, this.selectedObject.selected = !0;
                            else if (this.selectedObject.uuid != xi.uuid) this.selectedObject.selected = !1, xi.selected = !0, this.selectedObject = xi;
                            else if (this.selectedObject.uuid == xi.uuid) {
                                this.unselectObject();
                                return
                            }
                            this.selectedObject.dispatchEvent({
                                type: "Wireframed",
                                detail: this.selectedObject
                            }), this.selectedObject.dispatchEvent({
                                type: "IsPlayingChanged",
                                detail: this.selectedObject
                            }), this.repaint = !0, Ve.preventDefault()
                        }
                    } else {
                        let xi = [];
                        if ($e.tb.enableSelectingFeatures && (xi = this.queryRenderedFeatures(Ve.point)), xi.length > 0 && xi[0].layer.type == "fill-extrusion" && typeof xi[0].id != "undefined") {
                            if (this.selectedObject && this.unselectObject(), !this.selectedFeature) this.selectFeature(xi[0]);
                            else if (this.selectedFeature.id != xi[0].id) this.unselectFeature(this.selectedFeature), this.selectFeature(xi[0]);
                            else if (this.selectedFeature.id == xi[0].id) {
                                this.unselectFeature(this.selectedFeature);
                                return
                            }
                        }
                    }
                }, this.onMouseMove = function(Ve) {
                    let Dt = ae(Ve);
                    if (this.getCanvasContainer().style.cursor = "default", Ve.originalEvent.altKey && this.draggedObject) {
                        if (!$e.tb.enableRotatingObjects) return;
                        vi = "rotate", this.getCanvasContainer().style.cursor = "move", Math.min(Ei.x, Dt.x), Math.max(Ei.x, Dt.x), Math.min(Ei.y, Dt.y), Math.max(Ei.y, Dt.y);
                        let oe = {
                            x: 0,
                            y: 0,
                            z: Math.round(K[2] + ~~((Dt.x - Ei.x) / this.tb.rotationStep) % 360 * this.tb.rotationStep % 360)
                        };
                        this.draggedObject.setRotation(oe), this.draggedObject.addHelp("rot: " + oe.z + "&#176;");
                        return
                    }
                    if (Ve.originalEvent.shiftKey && this.draggedObject) {
                        if (!$e.tb.enableDraggingObjects) return;
                        vi = "translate", this.getCanvasContainer().style.cursor = "move";
                        let oe = Ve.lngLat,
                            ve = [Number((oe.lng + je).toFixed(this.tb.gridStep)), Number((oe.lat + li).toFixed(this.tb.gridStep)), this.draggedObject.modelHeight];
                        this.draggedObject.setCoords(ve), this.draggedObject.addHelp("lng: " + ve[0] + "&#176;, lat: " + ve[1] + "&#176;");
                        return
                    }
                    if (Ve.originalEvent.ctrlKey && this.draggedObject) {
                        if (!$e.tb.enableDraggingObjects) return;
                        vi = "altitude", this.getCanvasContainer().style.cursor = "move";
                        let oe = Ve.point.y * this.tb.altitudeStep,
                            ve = [this.draggedObject.coordinates[0], this.draggedObject.coordinates[1], Number((-oe - O).toFixed(this.tb.gridStep))];
                        this.draggedObject.setCoords(ve), this.draggedObject.addHelp("alt: " + ve[2] + "m");
                        return
                    }
                    let ei, xi = [];
                    if ($e.tb.enableSelectingObjects && (xi = this.tb.queryRenderedFeatures(Ve.point)), ei = typeof xi[0] == "object", ei) {
                        let oe = jt.prototype.findParent3DObject(xi[0]);
                        oe && (this.outFeature(this.overedFeature), this.getCanvasContainer().style.cursor = "pointer", (!this.selectedObject || oe.uuid != this.selectedObject.uuid) && (this.overedObject && this.overedObject.uuid != oe.uuid && this.outObject(), oe.over = !0, this.overedObject = oe), this.repaint = !0, Ve.preventDefault())
                    } else {
                        this.overedObject && this.outObject();
                        let oe = [];
                        $e.tb.enableSelectingFeatures && (oe = this.queryRenderedFeatures(Ve.point)), oe.length > 0 && (this.outFeature(oe[0]), oe[0].layer.type == "fill-extrusion" && typeof oe[0].id != "undefined" && (!this.selectedFeature || this.selectedFeature.id != oe[0].id) && (this.getCanvasContainer().style.cursor = "pointer", this.overedFeature = oe[0], this.setFeatureState({
                            source: this.overedFeature.source,
                            sourceLayer: this.overedFeature.sourceLayer,
                            id: this.overedFeature.id
                        }, {
                            hover: !0
                        }), this.overedFeature = $e.queryRenderedFeatures({
                            layers: [this.overedFeature.layer.id],
                            filter: ["==", ["id"], this.overedFeature.id]
                        })[0], this.addTooltip(this.overedFeature)))
                    }
                }, this.onMouseDown = function(Ve) {
                    (Ve.originalEvent.shiftKey || Ve.originalEvent.altKey || Ve.originalEvent.ctrlKey) && Ve.originalEvent.button === 0 && this.selectedObject && (!$e.tb.enableDraggingObjects && !$e.tb.enableRotatingObjects || (Ve.preventDefault(), $e.getCanvasContainer().style.cursor = "move", $e.once("mouseup", this.onMouseUp), this.draggedObject = this.selectedObject, Ei = ae(Ve), ct = this.draggedObject.coordinates, K = V.degreeify(this.draggedObject.rotation), je = ct[0] - Ve.lngLat.lng, li = ct[1] - Ve.lngLat.lat, O = -this.draggedObject.modelHeight - Ve.point.y * this.tb.altitudeStep))
                }, this.onMouseUp = function(Ve) {
                    this.getCanvasContainer().style.cursor = "default", this.off("mouseup", this.onMouseUp), this.off("mouseout", this.onMouseUp), this.dragPan.enable(), this.draggedObject && (this.draggedObject.dispatchEvent({
                        type: "ObjectDragged",
                        detail: {
                            draggedObject: this.draggedObject,
                            draggedAction: vi
                        }
                    }), this.draggedObject.removeHelp(), this.draggedObject = null, vi = null)
                }, this.onMouseOut = function(Ve) {
                    if (this.overedFeature) {
                        let Dt = this.queryRenderedFeatures(Ve.point);
                        Dt.length > 0 && this.overedFeature.id != Dt[0].id && (this.getCanvasContainer().style.cursor = "default", this.outFeature(Dt[0]))
                    }
                }, this.onZoom = function(Ve) {
                    this.tb.zoomLayers.forEach(Dt => {
                        this.tb.toggleLayer(Dt)
                    }), this.tb.world.children.filter(Dt => Dt.fixedZoom != null).forEach(Dt => {
                        Dt.setObjectScale(this.transform.scale)
                    })
                };
                let _e = !1,
                    xe = 17,
                    Ze = 91,
                    st = 16,
                    De = 83;

                function gt(Ve) {
                    Ve.which === xe || Ve.which, Ve.which === st && (_e = !0);
                    let Dt = this.selectedObject;
                    if (_e && Ve.which === De && Dt) {
                        let ei = V.toDecimal;
                        if (Dt.help) Dt.removeHelp();
                        else {
                            let xi = Dt.modelSize,
                                oe = 1;
                            Dt.userData.units !== "meters" && (oe = V.projectedUnitsPerMeter(Dt.coordinates[1]), oe || (oe = 1), oe = ei(oe, 7)), Dt.addHelp("size(m): " + ei(xi.x / oe, 3) + " W, " + ei(xi.y / oe, 3) + " L, " + ei(xi.z / oe, 3) + " H"), this.repaint = !0
                        }
                        return !1
                    }
                }

                function Qt(Ve) {
                    Ve.which == xe || Ve.which == Ze, Ve.which === st && (_e = !1)
                }
                this.on("click", this.onClick), this.on("mousemove", this.onMouseMove), this.on("mouseout", this.onMouseOut), this.on("mousedown", this.onMouseDown), this.on("zoom", this.onZoom), document.addEventListener("keydown", gt.bind(this), !0), document.addEventListener("keyup", Qt.bind(this))
            })
        },
        get sky() {
            return this.options.sky
        },
        set sky($e) {
            $e != this.sky && ($e ? this.createSkyLayer() : this.removeLayer(this.skyLayerName), this.options.sky = $e)
        },
        get fov() {
            return this.options.fov
        },
        set fov($e) {
            this.camera instanceof y.PerspectiveCamera && this.options.fov !== $e && (this.map.transform.fov = $e, this.camera.fov = this.map.transform.fov, this.cameraSync.setupCamera(), this.map.repaint = !0, this.options.fov = $e)
        },
        get orthographic() {
            return this.options.orthographic
        },
        set orthographic($e) {
            const vt = this.map.getCanvas().clientHeight,
                Kt = this.map.getCanvas().clientWidth;
            $e ? (this.map.transform.fov = 0, this.camera = new y.OrthographicCamera(Kt / -2, Kt / 2, vt / 2, vt / -2, .1, 1e21)) : (this.map.transform.fov = this.fov, this.camera = new y.PerspectiveCamera(this.map.transform.fov, Kt / vt, .1, 1e21)), this.camera.layers.enable(0), this.camera.layers.enable(1), this.cameraSync = new z(this.map, this.camera, this.world), this.map.repaint = !0, this.options.orthographic = $e
        },
        createSkyLayer: function() {
            this.map.getLayer(this.skyLayerName) || this.map.addLayer({
                id: this.skyLayerName,
                type: "sky",
                paint: {
                    "sky-opacity": ["interpolate", ["linear"],
                        ["zoom"], 0, 0, 5, .3, 8, 1
                    ],
                    "sky-type": "atmosphere",
                    "sky-atmosphere-sun": this.getSunSky(this.lightDateTime),
                    "sky-atmosphere-sun-intensity": 10
                }
            })
        },
        sphere: function($e) {
            return this.setDefaultView($e, this.options), ie($e, this.world)
        },
        line: Je,
        label: be,
        tooltip: Ee,
        tube: function($e) {
            return this.setDefaultView($e, this.options), wt($e, this.world)
        },
        extrusion: function($e) {
            return this.setDefaultView($e, this.options), He($e)
        },
        Object3D: function($e) {
            return this.setDefaultView($e, this.options), Tt($e)
        },
        loadObj: function(vt, Kt) {
            return no(this, null, function*() {
                this.setDefaultView(vt, this.options);
                let vi = this.objectsCache.get(vt.obj);
                vi ? vi.promise.then(Li => {
                    Kt(Li.duplicate(vt))
                }).catch(Li => {
                    this.objectsCache.delete(vt.obj), console.error("Could not load model file: " + vt.obj)
                }) : this.objectsCache.set(vt.obj, {
                    promise: new Promise((Li, Ei) => no(this, null, function*() {
                        Lt(vt, Kt, ct => no(this, null, function*() {
                            ct.duplicate ? Li(ct.duplicate()) : Ei(ct)
                        }))
                    }))
                })
            })
        },
        material: function($e) {
            return se($e)
        },
        initLights: {
            ambientLight: null,
            dirLight: null,
            dirLightBack: null,
            dirLightHelper: null,
            hemiLight: null,
            pointLight: null
        },
        utils: V,
        SunCalc: Y,
        Constants: C,
        projectToWorld: function($e) {
            return this.utils.projectToWorld($e)
        },
        unprojectFromWorld: function($e) {
            return this.utils.unprojectFromWorld($e)
        },
        projectedUnitsPerMeter: function($e) {
            return this.utils.projectedUnitsPerMeter($e)
        },
        getFeatureCenter: function(vt, Kt, vi) {
            return V.getFeatureCenter(vt, Kt, vi)
        },
        getObjectHeightOnFloor: function($e, vt, Kt) {
            return V.getObjectHeightOnFloor($e, vt, Kt)
        },
        queryRenderedFeatures: function($e) {
            let vt = new y.Vector2;
            return vt.x = $e.x / this.map.transform.width * 2 - 1, vt.y = 1 - $e.y / this.map.transform.height * 2, this.raycaster.setFromCamera(vt, this.camera), this.raycaster.intersectObjects(this.world.children, !0)
        },
        findParent3DObject: function($e) {
            var vt;
            return $e.object.traverseAncestors(function(Kt) {
                Kt.parent && Kt.parent.type == "Group" && Kt.userData.obj && (vt = Kt)
            }), vt
        },
        setLayoutProperty: function($e, vt, Kt) {
            if (this.map.setLayoutProperty($e, vt, Kt), Kt != null && vt === "visibility") {
                this.world.children.forEach(function(vi) {
                    vi.layer === $e && (vi.visibility = Kt)
                });
                return
            }
        },
        setLayerZoomRange: function($e, vt, Kt) {
            this.map.getLayer($e) && (this.map.setLayerZoomRange($e, vt, Kt), this.zoomLayers.includes($e) || this.zoomLayers.push($e), this.toggleLayer($e))
        },
        setLayerHeigthProperty: function($e, vt) {
            let Kt = this.map.getLayer($e);
            if (Kt)
                if (Kt.type == "fill-extrusion") {
                    let vi = this.map.getStyle().sources[Kt.source].data;
                    vi.features.forEach(function(Ei) {
                        Ei.properties.level = vt
                    }), this.map.getSource(Kt.source).setData(vi)
                } else Kt.type == "custom" && this.world.children.forEach(function(vi) {
                    let Li = vi.userData.feature;
                    if (Li && Li.layer === $e) {
                        let Ei = this.tb.getFeatureCenter(Li, vi, vt);
                        vi.setCoords(Ei)
                    }
                })
        },
        setStyle: function($e, vt) {
            this.clear().then(() => {
                this.map.setStyle($e, vt)
            })
        },
        toggleLayer: function($e, vt = !0) {
            let Kt = this.map.getLayer($e);
            if (Kt) {
                if (!vt) {
                    this.toggle(Kt.id, !1);
                    return
                }
                let vi = this.map.getZoom();
                if (Kt.minzoom && vi < Kt.minzoom) {
                    this.toggle(Kt.id, !1);
                    return
                }
                if (Kt.maxzoom && vi >= Kt.maxzoom) {
                    this.toggle(Kt.id, !1);
                    return
                }
                this.toggle(Kt.id, !0)
            }
        },
        toggle: function($e, vt) {
            this.setLayoutProperty($e, "visibility", vt ? "visible" : "none"), this.labelRenderer.toggleLabels($e, vt)
        },
        update: function() {
            this.map.repaint && (this.map.repaint = !1);
            var $e = Date.now();
            this.objects.animationManager.update($e), this.updateLightHelper(), this.renderer.resetState(), this.renderer.render(this.scene, this.camera), this.labelRenderer.render(this.scene, this.camera), this.options.passiveRendering === !1 && this.map.triggerRepaint()
        },
        add: function($e, vt, Kt) {
            if (!this.enableTooltips && $e.tooltip && ($e.tooltip.visibility = !1), this.world.add($e), vt) {
                $e.layer = vt, $e.source = Kt;
                let vi = this.map.getLayer(vt);
                if (vi) {
                    let Li = vi.visibility,
                        Ei = typeof Li == "undefined";
                    $e.visibility = !!(Ei || Li === "visible")
                }
            }
        },
        removeByName: function($e) {
            let vt = this.world.getObjectByName($e);
            vt && this.remove(vt)
        },
        remove: function($e) {
            this.map.selectedObject && $e.uuid == this.map.selectedObject.uuid && this.map.unselectObject(), this.map.draggedObject && $e.uuid == this.map.draggedObject.uuid && (this.map.draggedObject = null), $e.dispose && $e.dispose(), this.world.remove($e), $e = null
        },
        clear: function($e = null, vt = !1) {
            return no(this, null, function*() {
                return new Promise((Kt, vi) => {
                    let Li = [];
                    this.world.children.forEach(function(Ei) {
                        Li.push(Ei)
                    });
                    for (let Ei = 0; Ei < Li.length; Ei++) {
                        let ct = Li[Ei];
                        (ct.layer === $e || !$e) && this.remove(ct)
                    }
                    vt && this.objectsCache.forEach(Ei => {
                        Ei.promise.then(ct => {
                            ct.dispose(), ct = null
                        })
                    }), Kt("clear")
                })
            })
        },
        removeLayer: function($e) {
            this.clear($e, !0).then(() => {
                this.map.removeLayer($e)
            })
        },
        getSunPosition: function($e, vt) {
            return Y.getPosition($e || Date.now(), vt[1], vt[0])
        },
        getSunTimes: function($e, vt) {
            return Y.getTimes($e, vt[1], vt[0], vt[2] ? vt[2] : 0)
        },
        setBuildingShadows: function($e) {
            if (this.map.getLayer($e.buildingsLayerId)) {
                let vt = new Ye($e, this);
                this.map.addLayer(vt, $e.buildingsLayerId)
            } else console.warn("The layer '" + $e.buildingsLayerId + "' does not exist in the map.")
        },
        setSunlight: function($e = new Date, vt) {
            if (!this.lights.dirLight || !this.options.realSunlight) {
                console.warn("To use setSunlight it's required to set realSunlight : true in Threebox initial options.");
                return
            }
            var Kt = new Date($e.getTime());
            if (vt ? vt.lng && vt.lat ? this.mapCenter = vt : this.mapCenter = {
                    lng: vt[0],
                    lat: vt[1]
                } : this.mapCenter = this.map.getCenter(), this.lightDateTime && this.lightDateTime.getTime() === Kt.getTime() && this.lightLng === this.mapCenter.lng && this.lightLat === this.mapCenter.lat) return;
            this.lightDateTime = Kt, this.lightLng = this.mapCenter.lng, this.lightLat = this.mapCenter.lat, this.sunPosition = this.getSunPosition(Kt, [this.mapCenter.lng, this.mapCenter.lat]);
            let vi = this.sunPosition.altitude,
                Li = Math.PI + this.sunPosition.azimuth,
                Ei = C.WORLD_SIZE / 2,
                ct = Math.sin(vi),
                je = Math.cos(vi),
                li = Math.cos(Li) * je,
                O = Math.sin(Li) * je;
            this.lights.dirLight.position.set(O, li, ct), this.lights.dirLight.position.multiplyScalar(Ei), this.lights.dirLight.intensity = Math.max(ct, -.15), this.lights.dirLight.updateMatrixWorld(), this.updateLightHelper(), this.map.loaded() && (this.map.setLight({
                anchor: "map",
                position: [3, 180 + this.sunPosition.azimuth * 180 / Math.PI, 90 - this.sunPosition.altitude * 180 / Math.PI],
                intensity: Math.cos(this.sunPosition.altitude),
                color: `hsl(40, ${50*Math.cos(this.sunPosition.altitude)}%, ${Math.max(20,20+96*Math.sin(this.sunPosition.altitude))}%)`
            }, {
                duration: 0
            }), this.sky && this.updateSunSky(this.getSunSky(Kt, this.sunPosition)))
        },
        getSunSky: function($e, vt) {
            if (!vt) {
                var Kt = this.map.getCenter();
                vt = this.getSunPosition($e || Date.now(), [Kt.lng, Kt.lat])
            }
            var vi = 180 + vt.azimuth * 180 / Math.PI,
                Li = 90 - vt.altitude * 180 / Math.PI;
            return [vi, Li]
        },
        updateSunSky: function($e) {
            this.sky && this.map.setPaintProperty(tb.skyLayerName, "sky-atmosphere-sun", $e)
        },
        updateLightHelper: function() {
            this.lights.dirLightHelper && (this.lights.dirLightHelper.position.setFromMatrixPosition(this.lights.dirLight.matrixWorld), this.lights.dirLightHelper.updateMatrix(), this.lights.dirLightHelper.update())
        },
        dispose: function() {
            return no(this, null, function*() {
                return console.log(this.memory()), new Promise($e => {
                    $e(this.clear(null, !0).then(vt => (this.map.remove(), this.map = {}, this.scene.remove(this.world), this.world.children = [], this.world = null, this.objectsCache.clear(), this.labelRenderer.dispose(), console.log(this.memory()), this.renderer.dispose(), vt)))
                })
            })
        },
        defaultLights: function() {
            this.lights.ambientLight = new y.AmbientLight(new y.Color("hsl(0, 0%, 100%)"), .75), this.scene.add(this.lights.ambientLight), this.lights.dirLightBack = new y.DirectionalLight(new y.Color("hsl(0, 0%, 100%)"), .25), this.lights.dirLightBack.position.set(30, 100, 100), this.scene.add(this.lights.dirLightBack), this.lights.dirLight = new y.DirectionalLight(new y.Color("hsl(0, 0%, 100%)"), .25), this.lights.dirLight.position.set(-30, 100, -100), this.scene.add(this.lights.dirLight)
        },
        realSunlight: function($e = !1) {
            this.renderer.shadowMap.enabled = !0, this.lights.dirLight = new y.DirectionalLight(16777215, 1), this.scene.add(this.lights.dirLight), $e && (this.lights.dirLightHelper = new y.DirectionalLightHelper(this.lights.dirLight, 5), this.scene.add(this.lights.dirLightHelper));
            let vt = 1e3,
                Kt = 2,
                vi = 8192;
            this.lights.dirLight.castShadow = !0, this.lights.dirLight.shadow.radius = Kt, this.lights.dirLight.shadow.mapSize.width = vi, this.lights.dirLight.shadow.mapSize.height = vi, this.lights.dirLight.shadow.camera.top = this.lights.dirLight.shadow.camera.right = vt, this.lights.dirLight.shadow.camera.bottom = this.lights.dirLight.shadow.camera.left = -vt, this.lights.dirLight.shadow.camera.near = 1, this.lights.dirLight.shadow.camera.visible = !0, this.lights.dirLight.shadow.camera.far = 4e8, this.lights.hemiLight = new y.HemisphereLight(new y.Color(16777215), new y.Color(16777215), .6), this.lights.hemiLight.color.setHSL(.661, .96, .12), this.lights.hemiLight.groundColor.setHSL(.11, .96, .14), this.lights.hemiLight.position.set(0, 0, 50), this.scene.add(this.lights.hemiLight), this.setSunlight()
        },
        setDefaultView: function($e, vt) {
            $e.bbox = ($e.bbox || $e.bbox == null) && vt.enableSelectingObjects, $e.tooltip = ($e.tooltip || $e.tooltip == null) && vt.enableTooltips, $e.mapScale = this.map.transform.scale
        },
        memory: function() {
            return this.renderer.info.memory
        },
        programs: function() {
            return this.renderer.info.programs.length
        },
        version: "2.2.2"
    };
    var di = {
        defaultLights: !1,
        realSunlight: !1,
        realSunlightHelper: !1,
        passiveRendering: !0,
        preserveDrawingBuffer: !1,
        enableSelectingFeatures: !1,
        enableSelectingObjects: !1,
        enableDraggingObjects: !1,
        enableRotatingObjects: !1,
        enableTooltips: !1,
        multiLayer: !1,
        orthographic: !1,
        fov: C.FOV_DEGREES,
        sky: !1
    };
    ue.exports = jt
})(mf);
var bm = mf.exports;
(function(ue, R) {
    ue.exports = {
        Threebox: bm,
        THREE: Xa
    }
})(ff);
var sl = ff.exports;
const Yp = [{
        name: "Basant Valley Public School",
        center: [76.93680372410364, 28.442455686912695],
        latitude: 28.442455686912695,
        longitude: 76.93680372410364,
        path: "models/ROF_Landmarks/Basant_Valley_School.glb",
        zoom: 18.35731736701824,
        heading: -85.55847143499936,
        bound: [
            [76.93774214138404, 28.445179397427182],
            [76.93311872955962, 28.439781201404102]
        ],
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BXFluQGdAekFrQW5BYUFsQGVAbkF9QF5ZakF9QGJBd0B+QmdCfkJnQn5CZ0JuQWFBWFVWVWpCeUFoQnlBakJ7QXRBZUF0QWdBZkF5QHJAaUB4QmVCfkBzQFpZVkdoQnVBaEJ1QWhCdUFmQ2tCZENpQnJAaUBsQntBbEJ7QXJCfUFyQWNBdEF5QHZBd0BGT15Za0BGZ0N0QXVBdEB1QG5Ab0BtQE1PeUJpQ2NDTm9ASENARUBBRD9A"],
        footerInfo: {
            location: "Sector 89",
            distance: "3 KM",
            time: "7 mins"
        },
        category: "School"
    }, {
        name: "Bharat Petroleum Petrol Pump",
        center: [76.92325163543302, 28.422686711977846],
        latitude: 28.422686711977846,
        longitude: 76.92325163543302,
        path: "models/ROF_Landmarks/Bharat_Petroleum_Petrol_Pump.glb",
        zoom: 19.508381369430914,
        heading: -7.915803342354253,
        bound: [
            [76.9243712191672, 28.424032595120025],
            [76.92162486146032, 28.422119677297786]
        ],
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJDTGZCTGZCTm5EVn5DVn5DVHxCUlJCZEFGfkJQaEJSaEJSYENYYENWdkRiQGZCUnJBUHJASFhEbEFOVkJcRG5ATmRAUHpCdkBmQFBgQmpAYkFSZENoQGxBVHBBVlpGfEBQckBOckBKdEFWUkJiQEBWQlxEdEBKekJaaEBEWkJSRnBDVHBBTHRBSHJBSG5ARHJCTHZCTmhDUHxASHhEbEB2RGxAdkRqQHZEbEByQVB4QUxyQERUP15AbENAQE9AYUBARUJDXj9CPw=="],
        footerInfo: {
            location: "Sector 93",
            distance: "5.2 KM",
            time: "11 mins"
        },
        category: "Fuel Pump"
    }, {
        name: "BL College of Education",
        center: [76.91988007100963, 28.423089060697535],
        latitude: 28.423089060697535,
        longitude: 76.91988007100963,
        path: "models/ROF_Landmarks/BL_College_Of_Education.glb",
        zoom: 18.6871077210513,
        heading: -32.15360000000032,
        bound: [
            [76.92230312368235, 28.428991161884042],
            [76.91251738404873, 28.420425413116817]
        ],
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJDTGZCTGZCTm5EVn5DVn5DVHxCUlJCZEFGfkJQaEJSaEJSYENYYENWdkRiQGZCUnJBUHJASFhEbEFOVkJcRG5ATmRAUHpCdkBmQFBgQmpAYkFSZENoQGxBVHBBVlpGfEBQckBOckBKdEFWUkJiQEBWQlxEdEBKekJaaEBEWkJSRnBDVHBBTHRBSHJBSG5ARHJCTHZCTmhDUHxASHhEbEB2RGxAdkRqQHZEbEByQVB4QUxyQERUP15AbENAbkFEZkVGckJEZEFEZkBAYkROYEROQE19RFNDeUlAS0pDYENAP2ZF"],
        footerInfo: {
            location: "Sector 93",
            distance: "4.9 KM",
            time: "10 mins"
        },
        category: "College"
    }, {
        name: "Nayara Petrol Pump",
        center: [76.9466550000001, 28.4270000000001],
        latitude: 28.4270000000001,
        longitude: 76.9466550000001,
        path: "models/ROF_Landmarks/Nayara_Petrol_Pump.glb",
        zoom: 18.99,
        heading: 173.59,
        bound: [
            [76.9598799398367, 28.43857072024089],
            [76.93343006015954, 28.423099523197408]
        ],
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJDTGZCTGZCTm5EVn5DVn5DVHxCUlJCQmJAQEJCQFJA"],
        footerInfo: {
            location: "Sector 89",
            distance: "1.9 KM",
            time: "5 mins"
        },
        category: "Fuel Pump"
    }, {
        name: "Genesis Hospital",
        center: [76.95643464908142, 28.406916490569216],
        latitude: 28.406916490569216,
        longitude: 76.95643464908142,
        path: "models/ROF_Landmarks/Genesis_Hospital.glb",
        zoom: 19.35575665229151,
        heading: -88.94670300024188,
        bound: [
            [76.95680929439919, 28.408210373504048],
            [76.95460434150152, 28.405499760953205]
        ],
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJ3Q1V3Q1V1Q1N5QEVfQUFVQHFAQmNFZkBrQlRXRHFBTm1BSHNAQF9AQGVAQVdCaUBHT0VZR3VAXU9LX0BZdUBxQElRY0BbX0BRb0FvQHlDaUF3Q2lBYUNnQUNWTW5BQVJDUFd+Q1d8Q1V+Q1FoQ0VqQ1l+Q1l8Q094QU92QV1oQ1toQ0twQEloQFdmQXNAZENzQGZDcUBmQ3FAZkNvQHBCbUBwQlNoQE9FWUFVQl9AWE9aRVREUkxYSEhMRmBATF4/VENcTXBBWHxBWGRDbkBiQ25AZENwQHJAQ3RCcEByQnBAYkRiQWZCdkBiQ2RBYkNkQWJEdEFiQ2JBYkNkQWRDYkFNXl9BakJhQWpCfUBmQ3FAaENxQGhDR1JNakB1QH5CdUB+QkJiQEFIR05HSkdGWUxAZEBqQUViQUM="],
        footerInfo: {
            location: "Sector 84",
            distance: "4 KM",
            time: "9 mins"
        },
        category: "Hospital"
    }, {
        name: "Indian Oil Petrol Pump",
        center: [76.9302404253728, 28.424068746415713],
        latitude: 28.424068746415713,
        longitude: 76.9302404253728,
        path: "models/ROF_Landmarks/Indian_Oil_Petrol_Pump.glb",
        zoom: 18.983323031217186,
        heading: 0,
        bound: [
            [76.93202820368646, 28.425862931979026],
            [76.9280381988479, 28.423393133892333]
        ],
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJDTGZCTGZCTm5EVn5DVn5DVHxCUlJCZEFGfkJQaEJSaEJSYENYYENWdkRiQGZCUnJBUHJASFhEbEFOVkJcRG5ATmRAUHpCdkBmQFBgQmpAYkFSZENoQGxBVHBBVlpGfEBQckBOckBKdEFWUkJiQEBWQlxEdEBKekJaaEBEWkJSRnBDVHBBTHRBSHJBSG5ARHJCTHZCTkBNQXtA"],
        footerInfo: {
            location: "Sector 95A",
            distance: "5.9 KM",
            time: "12 mins"
        },
        category: "Fuel Pump"
    }, {
        name: "HDFC Bank",
        center: [76.93183150660855, 28.424125675642244],
        latitude: 28.424125675642244,
        longitude: 76.93183150660855,
        path: "models/ROF_Landmarks/HDFC_Bank.glb",
        zoom: 18.88649752393989,
        heading: 8.828099733561885,
        bound: [
            [76.93429420173084, 28.426439463659563],
            [76.93007776973508, 28.42346440543436]
        ],
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJDTGZCTGZCTm5EVn5DVn5DVHxCUlJCZEFGfkJQaEJSaEJSYENYYENWdkRiQGZCUnJBUHJASFhEbEFOVkJcRG5ATmRAUHpCdkBmQFBgQmpAYkFSZENoQGxBVHBBVlpGfEBQckBOckBKdEFWUkJiQEBWQlxEdEBKekJaaEBEWkJSRnBDVHBBTHRBSHJBSG5ARHJCTHZCTkBNX0FJUUFlQEN9QUt3QUlAY0A="],
        footerInfo: {
            location: "Sector 93",
            distance: "3.7 KM",
            time: "9 mins"
        },
        category: "Bank"
    }, {
        name: "Saraswati Model School",
        center: [76.94265463968776, 28.42539351416181],
        latitude: 28.42539351416181,
        longitude: 76.94265463968776,
        path: "models/ROF_Landmarks/Saraswati_Model_School.glb",
        zoom: 18.874029075917004,
        heading: -84.03917967554321,
        bound: [
            [76.94339798170336, 28.4275687813724],
            [76.94010161477979, 28.423804140846116]
        ],
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJDTGZCTGZCTm5EVn5DVn5DVHxCUlJCZEFGfkJQaEJSaEJSYENYYENWRWRGfkJCREA/bEBERkhASj8="],
        footerInfo: {
            location: "Sector 89",
            distance: "2.4 KM",
            time: "6 mins"
        },
        category: "School"
    }, {
        name: "Silverglades Merchant Plaza",
        center: [76.95757233696361, 28.422033956729436],
        latitude: 28.422033956729436,
        longitude: 76.95757233696361,
        path: "models/ROF_Landmarks/Silverglades_Merchant_Plaza_Gurgaon.glb",
        zoom: 17.39936421707884,
        heading: 49.83857337472682,
        bound: [
            [76.96217666612222, 28.426481026398747],
            [76.95604526633042, 28.421136233482073]
        ],
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BV3hBY0BoQ2FAakNlQk9FTnVAYEFpQHJAS057QGhBd0JuQ2lAbEB7QHRAa0NuQnVAaEB5QWRBeUFmQV9DZkJvQWBBb0FiQXdAakB5QXBBd0FuQXlAckBnQXRAT21Ab0FDRXVA"],
        footerInfo: {
            location: "Sector 88",
            distance: "2.5 KM",
            time: "7 mins"
        },
        category: "Commercial/Retail"
    }, {
        name: "St Pauls School",
        center: [76.9628607335132, 28.430302023446913],
        latitude: 28.430302023446913,
        longitude: 76.9628607335132,
        path: "models/ROF_Landmarks/St_Pauls_School.glb",
        zoom: 18.63532826794857,
        heading: 119.2881222127238,
        bound: [
            [76.96645726483769, 28.43124236127815],
            [76.96176469355697, 28.427235197240265]
        ],
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJ3Q1V3Q1V1Q1N5QEVfQUFVQHFAQmNFZkBrQlRXRHFBTm1BSHNAQF9AQGVAQVdCaUBHT0VZR3VAXU9LX0BZdUBxQElRY0BbX0BRb0FvQHlDaUF3Q2lBYUNnQUNWWUxfQE5bSFdEW0RpQEBjQT8="],
        footerInfo: {
            location: "Sector 88",
            distance: "2.8 KM",
            time: "7 mins"
        },
        category: "School"
    }, {
        name: "St Xaviers High School",
        center: [76.94494795427522, 28.41695308245764],
        latitude: 28.41695308245764,
        longitude: 76.94494795427522,
        path: "models/ROF_Landmarks/St_Xaviers_High_School _Sec_89.glb",
        zoom: 18.284161301305076,
        heading: 0,
        bound: [
            [76.95297501952939, 28.423804067505642],
            [76.93809244489097, 28.41459133687931]
        ],
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJDTGZCTGZCTm5EVn5DVn5DVHxCUlJCZEFGfkJQaEJSaEJSYENYYENWdkRiQGZCUnJBUHJASFhEbEFOVkJcRG5ATmRAUHpCdkBmQFBgQmpAYkFSZENoQGxBVHBBVlpGfEBQckBOckBKdEFWaUBsQX1AcEJfQXBCfUByQn1AckJlQXJCUV5NVH1AbEJxQHRBcUB0QXVAfEFxQHhBX0FwQldoQGlBYkNtQHBBbUBuQVlCT0BrQEk/QV9AUU0/S0BLQnFAVEtCST9JP2tMS21EQ0JlQg=="],
        footerInfo: {
            location: "Sector 89",
            distance: "4.5 KM",
            time: "10 mins"
        },
        category: "School"
    }, {
        name: "Supreme Pure Restaurant",
        center: [76.93471451355873, 28.424173849615613],
        latitude: 28.424173849615613,
        longitude: 76.93471451355873,
        path: "models/ROF_Landmarks/Supreme_Pure_Restaurant.glb",
        zoom: 20.737793671758954,
        heading: 167.2486243091289,
        bound: [
            [76.93546621759117, 28.424413830874443],
            [76.93431281786889, 28.423554346857117]
        ],
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJDTGZCTGZCTm5EVn5DVn5DVHxCUlJCZEFGfkJQaEJSaEJSYENYYENWdkRiQGZCUnJBUHJASFhEbEFOVkJcRG5ATmRAUHpCdkBmQFBgQmpAYkFSZENoQGxBVHBBVlpGfEBQckBOckBKdEFWUkJiQEBWQlxEdEBKR1A/Ug=="],
        footerInfo: {
            location: "Sector 94",
            distance: "3 KM",
            time: "6 mins"
        },
        category: "Food"
    }, {
        name: "India International Convention Centre",
        center: [77.04339656613337, 28.55256301129711],
        latitude: 28.55256301129711,
        longitude: 77.04339656613337,
        path: "models/ROF_Landmarks/International_Convention_Centre.glb",
        zoom: 16.027246249649025,
        heading: -87.33680841388997,
        bound: [
            [77.04812965272862, 28.56278568171159],
            [77.03959244372732, 28.54634542031509]
        ],
        routesFromBase: ["aWB0dE1naXFsRE1Lc0B1QHFAaUBTSF9BSnlDT3dDT3VARX1EUXtEUX1EUX1EUXtEUX1EUW9AUGlDS2lDS2dCU2dCU2VART91QkFzQkVpQ0VpQ015Qkt5QlF7Q1F7Q1N9Q1F7Q1NxQllrQ019QGlAZ0RpQGdEZUB3QmNAeUJ1QHVDdUB1Q19BcUN3QHtCeUB7QndAe0JFTWtAe0FpQHlBe0B7Qn1AfUJ7QHtCfUB7QlVrQE1dV2NAc0B3QXNAdUF5QXNDYUJ5Q2FCe0NhQnlDX0F9QV9BX0JpQHtAb0FpQmdCX0NxQXtBb0F7QWNBY0FjQWNBdUF1QXVBdUFjQGVAa0JhQm1CY0JtQmNCZ0FfQWdBX0FzQnlCdUJ3QmFCd0FhQnlBYUJ3QUlJe0FvQXdBa0F3QW1BdUNzQnVDc0JpQ3dCaUN3QmtCYUJrQl9Ca0JfQmFDcUJjQ3FCYUNxQmFDcUJpQ31Ca0NfQ2lDfUJtQmVCZ0N9QmlDfUJvQnNCb0JzQmlAaUB5Qn1CaUFlQWtBZUF7QHdAa0BnQHtCa0J3QW1BbUJrQm1CaUJtQmtCbUF3QW9BdUFfQ31CYUN9Qn1BeUF7QXlBe0F3QWdCeUFnQndBa0N3QmtDd0JjQn1BZUJ7QWNCfUF5QmlCeUJpQnNBY0FxQWFBX0J5QV9CeUFfQnlBfUFvQl9Cb0JfQm9Ca0J7Qm1CeUJrQntCa0J5QmlBfUFnQV9CaUJ3QmlCeUJpQnlCaUJ5Qm1Cb0JtQnFCb0JzQnFCdUJvQnNCYUJvQl9Cb0J1QW1CdUFrQnNBa0JzQm1Dc0JrQ2VCb0JlQm9CZUJxQmVCb0JnQndCaUJ3QmdCd0JxQntCcUJ9Qm9Ce0JxQntCa0J3QmtCd0JrQndCa0J3QmtCd0JxQnFCb0JxQm9CcUJfQmlCa0J7QmlCe0JrQntCaUJ7QmlCe0JrQntCaUJ7Ql9AY0B9QXdDe0F5Q3NAX0RhQHtDX0B7Q2FAe0NTd0F5QHtDe0B7Q3lAe0NvQH1BbUB9QXVAbUF1QGtBZUFzQWdBcUFrQn1Ca0J7QmlCfUJrQXdBY0JzQmNCc0JrQn1CbUJfQ21CfUJrQl9DaUJ5QmdCeUJpQnlCdUJjQ3NCY0NpQnlCZ0J3QmlCeUJ5QWdCe0FnQnlBaUJlQn1AX0NvQGlBS2NCQV9CSHNCZkBnQWRAYUBYa0BkQHVAfkBnQHZAZ0F8QmlBfEJnQX5Cc0BwQXVAcEF7QGBBY0F6QHlBfEBjQ3BBdUJ2QWpBRG5AWXRAW1xRbEBZTkt6QXtAZEJfQmpBd0F4QWFDUF1EVUBhQENhQE9LSU1BST9NSllWc0BmQXNDYEBlQWxAZUF2QWdCeEB3QG5CdUF4QmdBeEJnQXhCZ0F+QFliQm1AYkJrQGxDbUFgQ3NBYENxQW5DdUFsQ3NBbkN1QXpAQWpAU2JBX0BsQFVaTWBCa0BsQWRCbEFkQmJBdEFPQGFARlVKVVpNbkBTckFFQ0lDSUFHP0U/SUBHQkVERURDRENIP0Y/REJGQkREREZERkJGQHhCaEN2QmpDcUZ4Qz9UaUF0QEdMRFw/SklQRUpASkZE"],
        footerInfo: {
            location: "Sector 25, Dwarka",
            distance: "20.8 KM",
            time: "26 mins"
        },
        category: "Convention Centre"
    }, {
        name: "BM Public School",
        center: [76.93388681033196, 28.433736175505686],
        latitude: 28.433736175505686,
        longitude: 76.93388681033196,
        path: "models/ROF_Landmarks/BM_Public_School.glb",
        zoom: 18.938658096475276,
        bound: [
            [76.93580289942662, 28.434222109974],
            [76.93169081619766, 28.431583951870763]
        ],
        heading: -177.67712097989389,
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJDTGZCTGZCTm5EVn5DVn5DVHxCUlJCZEFGfkJQaEJSaEJSYENYYENWdkRiQGZCUnJBUHJASFhEbEFOVkJcRG5ATmRAUHpCdkBmQFBgQmpAYkFSZENoQGxBVHBBVlpGfEBQckBOckBKdEFWUkJiQEBWQlxEdEBKSmVDRm1DRHdCQH1AQG1AQH1BXmVDYEBjQkBNQFE/Y0Q/aUNAa0M/aUM/aUNATz93QT9pQUBlQUJlQX5AQA=="],
        footerInfo: {
            location: "Sector 95B",
            distance: "4.2 KM",
            time: "9 mins"
        },
        category: "School"
    }, {
        name: "Hotel Elite Oak",
        center: [76.97003666187646, 28.393783544818618],
        latitude: 28.393783544818618,
        longitude: 76.97003666187646,
        path: "models/ROF_Landmarks/Hotel_Elite_Oak.glb",
        zoom: 19.30061058840606,
        bound: [
            [76.97049471088832, 28.395455904161324],
            [76.96780028323099, 28.39273060799391]
        ],
        heading: -75.33687827792363,
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJ3Q1V3Q1V1Q1N5QEVfQUFVQHFAQmNFZkBrQlRXRHFBTm1BSHNAQF9AQGVAQVdCaUBHT0VZR3VAXU9LX0BZdUBxQElRY0BbX0BRb0FvQHlDaUF3Q2lBYUNnQUNWTW5BQVJDUFd+Q1d8Q1V+Q1FoQ0VqQ1l+Q1l8Q094QU92QV1oQ1toQ0twQEloQFdmQXNAZENzQGZDcUBmQ3FAZkNvQHBCbUBwQlNoQE9FWUFVQl9AWE9aRVREUkxYSEhMRn1BfEN7QX5De0F8Q3tBfkN5QGBCfUBuQnVBaEN1QHBBdUBwQV9CaENjQXRBZUF0QWFCeEJhQnhCbUJ0QmNBYEF7QmBDfUJiQ2tAaEBRUGBAVGBDZEFoQnBAZkJyQHpDakF6Q2xBYkNgQWBCbkBgQm5AX0B0QFNgQEVIX0BuQE1QS0pZVl9BckBNSmtAZEBrQnRBaUJ2QXdAakBhQmxBU05xQn5BTVJISEpWQkpASEBmQEBKRExGTlhsQFhuQERoQj9oQj9mQmFCQEFeZkF8QGRBYEFiQXhAZkJ+QWZCYEJtQWBBa0BiQF1WTUhISExJXllQT1pW"],
        footerInfo: {
            location: "Sector 83",
            distance: "7 KM",
            time: "17 mins"
        },
        category: "Hotel"
    }, {
        name: "HPL Electric And Power Ltd",
        center: [76.9989769066467, 28.44073738155079],
        latitude: 28.44073738155079,
        longitude: 76.9989769066467,
        path: "models/ROF_Landmarks/HPL_Electric_&_Power_Ltd.glb",
        zoom: 17.917965317278018,
        bound: [
            [77.00525846173844, 28.44644783349574],
            [76.99744156987458, 28.439501309208694]
        ],
        heading: 39.209600000000144,
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJ3Q1V3Q1V1Q1N5QEVfQUFVQHFAQmNFZkBrQlRXRHFBTm1BSHNAQF9AQGVAQVdCaUBHT0VZR3VAXU9LX0BZdUBxQElRY0BbX0BRb0FvQHlDaUF3Q2lBYUNnQX1AZ0B7QWVBfUFnQWVCb0FlQnFBd0N1QnFBdUBjQFV7QFljRHtBYUR7QXlDdUF5Q3VBeUNzQXtCYUF5QmFBe0JhQWVCc0BlQnVAa0J7QG1Ce0BlRHlBZ0R7QXNAVWNAS2lAR3dBV21BT29ASXNCV3tBUVE/dUBRbUBPUUVjQmdAZUFdV0tTSVNLT0tLS1lbTVN5QG1BYUBxQHVAc0FXYUBPVW9AZUBnQFl9QGNATUdbQU1Re0BJe0JZc0JXWUdfQ2VAY0JnQGVCZUBhQmlAYUN5QGlBY0BRR19BW31DY0F3QF1jQV1tQWFAZ0NpQXFBbUBzQn1AaUNpQXdAWVdJU0VpQm9AW0tpQmVAd0FrQHVCdUB5QFNVSXNBYUB7QFd9QFdnQFFvQFVpRGFBSUlFSUBRQklebUJAX0BZR2dAYkFxQHhBRUxhQHpAbUBwQT9MR0xRZEB3QX5DdUFgREdKY0F+QndAbEJTZkBTXl1kQE9EYUFkQVdYSkZQSn5BYkN+QWBDVmJAYEF6QVtMekBuQT9EP0RlQWRA"],
        footerInfo: {
            location: "Sector 37",
            distance: "8.2 KM",
            time: "18 mins"
        },
        category: "Others"
    }, {
        name: "MDS Public High School",
        center: [76.97703368432371, 28.443363077817665],
        latitude: 28.443363077817665,
        longitude: 76.97703368432371,
        path: "models/ROF_Landmarks/MDS_Public_School.glb",
        zoom: 18.95409528579556,
        bound: [
            [76.97789107495623, 28.446026455057634],
            [76.97403409684904, 28.442653935647627]
        ],
        heading: -48.05346737290983,
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJ3Q1V3Q1V1Q1N5QEVfQUFVQHFAQmNFZkBrQlRXRHFBTm1BSHNAQF9AQGVAQVdCaUBHT0VZR3VAXU9LX0BZdUBxQElRY0BbX0BRb0FvQHlDaUF3Q2lBYUNnQX1AZ0B7QWVBfUFnQWVCb0FlQnFBd0N1QnFBdUBjQFV7QFljRHtBYUR7QXlDdUF5Q3VBeUNzQXtCYUF5QmFBe0JhQWVCc0BlQnVAa0J7QG1Ce0BlRHlBZ0R7QXNAVWNAS2lAR3dBV21BT29ASXNCV3tBUVE/dUBRbkF3QGZCfUBoQ2NBZkBNbkBPQH1DQ2dCRF9CQk9QT2xASWpATXpAY0B2QGtAUkFVXVVda0B7QEtHR0BVZkBVQnFHRg=="],
        footerInfo: {
            location: "Sector 37D",
            distance: "5.5 KM",
            time: "12 mins"
        },
        category: "School"
    }, {
        name: "New Town Square",
        center: [76.93098192033659, 28.424665570059688],
        latitude: 28.424665570059688,
        longitude: 76.93098192033659,
        path: "models/ROF_Landmarks/New_Town_Square.glb",
        zoom: 18.388881428097783,
        bound: [
            [76.93173869346208, 28.427627594469627],
            [76.92689750930094, 28.422410558841122]
        ],
        heading: -79.96084133211345,
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJDTGZCTGZCTm5EVn5DVn5DVHxCUlJCZEFGfkJQaEJSaEJSYENYYENWdkRiQGZCUnJBUHJASFhEbEFOVkJcRG5ATmRAUHpCdkBmQFBgQmpAYkFSZENoQGxBVHBBVlpGfEBQckBOckBKdEFWUkJiQEBWQlxEdEBKekJaaEBEWkJSRnBDVHBBTHRBSHJBSG5ARHJCTHZCTkBNX0FJUUFEX0BGc0A/Q0VBb0BBYUFDQmtB"],
        footerInfo: {
            location: "Sector 95A",
            distance: "5.9 KM",
            time: "13 mins"
        },
        category: "Commercial/Retail"
    }, {
        name: "Suncity School",
        center: [76.97156774583283, 28.45520573782788],
        latitude: 28.45520573782788,
        longitude: 76.97156774583283,
        path: "models/ROF_Landmarks/Suncity_School.glb",
        zoom: 18.408024049191727,
        bound: [
            [76.97293976378808, 28.456266674154833],
            [76.96736398687466, 28.45131867395537]
        ],
        heading: -140.08363083290828,
        routesFromBase: ["aWB0dE1naXFsRE1Lc0B1QHFAaUBTSF9BSnlDT3dDT3VARX1EUXtEUX1EUX1EUXtEUX1EUW9AUGlDS2lDS2dCU2dCU2VART91QkFzQkVpQ0VpQ015Qkt5QlF7Q1F7Q1N9Q1F7Q1NxQllrQ019QGlAZ0RpQGdEZUB3QmNAeUJ1QHVDdUB1Q19BcUN3QHtCeUB7QndAe0JFTWtAe0FpQHlBe0B7Qn1AfUJ7QHtCfUB7QlVrQE1dV2NAc0B3QXNAdUF5QXNDUW9Bc0FjQ3NBZUNzQWNDaUBjQWtBc0JlQHtAcUF9QW9BX0JVcUB9QXFCX0JvQntBfUF7QX1BQVVBR0NHR0tLR01HTUVJQ0tBTz9RQE9CTURLRktIR0pDSkFGP0hASkJKRkpKSEpGTEROQmpAdEBsQnZCbEJ2QmpCfEJqQnpCTlJsQWBCZEB0QExSdEF6QnRBekJ2QXpCdEB2QXRAeEFyQHBBcEFqQkx4QFpsQU50QEJYRF5nRERpREZ9Q0JfRER9Q0JfRERZQH1BQHtDRGVCTHNBRFE/b0FAaUFAP2hAQ0xFTlFURUxVYEFVSn1CakBfQExLRktKY0BsQE9WbUBoQU5GWERKSmBCckBWSnZCeEBuQV5OQ0xKVlh+Q29BZkBVRkFCQFZQdkB0QHRAdEA="],
        footerInfo: {
            location: "Sector 37D",
            distance: "8.2 KM",
            time: "16 mins"
        },
        category: "School"
    }, {
        name: "Audi Gurugram Service Centre",
        center: [76.99735583868494, 28.440611684179032],
        latitude: 28.440611684179032,
        longitude: 76.99735583868494,
        path: "models/ROF_Landmarks/Audi_Gurugram_Service_Centre.glb",
        zoom: 17.743762285767,
        bound: [
            [76.99942455427481, 28.446613935854074],
            [76.99081008830319, 28.438866829712737]
        ],
        heading: -32.838323315028504,
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJ3Q1V3Q1V1Q1N5QEVfQUFVQHFAQmNFZkBrQlRXRHFBTm1BSHNAQF9AQGVAQVdCaUBHT0VZR3VAXU9LX0BZdUBxQElRY0BbX0BRb0FvQHlDaUF3Q2lBYUNnQX1AZ0B7QWVBfUFnQWVCb0FlQnFBd0N1QnFBdUBjQFV7QFljRHtBYUR7QXlDdUF5Q3VBeUNzQXtCYUF5QmFBe0JhQWVCc0BlQnVAa0J7QG1Ce0BlRHlBZ0R7QXNAVWNAS2lAR3dBV21BT29ASXNCV3tBUVE/dUBRbUBPUUVjQmdAZUFdV0tTSVNLT0tLS1lbTVN5QG1BYUBxQHVAc0FXYUBPVW9AZUBnQFl9QGNATUdbQU1Re0BJe0JZc0JXWUdfQ2VAY0JnQGVCZUBhQmlAYUN5QGlBY0BRR19BW31DY0F3QF1jQV1tQWFAZ0NpQXFBbUBzQn1AaUNpQXdAWVdJU0VpQm9AW0tpQmVAd0FrQHVCdUB5QFNVSXNBYUB7QFd9QFdnQFFvQFVpRGFBSUlFSUBRQklebUJAX0BZR2dAYkFxQHhBRUxhQHpAbUBwQT9MR0xRZEB3QX5DdUFgREdKY0F+QndAbEJTZkBTXl1kQE9EYUFkQVdYSkZQSn5BYkN+QWBDVmJAYEF6QWpAekBcZkBkQHpAdEFpQA=="],
        footerInfo: {
            location: "Sector 37",
            distance: "8.3 KM",
            time: "21 mins"
        },
        category: "Others"
    }, {
        name: "IRIS Broadway",
        center: [76.94800349569954, 28.40297271569115],
        latitude: 28.40297271569115,
        longitude: 76.94800349569954,
        path: "models/ROF_Landmarks/Trehan_IRIS.glb",
        zoom: 17.885556525672463,
        bound: [
            [76.95350446421372, 28.405638119253823],
            [76.94645032530786, 28.398310427649392]
        ],
        heading: 102.7062318170997,
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJ3Q1V3Q1V1Q1N5QEVfQUFVQHFAQmNFZkBrQlRXRHFBTm1BSHNAQF9AQGVAQVdCaUBHT0VZR3VAXU9LX0BZdUBxQElRY0BbX0BRb0FvQHlDaUF3Q2lBYUNnQUNWTW5BQVJDUFd+Q1d8Q1V+Q1FoQ0VqQ1l+Q1l8Q094QU92QV1oQ1toQ0twQEloQFdmQXNAZENzQGZDcUBmQ3FAZkNvQHBCbUBwQlNoQE9FWUFVQl9AWE9aRVREUkxYSEhMRmBATF4/VENcTXBBWHxBWGRDbkBiQ25AZENwQHJAQ3RCcEByQnBAYkRiQWZCdkBiQ2RBYkNkQWJEdEFiQ2JBYkNkQWRDYkFUSmhCdkByQnxAckJ8QGJDZkFkQ2RBaEBUZEJ0QGJCdEBaTGpDaEFqQ2ZBaER4QWJBZEB2Qn5AdkJ+QHxBdEBUTmRAYEA/SERKREZTbkFfQGZBXX5AR055QHpCbUB8QWtAfkFxQWJEb0FGfUBsQ09DTGlA"],
        footerInfo: {
            location: "Sector 85",
            distance: "5.7 KM",
            time: "11 mins"
        },
        category: "Commercial/Retail"
    }, {
        name: "Yaduvanshi Shiksha Niketan",
        center: [76.92421636543162, 28.417210265490723],
        latitude: 28.417210265490723,
        longitude: 76.92421636543162,
        path: "models/ROF_Landmarks/Yaduvanshi_Shiksha_Niketan_Sector_92.glb",
        zoom: 18.958158358696576,
        bound: [
            [76.92483793127957, 28.418601405782084],
            [76.921764626298, 28.41504427966929]
        ],
        heading: -95.05091444122303,
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJDTGZCTGZCTm5EVn5DVn5DVHxCUlJCZEFGfkJQaEJSaEJSYENYYENWdkRiQGZCUnJBUHJASFhEbEFOVkJcRG5ATmRAUHpCdkBmQFBgQmpAYkFSZENoQGxBVHBBVlpGfEBQckBOckBKdEFWUkJiQEBWQlxEdEBKekJaaEBEQ2pCQXxAP1hBbEBAakA/bEBBZEBBbEE/dkFBckA/Xj94QD98QD9SQWJAP1JkRGRAZERmQGREZkBiRGRAVEJ0Q2BAdENgQGxDWkhAYERaaEJQZkJQfEFOZEBEeEJUYEBCckBGRGJAREZERFJIckJiQENqQg=="],
        footerInfo: {
            location: "Sector 33",
            distance: "13 KM",
            time: "21 mins"
        },
        category: "School"
    }, {
        name: "Holiday Inn Gurugram",
        center: [76.93623505100726, 28.404127281210236],
        latitude: 28.404127281210236,
        longitude: 76.93623505100726,
        path: "models/ROF_Landmarks/Holiday_Inn.glb",
        zoom: 17.105579839575544,
        bound: [
            [76.94598798444156, 28.412277123792165],
            [76.93359613864129, 28.399827772483846]
        ],
        heading: 74.847249254963,
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJ3Q1V3Q1V1Q1N5QEVfQUFVQHFAQmNFZkBrQlRXRHFBTm1BSHNAQF9AQGVAQVdCaUBHT0VZR3VAXU9LX0BZdUBxQElRY0BbX0BRb0FvQHlDaUF3Q2lBYUNnQUNWTW5BQVJDUFd+Q1d8Q1V+Q1FoQ0VqQ1l+Q1l8Q094QU92QV1oQ1toQ0twQEloQFdmQXNAZENzQGZDcUBmQ3FAZkNvQHBCbUBwQlNoQE9FWUFVQl9AWE9aRVREUkxYSEhMRmBATF4/VENcTXBBWHxBWGRDbkBiQ25AZENwQHJAQ3RCcEByQnBAYkRiQWZCdkBiQ2RBYkNkQWJEdEFiQ2JBYkNkQWRDYkFUSmhCdkByQnxAckJ8QGJDZkFkQ2RBaEBUZEJ0QGJCdEBaTGpDaEFqQ2ZBaER4QWJBZEB2Qn5AdkJ+QHxBdEBUTmRAYEA/SERKREZGREJCREBIQkhAUEBKQURBSkN8Q2pBVkp4QWpAeEFqQGZBZEBqQnZAfEFuQHxBbkBiQWJAdEJ6QHRCekB0QnxAekJ6QHhCekB6QnxAWk5OWVRTWGFATF1MW0pbakBUakBUSldAXUBlQA=="],
        footerInfo: {
            location: "Sector 90",
            distance: "6.2 KM",
            time: "12 mins"
        },
        category: "Hotel"
    }, {
        name: "HP Petrol Pump",
        center: [76.92626962518676, 28.418954278283323],
        latitude: 28.418954278283323,
        longitude: 76.92626962518676,
        path: "models/ROF_Landmarks/HP_Petrol_Pump.glb",
        zoom: 19.30556723938671,
        bound: [
            [76.92736725890285, 28.4207335618799],
            [76.92427673903535, 28.418376799412812]
        ],
        heading: -14.437778742101157,
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJDTGZCTGZCTm5EVn5DVn5DVHxCUlJCZEFGfkJQaEJSaEJSYENYYENWdkRiQGZCUnJBUHJASFhEbEFOVkJcRG5ATmRAUHpCdkBmQFBgQmpAYkFSZENoQGxBVHBBVlpGfEBQckBOckBKdEFWUkJiQEBWQlxEdEBKekJaaEBEQ2pCQXxAP1hBbEBAakA/bEBBZEBBbEE/dkFBckA/Xj94QD98QD9SQWJAP1JkRGRAZERmQGREZkBiRGRAVEJ0Q2BAdENgQGxDWkhAYERaaEJQZkJQfEFORFVNe0BFXUFFRUNhQD8="],
        footerInfo: {
            location: "Sector 93",
            distance: "4.8 KM",
            time: "8 mins"
        },
        category: "Fuel Pump"
    }, {
        name: "Dhanuka Laboratories Ltd",
        center: [76.989201, 28.408618],
        latitude: 28.408618,
        longitude: 76.989201,
        path: "models/ROF_Landmarks/Dhanuka_Laboratories_Ltd.glb",
        zoom: 19.43147262942391,
        bound: [
            [76.98967479722643, 28.410698360084254],
            [76.98707503720465, 28.408309858443488]
        ],
        heading: -68.20431220009175,
        routesFromBase: ["aWB0dE1naXFsRE1Lc0B1QHFAaUBTSF9BSnlDT3dDT3VARX1EUXtEUX1EUX1EUXtEUX1EUW9BSWdDS2dDTWdDS3tBRVdEV1ZLZEBFdEBFYEFDeEJFZkJFaEJebEFFckFJaEFDZEFVYENVYENRekJPekJTakJRbEJVckJTckJXbENNfEFNfkFPZEJPZkJTYkJTZEJPYEJPYEJZZENXfEJZfEJhQGpEU25CUW5CR2BAQ1JhQHpCbUBoQ2tAZkNhQWRDYUFiQ2tAdkB5QGhAb0BeX0FWX0FUdUFUaUJWZUFGdUBAX0M/X0NNX0NRb0JHa0JCZUJOZUJaY0JgQHVBZEBfQnBAX0JyQGdDbEFfQnBAX0JyQHdBbEBjQ2hBYUNmQWNDZkFjQ3BBeUJsQX1CdEF9QXxAfUF8QGVDekFnQ3pBd0JkQXdCYkF3QmRBa0NwQW9DfEJnQVh1QXRBZ0FgQV9AWmtAYEB3QXZAc0BYX0FafUBIaUFDd0FHYUJDeUBda0BbRWFARU9Vb0BaRUBBP0FFTUdX"],
        footerInfo: {
            location: "Mohammadpur, Jharsa",
            distance: "7.4 KM",
            time: "12 mins"
        },
        category: "Others"
    }, {
        name: "Crosswalk",
        center: [76.92605822964964, 28.417635250704876],
        latitude: 28.417635250704876,
        longitude: 76.92605822964964,
        path: "models/ROF_Landmarks/Crosswalk.glb",
        zoom: 18.09151286480799,
        bound: [
            [76.93060585079735, 28.418844618064796],
            [76.92332343024873, 28.413593043822473]
        ],
        heading: 169.6250457874871,
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJDTGZCTGZCTm5EVn5DVn5DVHxCUlJCZEFGfkJQaEJSaEJSYENYYENWdkRiQGZCUnJBUHJASFhEbEFOVkJcRG5ATmRAUHpCdkBmQFBgQmpAYkFSZENoQGxBVHBBVlpGfEBQckBOckBKdEFWUkJiQEBWQlxEdEBKekJaaEBEQ2pCQXxAP1hBbEBAakA/bEBBZEBBbEE/dkFBckA/Xj94QD98QD9SQWJAP1JkRGRAZERmQGREZkBiRGRAVEJ0Q2BAdENgQGxDWkhAYERaaEJQZkJQfEFOZEBET3RAb0FHT0pHRENEQUY/RFZuQQ=="],
        footerInfo: {
            location: "Sector 93",
            distance: "4.6 KM",
            time: "7 mins"
        },
        category: "Commercial/Retail"
    }, {
        name: "Haldiram",
        center: [76.98930707741602, 28.401766018460293],
        latitude: 28.401766018460293,
        longitude: 76.98930707741602,
        path: "models/ROF_Landmarks/Haldirams_Kherki_Daula.glb",
        zoom: 18.339177891245047,
        bound: [
            [76.99282012118022, 28.404275529148165],
            [76.98833501786697, 28.398792112561893]
        ],
        heading: 91.41313538466409,
        routesFromBase: ["aWB0dE1naXFsRE1Lc0B1QHFAaUBTSF9BSnlDT3dDT3VARX1EUXtEUX1EUX1EUXtEUX1EUW9BSWdDS2dDTWdDS3tBRVdEV1ZLZEBFdEBFYEFDeEJFZkJFaEJebEFFckFJaEFDZEFVYENVYENRekJPekJTakJRbEJVckJTckJXbENNfEFNfkFPZEJPZkJTYkJTZEJPYEJPYEJZZENXfEJZfEJhQGpEU25CUW5CR2BAQ1JhQHpCbUBoQ2tAZkNhQWRDYUFiQ2tAdkB5QGhAb0BeX0FWX0FUdUFUaUJWZUFGdUBAX0M/X0NNX0NRb0JHa0JCZUJOZUJaY0JgQHVBZEBfQnBAX0JyQGdDbEFfQnBAX0JyQHdBbEBjQ2hBYUNmQWNDZkFjQ3BBeUJsQX1CdEF9QXxAfUF8QGVDekFnQ3pBd0JkQXdCYkF3QmRBa0NwQW9DfEJhQnZBeUJuQndAbEBrQmZBbUNsQXFDYEFxQ2BBc0NgQWNDdkBlQ3hAZUN2QGFCQWNBV2tAbUBPW0NrQEhrQFRvQFplQFRTaEBTXEVqQD9eSGhAUHBAZEB2QGhCeEBmQmxAdEFsQHJBbkFwQ3BBcEN4QGhCQXZATFh3QWJAQWRB"],
        footerInfo: {
            location: "Mohammadpur, Jharsa",
            distance: "7.4 KM",
            time: "12 mins"
        },
        category: "Food"
    }, {
        name: "Sapphire Mall",
        center: [76.96726054483037, 28.392803274705727],
        latitude: 28.392803274705727,
        longitude: 76.96726054483037,
        path: "models/ROF_Landmarks/Sapphire_83.glb",
        zoom: 18.160416019515946,
        bound: [
            [76.97261050852802, 28.394473188148936],
            [76.9660166144987, 28.388805360913636]
        ],
        heading: 122.48696434974295,
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJ3Q1V3Q1V1Q1N5QEVfQUFVQHFAQmNFZkBrQlRXRHFBTm1BSHNAQF9AQGVAQVdCaUBHT0VZR3VAXU9LX0BZdUBxQElRY0BbX0BRb0FvQHlDaUF3Q2lBYUNnQUNWTW5BQVJDUFd+Q1d8Q1V+Q1FoQ0VqQ1l+Q1l8Q094QU92QV1oQ1toQ0twQEloQFdmQXNAZENzQGZDcUBmQ3FAZkNvQHBCbUBwQlNoQE9FWUFVQl9AWE9aRVREUkxYSEhMRn1BfEN7QX5De0F8Q3tBfkN5QGBCfUBuQnVBaEN1QHBBdUBwQWBAWGpBekBsQXpAfkFsQXBBfEByQXxAeEBqQFBKcEF6QGpAYEBqQm5BWlJwQX5AUExIRnxBZkF6QWRBbkF4QH5CekFmQmhBVlRyQmpBP2JASVhFYEBRakNlQEFNbEJDWkNUQWRAQlY/RkRWQExSakFKYkBQdkBkQGJBVlpKTF5sQEhcQlhAWEdiQE9mQFViQGtAakFJQENAQ0JDRkFEP0JAREBCaUJkQlVccUJiQV1ebUB0QElSQ05ASkZ2QFFKX0BkQEtKe0BsQVNUYUJ0QmFCckJnQn5CaUJ+Qm1BYkJlQmxCb0FwQUtlQV9AWGFAXg=="],
        footerInfo: {
            location: "Sector 83",
            distance: "8.1 KM",
            time: "16 mins"
        },
        category: "Commercial/Retail"
    }, {
        name: "SS Omnia",
        center: [76.94678973241997, 28.40137273105988],
        latitude: 28.40137273105988,
        longitude: 76.94678973241997,
        path: "models/ROF_Landmarks/SS_omnia_Commercial_Complex.glb",
        zoom: 17.46094107181462,
        bound: [
            [76.9485220125577, 28.406530183843884],
            [76.94038489234038, 28.39644836308908]
        ],
        heading: -90.55236583591515,
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJ3Q1V3Q1V1Q1N5QEVfQUFVQHFAQmNFZkBrQlRXRHFBTm1BSHNAQF9AQGVAQVdCaUBHT0VZR3VAXU9LX0BZdUBxQElRY0BbX0BRb0FvQHlDaUF3Q2lBYUNnQUNWTW5BQVJDUFd+Q1d8Q1V+Q1FoQ0VqQ1l+Q1l8Q094QU92QV1oQ1toQ0twQEloQFdmQXNAZENzQGZDcUBmQ3FAZkNvQHBCbUBwQlNoQE9FWUFVQl9AWE9aRVREUkxYSEhMRmBATF4/VENcTXBBWHxBWGRDbkBiQ25AZENwQHJAQ3RCcEByQnBAYkRiQWZCdkBiQ2RBYkNkQWJEdEFiQ2JBYkNkQWRDYkFUSmhCdkByQnxAckJ8QGJDZkFkQ2RBaEBUZEJ0QGJCdEBaTGpDaEFqQ2ZBaER4QWJBZEB2Qn5AdkJ+QHxBdEBUTmRAYEA/SERKREZTbkFfQGZBXX5AR055QHpCbUB8QWtAfkFxQWJEZ0F+Q2NBbkNjQWxDYUFuQ1JGWndAbEBjQm5AY0JyQVxQRk5IQEg/RkRwQXRAPw=="],
        footerInfo: {
            location: "Sector 86",
            distance: "7.5 KM",
            time: "14 mins"
        },
        category: "Commercial/Retail"
    }, {
        name: "Elan Miracle",
        center: [76.96343838990049, 28.415058983792605],
        latitude: 28.415058983792605,
        longitude: 76.96343838990049,
        path: "models/ROF_Landmarks/Elan_Miracle.glb",
        zoom: 17.256536988399976,
        bound: [
            [76.96549282285093, 28.420895337175608],
            [76.95593389808909, 28.40928587671108]
        ],
        heading: -91.83641978677139,
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJ3Q1V3Q1V1Q1N5QEVfQUFVQHFAQmNFZkBrQlRXRHFBTm1BSHNAQF9AQGVAQVdCaUBHT0VZR3VAXU9LX0BZdUBxQElRY0BbX0BRb0FvQHlDaUF3Q2lBYUNnQUNWTW5BQVJDUFd+Q1d8Q1V+Q1FoQ0VqQ1l+Q1l8Q094QU92QV1oQ1toQ0twQEloQFdmQXNAZENzQGZDcUBmQ3FAZkNvQHBCbUBwQlNoQE9FWUFVQl9AWE9aRVREUkxYSEhMRmBATF4/VENcTXBBWHxBWG1CfkFeVF1YSVBDUD9KQE5yQHpAbEB0QEhCSkBwQD9yQD9IQ0ZFQEdEa0BARQ=="],
        footerInfo: {
            location: "Sector 88",
            distance: "4.4 KM ",
            time: "9 mins"
        },
        category: "Commercial/Retail"
    }, {
        name: "Iris Broadway",
        center: [76.94794627840923, 28.403900750326372],
        latitude: 28.403900750326372,
        longitude: 76.94794627840923,
        path: "models/ROF_Landmarks/Reliance_Smart_Superstore.glb",
        zoom: 18.100893316114085,
        bound: [
            [76.95203208189781, 28.407239912872484],
            [76.94653888104568, 28.400786034540815]
        ],
        heading: 85.95496431385709,
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJ3Q1V3Q1V1Q1N5QEVfQUFVQHFAQmNFZkBrQlRXRHFBTm1BSHNAQF9AQGVAQVdCaUBHT0VZR3VAXU9LX0BZdUBxQElRY0BbX0BRb0FvQHlDaUF3Q2lBYUNnQUNWTW5BQVJDUFd+Q1d8Q1V+Q1FoQ0VqQ1l+Q1l8Q094QU92QV1oQ1toQ0twQEloQFdmQXNAZENzQGZDcUBmQ3FAZkNvQHBCbUBwQlNoQE9FWUFVQl9AWE9aRVREUkxYSEhMRmBATF4/VENcTXBBWHxBWGRDbkBiQ25AZENwQHJAQ3RCcEByQnBAYkRiQWZCdkBiQ2RBYkNkQWJEdEFiQ2JBYkNkQWRDYkFUSmhCdkByQnxAckJ8QGJDZkFkQ2RBaEBUZEJ0QGJCdEBaTGpDaEFqQ2ZBaER4QWJBZEB2Qn5AdkJ+QHxBdEBUTmRAYEA/SERKREZTbkFfQGZBXX5AR055QHpCbUB8QWtAfkFxQWJEb0FGZ0JKP1VBb0E="],
        footerInfo: {
            location: "Sector 85",
            distance: "5.6 KM",
            time: "11 mins"
        },
        category: "Commercial/Retail"
    }, {
        name: "Adani Aangan",
        center: [76.94650359501298, 28.431690230740216],
        latitude: 28.431690230740216,
        longitude: 76.94650359501298,
        path: "models/ROF_Landmarks/Adani_Aangan.glb",
        zoom: 17.86673655098674,
        bound: [
            [76.94845104764295, 28.432550388347778],
            [76.94380304891808, 28.430765391828857]
        ],
        heading: 0,
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BXFluQGdAekFrQW5BYUFsQGVAbkF9QF5ZakF9QEpJ"],
        footerInfo: {
            location: "Sector 88A",
            distance: "1.2 KM",
            time: "3 mins"
        },
        category: "Residential"
    }, {
        name: "ATS Marigold",
        center: [76.9460407755223, 28.43711312823436],
        latitude: 28.43711312823436,
        longitude: 76.9460407755223,
        path: "models/ROF_Landmarks/ATS_Marigold.glb",
        zoom: 17.118222321474747,
        bound: [
            [76.94990075666067, 28.438397367598043],
            [76.94209183195102, 28.43539861179177]
        ],
        heading: 0,
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAWD9gQUJFYkFFcEVASGpDP0JRP0lARUJJRFFARUFhQD9N"],
        footerInfo: {
            location: "Sector 89A",
            distance: "1.5 KM",
            time: "3 mins"
        },
        category: "Residential"
    }, {
        name: "Godrej Icon",
        center: [76.94978032200754, 28.431987475620005],
        latitude: 28.431987475620005,
        longitude: 76.94978032200754,
        path: "models/ROF_Landmarks/Godrej_Icon.glb",
        zoom: 17.24418767128597,
        bound: [
            [76.95319075700343, 28.43322812288376],
            [76.94603473138176, 28.430479960093407]
        ],
        heading: 0,
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREZ0B3QEVRQmVAWl9CQk1KbUBcfUNlQkBjQD9pQT8="],
        footerInfo: {
            location: "Sector 88A",
            distance: "1.2 KM",
            time: "4 mins"
        },
        category: "Residential"
    }, {
        name: "Godrej Oasis",
        center: [76.95006322637028, 28.430947840705826],
        latitude: 28.430947840705826,
        longitude: 76.95006322637028,
        path: "models/ROF_Landmarks/Godrej_Oasis.glb",
        zoom: 17.362569292650754,
        bound: [
            [76.95279610082281, 28.4320393951311],
            [76.94620382351627, 28.42950770545751]
        ],
        heading: 0,
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREZ0B3QEVRQmVAWl9CQk1lQEVxQ1VpQkFBekA/Sg=="],
        footerInfo: {
            location: "Sector 88A",
            distance: "1 KM",
            time: "3 mins"
        },
        category: "Residential"
    }, {
        name: "The Edge Towers",
        center: [76.96901291409978, 28.447365517282137],
        latitude: 28.447365517282137,
        longitude: 76.96901291409978,
        path: "models/ROF_Landmarks/Ramprastha_Edge.glb",
        zoom: 16.607200302584967,
        bound: [
            [76.9743405928204, 28.449876952040952],
            [76.96321241154237, 28.44560398500603]
        ],
        heading: 0,
        routesFromBase: ["aWB0dE1naXFsRE1Lc0B1QHFAaUBTSF9BSnlDT3dDT3VARX1EUXtEUX1EUX1EUXtEUX1EUW9AUGlDS2lDS2dCU2dCUz9hRENvQkFxQkttREtfQkl7QUFLRXtAT19DQ2FAT3tBS29CS29CQGdCQGdCP2VARVNVd0JXdUJPaUF1QF9Ec0BhRHNAYUR1Q2xAUU5BRENIQFB2QGJDYEB8QV56QWNBTHtASmVBSGFBTnlARl9ASF9ATE9CXUBPQkNiQENQRU59QGpAUUJNSG1DZkJvQ2hCbUNmQlNZWV9AV11AQ0BJQUdBRUVFSUNLQUNAR0BFREVIP0I/REBGU05LRkVCTT9NQ0ZjQEltQkNHTz9bRG9AUlFbU1djQFtlQEtPQ1NBWT9fQEZ9QG5AakFqQQ=="],
        footerInfo: {
            location: "Sector 37D",
            distance: "4.1 KM",
            time: "8 mins"
        },
        category: "Residential"
    }, {
        name: "Skyz Towers",
        center: [76.9712235366789, 28.44887609016702],
        latitude: 28.44887609016702,
        longitude: 76.9712235366789,
        path: "models/ROF_Landmarks/Ramprastha_Skyz.glb",
        zoom: 16.968586991060835,
        bound: [
            [76.97557664399574, 28.45032462537857],
            [76.96691428938567, 28.446998508343853]
        ],
        heading: 0,
        routesFromBase: ["aWB0dE1naXFsRE1Lc0B1QHFAaUBTSF9BSnlDT3dDT3VARX1EUXtEUX1EUX1EUXtEUX1EUW9AUGlDS2lDS2dCU2dCUz9hRENvQkFxQkttREtfQkl7QUFLRXtAT19DQ2FAT3tBS29CS29CQGdCQGdCP2VARVNVd0JXdUJPaUF1QF9Ec0BhRHNAYUR1Q2xAUU5BRENIQFB2QGJDYEB8QV56QWNBTHtASmVBSGFBTnlARl9ASF9ATE9CXUBPQmlAaUBHUW9BaUFxQWlBd0BvQGtBZ0FrQWlBcUFlQUlEbUJsQW9CbEFvQm5BUE5cVFJQTlJjS35FUVFtQmtCbUFnQU1MWGpA"],
        footerInfo: {
            location: "Sector 37D",
            distance: "6.8 KM",
            time: "15 mins"
        },
        category: "Residential"
    }, {
        name: "Delhi Public School, Gurugram",
        center: [76.98711450584915, 28.483088775492547],
        latitude: 28.483088775492547,
        longitude: 76.98711450584915,
        path: "models/ROF_Landmarks/Delhi_Public_School.glb",
        zoom: 18.048043245268044,
        bound: [
            [76.9890057939416, 28.48397696139304],
            [76.98490670589524, 28.48240353325447]
        ],
        heading: 0,
        routesFromBase: ["aWB0dE1naXFsRE1Lc0B1QHFAaUBTSF9BSnlDT3dDT3VARX1EUXtEUX1EUX1EUXtEUX1EUW9AUGlDS2lDS2dCU2dCU2VART91QkFzQkVpQ0VpQ015Qkt5QlF7Q1F7Q1N9Q1F7Q1NxQllrQ019QGlAZ0RpQGdEZUB3QmNAeUJ1QHVDdUB1Q19BcUN3QHtCeUB7QndAe0JFTWtAe0FpQHlBe0B7Qn1AfUJ7QHtCfUB7QlVrQE1dV2NAc0B3QXNAdUF5QXNDUW9Bc0FjQ3NBZUNzQWNDaUBjQWtBc0JlQHtAcUF9QW9BX0JlQGVAZ0JvQmVCcUJnQnFCZUJxQmVCfUFlQn1BbUJjQmtCZUJtQmNCcUBxQGVDe0JlQ3tCZUN5QmVDe0J3QXtBe0BZYUNrQmNDbUJjQmtBdUFnQXdBaUFzQmVCc0JlQnVCZUJzQmVCc0JlQl9BZUF7QXNBeUFxQX1Bd0F9QXlBd0JnQndCaUJ1QmdCQUlDS2BAbUBKWz9LQ0ViQXdAZ0FfQQ=="],
        footerInfo: {
            location: "Sector 103",
            distance: "7.1 KM",
            time: "10 mins"
        },
        category: "School"
    }, {
        name: "Euro International School",
        center: [76.97347616870667, 28.45466757920417],
        latitude: 28.45466757920417,
        longitude: 76.97347616870667,
        path: "models/ROF_Landmarks/Euro_International_School.glb",
        zoom: 18.308860940863404,
        bound: [
            [76.9752517070778, 28.45520918370461],
            [76.9718305477756, 28.453895621420884]
        ],
        heading: 0,
        routesFromBase: ["aWB0dE1naXFsRE1Lc0B1QHFAaUBTSF9BSnlDT3dDT3VARX1EUXtEUX1EUX1EUXtEUX1EUW9AUGlDS2lDS2dCU2dCU2VART91QkFzQkVpQ0VpQ015Qkt5QlF7Q1F7Q1N9Q1F7Q1NxQllrQ019QGlAZ0RpQGdEZUB3QmNAeUJ1QHVDdUB1Q19BcUN3QHtCeUB7QndAe0JFTWtAe0FpQHlBe0B7Qn1AfUJ7QHtCfUB7QlVrQE1dV2NAc0B3QXNAdUF5QXNDUW9Bc0FjQ3NBZUNzQWNDaUBjQWtBc0JlQHtAcUF9QW9BX0JVcUB9QXFCX0JvQntBfUF7QX1BQVVBR0NHR0tLR01HTUVJQ0tBTz9RQE9CTURLRktIR0pDSkFGP0hASkJKRkpKSEpGTEROQmpAdEBsQnZCbEJ2QmpCfEJqQnpCTlJsQWBCZEB0QExSdEF6QnRBekJ2QXpCdEB2QXRAeEFyQHBBcEFqQkx4QFpsQU50QEJYRF5nRERpREZ9Q0JfRER9Q0JfRERZQH1BQHtDRGVCTHNBRFE/b0FAaUFAP2hAQ0xFTlFURUxVYEFVSn1CakBfQExLRktKY0BsQE9WbUBoQU5GWERKSmBCckBWSnZCeEBuQV5OQ0xKVlh2QH5A"],
        footerInfo: {
            location: "Sector 37D",
            distance: "5.9 KM",
            time: "13 mins"
        },
        category: "School"
    }, {
        name: "GD Goenka Public School",
        center: [77.00372383528025, 28.443683378430762],
        latitude: 28.443683378430762,
        longitude: 77.00372383528025,
        path: "models/ROF_Landmarks/GD_Goenka_School.glb",
        zoom: 16.372533623970156,
        bound: [
            [77.00836264500128, 28.448841899365704],
            [76.99513607412678, 28.4370814556397]
        ],
        heading: -45.81483104825515,
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJ3Q1V3Q1V1Q1N5QEVfQUFVQHFAQmNFZkBrQlRXRHFBTm1BSHNAQF9AQGVAQVdCaUBHT0VZR3VAXU9LX0BZdUBxQElRY0BbX0BRb0FvQHlDaUF3Q2lBYUNnQX1AZ0B7QWVBfUFnQWVCb0FlQnFBd0N1QnFBdUBjQFV7QFljRHtBYUR7QXlDdUF5Q3VBeUNzQXtCYUF5QmFBe0JhQWVCc0BlQnVAa0J7QG1Ce0BlRHlBZ0R7QXNAVWNAS2lAR3dBV21BT29ASXNCV3tBUVE/dUBRbUBPUUVjQmdAZUFdV0tTSVNLT0tLS1lbTVN5QG1BYUBxQHVAc0FXYUBPVW9AZUBnQFl9QGNATUdbQU1Re0BJe0JZc0JXWUdfQ2VAY0JnQGVCZUBhQmlAYUN5QGlBY0BRR19BW31DY0F3QF1jQV1tQWFAZ0NpQXFBbUBzQn1AaUNpQXdAWVdJU0VpQm9AW0tpQmVAd0FrQHVCdUB5QFNVSXNBYUB7QFd9QFdnQFFvQFVpRGFBSUlFSUBRQklebUJAX0BZR2dAYkFxQHhBRUxhQHpAbUBwQT9MR0xRZEB3QX5DdUFgREdKY0F+QndAbEJTZkBTXk9LU09tQXNBaUBrQGNBZUF5Q3BCc0BkQHVCdEF1QnRBcUB1QFthQA=="],
        footerInfo: {
            location: "Sector 10A",
            distance: "9.8 KM",
            time: "26 mins"
        },
        category: "School"
    }, {
        name: "Heritage Badminton Academy",
        center: [76.98790170458244, 28.45237482619524],
        latitude: 28.45237482619524,
        longitude: 76.98790170458244,
        path: "models/ROF_Landmarks/Heritage_Badminton_Academy.glb",
        zoom: 17.916757556491646,
        bound: [
            [76.99010672599644, 28.452940690694504],
            [76.98561712053998, 28.451216855628374]
        ],
        heading: 0,
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJ3Q1V3Q1V1Q1N5QEVfQUFVQHFAQmNFZkBrQlRXRHFBTm1BSHNAQF9AQGVAQVdCaUBHT0VZR3VAXU9LX0BZdUBxQElRY0BbX0BRb0FvQHlDaUF3Q2lBYUNnQX1AZ0B7QWVBfUFnQWVCb0FlQnFBd0N1QnFBdUBjQFV7QFljRHtBYUR7QXlDdUF5Q3VBeUNzQXtCYUF5QmFBe0JhQWVCc0BlQnVAa0J7QG1Ce0BlRHlBZ0R7QXNAVWNAS2lAR3dBV21BT29ASXNCV3tBUVE/dUBRbUBPUUVjQmdAZUFdV0tTSVNLT0tLS1lbTVN5QG1BYUBxQHVAc0FXYUBPVW9AZUBnQFl9QGNATUdbQU1Re0BJe0JZc0JXWUdfQ2VAY0JnQGVCZUBhQmlAYUN5QGlBY0BRR19BW31DY0F3QF1jQV1tQWFAZ0NpQXFBbUBzQn1AaUNpQXdAWVdJU0VpQm9AW0tpQmVAd0FrQHVCdUB5QFNVSXNBYUB7QFd9QFdnQFFvQFVpRGFBSUlFSUBRQklebUJAX0BAXUJLZkBnQUBNYEB7QGpAbUFKTWZAX0B8QGdCfkBxQnxAb0J8QHFCcEB9QXJAfUF2QHtBTE9oQGFAUkZ2QEdOSmRDVGpARmpBSGZDVG5CUGxCUmZEVGBCbkJsQGpAfkJ2Qg=="],
        footerInfo: {
            location: "Sector 37C",
            distance: "7.3 KM",
            time: "16 mins"
        },
        category: "Sports"
    }, {
        name: "Hyatt Regency Gurugram",
        center: [76.97620637732541, 28.39234714187397],
        latitude: 28.39234714187397,
        longitude: 76.97620637732541,
        path: "models/ROF_Landmarks/Hyatt_Regency.glb",
        zoom: 16.89334378807331,
        bound: [
            [76.9808849604658, 28.39416875154305],
            [76.97175883532879, 28.390662696708247]
        ],
        heading: 0,
        routesFromBase: ["aWB0dE1naXFsRE1Lc0B1QHFAaUBTSF9BSnlDT3dDT3VARX1EUXtEUX1EUX1EUXtEUX1EUW9BSWdDS2dDTWdDS3tBRVdEV1ZLZEBFdEBFYEFDeEJFZkJFaEJebEFFckFJaEFDZEFVYENVYENRekJPekJTakJRbEJVckJTckJXbENNfEFNfkFPZEJPZkJTYkJTZEJPYEJPYEJZZENXfEJZfEJhQGpEU25CUW5CR2BAQ1JhQHpCbUBoQ2tAZkNhQWRDYUFiQ2tAdkB5QGhAb0BeX0FWX0FUdUFUaUJWZUFGdUBAX0M/X0NNX0NRb0JHa0JCZUJOZUJaY0JgQHVBZEBfQnBAX0JyQGdDbEFfQnBAX0JyQHdBbEBjQ2hBYUNmQWNDZkFjQ3BBeUJsQX1CdEF9QXxAfUF8QGVDekFnQ3pBd0JkQXdCYkF3QmRBa0NwQW9DfEJhQnZBeUJuQndAbEBrQmZBbUNsQXFDYEFxQ2BBc0NgQWNDdkBlQ3hAZUN2QGFCQWNBV2tAbUBPW0NrQEhrQFRvQFplQFRTaEBTXEVqQD9eSGhAUHBAZEB2QGhCeEBmQmxAdEFsQHJBbkFwQ3BBcEN4QGhCdEB8QWpAfkBKUF5mQHBCYENoQWhBaEFoQWpBbkFqQW5BZEFiQXJBdkFmQWRBZkFkQW5CdEJmQmZCYEFiQXBCbkN+QGhBYEBgQHpBcEF6QW5BeEJoQnZAYEFgQWxBfkBqQWZAbEBJYEBwQW5BZEJmQmJCaEJUVHpBekFkQWZBZkFmQXpAfkB0QnZCUFBmQGhAckFyQXJBdEF4QXxBeEF6QXxCYEN+QWdBSUNVR1FDTUNJRXFBc0FxQXNBX0JfQnNCd0JjQWlBc0BvQF9CZUJxQXNBUVN7QX1Be0F9QWFAY0BiQFNUQ35Aa0BaSExAVj9gQENaUWpAV2lAX0BdWQ=="],
        footerInfo: {
            location: "Sector 83",
            distance: "9.4 KM",
            time: "17 mins"
        },
        category: "Hotel"
    }, {
        name: "Medanta The Medicity",
        center: [77.04043363900394, 28.43901266408048],
        latitude: 28.43901266408048,
        longitude: 77.04043363900394,
        path: "models/ROF_Landmarks/Medanta-_The_Medicity.glb",
        zoom: 16.477149985885283,
        bound: [
            [77.04657655352992, 28.44140168278861],
            [77.03439863013023, 28.436725255189174]
        ],
        heading: 0,
        routesFromBase: ["aWB0dE1naXFsRE1Lc0B1QHFAaUBTSF9BSnlDT3dDT3VARX1EUXtEUX1EUX1EUXtEUX1EUW9BSWdDS2dDTWdDS3tBRVdEV1ZLZEBFdEBFYEFDeEJFZkJFaEJebEFFckFJaEFDZEFVYENVYENRekJPekJTakJRbEJVckJTckJXbENNfEFNfkFPZEJPZkJTYkJTZEJPYEJPYEJZZENXfEJZfEJhQGpEU25CUW5CR2BAQ1JhQHpCbUBoQ2tAZkNhQWRDYUFiQ2tAdkB5QGhAb0BeX0FWX0FUdUFUaUJWZUFGdUBAX0M/X0NNX0NRb0JHa0JCZUJOZUJaY0JgQHVBZEBfQnBAX0JyQGdDbEFfQnBAX0JyQHdBbEBjQ2hBYUNmQWNDZkFjQ3BBeUJsQX1CdEF9QXxAfUF8QGVDekFnQ3pBd0JkQXdCYkF3QmRBa0NwQW9DfEJhQnZBeUJuQndAbEBrQmZBbUNsQWFCVnlAQndBT19BX0BtQXNAZ0FhQFdHaUFPaUFBY0JHeUBRZUJhQH1AbUJ7QG9CcUF1Q29BdUNxQXdDcUF1Q3FBdUNxQXVDfUB5QmNAYUF7QGtCeUBtQntAbUJjQXdCY0F5QntAdUJ9QHNCb0FvQ21Bb0NvQXFDb0FvQ21Bb0N1QH1Bc0BjQm1AbUFfQX1Bd0JrQ3dCa0NrQn1Ca0J9QmlCeUJpQl9DaUJfQ2lCX0NvQXtBbUF9QXtAa0F1QnFDdUBfQW9Bd0FxQXVBdUB5QG9Bd0FxQXVBeUFrQntBaUJhQW9BY0FvQU1PSUtJTXNAeUBvQmVDb0JlQ31BYUNfQl9DY0FhQmVAaUBzQWFCc0FhQnNCaUNxQmlDc0JnQ3FCaUNzQmlDcUJnQ31BcUJ9QW9CfUFxQn1BcUJfQV9BbUF9QG1AX0BnQWdAeUFnQHlCY0B3QU1zQUNrQkJpQkxxQVJfQ2JAX0NiQGFFdkBhRXZAdUBOa0NmQGlDZEBtQ2hAbUNmQG1DaEBxQl5xQmBAZ0FOZ0BIc0BGT0B7QEJVQF1AX0E/fUBBS0FpQENTQ3dAS2VBVXVBXWlAUXtAX0BrQFtnQXVAZ0FfQWNBY0FpQW1BY0FvQXtAe0BnQGtAZUBnQGNAYUFpQm9CaUJxQmlAX0F9QWdCfUFnQm1AcUBXW0tJcUF2QUpIVlZqQGhAakJwQmRBZkFkQWhBaEFuQWhBbEFiQmZCYEFgQXJCekJyQnhCYEFmQWRBeEBUbEB4QG5CckBwQldsQEtSW3ZAc0B0QVVgQF9AYkBhQFp3QGpATUh7Qn5Be0J8QXtCfEF7Qn5BdUJ2QXVCdkFzQXxAc0F+QH1AbEBhQmpBSkpmQm1BcEJ3QXBAZkBMSnZBZUFeVWpBe0BMSUhDRkBaVG5AcEB4QmpDaUJyQQ=="],
        footerInfo: {
            location: "Sector 38",
            distance: "15.8 KM",
            time: "24 mins"
        },
        category: "Hospital"
    }, {
        name: "Tau Devilal Cricket Stadium",
        center: [77.03622679248639, 28.441803969248028],
        latitude: 28.441803969248028,
        longitude: 77.03622679248639,
        path: "models/ROF_Landmarks/Tau_DeviLal_Sports_Complex.glb",
        zoom: 16.055227425362066,
        bound: [
            [77.06042465186488, 28.464477932487014],
            [77.02967753205553, 28.435085226077334]
        ],
        heading: 60,
        routesFromBase: ["aWB0dE1naXFsRE1Lc0B1QHFAaUBTSF9BSnlDT3dDT3VARX1EUXtEUX1EUX1EUXtEUX1EUW9BSWdDS2dDTWdDS3tBRVdEV1ZLZEBFdEBFYEFDeEJFZkJFaEJebEFFckFJaEFDZEFVYENVYENRekJPekJTakJRbEJVckJTckJXbENNfEFNfkFPZEJPZkJTYkJTZEJPYEJPYEJZZENXfEJZfEJhQGpEU25CUW5CR2BAQ1JhQHpCbUBoQ2tAZkNhQWRDYUFiQ2tAdkB5QGhAb0BeX0FWX0FUdUFUaUJWZUFGdUBAX0M/X0NNX0NRb0JHa0JCZUJOZUJaY0JgQHVBZEBfQnBAX0JyQGdDbEFfQnBAX0JyQHdBbEBjQ2hBYUNmQWNDZkFjQ3BBeUJsQX1CdEF9QXxAfUF8QGVDekFnQ3pBd0JkQXdCYkF3QmRBa0NwQW9DfEJhQnZBeUJuQndAbEBrQmZBbUNsQWFCVnlAQndBT19BX0BtQXNAZ0FhQFdHaUFPaUFBY0JHeUBRZUJhQH1AbUJ7QG9CcUF1Q29BdUNxQXdDcUF1Q3FBdUNxQXVDfUB5QmNAYUF7QGtCeUBtQntAbUJjQXdCY0F5QntAdUJ9QHNCb0FvQ21Bb0NvQXFDb0FvQ21Bb0N1QH1Bc0BjQm1AbUFfQX1Bd0JrQ3dCa0NrQn1Ca0J9QmlCeUJpQl9DaUJfQ2lCX0NvQXtBbUF9QXtAa0F1QnFDdUBfQW9Bd0FxQXVBdUB5QG9Bd0FxQXVBeUFrQntBaUJhQW9BY0FvQU1PSUtJTXNAeUBvQmVDb0JlQ31BYUNfQl9DY0FhQmVAaUBzQWFCc0FhQnNCaUNxQmlDc0JnQ3FCaUNzQmlDcUJnQ31BcUJ9QW9CfUFxQn1BcUJfQV9BbUF9QG1AX0BnQWdAeUFnQHlCY0B3QU1zQUNrQkJpQkxxQVJfQ2JAX0NiQGFFdkBhRXZAc0BFa0JaY0BJdUJcbURwQGNEdEBvQ3ZAeUJee0JgQGNBUGdARmtBRmNCQ2tBR0NgQmRAakBKUkhiQEFeSX5BSXxBQ2pAUXZDT3hDR2ZBSXJBZUNJZ0NJYUFxQU9VZ0BtQE9MYkBoQA=="],
        footerInfo: {
            location: "Sector 38",
            distance: "14 KM",
            time: "20 mins"
        },
        category: "Sports"
    }, {
        name: "The Signature Advanced Super Speciality Hospital",
        center: [76.97316484540426, 28.454167901125842],
        latitude: 28.454167901125842,
        longitude: 76.97316484540426,
        path: "models/ROF_Landmarks/The_Signature_Advanced_Super_Speciality_Hospital.glb",
        zoom: 18.360514992147802,
        bound: [
            [76.97500746368945, 28.45472903153116],
            [76.97170662821367, 28.453461662389117]
        ],
        heading: 0,
        routesFromBase: ["aWB0dE1naXFsRE1Lc0B1QHFAaUBTSF9BSnlDT3dDT3VARX1EUXtEUX1EUX1EUXtEUX1EUW9AUGlDS2lDS2dCU2dCU2VART91QkFzQkVpQ0VpQ015Qkt5QlF7Q1F7Q1N9Q1F7Q1NxQllrQ019QGlAZ0RpQGdEZUB3QmNAeUJ1QHVDdUB1Q19BcUN3QHtCeUB7QndAe0JFTWtAe0FpQHlBe0B7Qn1AfUJ7QHtCfUB7QlVrQE1dV2NAc0B3QXNAdUF5QXNDUW9Bc0FjQ3NBZUNzQWNDaUBjQWtBc0JlQHtAcUF9QW9BX0JVcUB9QXFCX0JvQntBfUF7QX1BQVVBR0NHR0tLR01HTUVJQ0tBTz9RQE9CTURLRktIR0pDSkFGP0hASkJKRkpKSEpGTEROQmpAdEBsQnZCbEJ2QmpCfEJqQnpCTlJsQWBCZEB0QExSdEF6QnRBekJ2QXpCdEB2QXRAeEFyQHBBcEFqQkx4QFpsQU50QEJYRF5nRERpREZ9Q0JfRER9Q0JfRERZQH1BQHtDRGVCTHNBRFE/b0FAaUFAP2hAQ0xFTlFURUxVYEFVSn1CakBfQExLRktKY0BsQE9WbUBoQU5GWERKSmBCckBWSnZCeEBuQV5OQ0xKVlhkQW5BfkBmQQ=="],
        footerInfo: {
            location: "Sector 37D",
            distance: "5.8 KM",
            time: "12 mins"
        },
        category: "Hospital"
    }, {
        name: "Aarvy Healthcare Super Speciality Hospital",
        center: [76.94156257473787, 28.4122421766059],
        latitude: 28.4122421766059,
        longitude: 76.94156257473787,
        path: "models/ROF_Landmarks/Aarvy_Hospital.glb",
        zoom: 18.19452811996605,
        bound: [
            [76.94328766424292, 28.412985360997823],
            [76.93958434709918, 28.411562895326156]
        ],
        heading: 0,
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJDTGZCTGZCTm5EVn5DVn5DVHxCUlJCZEFGfkJQaEJSaEJSYENYYENWdkRiQGZCUnJBUHJASFhEbEFOVkJcRG5ATmRAUHpCdkBmQFBgQmpAYkFSZENoQGxBVHBBVlpGfEBQckBOckBKdEFWaUBsQX1AcEJfQXBCfUByQn1AckJlQXJCUV5NVH1AbEJxQHRBcUB0QXVAfEFxQHhBX0FwQldoQGlBYkNtQHBBbUBuQVNmQHdAfEF3QHpBcUB2QWlAZEFrQWRDZ0BgQU9aUkpoQExPYEFxQHZBUD94QD8="],
        footerInfo: {
            location: "Sector 90",
            distance: "4.5 KM",
            time: "11 mins"
        },
        category: "Hospital"
    }, {
        name: "Fortis International Institute Of Medical Science",
        center: [77.07286, 28.45719],
        latitude: 28.45719,
        longitude: 77.07286,
        path: "models/ROF_Landmarks/Fortis_Hospital.glb",
        zoom: 17.30658127034213,
        altitude: -8,
        bound: [
            [77.0761952425114, 28.458231893928414],
            [77.06934210348965, 28.455600673669338]
        ],
        heading: 0,
        routesFromBase: ["aWB0dE1naXFsRFhUSkZOQlo/fEFHekBAQG5DP25DQGpCQGpCQ3pAR3ZAW2RCbUB2Q21AeENjQGBDY0B+QmVAYENlQGREVW5BW1Z9QmJCfUJiQn1CYkJ3Q1V3Q1V1Q1N5QEVfQUFVQHFAQmNFZkBrQlRXRHFBTm1BSHNAQF9AQGVAQVdCaUBHT0VZR3VAXU9LX0BZdUBxQElRY0BbX0BRb0FvQHlDaUF3Q2lBYUNnQX1AZ0B7QWVBfUFnQWVCb0FlQnFBd0N1QnFBdUBjQFV7QFljRHtBYUR7QXlDdUF5Q3VBeUNzQXtCYUF5QmFBe0JhQWVCc0BlQnVAa0J7QG1Ce0BlRHlBZ0R7QXNAVWNAS2lAR3dBV21BT29ASXNCV3tBUVE/dUBRbUBPUUVjQmdAZUFdV0tTSVNLT0tLS1lbTVN5QG1BYUBxQHVAc0FXYUBPVW9AZUBnQFl9QGNATUdbQU1Re0BJe0JZc0JXWUdfQ2VAY0JnQGVCZUBhQmlAYUN5QGlBY0BRR19BW31DY0F3QF1jQV1tQWFAZ0NpQXFBbUBzQn1AaUNpQXdAWVdJU0VpQm9AW0tpQmVAd0FrQHVCdUB5QFNVSXNBYUB7QFd9QFdnQFFvQFVpRGFBSUlFSUBRQklebUJAX0BZR2dAYkFxQHhBRUxhQHpAbUBwQT9MR0xRZEB3QX5DdUFgREdKY0F+QndAbEJTZkBTXl1kQE9EYUFkQVdYRVBxQHRAXWBAYUFoQWlAcEBlQGhAT0RnQWpBZUFoQVdSZUBaZUBac0NoQnNDaEJxQ2hCZ0BYa0BaZUBYXVBnQnxASURlQ3JBY0FsQGVBbEBfQVRrQFZrQnpAY0R4QWFBZEB7QEhNP09FXUl3Qm1DZ0J5QmdCaUNlQmlDdUF7QGVAaUBzQWFCc0FhQnNCaUNxQmlDc0JnQ3FCaUNzQmlDcUJnQ31BcUJ9QW9CfUFxQn1BcUJfQV9BbUF9QG1AX0BnQWdAeUFnQHlCY0B3QU1zQUNrQkJpQkxxQVJfQ2JAX0NiQGFFdkBhRXZAdUBOa0NmQGlDZEBtQ2hAbUNmQG1DaEBxQl5xQmBAZ0FOZ0BIc0BGT0B7QEJVQF1AX0E/fUBBS0FpQENTQ3dAS2VBVXVBXWlAUXtAX0BrQFtnQXVAZ0FfQWNBY0FpQW1BY0FvQXtAe0BnQGtAZUBnQGNBY0FfQ2dDX0NlQ19DZ0NfQ2VDQUNHR3NCd0J1QndCc0J5QnVCd0JzQndCZUFpQWVBZ0FhQmdCYUJlQnVCfUJtQGtAY0JrQmVCa0JjQmtCZUJpQndCd0JvQnVCcUJzQm9Cc0J7QF9BcUJ1Qm9CdUJxQnVCcUJ1QmlCa0JhQGNBX0FnQWVAb0BVX0BNWVt3QFlfQXFAd0FnQGFBTVNjQGVAc0B9QFFZQ1k/X0JEaUBCd0BGa0FAU0x1QmhAdUI/QWZAfUFoQH1BcEFzQkRVQEtBRUNDR0NFP0lEUU5fQnBCWWZBZUBwQWtAfEJTZkFHYkBHbEBJakFJZEJHYkBFUENIYUB2QEtSR0hbXFtYS0pHRlNKeUBiQG1EcEFvQF5xQnRBc0JyQXVBYEF3QWJBZ0FwQHtBYEF7QX5Ad0F4QHtBakFdXl9BeEBnQ2ZCYUFwQG1CdEFtQnJBbUNuQm1DbkJVTF9CaEFtQFhxQF5xQnRBb0JyQW9CdkFvQGRAcUNuQm1AVGNASk9AS0FdR3dCa0BJP0VAR0RHTEdQP0RISEFKQkJeTEBEQFpHP0k/QUBJRENEP0Q/QkBIREJGREQ/RlhGSlpa"],
        footerInfo: {
            location: "Sector 44",
            distance: "20.2 KM",
            time: "29 mins"
        },
        category: "Hospital"
    }, {
        name: "Air India GSD Building",
        center: [77.09225248850208, 28.558083843760016],
        latitude: 28.558083843760016,
        longitude: 77.09225248850208,
        path: "models/ROF_Landmarks/Air_India_GSD_Building.glb",
        zoom: 17.379019105456127,
        bound: [
            [77.10028394741886, 28.56483311565472],
            [77.08876361964587, 28.555594028442968]
        ],
        heading: 18.26528777979422,
        category: "Airport",
        routesFromBase: ["aWB0dE1naXFsRE1Lc0B1QHFAaUBTSF9BSnlDT3dDT3VARX1EUXtEUX1EUX1EUXtEUX1EUW9AUGlDS2lDS2dCU2dCU2VART91QkFzQkVpQ0VpQ015Qkt5QlF7Q1F7Q1N9Q1F7Q1NxQllrQ019QGlAZ0RpQGdEZUB3QmNAeUJ1QHVDdUB1Q19BcUN3QHtCeUB7QndAe0JFTWtAe0FpQHlBe0B7Qn1AfUJ7QHtCfUB7QlVrQE1dV2NAc0B3QXNAdUF5QXNDYUJ5Q2FCe0NhQnlDX0F9QV9BX0JpQHtAb0FpQmdCX0NxQXtBb0F7QWNBY0FjQWNBdUF1QXVBdUFjQGVAa0JhQm1CY0JtQmNCZ0FfQWdBX0FzQnlCdUJ3QmFCd0FhQnlBYUJ3QUlJe0FvQXdBa0F3QW1BdUNzQnVDc0JpQ3dCaUN3QmtCYUJrQl9Ca0JfQmFDcUJjQ3FCYUNxQmFDcUJpQ31Ca0NfQ2lDfUJtQmVCZ0N9QmlDfUJvQnNCb0JzQmlAaUB5Qn1CaUFlQWtBZUF7QHdAa0BnQHtCa0J3QW1BbUJrQm1CaUJtQmtCbUF3QW9BdUFfQ31CYUN9Qn1BeUF7QXlBe0F3QWdCeUFnQndBa0N3QmtDd0JjQn1BZUJ7QWNCfUF5QmlCeUJpQnNBY0FxQWFBX0J5QV9CeUFfQnlBfUFvQl9Cb0JfQm9Ca0J7Qm1CeUJrQntCa0J5QmlBfUFnQV9CaUJ3QmlCeUJpQnlCaUJ5Qm1Cb0JtQnFCb0JzQnFCdUJvQnNCYUJvQl9Cb0J1QW1CdUFrQnNBa0JzQm1Dc0JrQ2VCb0JlQm9CZUJxQmVCb0JnQndCaUJ3QmdCd0JxQntCcUJ9Qm9Ce0JxQntCa0J3QmtCd0JrQndCa0J3QmtCd0JxQnFCb0JxQm9CcUJfQmlCa0J7QmlCe0JrQntCaUJ7QmlCe0JrQntCaUJ7Ql9AY0B9QXdDe0F5Q3NAX0RhQHtDX0B7Q2FAe0NTd0F5QHtDe0B7Q3lAe0NvQH1BbUB9QXVAbUF1QGtBZUFzQWdBcUFrQn1Ca0J7QmlCfUJrQXdBY0JzQmNCc0JrQn1CbUJfQ21CfUJrQl9DaUJ5QmdCeUJpQnlCdUJjQ3NCY0NpQnlCZ0J3QmlCeUJ5QWdCe0FnQnlBaUJlQn1AX0NvQGlBS2NCQV9CSHNCZkBnQWRAYUBYa0BkQHVAfkBnQHZAZ0F8QmlBfEJnQX5Cc0BwQXVAcEF7QGBBY0F6QHlBfEBjQ3BBdUJ2QXVDZEFzQ2ZBc0NkQWdCcEBlQnJAb0NmQG9DZkBtQ2RAZUVsQGNFbEBjRWxAY0VsQGVFbEBjRWxAY0VqQGNFbEBlRWxAY0VsQGNFbEBjRWxAY0VsQGVFbEBjRWpAY0VsQGNFbEBlRWxAfUN2QH1DeEB9Q3hAX0R2QH1DeEB7RGxAeURsQHtEbkB3RFZ3RFZ3RFZ3RFh1RFZtRGRAbURkQG1EZEBrRGRAbURkQGdFYkBnRWJAZ0ViQGdFYkBnRWJAZ0ViQGdFZEBnRWJAaURoQGtEaEBrRGhAa0RoQGlEaEB3Q1h3Q1ZrQndAYUJPeUNvQXlDb0F3Q29BeUNvQXlDb0FvQFtpQW9AZUBdXVtjQGdAa0B3QG9Aa0F1QHFCUV9CfUB3Q1d1QHFAbUJAd0BCV0ptQFxnQUxdVmlBSlFETUJTQEtBTUFLSF1GR0pHWEdqQlVuQElQRWBAR2JASVZLZkBfQGxAUWZAS3pBUXpBVXZBU2pEa0BqRGtAekNfQHpDYUBuRGlAbERpQG5EaUB4QEtiRGdAVEdyQFlaW1BdUGFARGVAR3FBQG9ATmVAZEB7QGZAbUFiQWNDRk9QX0BwQH1CWHdAZkFjRHRAb0FeZUBqQG9AdEBtQG5DfUFyQllyQllmQ19AZkNhQGhDX0BuQlluQll8QllmQ2NAaENhQHJCXXRCW3pEb0B+RGtAYEVtQGZCVXRBUXJBVU5JQktCTUNLRUlLS1NDaUBDa0JYaUJYZUNcZUNcZUNcU0tRSUlPV21BU19BR3VAQkVARz9HdkFRaEFPakNXZkJNakNFYkFEQldLSUVJQEtCR0BJeEBLSkdGR0JdQU1DW0dNTUl5QExnQGlEX0Rc"],
        footerInfo: {
            location: "IGI Airport",
            distance: "30.2 KM",
            time: "43 mins"
        }
    }, {
        name: "Centaur Hotel",
        center: [77.10298091042966, 28.548958251132362],
        latitude: 28.548958251132362,
        longitude: 77.10298091042966,
        path: "models/ROF_Landmarks/Centaur_Hotel.glb",
        zoom: 17.179596213722583,
        bound: [
            [77.10572589371691, 28.556699000824125],
            [77.0939427151294, 28.544894405030504]
        ],
        heading: -74.74081193282848,
        category: "Airport",
        routesFromBase: ["aWB0dE1naXFsRE1Lc0B1QHFAaUBTSF9BSnlDT3dDT3VARX1EUXtEUX1EUX1EUXtEUX1EUW9AUGlDS2lDS2dCU2dCU2VART91QkFzQkVpQ0VpQ015Qkt5QlF7Q1F7Q1N9Q1F7Q1NxQllrQ019QGlAZ0RpQGdEZUB3QmNAeUJ1QHVDdUB1Q19BcUN3QHtCeUB7QndAe0JFTWtAe0FpQHlBe0B7Qn1AfUJ7QHtCfUB7QlVrQE1dV2NAc0B3QXNAdUF5QXNDYUJ5Q2FCe0NhQnlDX0F9QV9BX0JpQHtAb0FpQmdCX0NxQXtBb0F7QWNBY0FjQWNBdUF1QXVBdUFjQGVAa0JhQm1CY0JtQmNCZ0FfQWdBX0FzQnlCdUJ3QmFCd0FhQnlBYUJ3QUlJe0FvQXdBa0F3QW1BdUNzQnVDc0JpQ3dCaUN3QmtCYUJrQl9Ca0JfQmFDcUJjQ3FCYUNxQmFDcUJpQ31Ca0NfQ2lDfUJtQmVCZ0N9QmlDfUJvQnNCb0JzQmlAaUB5Qn1CaUFlQWtBZUF7QHdAa0BnQHtCa0J3QW1BbUJrQm1CaUJtQmtCbUF3QW9BdUFfQ31CYUN9Qn1BeUF7QXlBe0F3QWdCeUFnQndBa0N3QmtDd0JjQn1BZUJ7QWNCfUF5QmlCeUJpQnNBY0FxQWFBX0J5QV9CeUFfQnlBfUFvQl9Cb0JfQm9Ca0J7Qm1CeUJrQntCa0J5QmlBfUFnQV9CaUJ3QmlCeUJpQnlCaUJ5Qm1Cb0JtQnFCb0JzQnFCdUJvQnNCYUJvQl9Cb0J1QW1CdUFrQnNBa0JzQm1Dc0JrQ2VCb0JlQm9CZUJxQmVCb0JnQndCaUJ3QmdCd0JxQntCcUJ9Qm9Ce0JxQntCa0J3QmtCd0JrQndCa0J3QmtCd0JxQnFCb0JxQm9CcUJfQmlCa0J7QmlCe0JrQntCaUJ7QmlCe0JrQntCaUJ7Ql9AY0B9QXdDe0F5Q3NAX0RhQHtDX0B7Q2FAe0NTd0F5QHtDe0B7Q3lAe0NvQH1BbUB9QXVAbUF1QGtBZUFzQWdBcUFrQn1Ca0J7QmlCfUJrQXdBY0JzQmNCc0JrQn1CbUJfQ21CfUJrQl9DaUJ5QmdCeUJpQnlCdUJjQ3NCY0NpQnlCZ0J3QmlCeUJ5QWdCe0FnQnlBaUJlQn1AX0NvQGlBS2NCQV9CSHNCZkBnQWRAYUBYa0BkQHVAfkBnQHZAZ0F8QmlBfEJnQX5Cc0BwQXVAcEF7QGBBY0F6QHlBfEBjQ3BBdUJ2QXVDZEFzQ2ZBc0NkQWdCcEBlQnJAb0NmQG9DZkBtQ2RAZUVsQGNFbEBjRWxAY0VsQGVFbEBjRWxAY0VqQGNFbEBlRWxAY0VsQGNFbEBjRWxAY0VsQGVFbEBjRWpAY0VsQGNFbEBlRWxAfUN2QH1DeEB9Q3hAX0R2QH1DeEB7RGxAeURsQHtEbkB3RFZ3RFZ3RFZ3RFh1RFZtRGRAbURkQG1EZEBrRGRAbURkQGdFYkBnRWJAZ0ViQGdFYkBnRWJAZ0ViQGdFZEBnRWJAaURoQGtEaEBrRGhAa0RoQGlEaEB3Q1h3Q1ZrQndAYUJPeUNvQXlDb0F3Q29BeUNvQXlDb0FvQFtpQW9AZUBdXVtjQGdAa0B3QG9Aa0F1QHFCUV9CfUB3Q1d1QHFAbUJAd0BCV0ptQFxnQUxdVmlBSlFETUJTQEtBTUFLSF1GR0pHWEdqQlVuQElQRWBAR2JASVZLZkBfQGxAUWZAS3pBUXpBVXZBU2pEa0BqRGtAekNfQHpDYUBuRGlAbERpQG5EaUB4QEtiRGdAVEdyQFlaW1BdUGFARGVAR3FBQG9ATmVAZEB7QGZAbUFiQWNDRk90QEdeSW5AS2RCV0hcSFBGREhCSkJMP0ZD"],
        footerInfo: {
            location: "IGI Airport",
            distance: "30.2 KM",
            time: "43 mins"
        }
    }, {
        name: "Terminal2",
        center: [77.08778057432988, 28.55882231443691],
        latitude: 28.55882231443691,
        longitude: 77.08778057432988,
        path: "models/ROF_Landmarks/Terminal2.glb",
        zoom: 15.972095068813418,
        bound: [
            [77.09191024330283, 28.572930220140023],
            [77.06989065086447, 28.546779340350867]
        ],
        heading: -85.48947639642707,
        category: "Airport",
        routesFromBase: ["aWB0dE1naXFsRE1Lc0B1QHFAaUBTSF9BSnlDT3dDT3VARX1EUXtEUX1EUX1EUXtEUX1EUW9AUGlDS2lDS2dCU2dCU2VART91QkFzQkVpQ0VpQ015Qkt5QlF7Q1F7Q1N9Q1F7Q1NxQllrQ019QGlAZ0RpQGdEZUB3QmNAeUJ1QHVDdUB1Q19BcUN3QHtCeUB7QndAe0JFTWtAe0FpQHlBe0B7Qn1AfUJ7QHtCfUB7QlVrQE1dV2NAc0B3QXNAdUF5QXNDYUJ5Q2FCe0NhQnlDX0F9QV9BX0JpQHtAb0FpQmdCX0NxQXtBb0F7QWNBY0FjQWNBdUF1QXVBdUFjQGVAa0JhQm1CY0JtQmNCZ0FfQWdBX0FzQnlCdUJ3QmFCd0FhQnlBYUJ3QUlJe0FvQXdBa0F3QW1BdUNzQnVDc0JpQ3dCaUN3QmtCYUJrQl9Ca0JfQmFDcUJjQ3FCYUNxQmFDcUJpQ31Ca0NfQ2lDfUJtQmVCZ0N9QmlDfUJvQnNCb0JzQmlAaUB5Qn1CaUFlQWtBZUF7QHdAa0BnQHtCa0J3QW1BbUJrQm1CaUJtQmtCbUF3QW9BdUFfQ31CYUN9Qn1BeUF7QXlBe0F3QWdCeUFnQndBa0N3QmtDd0JjQn1BZUJ7QWNCfUF5QmlCeUJpQnNBY0FxQWFBX0J5QV9CeUFfQnlBfUFvQl9Cb0JfQm9Ca0J7Qm1CeUJrQntCa0J5QmlBfUFnQV9CaUJ3QmlCeUJpQnlCaUJ5Qm1Cb0JtQnFCb0JzQnFCdUJvQnNCYUJvQl9Cb0J1QW1CdUFrQnNBa0JzQm1Dc0JrQ2VCb0JlQm9CZUJxQmVCb0JnQndCaUJ3QmdCd0JxQntCcUJ9Qm9Ce0JxQntCa0J3QmtCd0JrQndCa0J3QmtCd0JxQnFCb0JxQm9CcUJfQmlCa0J7QmlCe0JrQntCaUJ7QmlCe0JrQntCaUJ7Ql9AY0B9QXdDe0F5Q3NAX0RhQHtDX0B7Q2FAe0NTd0F5QHtDe0B7Q3lAe0NvQH1BbUB9QXVAbUF1QGtBZUFzQWdBcUFrQn1Ca0J7QmlCfUJrQXdBY0JzQmNCc0JrQn1CbUJfQ21CfUJrQl9DaUJ5QmdCeUJpQnlCdUJjQ3NCY0NpQnlCZ0J3QmlCeUJ5QWdCe0FnQnlBaUJlQn1AX0NvQGlBS2NCQV9CSHNCZkBnQWRAYUBYa0BkQHVAfkBnQHZAZ0F8QmlBfEJnQX5Cc0BwQXVAcEF7QGBBY0F6QHlBfEBjQ3BBdUJ2QXVDZEFzQ2ZBc0NkQWdCcEBlQnJAb0NmQG9DZkBtQ2RAZUVsQGNFbEBjRWxAY0VsQGVFbEBjRWxAY0VqQGNFbEBlRWxAY0VsQGNFbEBjRWxAY0VsQGVFbEBjRWpAY0VsQGNFbEBlRWxAfUN2QH1DeEB9Q3hAX0R2QH1DeEB7RGxAeURsQHtEbkB3RFZ3RFZ3RFZ3RFh1RFZtRGRAbURkQG1EZEBrRGRAbURkQGdFYkBnRWJAZ0ViQGdFYkBnRWJAZ0ViQGdFZEBnRWJAaURoQGtEaEBrRGhAa0RoQGlEaEB3Q1h3Q1ZrQndAYUJPeUNvQXlDb0F3Q29BeUNvQXlDb0FvQFtpQW9AZUBdXVtjQGdAa0B3QG9Aa0F1QHFCUV9CfUB3Q1d1QHFAbUJAd0BCV0ptQFxnQUxdVmlBSlFETUJTQEtBTUFLSF1GR0pHWEdqQlVuQElQRWBAR2JASVZLZkBfQGxAUWZAS3pBUXpBVXZBU2pEa0BqRGtAekNfQHpDYUBuRGlAbERpQG5EaUB4QEtiRGdAVEdyQFlaW1BdUGFARGVAR3FBQG9ATmVAZEB7QGZAbUFiQWNDRk9QX0BwQH1CWHdAZkFjRHRAb0FeZUBqQG9AdEBtQG5DfUFyQllyQllmQ19AZkNhQGhDX0BuQlluQll8QllmQ2NAaENhQHJCXXRCW3pEb0B+RGtAYEVtQGZCVXRBUXJBVU5JQktCTUNLRUlLS1NDaUBDa0JYaUJYZUNcZUNcZUNcU0tRSUlPV21BU19BR3VAQkVARz9HdkFRaEFPakNXZkJNakNFYkFEZkJMZkJOckJEeEBFckNjQGBDX0BgQ2FAZkJlQHxCY0BURVJHUE1IS0JPP0tBU0VfQEdXUWFAWWFAb0BrQFtLTz9bQlFEYUJ8QGlAWA=="],
        footerInfo: {
            location: "IGI Airport",
            distance: "30.2 KM",
            time: "43 mins"
        }
    }, {
        name: "ATC Tower",
        center: [77.09303587816595, 28.55607847149517],
        latitude: 28.55607847149517,
        longitude: 77.09303587816595,
        path: "models/ROF_Landmarks/ATC_Tower.glb",
        zoom: 17.355351693000454,
        bound: [
            [77.1023774587573, 28.564430346747216],
            [77.09069977813124, 28.554200317688867]
        ],
        heading: 46.4316520509351,
        category: "Airport",
        routesFromBase: ["aWB0dE1naXFsRE1Lc0B1QHFAaUBTSF9BSnlDT3dDT3VARX1EUXtEUX1EUX1EUXtEUX1EUW9AUGlDS2lDS2dCU2dCU2VART91QkFzQkVpQ0VpQ015Qkt5QlF7Q1F7Q1N9Q1F7Q1NxQllrQ019QGlAZ0RpQGdEZUB3QmNAeUJ1QHVDdUB1Q19BcUN3QHtCeUB7QndAe0JFTWtAe0FpQHlBe0B7Qn1AfUJ7QHtCfUB7QlVrQE1dV2NAc0B3QXNAdUF5QXNDYUJ5Q2FCe0NhQnlDX0F9QV9BX0JpQHtAb0FpQmdCX0NxQXtBb0F7QWNBY0FjQWNBdUF1QXVBdUFjQGVAa0JhQm1CY0JtQmNCZ0FfQWdBX0FzQnlCdUJ3QmFCd0FhQnlBYUJ3QUlJe0FvQXdBa0F3QW1BdUNzQnVDc0JpQ3dCaUN3QmtCYUJrQl9Ca0JfQmFDcUJjQ3FCYUNxQmFDcUJpQ31Ca0NfQ2lDfUJtQmVCZ0N9QmlDfUJvQnNCb0JzQmlAaUB5Qn1CaUFlQWtBZUF7QHdAa0BnQHtCa0J3QW1BbUJrQm1CaUJtQmtCbUF3QW9BdUFfQ31CYUN9Qn1BeUF7QXlBe0F3QWdCeUFnQndBa0N3QmtDd0JjQn1BZUJ7QWNCfUF5QmlCeUJpQnNBY0FxQWFBX0J5QV9CeUFfQnlBfUFvQl9Cb0JfQm9Ca0J7Qm1CeUJrQntCa0J5QmlBfUFnQV9CaUJ3QmlCeUJpQnlCaUJ5Qm1Cb0JtQnFCb0JzQnFCdUJvQnNCYUJvQl9Cb0J1QW1CdUFrQnNBa0JzQm1Dc0JrQ2VCb0JlQm9CZUJxQmVCb0JnQndCaUJ3QmdCd0JxQntCcUJ9Qm9Ce0JxQntCa0J3QmtCd0JrQndCa0J3QmtCd0JxQnFCb0JxQm9CcUJfQmlCa0J7QmlCe0JrQntCaUJ7QmlCe0JrQntCaUJ7Ql9AY0B9QXdDe0F5Q3NAX0RhQHtDX0B7Q2FAe0NTd0F5QHtDe0B7Q3lAe0NvQH1BbUB9QXVAbUF1QGtBZUFzQWdBcUFrQn1Ca0J7QmlCfUJrQXdBY0JzQmNCc0JrQn1CbUJfQ21CfUJrQl9DaUJ5QmdCeUJpQnlCdUJjQ3NCY0NpQnlCZ0J3QmlCeUJ5QWdCe0FnQnlBaUJlQn1AX0NvQGlBS2NCQV9CSHNCZkBnQWRAYUBYa0BkQHVAfkBnQHZAZ0F8QmlBfEJnQX5Cc0BwQXVAcEF7QGBBY0F6QHlBfEBjQ3BBdUJ2QXVDZEFzQ2ZBc0NkQWdCcEBlQnJAb0NmQG9DZkBtQ2RAZUVsQGNFbEBjRWxAY0VsQGVFbEBjRWxAY0VqQGNFbEBlRWxAY0VsQGNFbEBjRWxAY0VsQGVFbEBjRWpAY0VsQGNFbEBlRWxAfUN2QH1DeEB9Q3hAX0R2QH1DeEB7RGxAeURsQHtEbkB3RFZ3RFZ3RFZ3RFh1RFZtRGRAbURkQG1EZEBrRGRAbURkQGdFYkBnRWJAZ0ViQGdFYkBnRWJAZ0ViQGdFZEBnRWJAaURoQGtEaEBrRGhAa0RoQGlEaEB3Q1h3Q1ZrQndAYUJPeUNvQXlDb0F3Q29BeUNvQXlDb0FvQFtpQW9AZUBdXVtjQGdAa0B3QG9Aa0F1QHFCUV9CfUB3Q1d1QHFAbUJAd0BCV0ptQFxnQUxdVmlBSlFETUJTQEtBTUFLSF1GR0pHWEdqQlVuQElQRWBAR2JASVZLZkBfQGxAUWZAS3pBUXpBVXZBU2pEa0BqRGtAekNfQHpDYUBuRGlAbERpQG5EaUB4QEtiRGdAVEdyQFlaW1BdUGFARGVAR3FBQG9ATmVAZEB7QGZAbUFiQWNDRk9QX0BwQH1CWHdAZkFjRHRAb0FeZUBqQG9AdEBtQG5DfUFyQllyQllmQ19AZkNhQGhDX0BuQlluQll8QllmQ2NAaENhQHJCXXRCW3pEb0B+RGtAYEVtQGZCVXRBUXJBVU5JQktCTUNLRUlLS1NDaUBDa0JYaUJYZUNcZUNcZUNcU0tRSUlPV21BU19BR3VAQkVARz9HdkFRaEFPakNXUH5AekJbUGxAQVxXWlFKXVJtQE5VQEdLS2VA"],
        footerInfo: {
            location: "IGI Airport",
            distance: "30.2 KM",
            time: "43 mins"
        }
    }, {
        name: "Indira Gandhi International Airport",
        center: [77.08456676061166, 28.55499190134995],
        latitude: 28.55499190134995,
        longitude: 77.08456676061166,
        path: "models/ROF_Landmarks/Indira_Gandhi_International_Airport.glb",
        zoom: 15.628723525869024,
        bound: [
            [77.11006326417822, 28.579015749907015],
            [77.07461917629348, 28.548223967751085]
        ],
        heading: 55.03849180699149,
        category: "Airport",
        routesFromBase: ["aWB0dE1naXFsRE1Lc0B1QHFAaUBTSF9BSnlDT3dDT3VARX1EUXtEUX1EUX1EUXtEUX1EUW9AUGlDS2lDS2dCU2dCU2VART91QkFzQkVpQ0VpQ015Qkt5QlF7Q1F7Q1N9Q1F7Q1NxQllrQ019QGlAZ0RpQGdEZUB3QmNAeUJ1QHVDdUB1Q19BcUN3QHtCeUB7QndAe0JFTWtAe0FpQHlBe0B7Qn1AfUJ7QHtCfUB7QlVrQE1dV2NAc0B3QXNAdUF5QXNDYUJ5Q2FCe0NhQnlDX0F9QV9BX0JpQHtAb0FpQmdCX0NxQXtBb0F7QWNBY0FjQWNBdUF1QXVBdUFjQGVAa0JhQm1CY0JtQmNCZ0FfQWdBX0FzQnlCdUJ3QmFCd0FhQnlBYUJ3QUlJe0FvQXdBa0F3QW1BdUNzQnVDc0JpQ3dCaUN3QmtCYUJrQl9Ca0JfQmFDcUJjQ3FCYUNxQmFDcUJpQ31Ca0NfQ2lDfUJtQmVCZ0N9QmlDfUJvQnNCb0JzQmlAaUB5Qn1CaUFlQWtBZUF7QHdAa0BnQHtCa0J3QW1BbUJrQm1CaUJtQmtCbUF3QW9BdUFfQ31CYUN9Qn1BeUF7QXlBe0F3QWdCeUFnQndBa0N3QmtDd0JjQn1BZUJ7QWNCfUF5QmlCeUJpQnNBY0FxQWFBX0J5QV9CeUFfQnlBfUFvQl9Cb0JfQm9Ca0J7Qm1CeUJrQntCa0J5QmlBfUFnQV9CaUJ3QmlCeUJpQnlCaUJ5Qm1Cb0JtQnFCb0JzQnFCdUJvQnNCYUJvQl9Cb0J1QW1CdUFrQnNBa0JzQm1Dc0JrQ2VCb0JlQm9CZUJxQmVCb0JnQndCaUJ3QmdCd0JxQntCcUJ9Qm9Ce0JxQntCa0J3QmtCd0JrQndCa0J3QmtCd0JxQnFCb0JxQm9CcUJfQmlCa0J7QmlCe0JrQntCaUJ7QmlCe0JrQntCaUJ7Ql9AY0B9QXdDe0F5Q3NAX0RhQHtDX0B7Q2FAe0NTd0F5QHtDe0B7Q3lAe0NvQH1BbUB9QXVAbUF1QGtBZUFzQWdBcUFrQn1Ca0J7QmlCfUJrQXdBY0JzQmNCc0JrQn1CbUJfQ21CfUJrQl9DaUJ5QmdCeUJpQnlCdUJjQ3NCY0NpQnlCZ0J3QmlCeUJ5QWdCe0FnQnlBaUJlQn1AX0NvQGlBS2NCQV9CSHNCZkBnQWRAYUBYa0BkQHVAfkBnQHZAZ0F8QmlBfEJnQX5Cc0BwQXVAcEF7QGBBY0F6QHlBfEBjQ3BBdUJ2QXVDZEFzQ2ZBc0NkQWdCcEBlQnJAb0NmQG9DZkBtQ2RAZUVsQGNFbEBjRWxAY0VsQGVFbEBjRWxAY0VqQGNFbEBlRWxAY0VsQGNFbEBjRWxAY0VsQGVFbEBjRWpAY0VsQGNFbEBlRWxAfUN2QH1DeEB9Q3hAX0R2QH1DeEB7RGxAeURsQHtEbkB3RFZ3RFZ3RFZ3RFh1RFZtRGRAbURkQG1EZEBrRGRAbURkQGdFYkBnRWJAZ0ViQGdFYkBnRWJAZ0ViQGdFZEBnRWJAaURoQGtEaEBrRGhAa0RoQGlEaEB3Q1h3Q1ZrQndAYUJPeUNvQXlDb0F3Q29BeUNvQXlDb0FvQFtpQW9AZUBdXVtjQGdAa0B3QG9Aa0F1QHFCUV9CfUB3Q1d1QHFAbUJAd0BCV0ptQFxnQUxdVmlBSlFETUJTQEtBTUFLSF1GR0pHWEdqQlVuQElQRWBAR2JASVZLZkBfQGxAUWZAS3pBUXpBVXZBU2pEa0BqRGtAekNfQHpDYUBuRGlAbERpQG5EaUB4QEtiRGdAVEdyQFlaW1BdUGFARGVAR3FBQG9ATmVAZEB7QGZAbUFiQWNDRk9QX0BwQH1CWHdAZkFjRHRAb0FeZUBqQG9AdEBtQG5DfUFyQllyQllmQ19AZkNhQGhDX0BuQlluQllcTkZKRkpCVEVIQUQ/SEJGREhGREhCSEBIP0hDSEdERUJJSklIRUpFYEBLXE9MT05PVFFkQFtkQE1oQ19AaENdVkFQQk5CZkJ+QGBBaEBeUl5kQHpAckBCQkBCQmJAQERCRERCREJEQEg/RkFQQ1RFTj9KP0hAbkBaVkZUQlhBakBBaEBFZkNdZkNdZkNdYEBDTkVwQVVYQ3JAS3BJaUFYSVxRZkRrRlxpQA=="],
        footerInfo: {
            location: "IGI Airport",
            distance: "30.2 KM",
            time: "43 mins"
        }
    }, {
        name: "Indira Gandhi International Airport ASB Building Parking",
        center: [77.09130177743583, 28.5542162972301],
        latitude: 28.5542162972301,
        longitude: 77.09130177743583,
        path: "models/ROF_Landmarks/Indira_Gandhi_International_Airport_ASB_Building_Parking.glb",
        zoom: 17.76111044269442,
        bound: [
            [77.09557710636562, 28.557297334309],
            [77.0897987012454, 28.552351149083677]
        ],
        heading: 38.05341045147202,
        category: "Airport",
        routesFromBase: ["aWB0dE1naXFsRE1Lc0B1QHFAaUBTSF9BSnlDT3dDT3VARX1EUXtEUX1EUX1EUXtEUX1EUW9AUGlDS2lDS2dCU2dCU2VART91QkFzQkVpQ0VpQ015Qkt5QlF7Q1F7Q1N9Q1F7Q1NxQllrQ019QGlAZ0RpQGdEZUB3QmNAeUJ1QHVDdUB1Q19BcUN3QHtCeUB7QndAe0JFTWtAe0FpQHlBe0B7Qn1AfUJ7QHtCfUB7QlVrQE1dV2NAc0B3QXNAdUF5QXNDYUJ5Q2FCe0NhQnlDX0F9QV9BX0JpQHtAb0FpQmdCX0NxQXtBb0F7QWNBY0FjQWNBdUF1QXVBdUFjQGVAa0JhQm1CY0JtQmNCZ0FfQWdBX0FzQnlCdUJ3QmFCd0FhQnlBYUJ3QUlJe0FvQXdBa0F3QW1BdUNzQnVDc0JpQ3dCaUN3QmtCYUJrQl9Ca0JfQmFDcUJjQ3FCYUNxQmFDcUJpQ31Ca0NfQ2lDfUJtQmVCZ0N9QmlDfUJvQnNCb0JzQmlAaUB5Qn1CaUFlQWtBZUF7QHdAa0BnQHtCa0J3QW1BbUJrQm1CaUJtQmtCbUF3QW9BdUFfQ31CYUN9Qn1BeUF7QXlBe0F3QWdCeUFnQndBa0N3QmtDd0JjQn1BZUJ7QWNCfUF5QmlCeUJpQnNBY0FxQWFBX0J5QV9CeUFfQnlBfUFvQl9Cb0JfQm9Ca0J7Qm1CeUJrQntCa0J5QmlBfUFnQV9CaUJ3QmlCeUJpQnlCaUJ5Qm1Cb0JtQnFCb0JzQnFCdUJvQnNCYUJvQl9Cb0J1QW1CdUFrQnNBa0JzQm1Dc0JrQ2VCb0JlQm9CZUJxQmVCb0JnQndCaUJ3QmdCd0JxQntCcUJ9Qm9Ce0JxQntCa0J3QmtCd0JrQndCa0J3QmtCd0JxQnFCb0JxQm9CcUJfQmlCa0J7QmlCe0JrQntCaUJ7QmlCe0JrQntCaUJ7Ql9AY0B9QXdDe0F5Q3NAX0RhQHtDX0B7Q2FAe0NTd0F5QHtDe0B7Q3lAe0NvQH1BbUB9QXVAbUF1QGtBZUFzQWdBcUFrQn1Ca0J7QmlCfUJrQXdBY0JzQmNCc0JrQn1CbUJfQ21CfUJrQl9DaUJ5QmdCeUJpQnlCdUJjQ3NCY0NpQnlCZ0J3QmlCeUJ5QWdCe0FnQnlBaUJlQn1AX0NvQGlBS2NCQV9CSHNCZkBnQWRAYUBYa0BkQHVAfkBnQHZAZ0F8QmlBfEJnQX5Cc0BwQXVAcEF7QGBBY0F6QHlBfEBjQ3BBdUJ2QXVDZEFzQ2ZBc0NkQWdCcEBlQnJAb0NmQG9DZkBtQ2RAZUVsQGNFbEBjRWxAY0VsQGVFbEBjRWxAY0VqQGNFbEBlRWxAY0VsQGNFbEBjRWxAY0VsQGVFbEBjRWpAY0VsQGNFbEBlRWxAfUN2QH1DeEB9Q3hAX0R2QH1DeEB7RGxAeURsQHtEbkB3RFZ3RFZ3RFZ3RFh1RFZtRGRAbURkQG1EZEBrRGRAbURkQGdFYkBnRWJAZ0ViQGdFYkBnRWJAZ0ViQGdFZEBnRWJAaURoQGtEaEBrRGhAa0RoQGlEaEB3Q1h3Q1ZrQndAYUJPeUNvQXlDb0F3Q29BeUNvQXlDb0FvQFtpQW9AZUBdXVtjQGdAa0B3QG9Aa0F1QHFCUV9CfUB3Q1d1QHFAbUJAd0BCV0ptQFxnQUxdVmlBSlFETUJTQEtBTUFLSF1GR0pHWEdqQlVuQElQRWBAR2JASVZLZkBfQGxAUWZAS3pBUXpBVXZBU2pEa0BqRGtAekNfQHpDYUBuRGlAbERpQG5EaUB4QEtiRGdAVEdyQFlaW1BdUGFARGVAR3FBQG9ATmVAZEB7QGZAbUFiQWNDRk9QX0BwQH1CWHdAZkFjRHRAb0FeZUBqQG9AdEBtQG5DfUFyQllyQllmQ19AZkNhQGhDX0BuQlluQll8QllmQ2NAaENhQHJCXXRCW3xAVmREfkFkRGBCekBmQGJCQG5BVWhBW2pASWhAQ3BBQnRCXXRCW0hTP01TX0FpQGlDZUJWZ0JYdUFadUBScUBM"],
        footerInfo: {
            location: "IGI Airport",
            distance: "30.2 KM",
            time: "43 mins"
        }
    }, {
        name: "Blu Smart Charging Station",
        center: [77.08697067257833, 28.555784441511065],
        latitude: 28.555784441511065,
        longitude: 77.08697067257833,
        path: "models/ROF_Landmarks/Blu_Smart_Charging_Station.glb",
        zoom: 16.418970858853267,
        bound: [
            [77.09080236565859, 28.559189067210696],
            [77.06870181771114, 28.540189947521654]
        ],
        heading: -123.33874242235237,
        category: "Airport",
        routesFromBase: ["aWB0dE1naXFsRE1Lc0B1QHFAaUBTSF9BSnlDT3dDT3VARX1EUXtEUX1EUX1EUXtEUX1EUW9AUGlDS2lDS2dCU2dCU2VART91QkFzQkVpQ0VpQ015Qkt5QlF7Q1F7Q1N9Q1F7Q1NxQllrQ019QGlAZ0RpQGdEZUB3QmNAeUJ1QHVDdUB1Q19BcUN3QHtCeUB7QndAe0JFTWtAe0FpQHlBe0B7Qn1AfUJ7QHtCfUB7QlVrQE1dV2NAc0B3QXNAdUF5QXNDYUJ5Q2FCe0NhQnlDX0F9QV9BX0JpQHtAb0FpQmdCX0NxQXtBb0F7QWNBY0FjQWNBdUF1QXVBdUFjQGVAa0JhQm1CY0JtQmNCZ0FfQWdBX0FzQnlCdUJ3QmFCd0FhQnlBYUJ3QUlJe0FvQXdBa0F3QW1BdUNzQnVDc0JpQ3dCaUN3QmtCYUJrQl9Ca0JfQmFDcUJjQ3FCYUNxQmFDcUJpQ31Ca0NfQ2lDfUJtQmVCZ0N9QmlDfUJvQnNCb0JzQmlAaUB5Qn1CaUFlQWtBZUF7QHdAa0BnQHtCa0J3QW1BbUJrQm1CaUJtQmtCbUF3QW9BdUFfQ31CYUN9Qn1BeUF7QXlBe0F3QWdCeUFnQndBa0N3QmtDd0JjQn1BZUJ7QWNCfUF5QmlCeUJpQnNBY0FxQWFBX0J5QV9CeUFfQnlBfUFvQl9Cb0JfQm9Ca0J7Qm1CeUJrQntCa0J5QmlBfUFnQV9CaUJ3QmlCeUJpQnlCaUJ5Qm1Cb0JtQnFCb0JzQnFCdUJvQnNCYUJvQl9Cb0J1QW1CdUFrQnNBa0JzQm1Dc0JrQ2VCb0JlQm9CZUJxQmVCb0JnQndCaUJ3QmdCd0JxQntCcUJ9Qm9Ce0JxQntCa0J3QmtCd0JrQndCa0J3QmtCd0JxQnFCb0JxQm9CcUJfQmlCa0J7QmlCe0JrQntCaUJ7QmlCe0JrQntCaUJ7Ql9AY0B9QXdDe0F5Q3NAX0RhQHtDX0B7Q2FAe0NTd0F5QHtDe0B7Q3lAe0NvQH1BbUB9QXVAbUF1QGtBZUFzQWdBcUFrQn1Ca0J7QmlCfUJrQXdBY0JzQmNCc0JrQn1CbUJfQ21CfUJrQl9DaUJ5QmdCeUJpQnlCdUJjQ3NCY0NpQnlCZ0J3QmlCeUJ5QWdCe0FnQnlBaUJlQn1AX0NvQGlBS2NCQV9CSHNCZkBnQWRAYUBYa0BkQHVAfkBnQHZAZ0F8QmlBfEJnQX5Cc0BwQXVAcEF7QGBBY0F6QHlBfEBjQ3BBdUJ2QXVDZEFzQ2ZBc0NkQWdCcEBlQnJAb0NmQG9DZkBtQ2RAZUVsQGNFbEBjRWxAY0VsQGVFbEBjRWxAY0VqQGNFbEBlRWxAY0VsQGNFbEBjRWxAY0VsQGVFbEBjRWpAY0VsQGNFbEBlRWxAfUN2QH1DeEB9Q3hAX0R2QH1DeEB7RGxAeURsQHtEbkB3RFZ3RFZ3RFZ3RFh1RFZtRGRAbURkQG1EZEBrRGRAbURkQGdFYkBnRWJAZ0ViQGdFYkBnRWJAZ0ViQGdFZEBnRWJAaURoQGtEaEBrRGhAa0RoQGlEaEB3Q1h3Q1ZrQndAYUJPeUNvQXlDb0F3Q29BeUNvQXlDb0FvQFtpQW9AZUBdXVtjQGdAa0B3QG9Aa0F1QHFCUV9CfUB3Q1d1QHFAbUJAd0BCV0ptQFxnQUxdVmlBSlFETUJTQEtBTUFLSF1GR0pHWEdqQlVuQElQRWBAR2JASVZLZkBfQGxAUWZAS3pBUXpBVXZBU2pEa0BqRGtAekNfQHpDYUBuRGlAbERpQG5EaUB4QEtiRGdAVEdyQFlaW1BdUGFARGVAR3FBQG9ATmVAZEB7QGZAbUFiQWNDRk9QX0BwQH1CWHdAZkFjRHRAb0FeZUBqQG9AdEBtQG5DfUFyQllyQllmQ19AZkNhQGhDX0BuQlluQll8QllmQ2NAaENhQHJCXXRCW3xAVmREfkFkRGBCekBmQHhBaEB0QENiQEViRGdAYkRnQGJEZ0BkQGVAfkJdbkBJfEFVckBLTEVGSUBNWWNCdEBPYEJvQ0VRfUBjQA=="],
        footerInfo: {
            location: "IGI Airport",
            distance: "30.2 KM",
            time: "43 mins"
        }
    }, {
        name: "Delhi Airport International Check Post",
        center: [77.10151579319921, 28.556846959407324],
        latitude: 28.556846959407324,
        longitude: 77.10151579319921,
        path: "models/ROF_Landmarks/Delhi_Airport_International_Check_Post.glb",
        zoom: 14.79218904329881,
        bound: [
            [77.1281395585512, 28.57249164064143],
            [77.05731432590898, 28.51912289441212]
        ],
        heading: -166.3503071457352,
        category: "Airport",
        routesFromBase: ["aWB0dE1naXFsRE1Lc0B1QHFAaUBTSF9BSnlDT3dDT3VARX1EUXtEUX1EUX1EUXtEUX1EUW9AUGlDS2lDS2dCU2dCU2VART91QkFzQkVpQ0VpQ015Qkt5QlF7Q1F7Q1N9Q1F7Q1NxQllrQ019QGlAZ0RpQGdEZUB3QmNAeUJ1QHVDdUB1Q19BcUN3QHtCeUB7QndAe0JFTWtAe0FpQHlBe0B7Qn1AfUJ7QHtCfUB7QlVrQE1dV2NAc0B3QXNAdUF5QXNDYUJ5Q2FCe0NhQnlDX0F9QV9BX0JpQHtAb0FpQmdCX0NxQXtBb0F7QWNBY0FjQWNBdUF1QXVBdUFjQGVAa0JhQm1CY0JtQmNCZ0FfQWdBX0FzQnlCdUJ3QmFCd0FhQnlBYUJ3QUlJe0FvQXdBa0F3QW1BdUNzQnVDc0JpQ3dCaUN3QmtCYUJrQl9Ca0JfQmFDcUJjQ3FCYUNxQmFDcUJpQ31Ca0NfQ2lDfUJtQmVCZ0N9QmlDfUJvQnNCb0JzQmlAaUB5Qn1CaUFlQWtBZUF7QHdAa0BnQHtCa0J3QW1BbUJrQm1CaUJtQmtCbUF3QW9BdUFfQ31CYUN9Qn1BeUF7QXlBe0F3QWdCeUFnQndBa0N3QmtDd0JjQn1BZUJ7QWNCfUF5QmlCeUJpQnNBY0FxQWFBX0J5QV9CeUFfQnlBfUFvQl9Cb0JfQm9Ca0J7Qm1CeUJrQntCa0J5QmlBfUFnQV9CaUJ3QmlCeUJpQnlCaUJ5Qm1Cb0JtQnFCb0JzQnFCdUJvQnNCYUJvQl9Cb0J1QW1CdUFrQnNBa0JzQm1Dc0JrQ2VCb0JlQm9CZUJxQmVCb0JnQndCaUJ3QmdCd0JxQntCcUJ9Qm9Ce0JxQntCa0J3QmtCd0JrQndCa0J3QmtCd0JxQnFCb0JxQm9CcUJfQmlCa0J7QmlCe0JrQntCaUJ7QmlCe0JrQntCaUJ7Ql9AY0B9QXdDe0F5Q3NAX0RhQHtDX0B7Q2FAe0NTd0F5QHtDe0B7Q3lAe0NvQH1BbUB9QXVAbUF1QGtBZUFzQWdBcUFrQn1Ca0J7QmlCfUJrQXdBY0JzQmNCc0JrQn1CbUJfQ21CfUJrQl9DaUJ5QmdCeUJpQnlCdUJjQ3NCY0NpQnlCZ0J3QmlCeUJ5QWdCe0FnQnlBaUJlQn1AX0NvQGlBS2NCQV9CSHNCZkBnQWRAYUBYa0BkQHVAfkBnQHZAZ0F8QmlBfEJnQX5Cc0BwQXVAcEF7QGBBY0F6QHlBfEBjQ3BBdUJ2QXVDZEFzQ2ZBc0NkQWdCcEBlQnJAb0NmQG9DZkBtQ2RAZUVsQGNFbEBjRWxAY0VsQGVFbEBjRWxAY0VqQGNFbEBlRWxAY0VsQGNFbEBjRWxAY0VsQGVFbEBjRWpAY0VsQGNFbEBlRWxAfUN2QH1DeEB9Q3hAX0R2QH1DeEB7RGxAeURsQHtEbkB3RFZ3RFZ3RFZ3RFh1RFZtRGRAbURkQG1EZEBrRGRAbURkQGdFYkBnRWJAZ0ViQGdFYkBnRWJAZ0ViQGdFZEBnRWJAaURoQGtEaEBrRGhAa0RoQGlEaEB3Q1h3Q1ZrQndAYUJPeUNvQXlDb0F3Q29BeUNvQXlDb0FvQFtpQW9AZUBdXVtjQGdAa0B3QG9Aa0F1QHFCUV9CfUB3Q1d1QHFAbUJAd0BCV0ptQFxnQUxdVmlBSlFETUJTQEtBTUFLSF1GR0pHWEdqQlVuQElQRWBAR2JASVZLZkBfQGxAUWZAS3pBUXpBVXZBU2pEa0BqRGtAekNfQHpDYUBuRGlAbERpQG5EaUB4QEtiRGdAVEdyQFlaW1BdUGFARGVAR3FBQG9ATmVAZEB7QGZAbUFiQWNDRk9QX0BwQH1CWHdAZkFjRHRAb0FeZUBqQG9AdEBtQG5DfUFyQllyQllQV0RPP1FHUU9LY0BPdUFSa0NacURmQHVBUnlASE9jQF9AX0JVYUFDW0FVZkRnQGZEZUB4QU9uQU9kQEdeQ3BBU3xBVWpCU3hDY0B2Q2NAdkNjQHBAS0NNcUBKd0NeeUNgQHdDYEBfQlRZY0BbZ0FpQG9CU2FB"],
        footerInfo: {
            location: "IGI Airport",
            distance: "30.2 KM",
            time: "43 mins"
        }
    }],
    qp = [{
        name: "Ramada By Wyndham",
        center: [77.0712100103508, 28.449836137376423],
        latitude: 28.449836137376423,
        longitude: 77.0712100103508,
        path: "models/ROF_Projects/Ramada_by_Wyndham.glb",
        zoom: 19.094760994904796,
        bound: [
            [77.07354278192867, 28.45184880554055],
            [77.07041496386933, 28.448717902906296]
        ],
        heading: 74.60929172587726,
        sector: "Sector 44",
        thumbnail: "projects/1.png",
        deliveredYear: 2011,
        isProject: !0
    }, {
        name: "ROF Aalayas",
        center: [76.96553915668346, 28.474684637133535],
        latitude: 28.474684637133535,
        longitude: 76.96553915668346,
        path: "models/ROF_Projects/ROF_Aalayas.glb",
        zoom: 17.461447293139113,
        bound: [
            [76.97348229273268, 28.481983900494157],
            [76.96273833114208, 28.47273228315359]
        ],
        heading: 56.145638818071355,
        sector: "Sector 102",
        thumbnail: "projects/2.png",
        deliveredYear: 2015,
        isProject: !0
    }, {
        name: "Galleria 102",
        center: [76.96553915668346, 28.474684637133535],
        latitude: 28.474684637133535,
        longitude: 76.96553915668346,
        path: "models/ROF_Projects/ROF_Aalayas.glb",
        zoom: 17.781829865122887,
        bound: [
            [76.96996476079448, 28.476663958629786],
            [76.96334301319973, 28.470162437857226]
        ],
        heading: 108.79999999999994,
        sector: "Sector 102",
        thumbnail: "projects/3.png",
        deliveredYear: 2016,
        isProject: !0,
        popup: {
            center: [76.96518170211084, 28.474661892252342],
            height: 0
        }
    }, {
        name: "ROF Ananda",
        center: [76.90556870738664, 28.414215715414983],
        latitude: 28.414215715414983,
        longitude: 76.90556870738664,
        path: "models/ROF_Projects/ROF_Ananda.glb",
        zoom: 17.722684449515608,
        bound: [
            [76.90780918445972, 28.419961497865003],
            [76.89873781373143, 28.412663307539603]
        ],
        heading: -18.40000000000032,
        sector: "Sector 95",
        thumbnail: "projects/4.png",
        deliveredYear: 2017,
        isProject: !0
    }, {
        name: "Galleria 95",
        center: [76.90643750613015, 28.414456808831872],
        latitude: 28.414456808831872,
        longitude: 76.90643750613015,
        path: "models/ROF_Projects/ROF_Ananda.glb",
        zoom: 17.630417677054734,
        bound: [
            [76.90789817100506, 28.416843512867473],
            [76.89901504055632, 28.408365763424655]
        ],
        heading: -108.95608740804862,
        sector: "Sector 95",
        thumbnail: "projects/5.png",
        deliveredYear: 2018,
        isProject: !0,
        popup: {
            center: [76.90643750613015, 28.414456808831872],
            height: 0
        }
    }, {
        name: "ROF Portico",
        center: [77.0822424701438, 28.453094065885125],
        latitude: 28.453094065885125,
        longitude: 77.0822424701438,
        path: "models/ROF_Projects/ROF_Portico.glb",
        zoom: 19.79508017566551,
        bound: [
            [77.08274940706605, 28.45450525384092],
            [77.08064196457104, 28.452702909963847]
        ],
        heading: -59.823839114757334,
        sector: "Sector 43",
        thumbnail: "projects/6.png",
        deliveredYear: 2018,
        isProject: !0
    }, {
        name: "ROF Amaltas",
        center: [76.92105942305699, 28.407644488462395],
        latitude: 28.407644488462395,
        longitude: 76.92105942305699,
        path: "models/ROF_Projects/ROF_Amaltas.glb",
        zoom: 17.77251868858189,
        altitude: -6,
        bound: [
            [76.92502445796373, 28.412531304600492],
            [76.91578892744093, 28.406813738245802]
        ],
        heading: 0,
        sector: "Sector 92",
        thumbnail: "projects/7.png",
        deliveredYear: 2019,
        isProject: !0
    }, {
        name: "Galleria 92",
        center: [76.92101280661768, 28.406904639877922],
        latitude: 28.406904639877922,
        longitude: 76.92101280661768,
        path: "models/ROF_Projects/ROF_Amaltas.glb",
        zoom: 17.224886067804544,
        bound: [
            [76.9262707721814, 28.41447218886303],
            [76.91334370134382, 28.405197735954843]
        ],
        heading: -10.400000000000205,
        altitude: -6,
        sector: "Sector 92",
        thumbnail: "projects/8.png",
        deliveredYear: 2019,
        isProject: !0,
        popup: {
            center: [76.92101280661768, 28.406904639877922],
            height: 0
        }
    }, {
        name: "ROF Aalayas II",
        center: [76.96553915668346, 28.474684637133535],
        latitude: 28.474684637133535,
        longitude: 76.96553915668346,
        path: "models/ROF_Projects/ROF_Aalayas_II.glb",
        zoom: 17.461447293139113,
        bound: [
            [76.97348229273268, 28.481983900494157],
            [76.96273833114208, 28.47273228315359]
        ],
        heading: 56.145638818071355,
        sector: "Sector 102",
        thumbnail: "projects/9.png",
        deliveredYear: 2019,
        isProject: !0
    }, {
        name: "ROF Alante",
        center: [76.97961, 28.51948],
        latitude: 28.51948,
        longitude: 76.97961,
        path: "models/ROF_Projects/ROF_Alante.glb",
        zoom: 17.781829865122887,
        bound: [
            [76.981537718379, 28.525365678927912],
            [76.97286822058425, 28.517847370586665]
        ],
        heading: -52.140483462840685,
        sector: "Sector 108",
        thumbnail: "projects/10.png",
        deliveredYear: 2020,
        isProject: !0
    }, {
        name: "ROF Atulyas",
        center: [76.93553982526953, 28.419389560564127],
        latitude: 28.419389560564127,
        longitude: 76.93553982526953,
        path: "models/ROF_Projects/ROF_Atulyas.glb",
        zoom: 16.71375441600558,
        bound: [
            [76.93780939440285, 28.42790724882792],
            [76.92397180412905, 28.410991961403624]
        ],
        heading: -91.41110250466498,
        sector: "Sector 93",
        thumbnail: "projects/11.png",
        deliveredYear: 2021,
        isProject: !0
    }, {
        name: "Galleria 93",
        center: [76.93581439021796, 28.419929850200774],
        latitude: 28.419929850200774,
        longitude: 76.93581439021796,
        path: "models/ROF_Projects/ROF_Atulyas.glb",
        zoom: 17.79922477667499,
        bound: [
            [76.93914476248563, 28.421109046078698],
            [76.93025128380418, 28.41462178899006]
        ],
        heading: -168.79999999999984,
        sector: "Sector 93",
        thumbnail: "projects/12.png",
        deliveredYear: 2021,
        isProject: !0,
        popup: {
            center: [76.93581439021796, 28.419929850200774],
            height: -1
        }
    }, {
        name: "ROF Insignia Souk",
        center: [76.93973680927519, 28.414171003350802],
        latitude: 28.414171003350802,
        longitude: 76.93973680927519,
        path: "models/ROF_Projects/ROF_Insignia_Souk.glb",
        zoom: 17.47900548898658,
        bound: [
            [76.94221824493161, 28.419857974916837],
            [76.93321790270954, 28.410027330488603]
        ],
        heading: -80.91378735283905,
        sector: "Sector 93",
        thumbnail: "projects/13.png",
        deliveredYear: 2021,
        isProject: !0
    }, {
        name: "ROF Insignia Park",
        center: [76.93973680927519, 28.414171003350802],
        latitude: 28.414171003350802,
        longitude: 76.93973680927519,
        path: "models/ROF_Projects/ROF_Insignia_Park.glb",
        zoom: 17.47900548898658,
        bound: [
            [76.94221824493161, 28.419857974916837],
            [76.93321790270954, 28.410027330488603]
        ],
        heading: -80.91378735283905,
        sector: "Sector 93",
        thumbnail: "projects/14.png",
        deliveredYear: 2021,
        isProject: !0
    }, {
        name: "ROF Normanton Park",
        center: [77.06391017567722, 28.2952858427184],
        latitude: 28.2952858427184,
        longitude: 77.06391017567722,
        path: "models/ROF_Projects/ROF_Normanton_Park.glb",
        zoom: 17.02476892478214,
        bound: [
            [77.06736657287269, 28.301305811914787],
            [77.05630359070665, 28.292307138949568]
        ],
        heading: -22.11840000000086,
        sector: "Sector 36",
        thumbnail: "projects/15.png",
        deliveredYear: 2022,
        isProject: !0
    }, {
        name: "ROF Insignia Park II",
        center: [76.91284, 28.41799],
        latitude: 28.41799,
        longitude: 76.91284,
        path: "models/ROF_Projects/ROF_Insignia_Park_II.glb",
        zoom: 17.647975872902215,
        bound: [
            [76.91927070723233, 28.422893797470195],
            [76.91058999377447, 28.415327121940493]
        ],
        heading: 54.032190310788565,
        sector: "Sector 95",
        thumbnail: "projects/16.png",
        deliveredYear: 2022,
        isProject: !0
    }, {
        name: "ROF Ambliss",
        center: [76.97934, 28.37614],
        latitude: 28.37614,
        longitude: 76.97934,
        path: "models/ROF_Projects/ROF_Ambliss.glb",
        zoom: 17.497922541221428,
        bound: [
            [76.98741237125961, 28.38315505945566],
            [76.9769316616941, 28.373849638630332]
        ],
        heading: 40.02635871234134,
        sector: "Sector 78",
        thumbnail: "projects/17.png",
        deliveredYear: 2022,
        isProject: !0
    }, {
        name: "ROF iCity",
        center: [77.06592524880062, 29.04457256829201],
        latitude: 29.04457256829201,
        longitude: 77.06592524880062,
        path: "models/ROF_Projects/ROF_I_City.glb",
        zoom: 16.000000000000004,
        bound: [
            [77.07167590492895, 29.04805703167125],
            [77.05833996170708, 29.04158512173818]
        ],
        heading: 0,
        sector: "Murthal",
        thumbnail: "projects/18.png",
        deliveredYear: 2022,
        isProject: !0
    }, {
        name: "Galleria 108",
        center: [76.98001970649646, 28.518897134805652],
        latitude: 28.518897134805652,
        longitude: 76.98001970649646,
        path: "models/ROF_Projects/ROF_Alante.glb",
        zoom: 18.08663177482705,
        bound: [
            [76.93780939440285, 28.42790724882792],
            [76.92397180412905, 28.410991961403624]
        ],
        heading: -49.688211106729455,
        sector: "Sector 108",
        thumbnail: "projects/19.png",
        deliveredYear: 2022,
        isProject: !0,
        popup: {
            center: [76.98001970649646, 28.518897134805652],
            height: -1
        }
    }, {
        name: "Galleria 78",
        center: [76.97885876236154, 28.37524269122123],
        latitude: 28.37524269122123,
        longitude: 76.97885876236154,
        path: "models/ROF_Projects/ROF_Ambliss.glb",
        zoom: 17.93324205319104,
        bound: [
            [76.98164792870926, 28.377465113031505],
            [76.97610345777036, 28.37451152815359]
        ],
        heading: 0,
        sector: "Sector 78",
        thumbnail: "projects/20.png",
        deliveredYear: 2022,
        isProject: !0,
        popup: {
            center: [76.97885876236154, 28.37524269122123],
            height: 0
        }
    }, {
        name: "ROF Insignia Mart",
        center: [76.93973680927519, 28.414171003350802],
        latitude: 28.414171003350802,
        longitude: 76.93973680927519,
        path: "models/ROF_Projects/ROF_Insignia_Mart.glb",
        zoom: 17.47900548898658,
        bound: [
            [76.94221824493161, 28.419857974916837],
            [76.93321790270954, 28.410027330488603]
        ],
        heading: -80.91378735283905,
        sector: "Sector 93",
        thumbnail: "projects/21.png",
        deliveredYear: 2023,
        isProject: !0
    }, {
        name: "ROF JBP Green",
        center: [77.06313766909403, 28.286823071684267],
        latitude: 28.286823071684267,
        longitude: 77.06313766909403,
        path: "models/ROF_Projects/ROF_JBP_Green.glb",
        zoom: 16.739502744493308,
        bound: [
            [77.07152927643341, 28.294884729856946],
            [77.05690197284952, 28.28387737789764]
        ],
        heading: 16.362898611268065,
        sector: "Sector 35,36",
        thumbnail: "projects/22.png",
        deliveredYear: 2023,
        isProject: !0
    }, {
        name: "ROF Normanton Mall",
        center: [77.06391017567722, 28.2952858427184],
        latitude: 28.2952858427184,
        longitude: 77.06391017567722,
        path: "models/ROF_Projects/ROF_Normanton_Mall.glb",
        zoom: 17.02476892478214,
        bound: [
            [77.06736657287269, 28.301305811914787],
            [77.05630359070665, 28.292307138949568]
        ],
        heading: -22.11840000000086,
        sector: "Sector 36",
        thumbnail: "projects/21.png",
        deliveredYear: 2023,
        isProject: !0
    }, {
        name: "ROF Insignia Park",
        center: [76.949519, 28.437122],
        latitude: 28.437122,
        longitude: 76.949519,
        path: "models/ROF_Projects/ROF_Insignia_Park_Sector_88.glb",
        zoom: 17.5,
        bound: [
            [76.94714741991294, 28.43651924638624],
            [76.95203568952257, 28.438656607630463]
        ],
        heading: -176.0000000000001,
        sector: "Sector 88A",
        thumbnail: "projects/ROF Insignia Park.jpg",
        deliveredYear: 2023,
        isProject: !0
    }];
var Nf = {
    exports: {}
};
(function(ue) {
    var R = {};

    function y(Y) {
        return Math.floor(Math.abs(Y) + .5) * (Y >= 0 ? 1 : -1)
    }

    function z(Y, C, p) {
        Y = y(Y * p), C = y(C * p);
        var se = (Y - C) * 2;
        se < 0 && (se = -se - 1);
        for (var ie = ""; se >= 32;) ie += String.fromCharCode((32 | se & 31) + 63), se /= 32;
        return ie += String.fromCharCode((se | 0) + 63), ie
    }
    R.decode = function(Y, C) {
        for (var p = 0, se = 0, ie = 0, He = [], be = 0, Ee = 0, Lt = null, Tt, Je, wt = Math.pow(10, Number.isInteger(C) ? C : 5); p < Y.length;) {
            Lt = null, be = 1, Ee = 0;
            do Lt = Y.charCodeAt(p++) - 63, Ee += (Lt & 31) * be, be *= 32; while (Lt >= 32);
            Tt = Ee & 1 ? (-Ee - 1) / 2 : Ee / 2, be = 1, Ee = 0;
            do Lt = Y.charCodeAt(p++) - 63, Ee += (Lt & 31) * be, be *= 32; while (Lt >= 32);
            Je = Ee & 1 ? (-Ee - 1) / 2 : Ee / 2, se += Tt, ie += Je, He.push([se / wt, ie / wt])
        }
        return He
    }, R.encode = function(Y, C) {
        if (!Y.length) return "";
        for (var p = Math.pow(10, Number.isInteger(C) ? C : 5), se = z(Y[0][0], 0, p) + z(Y[0][1], 0, p), ie = 1; ie < Y.length; ie++) {
            var He = Y[ie],
                be = Y[ie - 1];
            se += z(He[0], be[0], p), se += z(He[1], be[1], p)
        }
        return se
    };

    function V(Y) {
        for (var C = [], p = 0; p < Y.length; p++) {
            var se = Y[p].slice();
            C.push([se[1], se[0]])
        }
        return C
    }
    R.fromGeoJSON = function(Y, C) {
        if (Y && Y.type === "Feature" && (Y = Y.geometry), !Y || Y.type !== "LineString") throw new Error("Input must be a GeoJSON LineString");
        return R.encode(V(Y.coordinates), C)
    }, R.toGeoJSON = function(Y, C) {
        var p = R.decode(Y, C);
        return {
            type: "LineString",
            coordinates: V(p)
        }
    }, ue.exports && (ue.exports = R)
})(Nf);
var wm = Nf.exports;
const Of = tm(wm);

function Em(ue) {
    if (ue && typeof window != "undefined") {
        var R = document.createElement("style");
        return R.setAttribute("type", "text/css"), R.innerHTML = ue, document.head.appendChild(R), ue
    }
}

function Lu(ue, R) {
    var y = ue.__state.conversionName.toString(),
        z = Math.round(ue.r),
        V = Math.round(ue.g),
        Y = Math.round(ue.b),
        C = ue.a,
        p = Math.round(ue.h),
        se = ue.s.toFixed(1),
        ie = ue.v.toFixed(1);
    if (R || y === "THREE_CHAR_HEX" || y === "SIX_CHAR_HEX") {
        for (var He = ue.hex.toString(16); He.length < 6;) He = "0" + He;
        return "#" + He
    } else {
        if (y === "CSS_RGB") return "rgb(" + z + "," + V + "," + Y + ")";
        if (y === "CSS_RGBA") return "rgba(" + z + "," + V + "," + Y + "," + C + ")";
        if (y === "HEX") return "0x" + ue.hex.toString(16);
        if (y === "RGB_ARRAY") return "[" + z + "," + V + "," + Y + "]";
        if (y === "RGBA_ARRAY") return "[" + z + "," + V + "," + Y + "," + C + "]";
        if (y === "RGB_OBJ") return "{r:" + z + ",g:" + V + ",b:" + Y + "}";
        if (y === "RGBA_OBJ") return "{r:" + z + ",g:" + V + ",b:" + Y + ",a:" + C + "}";
        if (y === "HSV_OBJ") return "{h:" + p + ",s:" + se + ",v:" + ie + "}";
        if (y === "HSVA_OBJ") return "{h:" + p + ",s:" + se + ",v:" + ie + ",a:" + C + "}"
    }
    return "unknown format"
}
var $p = Array.prototype.forEach,
    Qd = Array.prototype.slice,
    mi = {
        BREAK: {},
        extend: function(R) {
            return this.each(Qd.call(arguments, 1), function(y) {
                var z = this.isObject(y) ? Object.keys(y) : [];
                z.forEach(function(V) {
                    this.isUndefined(y[V]) || (R[V] = y[V])
                }.bind(this))
            }, this), R
        },
        defaults: function(R) {
            return this.each(Qd.call(arguments, 1), function(y) {
                var z = this.isObject(y) ? Object.keys(y) : [];
                z.forEach(function(V) {
                    this.isUndefined(R[V]) && (R[V] = y[V])
                }.bind(this))
            }, this), R
        },
        compose: function() {
            var R = Qd.call(arguments);
            return function() {
                for (var y = Qd.call(arguments), z = R.length - 1; z >= 0; z--) y = [R[z].apply(this, y)];
                return y[0]
            }
        },
        each: function(R, y, z) {
            if (R) {
                if ($p && R.forEach && R.forEach === $p) R.forEach(y, z);
                else if (R.length === R.length + 0) {
                    var V = void 0,
                        Y = void 0;
                    for (V = 0, Y = R.length; V < Y; V++)
                        if (V in R && y.call(z, R[V], V) === this.BREAK) return
                } else
                    for (var C in R)
                        if (y.call(z, R[C], C) === this.BREAK) return
            }
        },
        defer: function(R) {
            setTimeout(R, 0)
        },
        debounce: function(R, y, z) {
            var V = void 0;
            return function() {
                var Y = this,
                    C = arguments;

                function p() {
                    V = null, z || R.apply(Y, C)
                }
                var se = z || !V;
                clearTimeout(V), V = setTimeout(p, y), se && R.apply(Y, C)
            }
        },
        toArray: function(R) {
            return R.toArray ? R.toArray() : Qd.call(R)
        },
        isUndefined: function(R) {
            return R === void 0
        },
        isNull: function(R) {
            return R === null
        },
        isNaN: function(ue) {
            function R(y) {
                return ue.apply(this, arguments)
            }
            return R.toString = function() {
                return ue.toString()
            }, R
        }(function(ue) {
            return isNaN(ue)
        }),
        isArray: Array.isArray || function(ue) {
            return ue.constructor === Array
        },
        isObject: function(R) {
            return R === Object(R)
        },
        isNumber: function(R) {
            return R === R + 0
        },
        isString: function(R) {
            return R === R + ""
        },
        isBoolean: function(R) {
            return R === !1 || R === !0
        },
        isFunction: function(R) {
            return R instanceof Function
        }
    },
    Sm = [{
        litmus: mi.isString,
        conversions: {
            THREE_CHAR_HEX: {
                read: function(R) {
                    var y = R.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
                    return y === null ? !1 : {
                        space: "HEX",
                        hex: parseInt("0x" + y[1].toString() + y[1].toString() + y[2].toString() + y[2].toString() + y[3].toString() + y[3].toString(), 0)
                    }
                },
                write: Lu
            },
            SIX_CHAR_HEX: {
                read: function(R) {
                    var y = R.match(/^#([A-F0-9]{6})$/i);
                    return y === null ? !1 : {
                        space: "HEX",
                        hex: parseInt("0x" + y[1].toString(), 0)
                    }
                },
                write: Lu
            },
            CSS_RGB: {
                read: function(R) {
                    var y = R.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
                    return y === null ? !1 : {
                        space: "RGB",
                        r: parseFloat(y[1]),
                        g: parseFloat(y[2]),
                        b: parseFloat(y[3])
                    }
                },
                write: Lu
            },
            CSS_RGBA: {
                read: function(R) {
                    var y = R.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
                    return y === null ? !1 : {
                        space: "RGB",
                        r: parseFloat(y[1]),
                        g: parseFloat(y[2]),
                        b: parseFloat(y[3]),
                        a: parseFloat(y[4])
                    }
                },
                write: Lu
            }
        }
    }, {
        litmus: mi.isNumber,
        conversions: {
            HEX: {
                read: function(R) {
                    return {
                        space: "HEX",
                        hex: R,
                        conversionName: "HEX"
                    }
                },
                write: function(R) {
                    return R.hex
                }
            }
        }
    }, {
        litmus: mi.isArray,
        conversions: {
            RGB_ARRAY: {
                read: function(R) {
                    return R.length !== 3 ? !1 : {
                        space: "RGB",
                        r: R[0],
                        g: R[1],
                        b: R[2]
                    }
                },
                write: function(R) {
                    return [R.r, R.g, R.b]
                }
            },
            RGBA_ARRAY: {
                read: function(R) {
                    return R.length !== 4 ? !1 : {
                        space: "RGB",
                        r: R[0],
                        g: R[1],
                        b: R[2],
                        a: R[3]
                    }
                },
                write: function(R) {
                    return [R.r, R.g, R.b, R.a]
                }
            }
        }
    }, {
        litmus: mi.isObject,
        conversions: {
            RGBA_OBJ: {
                read: function(R) {
                    return mi.isNumber(R.r) && mi.isNumber(R.g) && mi.isNumber(R.b) && mi.isNumber(R.a) ? {
                        space: "RGB",
                        r: R.r,
                        g: R.g,
                        b: R.b,
                        a: R.a
                    } : !1
                },
                write: function(R) {
                    return {
                        r: R.r,
                        g: R.g,
                        b: R.b,
                        a: R.a
                    }
                }
            },
            RGB_OBJ: {
                read: function(R) {
                    return mi.isNumber(R.r) && mi.isNumber(R.g) && mi.isNumber(R.b) ? {
                        space: "RGB",
                        r: R.r,
                        g: R.g,
                        b: R.b
                    } : !1
                },
                write: function(R) {
                    return {
                        r: R.r,
                        g: R.g,
                        b: R.b
                    }
                }
            },
            HSVA_OBJ: {
                read: function(R) {
                    return mi.isNumber(R.h) && mi.isNumber(R.s) && mi.isNumber(R.v) && mi.isNumber(R.a) ? {
                        space: "HSV",
                        h: R.h,
                        s: R.s,
                        v: R.v,
                        a: R.a
                    } : !1
                },
                write: function(R) {
                    return {
                        h: R.h,
                        s: R.s,
                        v: R.v,
                        a: R.a
                    }
                }
            },
            HSV_OBJ: {
                read: function(R) {
                    return mi.isNumber(R.h) && mi.isNumber(R.s) && mi.isNumber(R.v) ? {
                        space: "HSV",
                        h: R.h,
                        s: R.s,
                        v: R.v
                    } : !1
                },
                write: function(R) {
                    return {
                        h: R.h,
                        s: R.s,
                        v: R.v
                    }
                }
            }
        }
    }],
    Pd = void 0,
    pp = void 0,
    kp = function() {
        pp = !1;
        var R = arguments.length > 1 ? mi.toArray(arguments) : arguments[0];
        return mi.each(Sm, function(y) {
            if (y.litmus(R)) return mi.each(y.conversions, function(z, V) {
                if (Pd = z.read(R), pp === !1 && Pd !== !1) return pp = Pd, Pd.conversionName = V, Pd.conversion = z, mi.BREAK
            }), mi.BREAK
        }), pp
    },
    Kp = void 0,
    mp = {
        hsv_to_rgb: function(R, y, z) {
            var V = Math.floor(R / 60) % 6,
                Y = R / 60 - Math.floor(R / 60),
                C = z * (1 - y),
                p = z * (1 - Y * y),
                se = z * (1 - (1 - Y) * y),
                ie = [
                    [z, se, C],
                    [p, z, C],
                    [C, z, se],
                    [C, p, z],
                    [se, C, z],
                    [z, C, p]
                ][V];
            return {
                r: ie[0] * 255,
                g: ie[1] * 255,
                b: ie[2] * 255
            }
        },
        rgb_to_hsv: function(R, y, z) {
            var V = Math.min(R, y, z),
                Y = Math.max(R, y, z),
                C = Y - V,
                p = void 0,
                se = void 0;
            if (Y !== 0) se = C / Y;
            else return {
                h: NaN,
                s: 0,
                v: 0
            };
            return R === Y ? p = (y - z) / C : y === Y ? p = 2 + (z - R) / C : p = 4 + (R - y) / C, p /= 6, p < 0 && (p += 1), {
                h: p * 360,
                s: se,
                v: Y / 255
            }
        },
        rgb_to_hex: function(R, y, z) {
            var V = this.hex_with_component(0, 2, R);
            return V = this.hex_with_component(V, 1, y), V = this.hex_with_component(V, 0, z), V
        },
        component_from_hex: function(R, y) {
            return R >> y * 8 & 255
        },
        hex_with_component: function(R, y, z) {
            return z << (Kp = y * 8) | R & ~(255 << Kp)
        }
    },
    Am = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ue) {
        return typeof ue
    } : function(ue) {
        return ue && typeof Symbol == "function" && ue.constructor === Symbol && ue !== Symbol.prototype ? "symbol" : typeof ue
    },
    Mo = function(ue, R) {
        if (!(ue instanceof R)) throw new TypeError("Cannot call a class as a function")
    },
    Co = function() {
        function ue(R, y) {
            for (var z = 0; z < y.length; z++) {
                var V = y[z];
                V.enumerable = V.enumerable || !1, V.configurable = !0, "value" in V && (V.writable = !0), Object.defineProperty(R, V.key, V)
            }
        }
        return function(R, y, z) {
            return y && ue(R.prototype, y), z && ue(R, z), R
        }
    }(),
    Fc = function ue(R, y, z) {
        R === null && (R = Function.prototype);
        var V = Object.getOwnPropertyDescriptor(R, y);
        if (V === void 0) {
            var Y = Object.getPrototypeOf(R);
            return Y === null ? void 0 : ue(Y, y, z)
        } else {
            if ("value" in V) return V.value;
            var C = V.get;
            return C === void 0 ? void 0 : C.call(z)
        }
    },
    Lc = function(ue, R) {
        if (typeof R != "function" && R !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof R);
        ue.prototype = Object.create(R && R.prototype, {
            constructor: {
                value: ue,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), R && (Object.setPrototypeOf ? Object.setPrototypeOf(ue, R) : ue.__proto__ = R)
    },
    Qc = function(ue, R) {
        if (!ue) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return R && (typeof R == "object" || typeof R == "function") ? R : ue
    },
    ka = function() {
        function ue() {
            if (Mo(this, ue), this.__state = kp.apply(this, arguments), this.__state === !1) throw new Error("Failed to interpret color arguments");
            this.__state.a = this.__state.a || 1
        }
        return Co(ue, [{
            key: "toString",
            value: function() {
                return Lu(this)
            }
        }, {
            key: "toHexString",
            value: function() {
                return Lu(this, !0)
            }
        }, {
            key: "toOriginal",
            value: function() {
                return this.__state.conversion.write(this)
            }
        }]), ue
    }();

function Gp(ue, R, y) {
    Object.defineProperty(ue, R, {
        get: function() {
            return this.__state.space === "RGB" ? this.__state[R] : (ka.recalculateRGB(this, R, y), this.__state[R])
        },
        set: function(V) {
            this.__state.space !== "RGB" && (ka.recalculateRGB(this, R, y), this.__state.space = "RGB"), this.__state[R] = V
        }
    })
}

function Hp(ue, R) {
    Object.defineProperty(ue, R, {
        get: function() {
            return this.__state.space === "HSV" ? this.__state[R] : (ka.recalculateHSV(this), this.__state[R])
        },
        set: function(z) {
            this.__state.space !== "HSV" && (ka.recalculateHSV(this), this.__state.space = "HSV"), this.__state[R] = z
        }
    })
}
ka.recalculateRGB = function(ue, R, y) {
    if (ue.__state.space === "HEX") ue.__state[R] = mp.component_from_hex(ue.__state.hex, y);
    else if (ue.__state.space === "HSV") mi.extend(ue.__state, mp.hsv_to_rgb(ue.__state.h, ue.__state.s, ue.__state.v));
    else throw new Error("Corrupted color state")
};
ka.recalculateHSV = function(ue) {
    var R = mp.rgb_to_hsv(ue.r, ue.g, ue.b);
    mi.extend(ue.__state, {
        s: R.s,
        v: R.v
    }), mi.isNaN(R.h) ? mi.isUndefined(ue.__state.h) && (ue.__state.h = 0) : ue.__state.h = R.h
};
ka.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"];
Gp(ka.prototype, "r", 2);
Gp(ka.prototype, "g", 1);
Gp(ka.prototype, "b", 0);
Hp(ka.prototype, "h");
Hp(ka.prototype, "s");
Hp(ka.prototype, "v");
Object.defineProperty(ka.prototype, "a", {
    get: function() {
        return this.__state.a
    },
    set: function(R) {
        this.__state.a = R
    }
});
Object.defineProperty(ka.prototype, "hex", {
    get: function() {
        return this.__state.space !== "HEX" && (this.__state.hex = mp.rgb_to_hex(this.r, this.g, this.b), this.__state.space = "HEX"), this.__state.hex
    },
    set: function(R) {
        this.__state.space = "HEX", this.__state.hex = R
    }
});
var Qh = function() {
        function ue(R, y) {
            Mo(this, ue), this.initialValue = R[y], this.domElement = document.createElement("div"), this.object = R, this.property = y, this.__onChange = void 0, this.__onFinishChange = void 0
        }
        return Co(ue, [{
            key: "onChange",
            value: function(y) {
                return this.__onChange = y, this
            }
        }, {
            key: "onFinishChange",
            value: function(y) {
                return this.__onFinishChange = y, this
            }
        }, {
            key: "setValue",
            value: function(y) {
                return this.object[this.property] = y, this.__onChange && this.__onChange.call(this, y), this.updateDisplay(), this
            }
        }, {
            key: "getValue",
            value: function() {
                return this.object[this.property]
            }
        }, {
            key: "updateDisplay",
            value: function() {
                return this
            }
        }, {
            key: "isModified",
            value: function() {
                return this.initialValue !== this.getValue()
            }
        }]), ue
    }(),
    Tm = {
        HTMLEvents: ["change"],
        MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"],
        KeyboardEvents: ["keydown"]
    },
    Vf = {};
mi.each(Tm, function(ue, R) {
    mi.each(ue, function(y) {
        Vf[y] = R
    })
});
var Mm = /(\d+(\.\d+)?)px/;

function ol(ue) {
    if (ue === "0" || mi.isUndefined(ue)) return 0;
    var R = ue.match(Mm);
    return mi.isNull(R) ? 0 : parseFloat(R[1])
}
var Ut = {
        makeSelectable: function(R, y) {
            R === void 0 || R.style === void 0 || (R.onselectstart = y ? function() {
                return !1
            } : function() {}, R.style.MozUserSelect = y ? "auto" : "none", R.style.KhtmlUserSelect = y ? "auto" : "none", R.unselectable = y ? "on" : "off")
        },
        makeFullscreen: function(R, y, z) {
            var V = z,
                Y = y;
            mi.isUndefined(Y) && (Y = !0), mi.isUndefined(V) && (V = !0), R.style.position = "absolute", Y && (R.style.left = 0, R.style.right = 0), V && (R.style.top = 0, R.style.bottom = 0)
        },
        fakeEvent: function(R, y, z, V) {
            var Y = z || {},
                C = Vf[y];
            if (!C) throw new Error("Event type " + y + " not supported.");
            var p = document.createEvent(C);
            switch (C) {
                case "MouseEvents": {
                    var se = Y.x || Y.clientX || 0,
                        ie = Y.y || Y.clientY || 0;
                    p.initMouseEvent(y, Y.bubbles || !1, Y.cancelable || !0, window, Y.clickCount || 1, 0, 0, se, ie, !1, !1, !1, !1, 0, null);
                    break
                }
                case "KeyboardEvents": {
                    var He = p.initKeyboardEvent || p.initKeyEvent;
                    mi.defaults(Y, {
                        cancelable: !0,
                        ctrlKey: !1,
                        altKey: !1,
                        shiftKey: !1,
                        metaKey: !1,
                        keyCode: void 0,
                        charCode: void 0
                    }), He(y, Y.bubbles || !1, Y.cancelable, window, Y.ctrlKey, Y.altKey, Y.shiftKey, Y.metaKey, Y.keyCode, Y.charCode);
                    break
                }
                default: {
                    p.initEvent(y, Y.bubbles || !1, Y.cancelable || !0);
                    break
                }
            }
            mi.defaults(p, V), R.dispatchEvent(p)
        },
        bind: function(R, y, z, V) {
            var Y = V || !1;
            return R.addEventListener ? R.addEventListener(y, z, Y) : R.attachEvent && R.attachEvent("on" + y, z), Ut
        },
        unbind: function(R, y, z, V) {
            var Y = V || !1;
            return R.removeEventListener ? R.removeEventListener(y, z, Y) : R.detachEvent && R.detachEvent("on" + y, z), Ut
        },
        addClass: function(R, y) {
            if (R.className === void 0) R.className = y;
            else if (R.className !== y) {
                var z = R.className.split(/ +/);
                z.indexOf(y) === -1 && (z.push(y), R.className = z.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""))
            }
            return Ut
        },
        removeClass: function(R, y) {
            if (y)
                if (R.className === y) R.removeAttribute("class");
                else {
                    var z = R.className.split(/ +/),
                        V = z.indexOf(y);
                    V !== -1 && (z.splice(V, 1), R.className = z.join(" "))
                }
            else R.className = void 0;
            return Ut
        },
        hasClass: function(R, y) {
            return new RegExp("(?:^|\\s+)" + y + "(?:\\s+|$)").test(R.className) || !1
        },
        getWidth: function(R) {
            var y = getComputedStyle(R);
            return ol(y["border-left-width"]) + ol(y["border-right-width"]) + ol(y["padding-left"]) + ol(y["padding-right"]) + ol(y.width)
        },
        getHeight: function(R) {
            var y = getComputedStyle(R);
            return ol(y["border-top-width"]) + ol(y["border-bottom-width"]) + ol(y["padding-top"]) + ol(y["padding-bottom"]) + ol(y.height)
        },
        getOffset: function(R) {
            var y = R,
                z = {
                    left: 0,
                    top: 0
                };
            if (y.offsetParent)
                do z.left += y.offsetLeft, z.top += y.offsetTop, y = y.offsetParent; while (y);
            return z
        },
        isActive: function(R) {
            return R === document.activeElement && (R.type || R.href)
        }
    },
    Gf = function(ue) {
        Lc(R, ue);

        function R(y, z) {
            Mo(this, R);
            var V = Qc(this, (R.__proto__ || Object.getPrototypeOf(R)).call(this, y, z)),
                Y = V;
            V.__prev = V.getValue(), V.__checkbox = document.createElement("input"), V.__checkbox.setAttribute("type", "checkbox");

            function C() {
                Y.setValue(!Y.__prev)
            }
            return Ut.bind(V.__checkbox, "change", C, !1), V.domElement.appendChild(V.__checkbox), V.updateDisplay(), V
        }
        return Co(R, [{
            key: "setValue",
            value: function(z) {
                var V = Fc(R.prototype.__proto__ || Object.getPrototypeOf(R.prototype), "setValue", this).call(this, z);
                return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), V
            }
        }, {
            key: "updateDisplay",
            value: function() {
                return this.getValue() === !0 ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = !0, this.__prev = !0) : (this.__checkbox.checked = !1, this.__prev = !1), Fc(R.prototype.__proto__ || Object.getPrototypeOf(R.prototype), "updateDisplay", this).call(this)
            }
        }]), R
    }(Qh),
    Cm = function(ue) {
        Lc(R, ue);

        function R(y, z, V) {
            Mo(this, R);
            var Y = Qc(this, (R.__proto__ || Object.getPrototypeOf(R)).call(this, y, z)),
                C = V,
                p = Y;
            if (Y.__select = document.createElement("select"), mi.isArray(C)) {
                var se = {};
                mi.each(C, function(ie) {
                    se[ie] = ie
                }), C = se
            }
            return mi.each(C, function(ie, He) {
                var be = document.createElement("option");
                be.innerHTML = He, be.setAttribute("value", ie), p.__select.appendChild(be)
            }), Y.updateDisplay(), Ut.bind(Y.__select, "change", function() {
                var ie = this.options[this.selectedIndex].value;
                p.setValue(ie)
            }), Y.domElement.appendChild(Y.__select), Y
        }
        return Co(R, [{
            key: "setValue",
            value: function(z) {
                var V = Fc(R.prototype.__proto__ || Object.getPrototypeOf(R.prototype), "setValue", this).call(this, z);
                return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), V
            }
        }, {
            key: "updateDisplay",
            value: function() {
                return Ut.isActive(this.__select) ? this : (this.__select.value = this.getValue(), Fc(R.prototype.__proto__ || Object.getPrototypeOf(R.prototype), "updateDisplay", this).call(this))
            }
        }]), R
    }(Qh),
    Bm = function(ue) {
        Lc(R, ue);

        function R(y, z) {
            Mo(this, R);
            var V = Qc(this, (R.__proto__ || Object.getPrototypeOf(R)).call(this, y, z)),
                Y = V;

            function C() {
                Y.setValue(Y.__input.value)
            }

            function p() {
                Y.__onFinishChange && Y.__onFinishChange.call(Y, Y.getValue())
            }
            return V.__input = document.createElement("input"), V.__input.setAttribute("type", "text"), Ut.bind(V.__input, "keyup", C), Ut.bind(V.__input, "change", C), Ut.bind(V.__input, "blur", p), Ut.bind(V.__input, "keydown", function(se) {
                se.keyCode === 13 && this.blur()
            }), V.updateDisplay(), V.domElement.appendChild(V.__input), V
        }
        return Co(R, [{
            key: "updateDisplay",
            value: function() {
                return Ut.isActive(this.__input) || (this.__input.value = this.getValue()), Fc(R.prototype.__proto__ || Object.getPrototypeOf(R.prototype), "updateDisplay", this).call(this)
            }
        }]), R
    }(Qh);

function ef(ue) {
    var R = ue.toString();
    return R.indexOf(".") > -1 ? R.length - R.indexOf(".") - 1 : 0
}
var Hf = function(ue) {
    Lc(R, ue);

    function R(y, z, V) {
        Mo(this, R);
        var Y = Qc(this, (R.__proto__ || Object.getPrototypeOf(R)).call(this, y, z)),
            C = V || {};
        return Y.__min = C.min, Y.__max = C.max, Y.__step = C.step, mi.isUndefined(Y.__step) ? Y.initialValue === 0 ? Y.__impliedStep = 1 : Y.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(Y.initialValue)) / Math.LN10)) / 10 : Y.__impliedStep = Y.__step, Y.__precision = ef(Y.__impliedStep), Y
    }
    return Co(R, [{
        key: "setValue",
        value: function(z) {
            var V = z;
            return this.__min !== void 0 && V < this.__min ? V = this.__min : this.__max !== void 0 && V > this.__max && (V = this.__max), this.__step !== void 0 && V % this.__step !== 0 && (V = Math.round(V / this.__step) * this.__step), Fc(R.prototype.__proto__ || Object.getPrototypeOf(R.prototype), "setValue", this).call(this, V)
        }
    }, {
        key: "min",
        value: function(z) {
            return this.__min = z, this
        }
    }, {
        key: "max",
        value: function(z) {
            return this.__max = z, this
        }
    }, {
        key: "step",
        value: function(z) {
            return this.__step = z, this.__impliedStep = z, this.__precision = ef(z), this
        }
    }]), R
}(Qh);

function Rm(ue, R) {
    var y = Math.pow(10, R);
    return Math.round(ue * y) / y
}
var gp = function(ue) {
    Lc(R, ue);

    function R(y, z, V) {
        Mo(this, R);
        var Y = Qc(this, (R.__proto__ || Object.getPrototypeOf(R)).call(this, y, z, V));
        Y.__truncationSuspended = !1;
        var C = Y,
            p = void 0;

        function se() {
            var Tt = parseFloat(C.__input.value);
            mi.isNaN(Tt) || C.setValue(Tt)
        }

        function ie() {
            C.__onFinishChange && C.__onFinishChange.call(C, C.getValue())
        }

        function He() {
            ie()
        }

        function be(Tt) {
            var Je = p - Tt.clientY;
            C.setValue(C.getValue() + Je * C.__impliedStep), p = Tt.clientY
        }

        function Ee() {
            Ut.unbind(window, "mousemove", be), Ut.unbind(window, "mouseup", Ee), ie()
        }

        function Lt(Tt) {
            Ut.bind(window, "mousemove", be), Ut.bind(window, "mouseup", Ee), p = Tt.clientY
        }
        return Y.__input = document.createElement("input"), Y.__input.setAttribute("type", "text"), Ut.bind(Y.__input, "change", se), Ut.bind(Y.__input, "blur", He), Ut.bind(Y.__input, "mousedown", Lt), Ut.bind(Y.__input, "keydown", function(Tt) {
            Tt.keyCode === 13 && (C.__truncationSuspended = !0, this.blur(), C.__truncationSuspended = !1, ie())
        }), Y.updateDisplay(), Y.domElement.appendChild(Y.__input), Y
    }
    return Co(R, [{
        key: "updateDisplay",
        value: function() {
            return this.__input.value = this.__truncationSuspended ? this.getValue() : Rm(this.getValue(), this.__precision), Fc(R.prototype.__proto__ || Object.getPrototypeOf(R.prototype), "updateDisplay", this).call(this)
        }
    }]), R
}(Hf);

function tf(ue, R, y, z, V) {
    return z + (V - z) * ((ue - R) / (y - R))
}
var Dp = function(ue) {
        Lc(R, ue);

        function R(y, z, V, Y, C) {
            Mo(this, R);
            var p = Qc(this, (R.__proto__ || Object.getPrototypeOf(R)).call(this, y, z, {
                    min: V,
                    max: Y,
                    step: C
                })),
                se = p;
            p.__background = document.createElement("div"), p.__foreground = document.createElement("div"), Ut.bind(p.__background, "mousedown", ie), Ut.bind(p.__background, "touchstart", Ee), Ut.addClass(p.__background, "slider"), Ut.addClass(p.__foreground, "slider-fg");

            function ie(Je) {
                document.activeElement.blur(), Ut.bind(window, "mousemove", He), Ut.bind(window, "mouseup", be), He(Je)
            }

            function He(Je) {
                Je.preventDefault();
                var wt = se.__background.getBoundingClientRect();
                return se.setValue(tf(Je.clientX, wt.left, wt.right, se.__min, se.__max)), !1
            }

            function be() {
                Ut.unbind(window, "mousemove", He), Ut.unbind(window, "mouseup", be), se.__onFinishChange && se.__onFinishChange.call(se, se.getValue())
            }

            function Ee(Je) {
                Je.touches.length === 1 && (Ut.bind(window, "touchmove", Lt), Ut.bind(window, "touchend", Tt), Lt(Je))
            }

            function Lt(Je) {
                var wt = Je.touches[0].clientX,
                    Ke = se.__background.getBoundingClientRect();
                se.setValue(tf(wt, Ke.left, Ke.right, se.__min, se.__max))
            }

            function Tt() {
                Ut.unbind(window, "touchmove", Lt), Ut.unbind(window, "touchend", Tt), se.__onFinishChange && se.__onFinishChange.call(se, se.getValue())
            }
            return p.updateDisplay(), p.__background.appendChild(p.__foreground), p.domElement.appendChild(p.__background), p
        }
        return Co(R, [{
            key: "updateDisplay",
            value: function() {
                var z = (this.getValue() - this.__min) / (this.__max - this.__min);
                return this.__foreground.style.width = z * 100 + "%", Fc(R.prototype.__proto__ || Object.getPrototypeOf(R.prototype), "updateDisplay", this).call(this)
            }
        }]), R
    }(Hf),
    Wf = function(ue) {
        Lc(R, ue);

        function R(y, z, V) {
            Mo(this, R);
            var Y = Qc(this, (R.__proto__ || Object.getPrototypeOf(R)).call(this, y, z)),
                C = Y;
            return Y.__button = document.createElement("div"), Y.__button.innerHTML = V === void 0 ? "Fire" : V, Ut.bind(Y.__button, "click", function(p) {
                return p.preventDefault(), C.fire(), !1
            }), Ut.addClass(Y.__button, "button"), Y.domElement.appendChild(Y.__button), Y
        }
        return Co(R, [{
            key: "fire",
            value: function() {
                this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue())
            }
        }]), R
    }(Qh),
    Up = function(ue) {
        Lc(R, ue);

        function R(y, z) {
            Mo(this, R);
            var V = Qc(this, (R.__proto__ || Object.getPrototypeOf(R)).call(this, y, z));
            V.__color = new ka(V.getValue()), V.__temp = new ka(0);
            var Y = V;
            V.domElement = document.createElement("div"), Ut.makeSelectable(V.domElement, !1), V.__selector = document.createElement("div"), V.__selector.className = "selector", V.__saturation_field = document.createElement("div"), V.__saturation_field.className = "saturation-field", V.__field_knob = document.createElement("div"), V.__field_knob.className = "field-knob", V.__field_knob_border = "2px solid ", V.__hue_knob = document.createElement("div"), V.__hue_knob.className = "hue-knob", V.__hue_field = document.createElement("div"), V.__hue_field.className = "hue-field", V.__input = document.createElement("input"), V.__input.type = "text", V.__input_textShadow = "0 1px 1px ", Ut.bind(V.__input, "keydown", function(Je) {
                Je.keyCode === 13 && be.call(this)
            }), Ut.bind(V.__input, "blur", be), Ut.bind(V.__selector, "mousedown", function() {
                Ut.addClass(this, "drag").bind(window, "mouseup", function() {
                    Ut.removeClass(Y.__selector, "drag")
                })
            }), Ut.bind(V.__selector, "touchstart", function() {
                Ut.addClass(this, "drag").bind(window, "touchend", function() {
                    Ut.removeClass(Y.__selector, "drag")
                })
            });
            var C = document.createElement("div");
            mi.extend(V.__selector.style, {
                width: "122px",
                height: "102px",
                padding: "3px",
                backgroundColor: "#222",
                boxShadow: "0px 1px 3px rgba(0,0,0,0.3)"
            }), mi.extend(V.__field_knob.style, {
                position: "absolute",
                width: "12px",
                height: "12px",
                border: V.__field_knob_border + (V.__color.v < .5 ? "#fff" : "#000"),
                boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
                borderRadius: "12px",
                zIndex: 1
            }), mi.extend(V.__hue_knob.style, {
                position: "absolute",
                width: "15px",
                height: "2px",
                borderRight: "4px solid #fff",
                zIndex: 1
            }), mi.extend(V.__saturation_field.style, {
                width: "100px",
                height: "100px",
                border: "1px solid #555",
                marginRight: "3px",
                display: "inline-block",
                cursor: "pointer"
            }), mi.extend(C.style, {
                width: "100%",
                height: "100%",
                background: "none"
            }), nf(C, "top", "rgba(0,0,0,0)", "#000"), mi.extend(V.__hue_field.style, {
                width: "15px",
                height: "100px",
                border: "1px solid #555",
                cursor: "ns-resize",
                position: "absolute",
                top: "3px",
                right: "3px"
            }), Lm(V.__hue_field), mi.extend(V.__input.style, {
                outline: "none",
                textAlign: "center",
                color: "#fff",
                border: 0,
                fontWeight: "bold",
                textShadow: V.__input_textShadow + "rgba(0,0,0,0.7)"
            }), Ut.bind(V.__saturation_field, "mousedown", p), Ut.bind(V.__saturation_field, "touchstart", p), Ut.bind(V.__field_knob, "mousedown", p), Ut.bind(V.__field_knob, "touchstart", p), Ut.bind(V.__hue_field, "mousedown", se), Ut.bind(V.__hue_field, "touchstart", se);

            function p(Je) {
                Lt(Je), Ut.bind(window, "mousemove", Lt), Ut.bind(window, "touchmove", Lt), Ut.bind(window, "mouseup", ie), Ut.bind(window, "touchend", ie)
            }

            function se(Je) {
                Tt(Je), Ut.bind(window, "mousemove", Tt), Ut.bind(window, "touchmove", Tt), Ut.bind(window, "mouseup", He), Ut.bind(window, "touchend", He)
            }

            function ie() {
                Ut.unbind(window, "mousemove", Lt), Ut.unbind(window, "touchmove", Lt), Ut.unbind(window, "mouseup", ie), Ut.unbind(window, "touchend", ie), Ee()
            }

            function He() {
                Ut.unbind(window, "mousemove", Tt), Ut.unbind(window, "touchmove", Tt), Ut.unbind(window, "mouseup", He), Ut.unbind(window, "touchend", He), Ee()
            }

            function be() {
                var Je = kp(this.value);
                Je !== !1 ? (Y.__color.__state = Je, Y.setValue(Y.__color.toOriginal())) : this.value = Y.__color.toString()
            }

            function Ee() {
                Y.__onFinishChange && Y.__onFinishChange.call(Y, Y.__color.toOriginal())
            }
            V.__saturation_field.appendChild(C), V.__selector.appendChild(V.__field_knob), V.__selector.appendChild(V.__saturation_field), V.__selector.appendChild(V.__hue_field), V.__hue_field.appendChild(V.__hue_knob), V.domElement.appendChild(V.__input), V.domElement.appendChild(V.__selector), V.updateDisplay();

            function Lt(Je) {
                Je.type.indexOf("touch") === -1 && Je.preventDefault();
                var wt = Y.__saturation_field.getBoundingClientRect(),
                    Ke = Je.touches && Je.touches[0] || Je,
                    Ye = Ke.clientX,
                    jt = Ke.clientY,
                    di = (Ye - wt.left) / (wt.right - wt.left),
                    $e = 1 - (jt - wt.top) / (wt.bottom - wt.top);
                return $e > 1 ? $e = 1 : $e < 0 && ($e = 0), di > 1 ? di = 1 : di < 0 && (di = 0), Y.__color.v = $e, Y.__color.s = di, Y.setValue(Y.__color.toOriginal()), !1
            }

            function Tt(Je) {
                Je.type.indexOf("touch") === -1 && Je.preventDefault();
                var wt = Y.__hue_field.getBoundingClientRect(),
                    Ke = Je.touches && Je.touches[0] || Je,
                    Ye = Ke.clientY,
                    jt = 1 - (Ye - wt.top) / (wt.bottom - wt.top);
                return jt > 1 ? jt = 1 : jt < 0 && (jt = 0), Y.__color.h = jt * 360, Y.setValue(Y.__color.toOriginal()), !1
            }
            return V
        }
        return Co(R, [{
            key: "updateDisplay",
            value: function() {
                var z = kp(this.getValue());
                if (z !== !1) {
                    var V = !1;
                    mi.each(ka.COMPONENTS, function(p) {
                        if (!mi.isUndefined(z[p]) && !mi.isUndefined(this.__color.__state[p]) && z[p] !== this.__color.__state[p]) return V = !0, {}
                    }, this), V && mi.extend(this.__color.__state, z)
                }
                mi.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1;
                var Y = this.__color.v < .5 || this.__color.s > .5 ? 255 : 0,
                    C = 255 - Y;
                mi.extend(this.__field_knob.style, {
                    marginLeft: 100 * this.__color.s - 7 + "px",
                    marginTop: 100 * (1 - this.__color.v) - 7 + "px",
                    backgroundColor: this.__temp.toHexString(),
                    border: this.__field_knob_border + "rgb(" + Y + "," + Y + "," + Y + ")"
                }), this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + "px", this.__temp.s = 1, this.__temp.v = 1, nf(this.__saturation_field, "left", "#fff", this.__temp.toHexString()), this.__input.value = this.__color.toString(), mi.extend(this.__input.style, {
                    backgroundColor: this.__color.toHexString(),
                    color: "rgb(" + Y + "," + Y + "," + Y + ")",
                    textShadow: this.__input_textShadow + "rgba(" + C + "," + C + "," + C + ",.7)"
                })
            }
        }]), R
    }(Qh),
    Fm = ["-moz-", "-o-", "-webkit-", "-ms-", ""];

function nf(ue, R, y, z) {
    ue.style.background = "", mi.each(Fm, function(V) {
        ue.style.cssText += "background: " + V + "linear-gradient(" + R + ", " + y + " 0%, " + z + " 100%); "
    })
}

function Lm(ue) {
    ue.style.background = "", ue.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", ue.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", ue.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", ue.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", ue.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"
}
var Qm = {
        load: function(R, y) {
            var z = y || document,
                V = z.createElement("link");
            V.type = "text/css", V.rel = "stylesheet", V.href = R, z.getElementsByTagName("head")[0].appendChild(V)
        },
        inject: function(R, y) {
            var z = y || document,
                V = document.createElement("style");
            V.type = "text/css", V.innerHTML = R;
            var Y = z.getElementsByTagName("head")[0];
            try {
                Y.appendChild(V)
            } catch (C) {}
        }
    },
    Pm = `<div id="dg-save" class="dg dialogue">

  Here's the new load parameter for your <code>GUI</code>'s constructor:

  <textarea id="dg-new-constructor"></textarea>

  <div id="dg-save-locally">

    <input id="dg-local-storage" type="checkbox"/> Automatically save
    values to <code>localStorage</code> on exit.

    <div id="dg-local-explain">The values saved to <code>localStorage</code> will
      override those passed to <code>dat.GUI</code>'s constructor. This makes it
      easier to work incrementally, but <code>localStorage</code> is fragile,
      and your friends may not see the same values you do.

    </div>

  </div>

</div>`,
    km = function(R, y) {
        var z = R[y];
        return mi.isArray(arguments[2]) || mi.isObject(arguments[2]) ? new Cm(R, y, arguments[2]) : mi.isNumber(z) ? mi.isNumber(arguments[2]) && mi.isNumber(arguments[3]) ? mi.isNumber(arguments[4]) ? new Dp(R, y, arguments[2], arguments[3], arguments[4]) : new Dp(R, y, arguments[2], arguments[3]) : mi.isNumber(arguments[4]) ? new gp(R, y, {
            min: arguments[2],
            max: arguments[3],
            step: arguments[4]
        }) : new gp(R, y, {
            min: arguments[2],
            max: arguments[3]
        }) : mi.isString(z) ? new Bm(R, y) : mi.isFunction(z) ? new Wf(R, y, "") : mi.isBoolean(z) ? new Gf(R, y) : null
    };

function Dm(ue) {
    setTimeout(ue, 1e3 / 60)
}
var Um = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || Dm,
    Im = function() {
        function ue() {
            Mo(this, ue), this.backgroundElement = document.createElement("div"), mi.extend(this.backgroundElement.style, {
                backgroundColor: "rgba(0,0,0,0.8)",
                top: 0,
                left: 0,
                display: "none",
                zIndex: "1000",
                opacity: 0,
                WebkitTransition: "opacity 0.2s linear",
                transition: "opacity 0.2s linear"
            }), Ut.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), mi.extend(this.domElement.style, {
                position: "fixed",
                display: "none",
                zIndex: "1001",
                opacity: 0,
                WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
                transition: "transform 0.2s ease-out, opacity 0.2s linear"
            }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement);
            var R = this;
            Ut.bind(this.backgroundElement, "click", function() {
                R.hide()
            })
        }
        return Co(ue, [{
            key: "show",
            value: function() {
                var y = this;
                this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), mi.defer(function() {
                    y.backgroundElement.style.opacity = 1, y.domElement.style.opacity = 1, y.domElement.style.webkitTransform = "scale(1)"
                })
            }
        }, {
            key: "hide",
            value: function() {
                var y = this,
                    z = function V() {
                        y.domElement.style.display = "none", y.backgroundElement.style.display = "none", Ut.unbind(y.domElement, "webkitTransitionEnd", V), Ut.unbind(y.domElement, "transitionend", V), Ut.unbind(y.domElement, "oTransitionEnd", V)
                    };
                Ut.bind(this.domElement, "webkitTransitionEnd", z), Ut.bind(this.domElement, "transitionend", z), Ut.bind(this.domElement, "oTransitionEnd", z), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)"
            }
        }, {
            key: "layout",
            value: function() {
                this.domElement.style.left = window.innerWidth / 2 - Ut.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - Ut.getHeight(this.domElement) / 2 + "px"
            }
        }]), ue
    }(),
    zm = Em(`.dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}
`);
Qm.inject(zm);
var rf = "dg",
    af = 72,
    sf = 20,
    Id = "Default",
    kd = function() {
        try {
            return !!window.localStorage
        } catch (ue) {
            return !1
        }
    }(),
    Dd = void 0,
    of = !0,
    Ru = void 0,
    Lp = !1,
    Jf = [],
    Ir = function ue(R) {
        var y = this,
            z = R || {};
        this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), Ut.addClass(this.domElement, rf), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], z = mi.defaults(z, {
            closeOnTop: !1,
            autoPlace: !0,
            width: ue.DEFAULT_WIDTH
        }), z = mi.defaults(z, {
            resizable: z.autoPlace,
            hideable: z.autoPlace
        }), mi.isUndefined(z.load) ? z.load = {
            preset: Id
        } : z.preset && (z.load.preset = z.preset), mi.isUndefined(z.parent) && z.hideable && Jf.push(this), z.resizable = mi.isUndefined(z.parent) && z.resizable, z.autoPlace && mi.isUndefined(z.scrollable) && (z.scrollable = !0);
        var V = kd && localStorage.getItem(Fu(this, "isLocal")) === "true",
            Y = void 0,
            C = void 0;
        if (Object.defineProperties(this, {
                parent: {
                    get: function() {
                        return z.parent
                    }
                },
                scrollable: {
                    get: function() {
                        return z.scrollable
                    }
                },
                autoPlace: {
                    get: function() {
                        return z.autoPlace
                    }
                },
                closeOnTop: {
                    get: function() {
                        return z.closeOnTop
                    }
                },
                preset: {
                    get: function() {
                        return y.parent ? y.getRoot().preset : z.load.preset
                    },
                    set: function(Ee) {
                        y.parent ? y.getRoot().preset = Ee : z.load.preset = Ee, Gm(this), y.revert()
                    }
                },
                width: {
                    get: function() {
                        return z.width
                    },
                    set: function(Ee) {
                        z.width = Ee, Np(y, Ee)
                    }
                },
                name: {
                    get: function() {
                        return z.name
                    },
                    set: function(Ee) {
                        z.name = Ee, C && (C.innerHTML = z.name)
                    }
                },
                closed: {
                    get: function() {
                        return z.closed
                    },
                    set: function(Ee) {
                        z.closed = Ee, z.closed ? Ut.addClass(y.__ul, ue.CLASS_CLOSED) : Ut.removeClass(y.__ul, ue.CLASS_CLOSED), this.onResize(), y.__closeButton && (y.__closeButton.innerHTML = Ee ? ue.TEXT_OPEN : ue.TEXT_CLOSED)
                    }
                },
                load: {
                    get: function() {
                        return z.load
                    }
                },
                useLocalStorage: {
                    get: function() {
                        return V
                    },
                    set: function(Ee) {
                        kd && (V = Ee, Ee ? Ut.bind(window, "unload", Y) : Ut.unbind(window, "unload", Y), localStorage.setItem(Fu(y, "isLocal"), Ee))
                    }
                }
            }), mi.isUndefined(z.parent)) {
            if (this.closed = z.closed || !1, Ut.addClass(this.domElement, ue.CLASS_MAIN), Ut.makeSelectable(this.domElement, !1), kd && V) {
                y.useLocalStorage = !0;
                var p = localStorage.getItem(Fu(this, "gui"));
                p && (z.load = JSON.parse(p))
            }
            this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = ue.TEXT_CLOSED, Ut.addClass(this.__closeButton, ue.CLASS_CLOSE_BUTTON), z.closeOnTop ? (Ut.addClass(this.__closeButton, ue.CLASS_CLOSE_TOP), this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (Ut.addClass(this.__closeButton, ue.CLASS_CLOSE_BOTTOM), this.domElement.appendChild(this.__closeButton)), Ut.bind(this.__closeButton, "click", function() {
                y.closed = !y.closed
            })
        } else {
            z.closed === void 0 && (z.closed = !0);
            var se = document.createTextNode(z.name);
            Ut.addClass(se, "controller-name"), C = Wp(y, se);
            var ie = function(Ee) {
                return Ee.preventDefault(), y.closed = !y.closed, !1
            };
            Ut.addClass(this.__ul, ue.CLASS_CLOSED), Ut.addClass(C, "title"), Ut.bind(C, "click", ie), z.closed || (this.closed = !1)
        }
        z.autoPlace && (mi.isUndefined(z.parent) && (of && (Ru = document.createElement("div"), Ut.addClass(Ru, rf), Ut.addClass(Ru, ue.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(Ru), of = !1), Ru.appendChild(this.domElement), Ut.addClass(this.domElement, ue.CLASS_AUTO_PLACE)), this.parent || Np(y, z.width)), this.__resizeHandler = function() {
            y.onResizeDebounced()
        }, Ut.bind(window, "resize", this.__resizeHandler), Ut.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler), Ut.bind(this.__ul, "transitionend", this.__resizeHandler), Ut.bind(this.__ul, "oTransitionEnd", this.__resizeHandler), this.onResize(), z.resizable && Vm(this), Y = function() {
            kd && localStorage.getItem(Fu(y, "isLocal")) === "true" && localStorage.setItem(Fu(y, "gui"), JSON.stringify(y.getSaveObject()))
        }, this.saveToLocalStorageIfPossible = Y;

        function He() {
            var be = y.getRoot();
            be.width += 1, mi.defer(function() {
                be.width -= 1
            })
        }
        z.parent || He()
    };
Ir.toggleHide = function() {
    Lp = !Lp, mi.each(Jf, function(ue) {
        ue.domElement.style.display = Lp ? "none" : ""
    })
};
Ir.CLASS_AUTO_PLACE = "a";
Ir.CLASS_AUTO_PLACE_CONTAINER = "ac";
Ir.CLASS_MAIN = "main";
Ir.CLASS_CONTROLLER_ROW = "cr";
Ir.CLASS_TOO_TALL = "taller-than-window";
Ir.CLASS_CLOSED = "closed";
Ir.CLASS_CLOSE_BUTTON = "close-button";
Ir.CLASS_CLOSE_TOP = "close-top";
Ir.CLASS_CLOSE_BOTTOM = "close-bottom";
Ir.CLASS_DRAG = "drag";
Ir.DEFAULT_WIDTH = 245;
Ir.TEXT_CLOSED = "Close Controls";
Ir.TEXT_OPEN = "Open Controls";
Ir._keydownHandler = function(ue) {
    document.activeElement.type !== "text" && (ue.which === af || ue.keyCode === af) && Ir.toggleHide()
};
Ut.bind(window, "keydown", Ir._keydownHandler, !1);
mi.extend(Ir.prototype, {
    add: function(R, y) {
        return Ud(this, R, y, {
            factoryArgs: Array.prototype.slice.call(arguments, 2)
        })
    },
    addColor: function(R, y) {
        return Ud(this, R, y, {
            color: !0
        })
    },
    remove: function(R) {
        this.__ul.removeChild(R.__li), this.__controllers.splice(this.__controllers.indexOf(R), 1);
        var y = this;
        mi.defer(function() {
            y.onResize()
        })
    },
    destroy: function() {
        if (this.parent) throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
        this.autoPlace && Ru.removeChild(this.domElement);
        var R = this;
        mi.each(this.__folders, function(y) {
            R.removeFolder(y)
        }), Ut.unbind(window, "keydown", Ir._keydownHandler, !1), lf(this)
    },
    addFolder: function(R) {
        if (this.__folders[R] !== void 0) throw new Error('You already have a folder in this GUI by the name "' + R + '"');
        var y = {
            name: R,
            parent: this
        };
        y.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[R] && (y.closed = this.load.folders[R].closed, y.load = this.load.folders[R]);
        var z = new Ir(y);
        this.__folders[R] = z;
        var V = Wp(this, z.domElement);
        return Ut.addClass(V, "folder"), z
    },
    removeFolder: function(R) {
        this.__ul.removeChild(R.domElement.parentElement), delete this.__folders[R.name], this.load && this.load.folders && this.load.folders[R.name] && delete this.load.folders[R.name], lf(R);
        var y = this;
        mi.each(R.__folders, function(z) {
            R.removeFolder(z)
        }), mi.defer(function() {
            y.onResize()
        })
    },
    open: function() {
        this.closed = !1
    },
    close: function() {
        this.closed = !0
    },
    hide: function() {
        this.domElement.style.display = "none"
    },
    show: function() {
        this.domElement.style.display = ""
    },
    onResize: function() {
        var R = this.getRoot();
        if (R.scrollable) {
            var y = Ut.getOffset(R.__ul).top,
                z = 0;
            mi.each(R.__ul.childNodes, function(V) {
                R.autoPlace && V === R.__save_row || (z += Ut.getHeight(V))
            }), window.innerHeight - y - sf < z ? (Ut.addClass(R.domElement, Ir.CLASS_TOO_TALL), R.__ul.style.height = window.innerHeight - y - sf + "px") : (Ut.removeClass(R.domElement, Ir.CLASS_TOO_TALL), R.__ul.style.height = "auto")
        }
        R.__resize_handle && mi.defer(function() {
            R.__resize_handle.style.height = R.__ul.offsetHeight + "px"
        }), R.__closeButton && (R.__closeButton.style.width = R.width + "px")
    },
    onResizeDebounced: mi.debounce(function() {
        this.onResize()
    }, 50),
    remember: function() {
        if (mi.isUndefined(Dd) && (Dd = new Im, Dd.domElement.innerHTML = Pm), this.parent) throw new Error("You can only call remember on a top level GUI.");
        var R = this;
        mi.each(Array.prototype.slice.call(arguments), function(y) {
            R.__rememberedObjects.length === 0 && Om(R), R.__rememberedObjects.indexOf(y) === -1 && R.__rememberedObjects.push(y)
        }), this.autoPlace && Np(this, this.width)
    },
    getRoot: function() {
        for (var R = this; R.parent;) R = R.parent;
        return R
    },
    getSaveObject: function() {
        var R = this.load;
        return R.closed = this.closed, this.__rememberedObjects.length > 0 && (R.preset = this.preset, R.remembered || (R.remembered = {}), R.remembered[this.preset] = fp(this)), R.folders = {}, mi.each(this.__folders, function(y, z) {
            R.folders[z] = y.getSaveObject()
        }), R
    },
    save: function() {
        this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = fp(this), Ip(this, !1), this.saveToLocalStorageIfPossible()
    },
    saveAs: function(R) {
        this.load.remembered || (this.load.remembered = {}, this.load.remembered[Id] = fp(this, !0)), this.load.remembered[R] = fp(this), this.preset = R, zp(this, R, !0), this.saveToLocalStorageIfPossible()
    },
    revert: function(R) {
        mi.each(this.__controllers, function(y) {
            this.getRoot().load.remembered ? Zf(R || this.getRoot(), y) : y.setValue(y.initialValue), y.__onFinishChange && y.__onFinishChange.call(y, y.getValue())
        }, this), mi.each(this.__folders, function(y) {
            y.revert(y)
        }), R || Ip(this.getRoot(), !1)
    },
    listen: function(R) {
        var y = this.__listening.length === 0;
        this.__listening.push(R), y && Xf(this.__listening)
    },
    updateDisplay: function() {
        mi.each(this.__controllers, function(R) {
            R.updateDisplay()
        }), mi.each(this.__folders, function(R) {
            R.updateDisplay()
        })
    }
});

function Wp(ue, R, y) {
    var z = document.createElement("li");
    return R && z.appendChild(R), y ? ue.__ul.insertBefore(z, y) : ue.__ul.appendChild(z), ue.onResize(), z
}

function lf(ue) {
    Ut.unbind(window, "resize", ue.__resizeHandler), ue.saveToLocalStorageIfPossible && Ut.unbind(window, "unload", ue.saveToLocalStorageIfPossible)
}

function Ip(ue, R) {
    var y = ue.__preset_select[ue.__preset_select.selectedIndex];
    R ? y.innerHTML = y.value + "*" : y.innerHTML = y.value
}

function Nm(ue, R, y) {
    if (y.__li = R, y.__gui = ue, mi.extend(y, {
            options: function(C) {
                if (arguments.length > 1) {
                    var p = y.__li.nextElementSibling;
                    return y.remove(), Ud(ue, y.object, y.property, {
                        before: p,
                        factoryArgs: [mi.toArray(arguments)]
                    })
                }
                if (mi.isArray(C) || mi.isObject(C)) {
                    var se = y.__li.nextElementSibling;
                    return y.remove(), Ud(ue, y.object, y.property, {
                        before: se,
                        factoryArgs: [C]
                    })
                }
            },
            name: function(C) {
                return y.__li.firstElementChild.firstElementChild.innerHTML = C, y
            },
            listen: function() {
                return y.__gui.listen(y), y
            },
            remove: function() {
                return y.__gui.remove(y), y
            }
        }), y instanceof Dp) {
        var z = new gp(y.object, y.property, {
            min: y.__min,
            max: y.__max,
            step: y.__step
        });
        mi.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], function(Y) {
            var C = y[Y],
                p = z[Y];
            y[Y] = z[Y] = function() {
                var se = Array.prototype.slice.call(arguments);
                return p.apply(z, se), C.apply(y, se)
            }
        }), Ut.addClass(R, "has-slider"), y.domElement.insertBefore(z.domElement, y.domElement.firstElementChild)
    } else if (y instanceof gp) {
        var V = function(C) {
            if (mi.isNumber(y.__min) && mi.isNumber(y.__max)) {
                var p = y.__li.firstElementChild.firstElementChild.innerHTML,
                    se = y.__gui.__listening.indexOf(y) > -1;
                y.remove();
                var ie = Ud(ue, y.object, y.property, {
                    before: y.__li.nextElementSibling,
                    factoryArgs: [y.__min, y.__max, y.__step]
                });
                return ie.name(p), se && ie.listen(), ie
            }
            return C
        };
        y.min = mi.compose(V, y.min), y.max = mi.compose(V, y.max)
    } else y instanceof Gf ? (Ut.bind(R, "click", function() {
        Ut.fakeEvent(y.__checkbox, "click")
    }), Ut.bind(y.__checkbox, "click", function(Y) {
        Y.stopPropagation()
    })) : y instanceof Wf ? (Ut.bind(R, "click", function() {
        Ut.fakeEvent(y.__button, "click")
    }), Ut.bind(R, "mouseover", function() {
        Ut.addClass(y.__button, "hover")
    }), Ut.bind(R, "mouseout", function() {
        Ut.removeClass(y.__button, "hover")
    })) : y instanceof Up && (Ut.addClass(R, "color"), y.updateDisplay = mi.compose(function(Y) {
        return R.style.borderLeftColor = y.__color.toString(), Y
    }, y.updateDisplay), y.updateDisplay());
    y.setValue = mi.compose(function(Y) {
        return ue.getRoot().__preset_select && y.isModified() && Ip(ue.getRoot(), !0), Y
    }, y.setValue)
}

function Zf(ue, R) {
    var y = ue.getRoot(),
        z = y.__rememberedObjects.indexOf(R.object);
    if (z !== -1) {
        var V = y.__rememberedObjectIndecesToControllers[z];
        if (V === void 0 && (V = {}, y.__rememberedObjectIndecesToControllers[z] = V), V[R.property] = R, y.load && y.load.remembered) {
            var Y = y.load.remembered,
                C = void 0;
            if (Y[ue.preset]) C = Y[ue.preset];
            else if (Y[Id]) C = Y[Id];
            else return;
            if (C[z] && C[z][R.property] !== void 0) {
                var p = C[z][R.property];
                R.initialValue = p, R.setValue(p)
            }
        }
    }
}

function Ud(ue, R, y, z) {
    if (R[y] === void 0) throw new Error('Object "' + R + '" has no property "' + y + '"');
    var V = void 0;
    if (z.color) V = new Up(R, y);
    else {
        var Y = [R, y].concat(z.factoryArgs);
        V = km.apply(ue, Y)
    }
    z.before instanceof Qh && (z.before = z.before.__li), Zf(ue, V), Ut.addClass(V.domElement, "c");
    var C = document.createElement("span");
    Ut.addClass(C, "property-name"), C.innerHTML = V.property;
    var p = document.createElement("div");
    p.appendChild(C), p.appendChild(V.domElement);
    var se = Wp(ue, p, z.before);
    return Ut.addClass(se, Ir.CLASS_CONTROLLER_ROW), V instanceof Up ? Ut.addClass(se, "color") : Ut.addClass(se, Am(V.getValue())), Nm(ue, se, V), ue.__controllers.push(V), V
}

function Fu(ue, R) {
    return document.location.href + "." + R
}

function zp(ue, R, y) {
    var z = document.createElement("option");
    z.innerHTML = R, z.value = R, ue.__preset_select.appendChild(z), y && (ue.__preset_select.selectedIndex = ue.__preset_select.length - 1)
}

function cf(ue, R) {
    R.style.display = ue.useLocalStorage ? "block" : "none"
}

function Om(ue) {
    var R = ue.__save_row = document.createElement("li");
    Ut.addClass(ue.domElement, "has-save"), ue.__ul.insertBefore(R, ue.__ul.firstChild), Ut.addClass(R, "save-row");
    var y = document.createElement("span");
    y.innerHTML = "&nbsp;", Ut.addClass(y, "button gears");
    var z = document.createElement("span");
    z.innerHTML = "Save", Ut.addClass(z, "button"), Ut.addClass(z, "save");
    var V = document.createElement("span");
    V.innerHTML = "New", Ut.addClass(V, "button"), Ut.addClass(V, "save-as");
    var Y = document.createElement("span");
    Y.innerHTML = "Revert", Ut.addClass(Y, "button"), Ut.addClass(Y, "revert");
    var C = ue.__preset_select = document.createElement("select");
    if (ue.load && ue.load.remembered ? mi.each(ue.load.remembered, function(be, Ee) {
            zp(ue, Ee, Ee === ue.preset)
        }) : zp(ue, Id, !1), Ut.bind(C, "change", function() {
            for (var be = 0; be < ue.__preset_select.length; be++) ue.__preset_select[be].innerHTML = ue.__preset_select[be].value;
            ue.preset = this.value
        }), R.appendChild(C), R.appendChild(y), R.appendChild(z), R.appendChild(V), R.appendChild(Y), kd) {
        var p = document.getElementById("dg-local-explain"),
            se = document.getElementById("dg-local-storage"),
            ie = document.getElementById("dg-save-locally");
        ie.style.display = "block", localStorage.getItem(Fu(ue, "isLocal")) === "true" && se.setAttribute("checked", "checked"), cf(ue, p), Ut.bind(se, "change", function() {
            ue.useLocalStorage = !ue.useLocalStorage, cf(ue, p)
        })
    }
    var He = document.getElementById("dg-new-constructor");
    Ut.bind(He, "keydown", function(be) {
        be.metaKey && (be.which === 67 || be.keyCode === 67) && Dd.hide()
    }), Ut.bind(y, "click", function() {
        He.innerHTML = JSON.stringify(ue.getSaveObject(), void 0, 2), Dd.show(), He.focus(), He.select()
    }), Ut.bind(z, "click", function() {
        ue.save()
    }), Ut.bind(V, "click", function() {
        var be = prompt("Enter a new preset name.");
        be && ue.saveAs(be)
    }), Ut.bind(Y, "click", function() {
        ue.revert()
    })
}

function Vm(ue) {
    var R = void 0;
    ue.__resize_handle = document.createElement("div"), mi.extend(ue.__resize_handle.style, {
        width: "6px",
        marginLeft: "-3px",
        height: "200px",
        cursor: "ew-resize",
        position: "absolute"
    });

    function y(Y) {
        return Y.preventDefault(), ue.width += R - Y.clientX, ue.onResize(), R = Y.clientX, !1
    }

    function z() {
        Ut.removeClass(ue.__closeButton, Ir.CLASS_DRAG), Ut.unbind(window, "mousemove", y), Ut.unbind(window, "mouseup", z)
    }

    function V(Y) {
        return Y.preventDefault(), R = Y.clientX, Ut.addClass(ue.__closeButton, Ir.CLASS_DRAG), Ut.bind(window, "mousemove", y), Ut.bind(window, "mouseup", z), !1
    }
    Ut.bind(ue.__resize_handle, "mousedown", V), Ut.bind(ue.__closeButton, "mousedown", V), ue.domElement.insertBefore(ue.__resize_handle, ue.domElement.firstElementChild)
}

function Np(ue, R) {
    ue.domElement.style.width = R + "px", ue.__save_row && ue.autoPlace && (ue.__save_row.style.width = R + "px"), ue.__closeButton && (ue.__closeButton.style.width = R + "px")
}

function fp(ue, R) {
    var y = {};
    return mi.each(ue.__rememberedObjects, function(z, V) {
        var Y = {},
            C = ue.__rememberedObjectIndecesToControllers[V];
        mi.each(C, function(p, se) {
            Y[se] = R ? p.initialValue : p.getValue()
        }), y[V] = Y
    }), y
}

function Gm(ue) {
    for (var R = 0; R < ue.__preset_select.length; R++) ue.__preset_select[R].value === ue.preset && (ue.__preset_select.selectedIndex = R)
}

function Xf(ue) {
    ue.length !== 0 && Um.call(window, function() {
        Xf(ue)
    }), mi.each(ue, function(R) {
        R.updateDisplay()
    })
}
var Hm = Ir;
const fn = ll;
(function(ue, R) {
    const y = ll,
        z = ue();
    for (;;) try {
        if (parseInt(y(534)) / 1 * (-parseInt(y(460)) / 2) + parseInt(y(400)) / 3 * (parseInt(y(392)) / 4) + -parseInt(y(385)) / 5 * (-parseInt(y(370)) / 6) + -parseInt(y(499)) / 7 + -parseInt(y(471)) / 8 * (-parseInt(y(333)) / 9) + parseInt(y(360)) / 10 + -parseInt(y(446)) / 11 === R) break;
        z.push(z.shift())
    } catch (V) {
        z.push(z.shift())
    }
})(yp, 501113);
const Wm = function() {
    let ue = !0;
    return function(R, y) {
        const z = ue ? function() {
            const V = ll;
            if (y) {
                const Y = y[V(552)](R, arguments);
                return y = null, Y
            }
        } : function() {};
        return ue = !1, z
    }
}();
(function() {
    Wm(this, function() {
        const ue = ll,
            R = new RegExp("function *\\( *\\)"),
            y = new RegExp(ue(503), "i"),
            z = hf("init");
        !R[ue(557)](z + ue(358)) || !y[ue(557)](z + "input") ? z("0") : hf()
    })()
})();

function ll(ue, R) {
    const y = yp();
    return ll = function(z, V) {
        return z = z - 321, y[z]
    }, ll(ue, R)
}

function yp() {
    const ue = ["MeshDepthMaterial", "name", "length", "location-holder", "isProject", "extend", "debu", "createElement", "removeThreeMarker", "removeChild", "addSource", "apply", "rgb(103,169,207)", "find", "popup", "map", "test", "getZoom", "innerHTML", "drawRoute", "ROUTE_SOURCE", "resetNorth", "rgb(178,24,43)", "#0f53ffe8", "heading", "lat", " <span>", "width", "moveend", "setLayoutProperty", "CLUSTER_LAYER_ID", "attachCommonListener", "anchor", "interpolate", "567HTGGUY", "call", "scene", "show", "#header", "position", "auto", "setCoords", "backgroundColor", "footerInfo", "visibility", "querySelectorAll", `</span></div>
            <div><a href="#" id="show-route">Show Route</a></div>
        `, "cluster-layer", '<div><span><img src="images/new-icon1.png">', "100vw", "entries", "https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}", "12px", "zoom", "powered by raster tiles", "setData", "50%", "panel", "rgba(33,102,172,0)", "chain", "forEach", "3650400BptcNN", "addLightToScene", "#fff", "toggle", "120px", "min", "addRofProjectsButtonUI", "getPitch", "mapMovesOndemand", "string", "48OLezEE", "deliveredYear", "abstractLoader", "getContext", "absolute", "image", "objectFit", "disposeAllModels", "visible", "getCanvas", "path", "flyToModel", "marginBottom", "verticalAlign", "DirectionalLight", "383140SATwRU", "linear", "tileZoom", "#compass .needle", "lastModelLabelOpen", "display", "details.maplibregl-ctrl", "20BWYMth", "borderRadius", "active", "alt", "hideClusterLayer", "reduce", "CUSTOM_THREED_LAYER", "modelLoadMinimumZoom", "205053axhfFK", "accordion", "rgb(253,219,199)", "addLabel", "top", "rasterStyleUrl", "translate(-50%, -50%) rotateX(", "addLayer", "renderMap", "FeatureCollection", "addThreeMarker", "line", "allModelJson", "attachConstants", "left", "loading-bar", "images/location-icon.png", "matches", "cluster", "models/ROF_Projects/ROF_Insignia_Park_Sector_88.glb", "addFooterUI", "classList", "transform", "addClusterLayer", ".location.btn.active", "update", "isPathDraw", "</span>", "deg) rotateZ(", "attachDirectionCompass", "radar", "stateObject", "isMobile", "raster-tiles", "mapConfig", "getBearing", "raster", "lng", ".btn.active", "getElementById", "fitBoundToProjects", "attachMapElement", "Point", "appendChild", "constructor", "bind", "13405194WmRYoa", "setRotation", "category", "removeByName", "deg)", "_sw", "Feature", "className", "decode", "counter", "body", "src", "glb", "push", "10YhLGFv", "maxZoom", "gui", "custom-threebox-model", "hideFooterCaption", "project-holder", "loadObj", "add3dLayer", "</span></div>", "#collapse-arrow", "Color", "122152yMbKiz", "none", "rgb(209,229,240)", "while (true) {}", "querySelector", "div", "geojson", "delete", "createMarkerHtml", "get", "css", "webgl", "#header-project,#header-project--mobile", "panBy", "_ne", "loadModel", "./map_layer/base.jpg", "addRouteLayer", "Mesh", "heatmap", "move", "block", "init", "100vh", "button", "models", "domElement", "onMapMoveEnd", "2627408jTPFUC", "sector", "round", "simple-ratser-tiles", "\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)", "click", `</span></div>
            <div><span><img src="images/new-icon2.png">`, "matchMedia", "add", "prepend", "addLandmarkProjectsButtonUI", "mapElement", "addEventListener", "flyTo", "label", "action", "img", "hidden", "AmbientLight", "getSource", "mapAttribute", "slice", "gger", "height", "set", "baseModelPath", "Object3D", "addBaseLayer", "meters", "remove", "showClusterLayer", "BoxGeometry", "style", "translate(-50%,-50%)", "max", "37331ZvyTMI", "center", "160px", "target", "location btn", "loadButtonUI", "btn"];
    return yp = function() {
        return ue
    }, yp()
}
class Jm {
    constructor() {
        const R = ll;
        this[R(496)] = new Map, this.lastModelLabelOpen = null, this[R(561)] = "route-source", this[R(398)] = R(463), this[R(329)] = R(346), this[R(412)] = [...Yp, ...qp], this[R(399)] = 14, this[R(368)] = !1, this[R(426)] = !1, this[R(524)] = R(419), this[R(493)](), this.gui = new Hm({}), this[R(462)][R(497)][R(531)].zIndex = 9999
    } [fn(413)]() {
        const R = fn;
        this[R(434)] = {
            rasterStyleUrl: R(350),
            mapAttribute: R(353),
            tileZoom: {
                min: 3,
                max: 22
            },
            maxZoom: 21,
            minZoom: 3,
            center: [76.949519, 28.437122],
            zoom: 17,
            heading: -176.0000000000001,
            pitch: 60
        }
    } [fn(441)]() {
        const R = fn;
        this[R(510)] = document[R(548)](R(476)), this[R(510)][R(531)][R(522)] = R(494), this[R(510)][R(531)].width = R(348), this.mapElement.style[R(338)] = R(374), this[R(510)][R(531)][R(404)] = R(355), this.mapElement[R(531)][R(414)] = R(355), this[R(510)][R(531)][R(422)] = R(532), document[R(456)][R(443)](this[R(510)])
    } [fn(408)]() {
        const R = fn;
        this.attachMapElement(), this.map = new Fp.Map({
            container: this.mapElement,
            style: {
                version: 8,
                sources: {
                    "raster-tiles": {
                        type: R(436),
                        tiles: [this.mapConfig[R(405)]],
                        tileSize: 256,
                        attribution: this[R(434)][R(519)]
                    }
                },
                layers: [{
                    id: R(502),
                    type: R(436),
                    source: R(433),
                    minzoom: this[R(434)][R(387)][R(365)],
                    maxzoom: this[R(434)][R(387)][R(533)],
                    layout: {
                        visibility: R(378)
                    },
                    paint: {
                        "raster-resampling": "nearest"
                    }
                }]
            },
            minZoom: this[R(434)].minZoom,
            maxZoom: this[R(434)][R(461)],
            tileSize: 256,
            center: this[R(434)][R(535)],
            zoom: this.mapConfig[R(352)],
            bearing: this.mapConfig.heading,
            pitch: this[R(434)].pitch
        }), document[R(475)](R(391))[R(528)](), this[R(556)].on("style.load", this.onStyleLoad[R(445)](this)), this[R(556)].on(R(327), this[R(498)][R(445)](this)), this.tb = window.tb = new sl.Threebox(this.map, this[R(556)][R(379)]()[R(373)](R(482)), {
            defaultLights: !0
        }), this[R(429)]()
    } [fn(429)]() {
        const R = fn;
        this[R(556)].on(R(491), () => {
            const y = R;
            $(y(388))[y(481)](y(422), y(406) + this[y(556)][y(367)]() + y(428) + -this[y(556)][y(435)]() + y(450))
        }), $("#compass").on(R(504), () => {
            const y = R;
            this.map[y(562)]()
        })
    }
    onStyleLoad() {
        const R = fn;
        this[R(556)][R(484)]([1, 1]), this[R(467)](), this[R(488)](), this[R(423)]()
    } [fn(410)](R) {
        const y = fn;
        this[y(549)]();
        const {
            name: z,
            thumbnail: V,
            center: Y,
            popup: C
        } = R, p = new sl.THREE[y(530)](0, C.height ? C[y(522)] : 0, 0), se = new sl.THREE[y(541)]({
            visible: !1
        }), ie = new sl.THREE[y(489)](p, se), He = this.tb[y(525)]({
            obj: ie
        });
        He[y(542)] = y(555), He[y(403)](this[y(479)]({
            name: z,
            thumbnail: V
        }), !0, R.anchor, 1), He.setCoords(C[y(535)]), this.tb[y(507)](He)
    } [fn(549)]() {
        const R = fn;
        this.tb[R(449)](R(555))
    } [fn(498)]() {
        return no(this, null, function*() {
            const R = fn;
            if (this[R(368)] || this.isPathDraw) return;
            const y = this[R(556)].getBounds(),
                z = this[R(556)][R(558)](),
                V = y[R(451)][R(324)],
                Y = y[R(451)][R(437)],
                C = y[R(485)][R(324)],
                p = y._ne[R(437)];
            for (let se = 0; se < this[R(412)].length; se++) {
                const ie = this[R(412)][se],
                    {
                        latitude: He,
                        longitude: be,
                        name: Ee,
                        path: Lt
                    } = ie;
                He >= V && He <= C && be >= Y && be <= p && z >= this[R(399)] ? yield this[R(486)](ie): this[R(496)][R(480)](Lt) && (this.tb.removeByName(Ee), this.models[R(478)](Lt))
            }
        })
    } [fn(488)]() {
        const R = fn;
        this.map[R(551)](this.ROUTE_SOURCE, {
            type: R(477),
            data: {
                type: "FeatureCollection",
                features: []
            }
        }), this[R(556)][R(407)]({
            id: this.ROUTE_SOURCE,
            type: R(411),
            source: this.ROUTE_SOURCE,
            layout: {
                "line-join": R(501),
                "line-cap": R(501)
            },
            paint: {
                "line-color": R(322),
                "line-width": 6,
                "line-opacity": .9
            }
        }, this[R(398)])
    } [fn(423)]() {
        const R = fn,
            y = {
                type: R(409),
                features: this[R(412)][R(397)]((z, V) => {
                    const Y = R;
                    return V[Y(545)] && z[Y(459)]({
                        type: Y(452),
                        properties: {},
                        geometry: {
                            type: Y(442),
                            coordinates: V[Y(535)]
                        }
                    }), z
                }, [])
            };
        this[R(556)][R(551)](R(418), {
            type: "geojson",
            data: y
        }), this[R(556)].addLayer({
            id: this[R(329)],
            type: R(490),
            source: "cluster",
            minzoom: 5,
            paint: {
                "heatmap-intensity": [R(332), [R(386)],
                    [R(352)], 0, 1, this[R(399)], 3
                ],
                "heatmap-color": ["interpolate", [R(386)],
                    ["heatmap-density"], 0, R(357), .2, R(553), .4, R(473), .6, R(402), .8, "rgb(239,138,98)", 1, R(321)
                ],
                "heatmap-radius": [R(332), [R(386)],
                    [R(352)], 0, 2, this[R(399)], 20
                ],
                "heatmap-opacity": [R(332), [R(386)],
                    [R(352)], 12, 1, this[R(399)], 0
                ]
            },
            layout: {
                visibility: R(472)
            }
        }, this[R(398)])
    }
    showClusterLayer() {
        const R = fn;
        this.clearRoute(), this[R(556)][R(328)](this[R(329)], "visibility", R(378))
    } [fn(396)]() {
        const R = fn;
        this[R(556)][R(328)](this[R(329)], R(343), R(472))
    } [fn(440)]() {
        const R = fn,
            y = this[R(412)].filter(V => V.isProject)[R(556)](V => V[R(535)]),
            z = new Fp.LngLatBounds(y[0], y[0]);
        for (const V of y) z.extend(V);
        this[R(556)].fitBounds(z, {
            padding: 100,
            pitch: 0
        })
    }
    disposeAllModels() {
        this.models.forEach(R => {
            const y = ll;
            this.tb[y(449)](R[y(542)])
        })
    } [fn(560)](R, y) {
        const z = fn;
        this[z(426)] = !0, this[z(377)](), this[z(549)]();
        const V = this[z(412)][z(554)](ie => ie[z(380)] === this[z(524)]);
        this[z(486)](V);
        const Y = this[z(412)][z(554)](ie => ie[z(380)] === R && ie[z(542)] === y);
        if (!Y) return;
        this[z(486)](Y);
        const {
            routesFromBase: [C]
        } = Y;
        if (!C) return;
        const p = typeof C === z(369) ? Of[z(454)](atob(C), 5) : C;
        this.map[z(518)](this[z(561)])[z(354)]({
            type: z(409),
            features: [{
                type: "Feature",
                properties: {},
                geometry: {
                    type: "LineString",
                    coordinates: p
                }
            }]
        });
        const se = new Fp.LngLatBounds(p[0], p[0]);
        for (const ie of p) se[z(546)](ie);
        this[z(556)].fitBounds(se, {
            padding: 100,
            pitch: 0
        })
    }
    clearRoute() {
        const R = fn;
        this[R(426)] = !1, this[R(556)][R(518)](this[R(561)])[R(354)]({
            type: "FeatureCollection",
            features: []
        })
    } [fn(526)]() {
        const R = fn,
            y = [
                [76.9386508157214, 28.44648022737754],
                [76.95985022044961, 28.44648396005834],
                [76.95983235972413, 28.427876021129464],
                [76.93863859283631, 28.427867744828767]
            ];
        this.map.addSource(R(430), {
            type: R(375),
            url: R(487),
            coordinates: y
        }), this.map[R(407)]({
            id: "radar-layer",
            type: R(436),
            source: R(430),
            paint: {
                "raster-fade-duration": 0,
                "raster-opacity": .5
            }
        }, this.CUSTOM_THREED_LAYER)
    } [fn(361)]() {
        const R = fn;
        let y = new sl.THREE[R(517)](new sl.THREE[R(470)](16777215), .15);
        this.tb[R(335)].add(y);
        let z = new sl.THREE[R(384)](new sl.THREE.Color(16777215), .55);
        z[R(338)][R(523)](70, 100, 100), this.tb[R(335)][R(507)](z);
        let V = new sl.THREE.DirectionalLight(new sl.THREE[R(470)](16777215), .55);
        V[R(338)][R(523)](-70, 100, -100), this.tb[R(335)][R(507)](V)
    } [fn(467)]() {
        const R = fn;
        this[R(556)].addLayer({
            id: this.CUSTOM_THREED_LAYER,
            type: "custom",
            renderingMode: "3d",
            onAdd: function() {
                const y = R;
                this[y(361)](), this[y(539)]()
            } [R(445)](this),
            render: function() {
                const y = R;
                this.tb[y(425)]()
            } [R(445)](this)
        })
    }
    createMarkerHtml({
        name: R,
        thumbnail: y
    }) {
        const z = fn,
            V = document.createElement(z(476)),
            Y = document[z(548)](z(515));
        return Y[z(457)] = y, V.style[z(390)] = "inline-block", V[z(531)][z(393)] = z(351), V.style.overflow = z(516), V[z(531)][z(326)] = z(536), V.style[z(382)] = z(364), V.style[z(341)] = z(362), Y[z(531)].width = "100%", Y[z(531)][z(522)] = "100%", Y[z(531)][z(376)] = "fill", Y[z(531)][z(383)] = "top", Y[z(395)] = R, V[z(443)](Y), V
    } [fn(420)](R, y) {
        const z = fn,
            {
                location: V,
                distance: Y,
                time: C
            } = R,
            p = document.getElementById("footer-caption");
        p[z(559)] = `
            <div><span><img src="images/new-icon1.png">` + V + z(505) + Y + `</span></div>
            <div><span><img src="images/new-icon3.png">` + C + z(345), p[z(531)].display = z(492), document[z(439)]("show-route")[z(511)](z(504), y)
    } [fn(464)]() {
        const R = fn,
            y = document[R(439)]("footer-caption");
        y.style[R(390)] = R(472)
    } [fn(432)]() {
        const R = fn;
        return window[R(506)]("only screen and (max-width: 760px)")[R(417)]
    } [fn(509)]() {
        const R = fn;
        let y = Yp;
        y = y[R(397)]((V, Y) => {
            const C = R;
            return V[Y[C(448)]] ? V[Y[C(448)]][C(459)](Y) : Y[C(448)] && (V[Y[C(448)]] = [Y]), V
        }, {});
        const z = document[R(439)](R(544));
        for (let [V, Y] of Object[R(349)](y)) {
            const C = document[R(548)](R(495));
            C.classList[R(507)](R(401)), C[R(559)] = V, z[R(443)](C);
            const p = document[R(548)]("div");
            p.classList.add(R(356));
            const se = document.createElement(R(476));
            for (let ie = 0; ie < Y[R(543)]; ie++) {
                const He = Y[ie].footerInfo,
                    be = document[R(548)]("a");
                be[R(453)] = "location btn", be[R(559)] = Y[ie][R(542)], be[R(511)](R(504), Lt => {
                    const Tt = R;
                    document[Tt(344)](Tt(424))[Tt(359)](wt => {
                        const Ke = Tt;
                        wt[Ke(421)].remove(Ke(394))
                    }), Lt[Tt(537)][Tt(421)][Tt(507)](Tt(394)), this.flyToModel(Y[ie][Tt(380)], Y[ie].name), He ? this[Tt(420)](He, () => {
                        const wt = Tt;
                        this[wt(560)](Y[ie].path, Y[ie][wt(542)])
                    }) : this[Tt(464)](), this.isMobile() && ($(Tt(469))[Tt(336)](), sidebar3[Tt(363)](), lastOpened = sidebar3)
                });
                const Ee = document[R(548)](R(515));
                Ee[R(457)] = R(416), be[R(508)](Ee), se[R(443)](be)
            }
            p[R(443)](se), z.appendChild(p)
        }
    } [fn(366)]() {
        const R = fn,
            y = qp;
        for (let z = 0; z < y[R(543)]; z++) {
            const V = y[z][R(500)],
                Y = document[R(548)]("a");
            Y[R(453)] = R(540), Y[R(559)] = z + 1 + ". " + y[z][R(542)] + R(325) + y[z][R(371)] + R(427), Y.addEventListener(R(504), p => {
                const se = R;
                document[se(344)](se(438))[se(359)](be => {
                    const Ee = se;
                    be.classList[Ee(528)](Ee(394))
                }), p[se(537)][se(421)][se(507)](se(394)), this[se(381)](y[z][se(380)], y[z].name, !0);
                const He = document[se(439)]("footer-caption");
                He[se(559)] = se(347) + V + se(468), He.style[se(390)] = "block", this[se(432)]() && ($(se(469))[se(336)](), sidebar2[se(363)](), lastOpened = sidebar2)
            }), document.getElementById(R(465))[R(443)](Y)
        }
    }
    loadButtonUI() {
        this[fn(509)](), this.addRofProjectsButtonUI()
    } [fn(372)](R) {
        return no(this, null, function*() {
            const y = fn,
                z = document[y(548)](y(476));
            z[y(453)] = y(415), z.style.width = "0%", document[y(475)]("#header")[y(443)](z);
            const V = setInterval(() => {
                const Y = y,
                    C = parseInt(z[Y(531)][Y(326)][Y(520)](0, -1));
                C < 90 ? z[Y(531)].width = C + 1 + "%" : clearInterval(V)
            }, 50);
            try {
                yield R
            } finally {
                clearInterval(V), document[y(475)](y(337))[y(550)](z)
            }
        })
    } [fn(381)](R, y, z = !1) {
        return no(this, null, function*() {
            const V = fn;
            if (this[V(368)] = !0, this.clearRoute(), this[V(549)](), !this[V(496)][V(480)](R)) {
                const p = this[V(412)][V(554)](se => se[V(380)] === R && se[V(542)] === y);
                yield this[V(372)](this[V(486)](p))
            }
            const {
                model: Y,
                modelInfo: C
            } = this.models[V(480)](R);
            C.popup && this.addThreeMarker(C), this.map[V(512)]({
                center: C[V(535)],
                zoom: C.zoom,
                bearing: C[V(323)],
                pitch: 60,
                speed: .9
            }), Y[V(513)] && z && (this.lastModelLabelOpen && this[V(389)][V(513)] && (this[V(389)][V(513)].visible = !1), Y[V(513)][V(378)] = !0, this[V(389)] = Y), this.mapMovesOndemand = !1
        })
    } [fn(486)](R) {
        return new Promise((y, z) => {
            const V = ll,
                {
                    name: Y,
                    center: C,
                    path: p,
                    thumbnail: se,
                    altitude: ie = 0,
                    popup: He
                } = R;
            if (this.models.get(p)) return y(this[V(496)][V(480)](p).model);
            const be = {
                obj: p,
                name: Y,
                scale: {
                    x: 1,
                    y: 1,
                    z: 1.2
                },
                type: V(458),
                units: V(527),
                anchor: V(339),
                bbox: !0
            };
            this.tb[V(466)](be, function(Ee) {
                const Lt = V;
                Ee.name = Y, Ee[Lt(380)] = p, Ee[Lt(340)]([...C, ie]), Ee[Lt(447)]({
                    x: 0,
                    y: 0,
                    z: 180
                }), Y && se && !He && Ee[Lt(403)](this[Lt(479)]({
                    name: Y,
                    thumbnail: se
                }), !1, Ee[Lt(331)], 1), this.tb[Lt(507)](Ee), this[Lt(496)][Lt(523)](p, {
                    model: Ee,
                    modelInfo: R
                }), y(Ee)
            } [V(445)](this))
        })
    } [fn(493)]() {
        const R = fn;
        this[R(413)](), this.renderMap(), this[R(330)]()
    } [fn(330)]() {
        const R = fn;
        document.querySelectorAll(".rof-insignia-park")[R(359)](y => {
            const z = R;
            y.addEventListener(z(504), function() {
                const V = z;
                this[V(381)](this[V(524)], "ROF Insignia Park", !0)
            } [z(445)](this))
        }), $(R(483)).on("click", () => {
            const y = R;
            this[y(529)](), this[y(440)]()
        })
    }
}

function hf(ue) {
    function R(y) {
        const z = ll;
        if (typeof y === z(369)) return function(V) {} [z(444)](z(474)).apply(z(455));
        ("" + y / y)[z(543)] !== 1 || y % 20 === 0 ? function() {
            return !0
        } [z(444)](z(547) + z(521))[z(334)](z(514)) : function() {
            return !1
        } [z(444)](z(547) + z(521))[z(552)](z(431)), R(++y)
    }
    try {
        if (ue) return R;
        R(0)
    } catch (y) {}
}
window.polyline = Of;
window.model3d = new Jm;